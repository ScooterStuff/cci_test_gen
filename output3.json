[
  {
    "id": "apache_calcite-896-FirstSentence-0",
    "old_comment_raw": "Creates elastic node as single member of a cluster.",
    "new_comment_raw": "Creates an instance with existing settings",
    "old_code_raw": "  public static EmbeddedElasticsearchNode create() {\n    File data = Files.createTempDir();\n    data.deleteOnExit();\n    File home = Files.createTempDir();\n    home.deleteOnExit();\n\n    Settings settings = Settings.builder()\n        .put(\"node.name\", \"fake-elastic\")\n        .put(\"path.home\", home.getAbsolutePath())\n        .put(\"path.data\", data.getAbsolutePath())\n        .put(\"http.type\", \"netty4\")\n        .put(\"network.host\", \"localhost\")\n        .build();\n\n    return create(settings);\n  }\n",
    "new_code_raw": "  private static EmbeddedElasticsearchNode create(Settings settings) {\n    // ensure PainlessPlugin is installed or otherwise scripted fields would not work\n    Node node = new LocalNode(settings, Arrays.asList(Netty4Plugin.class, PainlessPlugin.class));\n    return new EmbeddedElasticsearchNode(node);\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1601-FirstSentence-0",
    "old_comment_raw": "Check whether any insertion or deletion actions are currently queued.",
    "new_comment_raw": "Check whether any insertion or deletion actions are currently queued.",
    "old_code_raw": "\tpublic boolean areInsertionsOrDeletionsQueued() {\n\t\treturn ( insertions.size() > 0 || deletions.size() > 0 );\n\t}\n",
    "new_code_raw": "\tpublic boolean areInsertionsOrDeletionsQueued() {\n\t\treturn ( insertions.size() > 0 || ! unresolvedInsertions.isEmpty() || deletions.size() > 0 );\n\t}\n"
  },
  {
    "id": "apache_giraph-33-Associations-FirstSentence",
    "old_comment_raw": "Marshal the aggregator values of to a JSONArray that will later be aggregated by master.",
    "new_comment_raw": "Marshal the aggregator values of the worker to a byte array that will later be aggregated by master.",
    "old_code_raw": "  private JSONArray marshalAggregatorValues(long superstep) {\n    JSONArray aggregatorArray = new JSONArray();\n    if ((superstep == INPUT_SUPERSTEP) || (aggregatorInUse.size() == 0)) {\n      return aggregatorArray;\n    }\n\n    for (String name : aggregatorInUse) {\n      try {\n        Aggregator<Writable> aggregator = getAggregatorMap().get(name);\n        ByteArrayOutputStream outputStream =\n            new ByteArrayOutputStream();\n        DataOutput output = new DataOutputStream(outputStream);\n        aggregator.getAggregatedValue().write(output);\n\n        JSONObject aggregatorObj = new JSONObject();\n        aggregatorObj.put(AGGREGATOR_NAME_KEY, name);\n        aggregatorObj.put(AGGREGATOR_CLASS_NAME_KEY,\n            aggregator.getClass().getName());\n        aggregatorObj.put(\n            AGGREGATOR_VALUE_KEY,\n            Base64.encodeBytes(outputStream.toByteArray()));\n        aggregatorArray.put(aggregatorObj);\n        if (LOG.isInfoEnabled()) {\n          LOG.info(\"marshalAggregatorValues: \" +\n              \"Found aggregatorObj \" +\n              aggregatorObj + \", value (\" +\n              aggregator.getAggregatedValue() + \")\");\n        }\n      } catch (JSONException e) {\n        throw new IllegalStateException(\"Failed to marshall aggregator \" +\n            \"with JSONException \" + name, e);\n      } catch (IOException e) {\n        throw new IllegalStateException(\"Failed to marshall aggregator \" +\n            \"with IOException \" + name, e);\n      }\n    }\n\n    if (LOG.isInfoEnabled()) {\n      LOG.info(\"marshalAggregatorValues: Finished assembling \" +\n          \"aggregator values in JSONArray - \" + aggregatorArray);\n    }\n    aggregatorInUse.clear();\n    return aggregatorArray;\n  }\n",
    "new_code_raw": "  private byte[] marshalAggregatorValues(long superstep) {\n    if (superstep == INPUT_SUPERSTEP) {\n      return new byte[0];\n    }\n\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    DataOutputStream output = new DataOutputStream(outputStream);\n    for (Entry<String, AggregatorWrapper<Writable>> entry :\n        getAggregatorMap().entrySet()) {\n      if (entry.getValue().isChanged()) {\n        try {\n          output.writeUTF(entry.getKey());\n          entry.getValue().getCurrentAggregatedValue().write(output);\n        } catch (IOException e) {\n          throw new IllegalStateException(\"Failed to marshall aggregator \" +\n              \"with IOException \" + entry.getKey(), e);\n        }\n      }\n    }\n\n    if (LOG.isInfoEnabled()) {\n      LOG.info(\n          \"marshalAggregatorValues: Finished assembling aggregator values\");\n    }\n    return outputStream.toByteArray();\n  }\n\n"
  },
  {
    "id": "apache_calcite-677-FirstSentence-0",
    "old_comment_raw": "Returns a list of the types of the fields in a given struct type.",
    "new_comment_raw": "Returns a list of the types of the fields in a given struct type.",
    "old_code_raw": "  public static List<RelDataType> getFieldTypeList(final RelDataType type) {\n    return new AbstractList<RelDataType>() {\n      public RelDataType get(int index) {\n        return type.getFieldList().get(index).getType();\n      }\n\n      public int size() {\n        return type.getFieldCount();\n      }\n    };\n  }\n",
    "new_code_raw": "  public static List<RelDataType> getFieldTypeList(final RelDataType type) {\n    return Lists.transform(type.getFieldList(), GET_TYPE);\n  }\n"
  },
  {
    "id": "apache_calcite-315-Associations-FirstSentence",
    "old_comment_raw": "Create an instance based on current maven profile (as defined by  -Pit).",
    "new_comment_raw": "Creates an instance based on current maven profile (as defined by  -Pit).",
    "old_code_raw": "  static MongoDatabaseRule create() {\n    final MongoClient client;\n    if (MongoAssertions.useMongo()) {\n      // use to real client (connects to mongo)\n      client = new MongoClient();\n    } else if (MongoAssertions.useFongo()) {\n      // in-memory DB (fake Mongo)\n      client = new Fongo(MongoDatabaseRule.class.getSimpleName()).getMongo();\n    } else {\n      throw new UnsupportedOperationException(\"I can only connect to Mongo or Fongo instances\");\n    }\n\n    return new MongoDatabaseRule(client);\n  }\n",
    "new_code_raw": "  static MongoDatabasePolicy create() {\n    final MongoClient client;\n    if (MongoAssertions.useMongo()) {\n      // use to real client (connects to mongo)\n      client = new MongoClient();\n    } else if (MongoAssertions.useFongo()) {\n      // in-memory DB (fake Mongo)\n      client = new Fongo(MongoDatabasePolicy.class.getSimpleName()).getMongo();\n    } else {\n      throw new UnsupportedOperationException(\"I can only connect to Mongo or Fongo instances\");\n    }\n\n    return new MongoDatabasePolicy(client);\n  }\n\n"
  },
  {
    "id": "debezium_debezium-1182-FirstSentence-0",
    "old_comment_raw": "Construct the value of the data attribute of CloudEvents.",
    "new_comment_raw": "Construct the value of the data attribute of CloudEvents.",
    "old_code_raw": "    public Struct ceDataAttribute() {\n        Struct data = new Struct(ceDataAttributeSchema());\n        if (recordParser.before() != null) {\n            data.put(Envelope.FieldName.BEFORE, recordParser.before());\n        }\n        if (recordParser.after() != null) {\n            data.put(Envelope.FieldName.AFTER, recordParser.after());\n        }\n        return data;\n    }\n",
    "new_code_raw": "    public Struct ceDataAttribute() {\n        return recordParser.data();\n    }\n"
  },
  {
    "id": "nickman_qreactor-1-Associations-FirstSentence",
    "old_comment_raw": "Returns",
    "new_comment_raw": "Returns the queue directory",
    "old_code_raw": "\tpublic File getSinkFile() {\n\t\treturn sinkFile;\n\t}\n",
    "new_code_raw": "\tpublic File getSinkFile() {\n\t\treturn queue.file();\n\t}\n\n"
  },
  {
    "id": "zaproxy_zaproxy-2180-FirstSentence-0",
    "old_comment_raw": "This method initializes txtPattern",
    "new_comment_raw": "This method initializes txtPattern",
    "old_code_raw": "\tpublic JTextField getTxtPattern() {\n\t\tif (txtPattern == null) {\n\t\t\ttxtPattern = new JTextField();\n\t\t}\n\t\treturn txtPattern;\n\t}\n",
    "new_code_raw": "\tpublic ZapTextField getTxtPattern() {\n\t\tif (txtPattern == null) {\n\t\t\ttxtPattern = new ZapTextField();\n\t\t}\n\t\treturn txtPattern;\n\t}\n"
  },
  {
    "id": "jenkinsci_parameterized-trigger-plugin-1-Associations-FirstSentence",
    "old_comment_raw": "Provides a list containing four set, each containing projects to be displayed on the project view for projects using the parameterized trigger plugin under 'Subprojects'. ",
    "new_comment_raw": "Provides a SubProjectData object containing four set, each containing projects to be displayed on the project view under 'Subprojects' section. ",
    "old_code_raw": "    public List<Set<?>> getProjectInfo(AbstractProject context) {\n\n        Comparator customComparator = new Comparator<AbstractProject>() {\n            public int compare(AbstractProject abstractProject1, AbstractProject abstractProject2) {\n                return abstractProject1.getFullName().compareTo(abstractProject2.getFullName());\n            }\n        };\n\n        Set<AbstractProject> dynamicProject = new TreeSet<AbstractProject>(customComparator);\n        Set<AbstractProject> staticProject = new TreeSet<AbstractProject>(customComparator);\n        Set<AbstractProject> triggeredProject = new TreeSet<AbstractProject>(customComparator);\n        Set<String> unresolvedProject = new TreeSet<String>();\n\n        iterateBuilds(context, projects, dynamicProject, staticProject, triggeredProject, unresolvedProject);\n\n        // We don't want to show a project twice\n        triggeredProject.removeAll(dynamicProject);\n        triggeredProject.removeAll(staticProject);\n\n        return Arrays.asList(staticProject, dynamicProject, triggeredProject, unresolvedProject);\n    }\n",
    "new_code_raw": "    public SubProjectData getProjectInfo(AbstractProject context) {\n\n        SubProjectData subProjectData = new SubProjectData();\n\n        iterateBuilds(context, projects, subProjectData);\n\n        // We don't want to show a project twice\n        subProjectData.getTriggered().removeAll(subProjectData.getDynamic());\n        subProjectData.getTriggered().removeAll(subProjectData.getFixed());\n\n        return subProjectData;\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2184-FirstSentence-0",
    "old_comment_raw": "Return the name of the oneOf schema",
    "new_comment_raw": "Return the name of the oneOf schema",
    "old_code_raw": "    public String toOneOfName(List<String> names, ComposedSchema composedSchema) {\n        return \"oneOf<\" + String.join(\",\", names) + \">\";\n    }\n",
    "new_code_raw": "    public String toOneOfName(List<String> names, ComposedSchema composedSchema) {\n        Map<String, Object> exts = composedSchema.getExtensions();\n        if (exts != null && exts.containsKey(\"x-oneOf-name\")) {\n            return (String) exts.get(\"x-oneOf-name\");\n        }\n        return \"oneOf<\" + String.join(\",\", names) + \">\";\n    }\n"
  },
  {
    "id": "apache_jclouds-356-Associations-FirstSentence",
    "old_comment_raw": "Returns the providers that are bound to the same location as the given ISO 3166 code and of the given type.",
    "new_comment_raw": "Returns the providers that are bound to the same location as the given ISO 3166 code and of the given contextWrappableAs.",
    "old_code_raw": "   public static Iterable<ProviderMetadata<?, ?, ?, ?>> boundedByIso3166Code(String iso3166Code, ApiType type) {\n      return filter(all(),\n            Predicates.and(ProviderPredicates.boundedByIso3166Code(iso3166Code), ProviderPredicates.type(type)));\n   }\n",
    "new_code_raw": "   public static Iterable<ProviderMetadata> boundedByIso3166Code(String iso3166Code,\n            TypeToken<? extends Wrapper> contextWrappableAs) {\n      return filter(all(), Predicates.and(ProviderPredicates.boundedByIso3166Code(iso3166Code), ProviderPredicates\n               .contextWrappableAs(contextWrappableAs)));\n   }\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-1570-FirstSentence-0",
    "old_comment_raw": "Generate a \"standard\" (i.e., non-identifier and non-version) based on the given mapped property.",
    "new_comment_raw": "Generate a \"standard\" (i.e., non-identifier and non-version) based on the given mapped property.",
    "old_code_raw": "\tpublic static StandardProperty buildStandardProperty(Property property, boolean lazyAvailable) {\n\t\t\n\t\tfinal Type type = property.getValue().getType();\n\t\t\n\t\t// we need to dirty check collections, since they can cause an owner\n\t\t// version number increment\n\t\t\n\t\t// we need to dirty check many-to-ones with not-found=\"ignore\" in order \n\t\t// to update the cache (not the database), since in this case a null\n\t\t// entity reference can lose information\n\t\t\n\t\tboolean alwaysDirtyCheck = type.isAssociationType() && \n\t\t\t\t( (AssociationType) type ).isAlwaysDirtyChecked(); \n\n\t\treturn new StandardProperty(\n\t\t\t\tproperty.getName(),\n\t\t\t\tproperty.getNodeName(),\n\t\t\t\ttype,\n\t\t\t\tlazyAvailable && property.isLazy(),\n\t\t\t\tproperty.isInsertable(),\n\t\t\t\tproperty.isUpdateable(),\n\t\t        property.getGeneration() == PropertyGeneration.INSERT || property.getGeneration() == PropertyGeneration.ALWAYS,\n\t\t\t\tproperty.getGeneration() == PropertyGeneration.ALWAYS,\n\t\t\t\tproperty.isOptional(),\n\t\t\t\talwaysDirtyCheck || property.isUpdateable(),\n\t\t\t\tproperty.isOptimisticLocked(),\n\t\t\t\tproperty.getCascadeStyle(),\n\t\t        property.getValue().getFetchMode()\n\t\t\t);\n\t}\n",
    "new_code_raw": "\tpublic static StandardProperty buildStandardProperty(AttributeBinding property, boolean lazyAvailable) {\n\n\t\tfinal Type type = property.getHibernateTypeDescriptor().getExplicitType();\n\n\t\t// we need to dirty check collections, since they can cause an owner\n\t\t// version number increment\n\n\t\t// we need to dirty check many-to-ones with not-found=\"ignore\" in order\n\t\t// to update the cache (not the database), since in this case a null\n\t\t// entity reference can lose information\n\n\t\tboolean alwaysDirtyCheck = type.isAssociationType() &&\n\t\t\t\t( (AssociationType) type ).isAlwaysDirtyChecked();\n\n\t\tif ( property.isSimpleValue() ) {\n\t\t\tSimpleAttributeBinding simpleProperty = ( SimpleAttributeBinding ) property;\n\t\t\treturn new StandardProperty(\n\t\t\t\t\tsimpleProperty.getAttribute().getName(),\n\t\t\t\t\tsimpleProperty.getNodeName(),\n\t\t\t\t\ttype,\n\t\t\t\t\tlazyAvailable && simpleProperty.isLazy(),\n\t\t\t\t\tsimpleProperty.isInsertable(),\n\t\t\t\t\tsimpleProperty.isUpdatable(),\n\t\t\t\t\tsimpleProperty.getGeneration() == PropertyGeneration.INSERT || simpleProperty.getGeneration() == PropertyGeneration.ALWAYS,\n\t\t\t\t\tsimpleProperty.getGeneration() == PropertyGeneration.ALWAYS,\n\t\t\t\t\tsimpleProperty.isNullable(),\n\t\t\t\t\talwaysDirtyCheck || simpleProperty.isUpdatable(),\n\t\t\t\t\tsimpleProperty.isOptimisticLockable(),\n\t\t\t\t\t// TODO: get cascadeStyle from simpleProperty when HHH-6355 is fixed; for now, assume NONE\n\t\t\t\t\t//simpleProperty.getCascadeStyle(),\n\t\t\t\t\tCascadeStyle.NONE,\n\t\t\t\t\t// TODO: get fetchMode() from simpleProperty when HHH-6357 is fixed; for now, assume FetchMode.DEFAULT\n\t\t\t\t\t//simpleProperty.getFetchMode()\n\t\t\t\t\tFetchMode.DEFAULT\n\t\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tPluralAttributeBinding pluralProperty = ( PluralAttributeBinding ) property;\n\n\t\t\treturn new StandardProperty(\n\t\t\t\t\tpluralProperty.getAttribute().getName(),\n\t\t\t\t\tpluralProperty.getNodeName(),\n\t\t\t\t\ttype,\n\t\t\t\t\tlazyAvailable && pluralProperty.isLazy(),\n\t\t\t\t\t// TODO: fix this when HHH-6356 is fixed; for now assume PluralAttributeBinding is updatable and insertable\n\t\t\t\t\t// pluralProperty.isInsertable(),\n\t\t\t\t\t//pluralProperty.isUpdatable(),\n\t\t\t\t\ttrue,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse,\n\t\t\t\t\tfalse,\n\t\t\t\t\tpluralProperty.isNullable(),\n\t\t\t\t\t// TODO: fix this when HHH-6356 is fixed; for now assume PluralAttributeBinding is updatable and insertable\n\t\t\t\t\t//alwaysDirtyCheck || pluralProperty.isUpdatable(),\n\t\t\t\t\ttrue,\n\t\t\t\t\tpluralProperty.isOptimisticLocked(),\n\t\t\t\t\t// TODO: get cascadeStyle from property when HHH-6355 is fixed; for now, assume NONE\n\t\t\t\t\t//pluralProperty.getCascadeStyle(),\n\t\t\t\t\tCascadeStyle.NONE,\n\t\t\t\t\t// TODO: get fetchMode() from simpleProperty when HHH-6357 is fixed; for now, assume FetchMode.DEFAULT\n\t\t\t\t\t//pluralProperty.getFetchMode()\n\t\t\t\t\tFetchMode.DEFAULT\n\t\t\t\t);\n\t\t}\n\t}\n"
  },
  {
    "id": "eclipse_eclipse.platform.team-272-Associations-FirstSentence",
    "old_comment_raw": "Only the views are mirrored.",
    "new_comment_raw": "Returns true if the compare viewer is mirrored, i.e.",
    "old_code_raw": "\tpublic boolean isMirrored() {\n\t\tObject property = getProperty(MIRRORED);\n\t\treturn property instanceof Boolean && (Boolean) property;\n\t}\n",
    "new_code_raw": "\tpublic boolean isMirrored() {\n\t\tif (!fMirroringEnabled)\n\t\t\treturn false;\n\t\tObject property = getProperty(MIRRORED);\n\t\treturn property instanceof Boolean && (Boolean) property;\n\t}\n\n"
  },
  {
    "id": "apache_kylin-447-FirstSentence-0",
    "old_comment_raw": "HBase region cut size, in GB",
    "new_comment_raw": "HBase region cut size, in GB",
    "old_code_raw": "    public float getKylinHBaseRegionCut() {\n        return Float.valueOf(getOptional(\"kylin.hbase.region.cut\", \"1.0\"));\n    }\n",
    "new_code_raw": "    public float getKylinHBaseRegionCut() {\n        return Float.valueOf(getOptional(\"kylin.hbase.region.cut\", \"5.0\"));\n    }\n"
  },
  {
    "id": "reddit_Lob-0-Associations-FirstSentence",
    "old_comment_raw": "Build a Ravioli client",
    "new_comment_raw": "Build a Lob client",
    "old_code_raw": "        public Ravioli build() {\n            return new Ravioli(this);\n        }\n",
    "new_code_raw": "        public Lob build() {\n            return new Lob(this);\n        }\n\n"
  },
  {
    "id": "debezium_debezium-795-FirstSentence-0",
    "old_comment_raw": "Create a new  Builder configuration builder that starts with a copy of the supplied configuration.",
    "new_comment_raw": "Create a new  Builder configuration builder that starts with a copy of the supplied configuration.",
    "old_code_raw": "    public static Builder copy(Configuration config) {\n        return new Builder() {\n            private Properties props = config.asProperties();\n\n            @Override\n            public Builder with(String key, String value) {\n                props.setProperty(key, value);\n                return this;\n            }\n\n            @Override\n            public Builder withDefault(String key, String value) {\n                if (!props.containsKey(key)) {\n                    props.setProperty(key, value);\n                }\n                return this;\n            }\n\n            @Override\n            public Builder apply(Consumer<Builder> function) {\n                function.accept(this);\n                return this;\n            }\n\n            @Override\n            public JdbcConfiguration build() {\n                return JdbcConfiguration.adapt(Configuration.from(props));\n            }\n\n            @Override\n            public String toString() {\n                return props.toString();\n            }\n        };\n    }\n",
    "new_code_raw": "    public static Builder copy(Configuration config) {\n        return new Builder() {\n            private Configuration.Builder builder = Configuration.copy(config);\n\n            @Override\n            public Builder with(String key, String value) {\n                builder.with(key, value);\n                return this;\n            }\n\n            @Override\n            public Builder withDefault(String key, String value) {\n                builder.withDefault(key, value);\n                return this;\n            }\n\n            @Override\n            public Builder apply(Consumer<Builder> function) {\n                function.accept(this);\n                return this;\n            }\n            \n            @Override\n            public Builder changeString(Field field, Function<String, String> function) {\n                changeString(field,function);\n                return this;\n            }\n            \n            @Override\n            public Builder changeString(String key, Function<String, String> function) {\n                changeString(key,function);\n                return this;\n            }\n\n            @Override\n            public JdbcConfiguration build() {\n                return JdbcConfiguration.adapt(builder.build());\n            }\n\n            @Override\n            public String toString() {\n                return builder.toString();\n            }\n        };\n    }\n"
  },
  {
    "id": "apache_drill-1513-FirstSentence-0",
    "old_comment_raw": "Create a web page using the given template,  SecurityContext and model data.",
    "new_comment_raw": "Create the web page using the given template and  SecurityContext after authentication is done.",
    "old_code_raw": "  public static Viewable create(final String templateName, final SecurityContext sc, final Object model) {\n    return new ViewableWithPermissions(templateName, sc, true, model);\n  }\n",
    "new_code_raw": "  public static Viewable create(final boolean authEnabled, final String templateName, final SecurityContext sc) {\n    return new ViewableWithPermissions(authEnabled, templateName, sc, true, null);\n  }\n"
  },
  {
    "id": "runelite_runelite-148-FirstSentence-0",
    "old_comment_raw": "Loads item sprite from game, makes transparent, and generates image",
    "new_comment_raw": "Loads item sprite from game, makes transparent, and generates image",
    "old_code_raw": "\tprivate AsyncBufferedImage loadImage(int itemId, int quantity, boolean stackable)\n\t{\n\t\tAsyncBufferedImage img = new AsyncBufferedImage(36, 32, BufferedImage.TYPE_INT_ARGB);\n\t\tclientThread.invokeLater(() ->\n\t\t{\n\t\t\tif (client.getGameState().ordinal() < GameState.LOGIN_SCREEN.ordinal())\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tSpritePixels sprite = client.createItemSprite(itemId, quantity, 1, SpritePixels.DEFAULT_SHADOW_COLOR,\n\t\t\t\tstackable ? 1 : 0, false, CLIENT_DEFAULT_ZOOM);\n\t\t\tif (sprite == null)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsprite.toBufferedImage(img);\n\t\t\timg.changed();\n\t\t\treturn true;\n\t\t});\n\t\treturn img;\n\t}\n",
    "new_code_raw": "\tprivate BufferedImage loadImage(int itemId, int quantity, boolean stackable)\n\t{\n\t\tSpritePixels sprite = client.get().createItemSprite(itemId, quantity, 1, SpritePixels.DEFAULT_SHADOW_COLOR,\n\t\t\tstackable ? 1 : 0, false, CLIENT_DEFAULT_ZOOM);\n\t\treturn sprite.toBufferedImage();\n\t}\n"
  },
  {
    "id": "apache_axis1-java-149-Associations-FirstSentence",
    "old_comment_raw": "Return XML schema for the specified type, suitable for insertion into the  element of a WSDL document.",
    "new_comment_raw": "Return XML schema for the specified type, suitable for insertion into the &lt;types&gt; element of a WSDL document, or underneath an &lt;element&gt; or &lt;attribute&gt; declaration.",
    "old_code_raw": "    public boolean writeSchema(Types types) throws Exception {\n        // Let the caller generate WSDL if this is not a SimpleType\n        if (!SimpleType.class.isAssignableFrom(javaType))\n            return false;\n\n        // ComplexType representation of SimpleType bean class\n        Element complexType = types.createElement(\"complexType\");\n        types.writeSchemaElement(xmlType, complexType);\n        complexType.setAttribute(\"name\", xmlType.getLocalPart());\n\n        // Produce simpleContent extending base type.\n        Element simpleContent = types.createElement(\"simpleContent\");\n        complexType.appendChild(simpleContent);\n        Element extension = types.createElement(\"extension\");\n        simpleContent.appendChild(extension);\n\n        // Get the base type from the \"value\" element of the bean\n        String base = \"string\";\n        for (int i=0; i<propertyDescriptor.length; i++) {\n            String propName = propertyDescriptor[i].getName();\n            if (!propName.equals(\"value\")) {\n                if (typeDesc != null) {\n                    FieldDesc field = typeDesc.getFieldByName(propName);\n                    if (field != null) {\n                        if (field.isElement()) {\n                            // throw?\n                        }\n                        QName qname = field.getXmlName();\n                        if (qname == null) {\n                            // Use the default...\n                            propName = propName;\n                            qname = new QName(\"\", propName);\n                        }\n\n                        //  write attribute element\n                        Class fieldType = propertyDescriptor[i].getType();\n\n                        // Attribute must be a simple type, enum or SimpleType\n                        if (!types.isAcceptableAsAttribute(fieldType)) {\n                            throw new AxisFault(Messages.getMessage(\"AttrNotSimpleType00\",\n                                    propName,\n                                    fieldType.getName()));\n                        }\n\n                        // write attribute element\n                        // TODO the attribute name needs to be preserved from the XML\n                        String elementType = types.writeType(fieldType);\n                        Element elem = types.createAttributeElement(propName,\n                                elementType,\n                                false,\n                                extension.getOwnerDocument());\n                        extension.appendChild(elem);\n                    }\n                }\n                continue;\n            }\n\n            BeanPropertyDescriptor bpd = propertyDescriptor[i];\n            Class type = bpd.getType();\n            // Attribute must extend a simple type, enum or SimpleType\n            if (!types.isAcceptableAsAttribute(type)) {\n                throw new AxisFault(Messages.getMessage(\"AttrNotSimpleType01\",\n                        type.getName()));\n            }\n            base = types.writeType(type);\n            extension.setAttribute(\"base\", base);\n        }\n\n        // done\n        return true;\n\n    }\n",
    "new_code_raw": "    public Element writeSchema(Class javaType, Types types) throws Exception {\n        // Let the caller generate WSDL if this is not a SimpleType\n        if (!SimpleType.class.isAssignableFrom(javaType))\n            return null;\n\n        // ComplexType representation of SimpleType bean class\n        Element complexType = types.createElement(\"complexType\");\n        types.writeSchemaElement(xmlType, complexType);\n        complexType.setAttribute(\"name\", xmlType.getLocalPart());\n\n        // Produce simpleContent extending base type.\n        Element simpleContent = types.createElement(\"simpleContent\");\n        complexType.appendChild(simpleContent);\n        Element extension = types.createElement(\"extension\");\n        simpleContent.appendChild(extension);\n\n        // Get the base type from the \"value\" element of the bean\n        String base = \"string\";\n        for (int i=0; i<propertyDescriptor.length; i++) {\n            String propName = propertyDescriptor[i].getName();\n            if (!propName.equals(\"value\")) {\n                if (typeDesc != null) {\n                    FieldDesc field = typeDesc.getFieldByName(propName);\n                    if (field != null) {\n                        if (field.isElement()) {\n                            // throw?\n                        }\n                        QName qname = field.getXmlName();\n                        if (qname == null) {\n                            // Use the default...\n                            qname = new QName(\"\", propName);\n                        }\n\n                        //  write attribute element\n                        Class fieldType = propertyDescriptor[i].getType();\n\n                        // Attribute must be a simple type, enum or SimpleType\n                        if (!types.isAcceptableAsAttribute(fieldType)) {\n                            throw new AxisFault(Messages.getMessage(\"AttrNotSimpleType00\",\n                                    propName,\n                                    fieldType.getName()));\n                        }\n\n                        // write attribute element\n                        // TODO the attribute name needs to be preserved from the XML\n                        Element elem = types.createAttributeElement(propName,\n                                fieldType,\n                                field.getXmlType(),\n                                false,\n                                extension.getOwnerDocument());\n                        extension.appendChild(elem);\n                    }\n                }\n                continue;\n            }\n\n            BeanPropertyDescriptor bpd = propertyDescriptor[i];\n            Class type = bpd.getType();\n            // Attribute must extend a simple type, enum or SimpleType\n            if (!types.isAcceptableAsAttribute(type)) {\n                throw new AxisFault(Messages.getMessage(\"AttrNotSimpleType01\",\n                        type.getName()));\n            }\n            base = types.writeType(type);\n            extension.setAttribute(\"base\", base);\n        }\n\n        // done\n        return complexType;\n\n    }\n\n"
  },
  {
    "id": "Atmosphere_atmosphere-697-FirstSentence-0",
    "old_comment_raw": "Given a Class of something that extends AsyncSupport, it tries to return an instance of that class.",
    "new_comment_raw": "Given a Class of something that extends AsyncSupport, it tries to return an instance of that class.",
    "old_code_raw": "    public AsyncSupport newCometSupport(final Class<? extends AsyncSupport> targetClass) {\n        try {\n            return targetClass.getDeclaredConstructor(new Class[]{AtmosphereConfig.class})\n                    .newInstance(config);\n        } catch (final Exception e) {\n            logger.error(\"Failed to create comet support class: {}, error: {}\", targetClass, e);\n            logger.error(\"Switching to BlockingIO\");\n\n            return new BlockingIOCometSupport(config);\n        }\n    }\n",
    "new_code_raw": "    public AsyncSupport newCometSupport(final Class<? extends AsyncSupport> targetClass) {\n        try {\n            return (AsyncSupport) targetClass.getDeclaredConstructor(new Class[]{AtmosphereConfig.class})\n                    .newInstance(config);\n        } catch (final Exception e) {\n            logger.error(\"Failed to create comet support class: {}, error: {}\", targetClass, e);\n            logger.error(\"Switching to BlockingIO\");\n\n            return new BlockingIOCometSupport(config);\n        }\n    }\n"
  },
  {
    "id": "google_iosched-44-Associations-FirstSentence",
    "old_comment_raw": "Add a tag to the set of filters",
    "new_comment_raw": "Add a tagId to the set of filters.",
    "old_code_raw": "    public boolean add(Tag tag) {\n        return isCategoryValid(tag.getCategory()) && mSelectedTopics.add(tag);\n    }\n",
    "new_code_raw": "    public boolean add(String tagId, String category) {\n        return isCategoryValid(category) && mSelectedTopics.add(tagId);\n    }\n\n"
  },
  {
    "id": "graphql_java_graphql_java-430-FirstSentence-0",
    "old_comment_raw": "Allow to print directives.",
    "new_comment_raw": "Allow to print directives.",
    "old_code_raw": "        public Options includeDirectives(boolean flag) {\n            return new Options(this.includeIntrospectionTypes, this.includeScalars, this.includeExtendedScalars, this.includeSchemaDefinition, flag, this.useAstDefinitions, this.descriptionsAsHashComments, this.comparatorRegistry);\n        }\n",
    "new_code_raw": "        public Options includeDirectives(boolean flag) {\n            return new Options(this.includeIntrospectionTypes, this.includeScalars, this.includeExtendedScalars, this.includeSchemaDefinition, this.useAstDefinitions, this.descriptionsAsHashComments, directive -> flag, this.comparatorRegistry);\n        }\n"
  },
  {
    "id": "apache_struts1-44-Associations-FirstSentence",
    "old_comment_raw": "Return the list of module prefixes that are defined for this web application, creating it if necessary.",
    "new_comment_raw": "Return the list of module prefixes that are defined for this web application.",
    "old_code_raw": "    public synchronized static String[] getModulePrefixes(ServletContext context) {\n        // TODO Move prefix list initialization to ActionServlet.init() and unsynchronize\n        // this method in Struts 1.2 \n        \n        String prefixes[] = (String[]) context.getAttribute(PREFIXES_KEY);\n        if (prefixes != null) {\n            return (prefixes);\n        }\n\n        ArrayList list = new ArrayList();\n        Enumeration names = context.getAttributeNames();\n        while (names.hasMoreElements()) {\n            String name = (String) names.nextElement();\n            if (!name.startsWith(Globals.MODULE_KEY)) {\n                continue;\n            }\n            String prefix = name.substring(Globals.MODULE_KEY.length());\n            if (prefix.length() > 0) {\n                list.add(prefix);\n            }\n        }\n        prefixes = (String[]) list.toArray(new String[list.size()]);\n        context.setAttribute(PREFIXES_KEY, prefixes);\n        return (prefixes);\n\n    }\n",
    "new_code_raw": "    public static String[] getModulePrefixes(ServletContext context) {\n        return (String[]) context.getAttribute(Globals.MODULE_PREFIXES_KEY);\n    }\n\n"
  },
  {
    "id": "apache_drill-1265-FirstSentence-0",
    "old_comment_raw": "Build the column writer, and any nested content, returning the built column writer as a generic object writer.",
    "new_comment_raw": "Build the column writer, and any nested content, returning the built column writer as a generic object writer.",
    "old_code_raw": "  private ObjectWriter buildColumn(ParentShim parent, ColumnMetadata colSchema) {\n    if (colSchema.isMultiList()) {\n      return buildRepeatedList(parent, colSchema);\n    } else if (colSchema.isMap()) {\n      return buildMap(parent, colSchema);\n    } else if (isSingleList(colSchema)) {\n      return buildSingleList(parent, colSchema);\n    } else if (colSchema.isVariant()) {\n      return buildVariant(parent, colSchema);\n    } else {\n      return buildPrimitive(parent, colSchema);\n    }\n  }\n",
    "new_code_raw": "  private ObjectWriter buildColumn(ParentShim parent, ColumnMetadata colSchema) {\n    if (colSchema.isMultiList()) {\n      return buildRepeatedList(parent, colSchema);\n    } else if (colSchema.isMap()) {\n      return buildMap(parent, colSchema);\n    } else if (isSingleList(colSchema)) {\n      return buildSingleList(parent, colSchema);\n    } else if (colSchema.isVariant()) {\n      return buildVariant(parent, colSchema);\n    } else if (colSchema.isDict()) {\n      return buildDict(parent, colSchema);\n    } else {\n      return buildPrimitive(parent, colSchema);\n    }\n  }\n"
  },
  {
    "id": "Graylog2_graylog2-server-13-Associations-FirstSentence",
    "old_comment_raw": "Check if the Elasticsearch  Node is connected and that the cluster health status is not  ClusterHealthStatus#RED.",
    "new_comment_raw": "Check if the Elasticsearch  Node is connected and that the cluster health status is not  ClusterHealthStatus#RED and that the  org.graylog2.indexer.Deflector#isUp() deflector is up.",
    "old_code_raw": "    public boolean isConnectedAndHealthy() {\n        try {\n            return getHealth() != ClusterHealthStatus.RED;\n        } catch (ElasticsearchException e) {\n            LOG.trace(\"Couldn't determine Elasticsearch health properly\", e);\n            return false;\n        }\n    }\n",
    "new_code_raw": "    public boolean isConnectedAndHealthy() {\n        Map<String, DiscoveryNode> nodeMap = nodes.get();\n        if (nodeMap == null || nodeMap.isEmpty()) {\n            return false;\n        }\n        if (!deflector.isUp()) {\n            return false;\n        }\n        try {\n            return getHealth() != ClusterHealthStatus.RED;\n        } catch (ElasticsearchException e) {\n            LOG.trace(\"Couldn't determine Elasticsearch health properly\", e);\n            return false;\n        }\n    }\n\n"
  },
  {
    "id": "processing_processing-209-FirstSentence-0",
    "old_comment_raw": "A variation of findDeclaration() but accepts an alternate parent ASTNode",
    "new_comment_raw": "A variation of findDeclaration() but accepts an alternate parent ASTNode",
    "old_code_raw": "  protected static ASTNode findDeclaration2(Name findMe, ASTNode alternateParent) {\n    ASTNode declaringClass = null;\n    ASTNode parent = findMe.getParent();\n    ASTNode ret = null;\n    ArrayList<Integer> constrains = new ArrayList<Integer>();\n    if (parent.getNodeType() == ASTNode.METHOD_INVOCATION) {\n      Expression exp = (Expression) ((MethodInvocation) parent)\n          .getStructuralProperty(MethodInvocation.EXPRESSION_PROPERTY);\n      //TODO: Note the imbalance of constrains.add(ASTNode.METHOD_DECLARATION);\n      // Possibly a bug here. Investigate later.\n      if (((MethodInvocation) parent).getName().toString()\n          .equals(findMe.toString())) {\n        constrains.add(ASTNode.METHOD_DECLARATION);\n\n        if (exp != null) {\n          constrains.add(ASTNode.TYPE_DECLARATION);\n//          log(\"MI EXP: \" + exp.toString() + \" of type \"\n//              + exp.getClass().getName() + \" parent: \" + exp.getParent());\n          if (exp instanceof MethodInvocation) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((MethodInvocation) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains, declaringClass);\n          } else if (exp instanceof FieldAccess) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((FieldAccess) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2((stp.getName()), alternateParent);\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains, declaringClass);\n          }\n          if (exp instanceof SimpleName) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((SimpleName) exp),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n//            log(\"MI.SN \" + getNodeAsString(declaringClass));\n            constrains.add(ASTNode.METHOD_DECLARATION);\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains, declaringClass);\n          }\n\n        }\n      } else {\n        parent = parent.getParent(); // Move one up the ast. V V IMP!!\n        alternateParent = alternateParent.getParent();\n      }\n    } else if (parent.getNodeType() == ASTNode.FIELD_ACCESS) {\n      FieldAccess fa = (FieldAccess) parent;\n      Expression exp = fa.getExpression();\n      if (fa.getName().toString().equals(findMe.toString())) {\n        constrains.add(ASTNode.FIELD_DECLARATION);\n\n        if (exp != null) {\n          constrains.add(ASTNode.TYPE_DECLARATION);\n//          log(\"FA EXP: \" + exp.toString() + \" of type \"\n//              + exp.getClass().getName() + \" parent: \" + exp.getParent());\n          if (exp instanceof MethodInvocation) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((MethodInvocation) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains, declaringClass);\n          } else if (exp instanceof FieldAccess) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((FieldAccess) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2((stp.getName()), alternateParent);\n            constrains.add(ASTNode.TYPE_DECLARATION);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains, declaringClass);\n          }\n          if (exp instanceof SimpleName) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((SimpleName) exp),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n//            log(\"FA.SN \" + getNodeAsString(declaringClass));\n            constrains.add(ASTNode.METHOD_DECLARATION);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains, declaringClass);\n          }\n        }\n\n      } else {\n        parent = parent.getParent(); // Move one up the ast. V V IMP!!\n        alternateParent = alternateParent.getParent();\n      }\n    } else if (parent.getNodeType() == ASTNode.QUALIFIED_NAME) {\n\n      QualifiedName qn = (QualifiedName) parent;\n      if (!findMe.toString().equals(qn.getQualifier().toString())) {\n\n        SimpleType stp = extracTypeInfo(findDeclaration2((qn.getQualifier()),\n                                                         alternateParent));\n        if(stp == null)\n          return null;\n        declaringClass = findDeclaration2(stp.getName(), alternateParent);\n//        log(qn.getQualifier() + \"->\" + qn.getName());\n//        log(\"QN decl class: \" + getNodeAsString(declaringClass));\n        constrains.clear();\n        constrains.add(ASTNode.TYPE_DECLARATION);\n        constrains.add(ASTNode.FIELD_DECLARATION);\n        return definedIn(declaringClass, qn.getName().toString(), constrains,\n                         null);\n      }\n      else{\n        if(findMe instanceof QualifiedName){\n          QualifiedName qnn = (QualifiedName) findMe;\n//          log(\"findMe is a QN, \"\n//              + (qnn.getQualifier().toString() + \" other \" + qnn.getName()\n//                  .toString()));\n\n          SimpleType stp = extracTypeInfo(findDeclaration2((qnn.getQualifier()), alternateParent));\n//          log(qnn.getQualifier() + \"->\" + qnn.getName());\n          declaringClass = findDeclaration2(stp.getName(), alternateParent);\n\n//          log(\"QN decl class: \"\n//              + getNodeAsString(declaringClass));\n          constrains.clear();\n          constrains.add(ASTNode.TYPE_DECLARATION);\n          constrains.add(ASTNode.FIELD_DECLARATION);\n          return definedIn(declaringClass, qnn.getName().toString(), constrains,\n                           null);\n        }\n      }\n    } else if (parent.getNodeType() == ASTNode.SIMPLE_TYPE) {\n      constrains.add(ASTNode.TYPE_DECLARATION);\n      if (parent.getParent().getNodeType() == ASTNode.CLASS_INSTANCE_CREATION)\n        constrains.add(ASTNode.CLASS_INSTANCE_CREATION);\n    } else if (parent instanceof Expression) {\n//      constrains.add(ASTNode.TYPE_DECLARATION);\n//      constrains.add(ASTNode.METHOD_DECLARATION);\n//      constrains.add(ASTNode.FIELD_DECLARATION);\n    } // TODO: in findDec, we also have a case where parent of type TD is handled.\n      // Figure out if needed here as well.\n//    log(\"Alternate parent: \" + getNodeAsString(alternateParent));\n    while (alternateParent != null) {\n//      log(\"findDeclaration2 -> \"\n//          + getNodeAsString(alternateParent));\n      for (Object oprop : alternateParent.structuralPropertiesForType()) {\n        StructuralPropertyDescriptor prop = (StructuralPropertyDescriptor) oprop;\n        if (prop.isChildProperty() || prop.isSimpleProperty()) {\n          if (alternateParent.getStructuralProperty(prop) instanceof ASTNode) {\n//            log(prop + \" C/S Prop of -> \"\n//                + getNodeAsString(alternateParent));\n            ret = definedIn((ASTNode) alternateParent\n                                .getStructuralProperty(prop),\n                            findMe.toString(), constrains, declaringClass);\n            if (ret != null)\n              return ret;\n          }\n        } else if (prop.isChildListProperty()) {\n//          log((prop) + \" ChildList props of \"\n//              + getNodeAsString(alternateParent));\n          List<ASTNode> nodelist = (List<ASTNode>) alternateParent\n              .getStructuralProperty(prop);\n          for (ASTNode retNode : nodelist) {\n            ret = definedIn(retNode, findMe.toString(), constrains,\n                            declaringClass);\n            if (ret != null)\n              return ret;\n          }\n        }\n      }\n      alternateParent = alternateParent.getParent();\n    }\n    return null;\n  }\n",
    "new_code_raw": "  protected static ASTNode findDeclaration2(Name findMe, ASTNode alternateParent) {\n    ASTNode declaringClass = null;\n    ASTNode parent = findMe.getParent();\n    ASTNode ret = null;\n    ArrayList<Integer> constrains = new ArrayList<Integer>();\n    if (parent.getNodeType() == ASTNode.METHOD_INVOCATION) {\n      Expression exp = (Expression) ((MethodInvocation) parent)\n          .getStructuralProperty(MethodInvocation.EXPRESSION_PROPERTY);\n      //TODO: Note the imbalance of constrains.add(ASTNode.METHOD_DECLARATION);\n      // Possibly a bug here. Investigate later.\n      if (((MethodInvocation) parent).getName().toString()\n          .equals(findMe.toString())) {\n        constrains.add(ASTNode.METHOD_DECLARATION);\n\n        if (exp != null) {\n          constrains.add(ASTNode.TYPE_DECLARATION);\n//          log(\"MI EXP: \" + exp.toString() + \" of type \"\n//              + exp.getClass().getName() + \" parent: \" + exp.getParent());\n          if (exp instanceof MethodInvocation) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((MethodInvocation) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains, declaringClass);\n          } else if (exp instanceof FieldAccess) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((FieldAccess) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2((stp.getName()), alternateParent);\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains, declaringClass);\n          }\n          if (exp instanceof SimpleName) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((SimpleName) exp),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n//            log(\"MI.SN \" + getNodeAsString(declaringClass));\n            constrains.add(ASTNode.METHOD_DECLARATION);\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains, declaringClass);\n          }\n\n        }\n      } else {\n        parent = parent.getParent(); // Move one up the ast. V V IMP!!\n        alternateParent = alternateParent.getParent();\n      }\n    } else if (parent.getNodeType() == ASTNode.FIELD_ACCESS) {\n      FieldAccess fa = (FieldAccess) parent;\n      Expression exp = fa.getExpression();\n      if (fa.getName().toString().equals(findMe.toString())) {\n        constrains.add(ASTNode.FIELD_DECLARATION);\n\n        if (exp != null) {\n          constrains.add(ASTNode.TYPE_DECLARATION);\n//          log(\"FA EXP: \" + exp.toString() + \" of type \"\n//              + exp.getClass().getName() + \" parent: \" + exp.getParent());\n          if (exp instanceof MethodInvocation) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((MethodInvocation) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains, declaringClass);\n          } else if (exp instanceof FieldAccess) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((FieldAccess) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2((stp.getName()), alternateParent);\n            constrains.add(ASTNode.TYPE_DECLARATION);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains, declaringClass);\n          }\n          if (exp instanceof SimpleName) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((SimpleName) exp),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n//            log(\"FA.SN \" + getNodeAsString(declaringClass));\n            constrains.add(ASTNode.METHOD_DECLARATION);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains, declaringClass);\n          }\n        }\n\n      } else {\n        parent = parent.getParent(); // Move one up the ast. V V IMP!!\n        alternateParent = alternateParent.getParent();\n      }\n    } else if (parent.getNodeType() == ASTNode.QUALIFIED_NAME) {\n\n      QualifiedName qn = (QualifiedName) parent;\n      if (!findMe.toString().equals(qn.getQualifier().toString())) {\n\n        SimpleType stp = extracTypeInfo(findDeclaration2((qn.getQualifier()),\n                                                         alternateParent));\n        if(stp == null)\n          return null;\n        declaringClass = findDeclaration2(stp.getName(), alternateParent);\n//        log(qn.getQualifier() + \"->\" + qn.getName());\n//        log(\"QN decl class: \" + getNodeAsString(declaringClass));\n        constrains.clear();\n        constrains.add(ASTNode.TYPE_DECLARATION);\n        constrains.add(ASTNode.FIELD_DECLARATION);\n        return definedIn(declaringClass, qn.getName().toString(), constrains,\n                         null);\n      }\n      else{\n        if(findMe instanceof QualifiedName){\n          QualifiedName qnn = (QualifiedName) findMe;\n//          log(\"findMe is a QN, \"\n//              + (qnn.getQualifier().toString() + \" other \" + qnn.getName()\n//                  .toString()));\n\n          SimpleType stp = extracTypeInfo(findDeclaration2((qnn.getQualifier()), alternateParent));\n\n          if (stp == null) {\n            return null;\n          }\n\n//          log(qnn.getQualifier() + \"->\" + qnn.getName());\n          declaringClass = findDeclaration2(stp.getName(), alternateParent);\n\n//          log(\"QN decl class: \"\n//              + getNodeAsString(declaringClass));\n          constrains.clear();\n          constrains.add(ASTNode.TYPE_DECLARATION);\n          constrains.add(ASTNode.FIELD_DECLARATION);\n          return definedIn(declaringClass, qnn.getName().toString(), constrains,\n                           null);\n        }\n      }\n    } else if (parent.getNodeType() == ASTNode.SIMPLE_TYPE) {\n      constrains.add(ASTNode.TYPE_DECLARATION);\n      if (parent.getParent().getNodeType() == ASTNode.CLASS_INSTANCE_CREATION)\n        constrains.add(ASTNode.CLASS_INSTANCE_CREATION);\n    } else if (parent instanceof Expression) {\n//      constrains.add(ASTNode.TYPE_DECLARATION);\n//      constrains.add(ASTNode.METHOD_DECLARATION);\n//      constrains.add(ASTNode.FIELD_DECLARATION);\n    } // TODO: in findDec, we also have a case where parent of type TD is handled.\n      // Figure out if needed here as well.\n//    log(\"Alternate parent: \" + getNodeAsString(alternateParent));\n    while (alternateParent != null) {\n//      log(\"findDeclaration2 -> \"\n//          + getNodeAsString(alternateParent));\n      for (Object oprop : alternateParent.structuralPropertiesForType()) {\n        StructuralPropertyDescriptor prop = (StructuralPropertyDescriptor) oprop;\n        if (prop.isChildProperty() || prop.isSimpleProperty()) {\n          if (alternateParent.getStructuralProperty(prop) instanceof ASTNode) {\n//            log(prop + \" C/S Prop of -> \"\n//                + getNodeAsString(alternateParent));\n            ret = definedIn((ASTNode) alternateParent\n                                .getStructuralProperty(prop),\n                            findMe.toString(), constrains, declaringClass);\n            if (ret != null)\n              return ret;\n          }\n        } else if (prop.isChildListProperty()) {\n//          log((prop) + \" ChildList props of \"\n//              + getNodeAsString(alternateParent));\n          List<ASTNode> nodelist = (List<ASTNode>) alternateParent\n              .getStructuralProperty(prop);\n          for (ASTNode retNode : nodelist) {\n            ret = definedIn(retNode, findMe.toString(), constrains,\n                            declaringClass);\n            if (ret != null)\n              return ret;\n          }\n        }\n      }\n      alternateParent = alternateParent.getParent();\n    }\n    return null;\n  }\n"
  },
  {
    "id": "apache_kylin-69-Associations-FirstSentence",
    "old_comment_raw": "Returns true if, the lockClient is keeping the lock for the lockPath",
    "new_comment_raw": "Returns true if, the job server is keeping the lock for the lockPath",
    "old_code_raw": "\n    private boolean isKeepLock(String lockClient, String lockPath) {\n        try {\n            if (zkClient.checkExists().forPath(lockPath) != null) {\n                byte[] data = zkClient.getData().forPath(lockPath);\n                String lockServerName = new String(data, Charset.forName(\"UTF-8\"));\n                return lockServerName.equalsIgnoreCase(lockClient);\n            }\n        } catch (Exception e) {\n            logger.error(\"fail to get the lockClient for the path: \" + lockPath, e);\n        }\n        return false;\n    }\n",
    "new_code_raw": "\n    private boolean isKeepLock(String serverName, String lockPath) {\n        try {\n            if (zkClient.checkExists().forPath(lockPath) != null) {\n                byte[] data = zkClient.getData().forPath(lockPath);\n                String lockServerName = new String(data, Charset.forName(\"UTF-8\"));\n                return lockServerName.equalsIgnoreCase(serverName);\n            }\n        } catch (Exception e) {\n            logger.error(\"fail to get the serverName for the path: \" + lockPath, e);\n        }\n        return false;\n    }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-909-FirstSentence-0",
    "old_comment_raw": "Returns the difference between this field property instant and the one passed in, in the units of this field.",
    "new_comment_raw": "Returns the difference between this field property instant and the one passed in, in the units of this field.",
    "old_code_raw": "    public long getDifferenceAsLong(ReadableInstant instant) {\n        if (instant == null) {\n            return getField().getDifferenceAsLong(getReadableInstant().getMillis(), DateTimeUtils.currentTimeMillis());\n        }\n        return getField().getDifferenceAsLong(getReadableInstant().getMillis(), instant.getMillis());\n    }\n",
    "new_code_raw": "    public long getDifferenceAsLong(ReadableInstant instant) {\n        if (instant == null) {\n            return getField().getDifferenceAsLong(getMillis(), DateTimeUtils.currentTimeMillis());\n        }\n        return getField().getDifferenceAsLong(getMillis(), instant.getMillis());\n    }\n"
  },
  {
    "id": "galderz_rhq-58-Associations-FirstSentence",
    "old_comment_raw": "Unsubscribes the resource from this channel, if it exists.",
    "new_comment_raw": "Unsubscribes the resource from this repo, if it exists.",
    "old_code_raw": "    public ResourceChannel removeResource(Resource resource) {\n        if ((this.resourceChannels == null) || (resource == null)) {\n            return null;\n        }\n\n        ResourceChannel doomed = null;\n\n        for (ResourceChannel rc : this.resourceChannels) {\n            if (resource.equals(rc.getResourceChannelPK().getResource())) {\n                doomed = rc;\n                break;\n            }\n        }\n\n        if (doomed != null) {\n            this.resourceChannels.remove(doomed);\n        }\n\n        return doomed;\n    }\n",
    "new_code_raw": "    public ResourceRepo removeResource(Resource resource) {\n        if ((this.resourceRepos == null) || (resource == null)) {\n            return null;\n        }\n\n        ResourceRepo doomed = null;\n\n        for (ResourceRepo rc : this.resourceRepos) {\n            if (resource.equals(rc.getResourceRepoPK().getResource())) {\n                doomed = rc;\n                break;\n            }\n        }\n\n        if (doomed != null) {\n            this.resourceRepos.remove(doomed);\n        }\n\n        return doomed;\n    }\n\n"
  },
  {
    "id": "Netflix_eureka-276-FirstSentence-0",
    "old_comment_raw": "Gets the task that updates the ASG information periodically.",
    "new_comment_raw": "Gets the task that updates the ASG information periodically.",
    "old_code_raw": "    private TimerTask getASGUpdateTask() {\n        return new TimerTask() {\n\n            @Override\n            public void run() {\n                try {\n                    // First get the active ASG names\n                    Set<CacheKey> cacheKeys = getCacheKeys();\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Trying to  refresh the keys for {}\", Arrays.toString(cacheKeys.toArray()));\n                    }\n                    for (CacheKey key : cacheKeys) {\n                        try {\n                            asgCache.refresh(key);\n                        } catch (Throwable e) {\n                            logger.error(\"Error updating the ASG cache for {}\", key, e);\n                        }\n\n                    }\n\n                } catch (Throwable e) {\n                    logger.error(\"Error updating the ASG cache\", e);\n                }\n\n            }\n\n        };\n    }\n",
    "new_code_raw": "    private TimerTask getASGUpdateTask() {\n        return new TimerTask() {\n\n            @Override\n            public void run() {\n                try {\n                    if (!serverConfig.shouldUseAwsAsgApi()) {\n                        // Disabled via the config, no-op.\n                        return;\n                    }\n\n                    // First get the active ASG names\n                    Set<CacheKey> cacheKeys = getCacheKeys();\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Trying to  refresh the keys for {}\", Arrays.toString(cacheKeys.toArray()));\n                    }\n                    for (CacheKey key : cacheKeys) {\n                        try {\n                            asgCache.refresh(key);\n                        } catch (Throwable e) {\n                            logger.error(\"Error updating the ASG cache for {}\", key, e);\n                        }\n\n                    }\n\n                } catch (Throwable e) {\n                    logger.error(\"Error updating the ASG cache\", e);\n                }\n\n            }\n\n        };\n    }\n"
  },
  {
    "id": "hazelcast_hazelcast-377-Associations-FirstSentence",
    "old_comment_raw": "Checks if a flag is set.",
    "new_comment_raw": "Returns  true if any of the flags supplied in the argument are set.",
    "old_code_raw": "    public boolean isFlagSet(int flag) {\n        return (flags & flag) != 0;\n    }\n",
    "new_code_raw": "    public boolean isFlagSet(int flagsToCheck) {\n        return (flags & flagsToCheck) != 0;\n    }\n\n"
  },
  {
    "id": "dropwizard_dropwizard-140-FirstSentence-0",
    "old_comment_raw": "Builds the  Client instance.",
    "new_comment_raw": "Builds the  Client instance.",
    "old_code_raw": "    public Client build() {\n        if ((environment == null) && (executorService == null) && (objectMapper == null)) {\n            throw new IllegalStateException(\"Must have either an environment or both \" +\n                                                    \"an executor service and an object mapper\");\n        }\n\n        if (environment == null) {\n            return build(executorService, objectMapper);\n        }\n\n        return build(environment.getLifecycleEnvironment()\n                                .managedExecutorService(\"jersey-client-%d\",\n                                                        configuration.getMinThreads(),\n                                                        configuration.getMaxThreads(),\n                                                        60,\n                                                        TimeUnit.SECONDS),\n                     environment.getJsonEnvironment().buildObjectMapper());\n    }\n",
    "new_code_raw": "    public Client build() {\n        if ((environment == null) && (executorService == null) && (objectMapper == null)) {\n            throw new IllegalStateException(\"Must have either an environment or both \" +\n                                                    \"an executor service and an object mapper\");\n        }\n\n        if (environment == null) {\n            return build(executorService, objectMapper);\n        }\n\n        return build(environment.getLifecycleEnvironment()\n                                .managedExecutorService(\"jersey-client-%d\",\n                                                        configuration.getMinThreads(),\n                                                        configuration.getMaxThreads(),\n                                                        60,\n                                                        TimeUnit.SECONDS),\n                     environment.getJsonEnvironment().build());\n    }\n"
  },
  {
    "id": "jackyglony_objectiveclipse-216-Associations-FirstSentence",
    "old_comment_raw": "Create an IType for an IASTName.",
    "new_comment_raw": "Create an IType for an IASTDeclarator.",
    "old_code_raw": "\tpublic static IType createType(IASTName name) {\n\t\tif (!(name.getParent() instanceof IASTDeclarator)) return null;\n\t\t\n\t    IASTDeclSpecifier declSpec = null;\n\t\tIASTDeclarator declarator = (IASTDeclarator) name.getParent();\n\t\t\n\t\tIASTNode node = declarator.getParent();\n\t\twhile( node instanceof IASTDeclarator ){\n\t\t\tdeclarator = (IASTDeclarator) node;\n\t\t\tnode = node.getParent();\n\t\t}\n\t\t\n\t\tif( node instanceof IASTParameterDeclaration )\n\t\t\tdeclSpec = ((IASTParameterDeclaration) node).getDeclSpecifier();\n\t\telse if( node instanceof IASTSimpleDeclaration )\n\t\t\tdeclSpec = ((IASTSimpleDeclaration)node).getDeclSpecifier();\n\t\telse if( node instanceof IASTFunctionDefinition )\n\t\t\tdeclSpec = ((IASTFunctionDefinition)node).getDeclSpecifier();\n\t\telse if( node instanceof IASTTypeId )\n\t\t    declSpec = ((IASTTypeId)node).getDeclSpecifier();\n\t\n\t\tboolean isParameter = ( node instanceof IASTParameterDeclaration || node.getParent() instanceof ICASTKnRFunctionDeclarator ); \n\t\t\n\t\tIType type = null;\n\t\t\n\t\t//C99 6.7.5.3-12 The storage class specifier for a parameter declaration is ignored unless the declared parameter is one of the \n\t\t//members of the parameter type list for a function definition.\n\t\tif( isParameter && node.getParent().getParent() instanceof IASTFunctionDefinition ){\n\t\t    type = createBaseType( declSpec );\n\t\t} else {\n\t\t    type = createType( declSpec );\n\t\t}\n\t\t\n\t\ttype = createType( type, declarator );\n\t\t\n\t\t\n        if( isParameter ) {\n            //C99: 6.7.5.3-7 a declaration of a parameter as \"array of type\" shall be adjusted to \"qualified pointer to type\", where the\n    \t\t//type qualifiers (if any) are those specified within the [ and ] of the array type derivation\n            if( type instanceof IArrayType ){\n\t            CArrayType at = (CArrayType) type;\n\t            type = new CQualifiedPointerType( at.getType(), at.getModifier() );\n\t        } else if( type instanceof IFunctionType ) {\n\t            //-8 A declaration of a parameter as \"function returning type\" shall be adjusted to \"pointer to function returning type\"\n\t            type = new CPointerType( type );\n\t        }\n        }\n        \n\t\treturn type;\n\t}\n",
    "new_code_raw": "\tpublic static IType createType(IASTDeclarator declarator) {\n\t    IASTDeclSpecifier declSpec = null;\n\t\t\n\t\tIASTNode node = declarator.getParent();\n\t\twhile( node instanceof IASTDeclarator ){\n\t\t\tdeclarator = (IASTDeclarator) node;\n\t\t\tnode = node.getParent();\n\t\t}\n\t\t\n\t\tif( node instanceof IASTParameterDeclaration )\n\t\t\tdeclSpec = ((IASTParameterDeclaration) node).getDeclSpecifier();\n\t\telse if( node instanceof IASTSimpleDeclaration )\n\t\t\tdeclSpec = ((IASTSimpleDeclaration)node).getDeclSpecifier();\n\t\telse if( node instanceof IASTFunctionDefinition )\n\t\t\tdeclSpec = ((IASTFunctionDefinition)node).getDeclSpecifier();\n\t\telse if( node instanceof IASTTypeId )\n\t\t    declSpec = ((IASTTypeId)node).getDeclSpecifier();\n\t\n\t\tboolean isParameter = ( node instanceof IASTParameterDeclaration || node.getParent() instanceof ICASTKnRFunctionDeclarator ); \n\t\t\n\t\tIType type = null;\n\t\t\n\t\t//C99 6.7.5.3-12 The storage class specifier for a parameter declaration is ignored unless the declared parameter is one of the \n\t\t//members of the parameter type list for a function definition.\n\t\tif( isParameter && node.getParent().getParent() instanceof IASTFunctionDefinition ){\n\t\t    type = createBaseType( declSpec );\n\t\t} else {\n\t\t    type = createType( declSpec );\n\t\t}\n\t\t\n\t\ttype = createType( type, declarator );\n\t\t\n\t\t\n        if( isParameter ) {\n            //C99: 6.7.5.3-7 a declaration of a parameter as \"array of type\" shall be adjusted to \"qualified pointer to type\", where the\n    \t\t//type qualifiers (if any) are those specified within the [ and ] of the array type derivation\n            if( type instanceof IArrayType ){\n\t            CArrayType at = (CArrayType) type;\n\t            type = new CQualifiedPointerType( at.getType(), at.getModifier() );\n\t        } else if( type instanceof IFunctionType ) {\n\t            //-8 A declaration of a parameter as \"function returning type\" shall be adjusted to \"pointer to function returning type\"\n\t            type = new CPointerType( type );\n\t        }\n        }\n        \n\t\treturn type;\n\t}\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1993-FirstSentence-0",
    "old_comment_raw": "Tries to load config class with SPI first, then with class name directly from classpath",
    "new_comment_raw": "Tries to load config class with SPI first, then with class name directly from classpath",
    "old_code_raw": "    public static CodegenConfig forName(String name) {\n        ServiceLoader<CodegenConfig> loader = load(CodegenConfig.class);\n\n        StringBuilder availableConfigs = new StringBuilder();\n\n        for (CodegenConfig config : loader) {\n            if (config.getName().equals(name)) {\n                return config;\n            }\n\n            availableConfigs.append(config.getName()).append(\"\\n\");\n        }\n\n        // else try to load directly\n        try {\n            return (CodegenConfig) Class.forName(name).newInstance();\n        } catch (Exception e) {\n            throw new GeneratorNotFoundException(\"Can't load config class with name '\".concat(name) + \"'\\nAvailable:\\n\" + availableConfigs.toString(), e);\n        }\n    }\n",
    "new_code_raw": "    public static CodegenConfig forName(String name) {\n        ServiceLoader<CodegenConfig> loader = load(CodegenConfig.class);\n\n        StringBuilder availableConfigs = new StringBuilder();\n\n        for (CodegenConfig config : loader) {\n            if (config.getName().equals(name)) {\n                return config;\n            }\n\n            availableConfigs.append(config.getName()).append(\"\\n\");\n        }\n\n        // else try to load directly\n        try {\n            return (CodegenConfig) Class.forName(name).getDeclaredConstructor().newInstance();\n        } catch (Exception e) {\n            throw new GeneratorNotFoundException(\"Can't load config class with name '\".concat(name) + \"'\\nAvailable:\\n\" + availableConfigs.toString(), e);\n        }\n    }\n"
  },
  {
    "id": "JetBrains_jdk8u_jaxp-41-Associations-FirstSentence",
    "old_comment_raw": "Returns a List containing all the child nodes of this node.",
    "new_comment_raw": "Returns a Vector containing all the child nodes of this node.",
    "old_code_raw": "    protected final List<SyntaxTreeNode> getContents() {\n        return _contents;\n    }\n",
    "new_code_raw": "    protected final Vector getContents() {\n        return _contents;\n    }\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2153-FirstSentence-0",
    "old_comment_raw": "Constructs a new PTBTokenizer that makes CoreLabel tokens.",
    "new_comment_raw": "Constructs a new PTBTokenizer that makes CoreLabel tokens.",
    "old_code_raw": "  public static PTBTokenizer<CoreLabel> newPTBTokenizer(Reader r, boolean tokenizeNLs, boolean invertible) {\n    return new PTBTokenizer<CoreLabel>(r, tokenizeNLs, invertible, false, new CoreLabelTokenFactory());\n  }\n",
    "new_code_raw": "  public static PTBTokenizer<CoreLabel> newPTBTokenizer(Reader r, boolean tokenizeNLs, boolean invertible) {\n    return new PTBTokenizer<>(r, tokenizeNLs, invertible, false, new CoreLabelTokenFactory());\n  }\n"
  },
  {
    "id": "apache_drill-1532-FirstSentence-0",
    "old_comment_raw": "Method that get's left and right incoming batch and produce the output batch.",
    "new_comment_raw": "Gets the left and right incoming batch and produce the output batch.",
    "old_code_raw": "  public IterOutcome innerNext() {\n\n    if (hasRemainderForLeftJoin) { // if set that means there is spill over from previous left batch and no\n      // corresponding right rows and it is left join scenario\n      allocateVectors();\n\n      boolean hasMoreRows = !handleRemainingLeftRows();\n      if (leftUpstream == EMIT || hasMoreRows) {\n        logger.debug(\"Sending current output batch with EMIT outcome since left is received with EMIT and is fully \" +\n          \"consumed now in output batch\");\n        hasRemainderForLeftJoin = hasMoreRows;\n        finalizeOutputContainer();\n        return (leftUpstream == EMIT) ? EMIT : OK;\n      } else {\n        // release memory for previous left batch\n        leftJoinIndex = -1;\n        VectorAccessibleUtilities.clear(left);\n      }\n    }\n\n    // We don't do anything special on FIRST state. Process left batch first and then right batch if need be\n    IterOutcome childOutcome = processLeftBatch();\n    logger.debug(\"Received left batch with outcome {}\", childOutcome);\n\n    if (processLeftBatchInFuture && hasRemainderForLeftJoin) {\n      finalizeOutputContainer();\n      hasRemainderForLeftJoin = false;\n      return OK;\n    }\n\n    // reset this state after calling processLeftBatch above.\n    processLeftBatchInFuture = false;\n    hasRemainderForLeftJoin = false;\n\n    // If the left batch doesn't have any record in the incoming batch (with OK_NEW_SCHEMA/EMIT) or the state returned\n    // from left side is terminal state then just return the IterOutcome and don't call next() on right branch\n    if (isTerminalOutcome(childOutcome) || left.getRecordCount() == 0) {\n      container.setRecordCount(0);\n      return childOutcome;\n    }\n\n    // Left side has some records in the batch so let's process right batch\n    childOutcome = processRightBatch();\n    logger.debug(\"Received right batch with outcome {}\", childOutcome);\n\n    // reset the left & right outcomes to OK here and send the empty batch downstream. Non-Empty right batch with\n    // OK_NEW_SCHEMA will be handled in subsequent next call\n    if (childOutcome == OK_NEW_SCHEMA) {\n      leftUpstream = (leftUpstream != EMIT) ? OK : leftUpstream;\n      rightUpstream = OK;\n      return childOutcome;\n    }\n\n    if (isTerminalOutcome(childOutcome)) {\n      return childOutcome;\n    }\n\n    // If OK_NEW_SCHEMA is seen only on non empty left batch but not on right batch, then we should setup schema in\n    // output container based on new left schema and old right schema. If schema change failed then return STOP\n    // downstream\n    if (leftUpstream == OK_NEW_SCHEMA && !handleSchemaChange()) {\n      return STOP;\n    }\n\n    // Setup the references of left, right and outgoing container in generated operator\n    state = BatchState.NOT_FIRST;\n\n    // Update the memory manager only if its a brand new incoming i.e. leftJoinIndex and rightJoinIndex is 0\n    // Otherwise there will be a case where while filling last output batch, some records from previous left or\n    // right batch are still left to be sent in output for which we will count this batch twice. The actual checks\n    // are done in updateMemoryManager\n    updateMemoryManager(LEFT_INDEX);\n\n    // We have to call update on memory manager for empty batches (rightJoinIndex = -1) as well since other wise while\n    // allocating memory for vectors below it can fail. Since in that case colSize will not have any info on right side\n    // vectors and throws NPE. The actual checks are done in updateMemoryManager\n    updateMemoryManager(RIGHT_INDEX);\n\n    if (outputIndex > 0) {\n      // this means batch is already allocated but because of new incoming the width and output row count might have\n      // changed. So update the maxOutputRowCount with new value\n      if (useMemoryManager) {\n        setMaxOutputRowCount(batchMemoryManager.getCurrentOutgoingMaxRowCount());\n      }\n    }\n    // if output is not allocated then maxRowCount will be set correctly below\n    // allocate space for the outgoing batch\n    allocateVectors();\n\n    return produceOutputBatch();\n  }\n",
    "new_code_raw": "  public IterOutcome innerNext() {\n\n    if (hasRemainderForLeftJoin) { // if set that means there is spill over from previous left batch and no\n      // corresponding right rows and it is left join scenario\n      allocateVectors();\n\n      boolean hasMoreRows = !handleRemainingLeftRows();\n      if (leftUpstream == EMIT || hasMoreRows) {\n        logger.debug(\"Sending current output batch with EMIT outcome since left is received with EMIT and is fully \" +\n          \"consumed now in output batch\");\n        hasRemainderForLeftJoin = hasMoreRows;\n        finalizeOutputContainer();\n        return (leftUpstream == EMIT) ? EMIT : OK;\n      } else {\n        // release memory for previous left batch\n        leftJoinIndex = -1;\n        VectorAccessibleUtilities.clear(left);\n      }\n    }\n\n    // We don't do anything special on FIRST state. Process left batch first and then right batch if need be\n    IterOutcome childOutcome = processLeftBatch();\n    logger.debug(\"Received left batch with outcome {}\", childOutcome);\n\n    if (processLeftBatchInFuture && hasRemainderForLeftJoin) {\n      finalizeOutputContainer();\n      hasRemainderForLeftJoin = false;\n      return OK;\n    }\n\n    // reset this state after calling processLeftBatch above.\n    processLeftBatchInFuture = false;\n    hasRemainderForLeftJoin = false;\n\n    // If the left batch doesn't have any record in the incoming batch (with OK_NEW_SCHEMA/EMIT) or the state returned\n    // from left side is terminal state then just return the IterOutcome and don't call next() on right branch\n    if (isTerminalOutcome(childOutcome) || left.getRecordCount() == 0) {\n      container.setRecordCount(0);\n      return childOutcome;\n    }\n\n    // Left side has some records in the batch so let's process right batch\n    childOutcome = processRightBatch();\n    logger.debug(\"Received right batch with outcome {}\", childOutcome);\n\n    // reset the left & right outcomes to OK here and send the empty batch downstream. Non-Empty right batch with\n    // OK_NEW_SCHEMA will be handled in subsequent next call\n    if (childOutcome == OK_NEW_SCHEMA) {\n      leftUpstream = (leftUpstream != EMIT) ? OK : leftUpstream;\n      rightUpstream = OK;\n      return childOutcome;\n    }\n\n    if (isTerminalOutcome(childOutcome)) {\n      return childOutcome;\n    }\n\n    // If OK_NEW_SCHEMA is seen only on non empty left batch but not on right batch, then we should setup schema in\n    // output container based on new left schema and old right schema. If schema change failed then return STOP\n    // downstream\n    if (leftUpstream == OK_NEW_SCHEMA) {\n      handleSchemaChange();\n    }\n\n    // Setup the references of left, right and outgoing container in generated operator\n    state = BatchState.NOT_FIRST;\n\n    // Update the memory manager only if its a brand new incoming i.e. leftJoinIndex and rightJoinIndex is 0\n    // Otherwise there will be a case where while filling last output batch, some records from previous left or\n    // right batch are still left to be sent in output for which we will count this batch twice. The actual checks\n    // are done in updateMemoryManager\n    updateMemoryManager(LEFT_INDEX);\n\n    // We have to call update on memory manager for empty batches (rightJoinIndex = -1) as well since other wise while\n    // allocating memory for vectors below it can fail. Since in that case colSize will not have any info on right side\n    // vectors and throws NPE. The actual checks are done in updateMemoryManager\n    updateMemoryManager(RIGHT_INDEX);\n\n    if (outputIndex > 0) {\n      // this means batch is already allocated but because of new incoming the width and output row count might have\n      // changed. So update the maxOutputRowCount with new value\n      if (useMemoryManager) {\n        setMaxOutputRowCount(batchMemoryManager.getCurrentOutgoingMaxRowCount());\n      }\n    }\n    // if output is not allocated then maxRowCount will be set correctly below\n    // allocate space for the outgoing batch\n    allocateVectors();\n\n    return produceOutputBatch();\n  }\n"
  },
  {
    "id": "querydsl_querydsl-235-FirstSentence-0",
    "old_comment_raw": "Expr : left.endsWith(right)",
    "new_comment_raw": "Expr : left.endsWith(right)",
    "old_code_raw": "    public static EBoolean endsWith(Expr<String> left, String right) {\n        return createBoolean(Ops.ENDSWITH, left, createConstant(right));\n    }\n",
    "new_code_raw": "    public static EBoolean endsWith(Expr<String> left, String right) {\n        return factory.createBoolean(Ops.ENDSWITH, left, factory.createConstant(right));\n    }\n"
  },
  {
    "id": "zaproxy_zaproxy-2115-FirstSentence-0",
    "old_comment_raw": "This method initializes jTextArea",
    "new_comment_raw": "This method initializes ZapTextArea",
    "old_code_raw": "    private JTextArea getTxtSkipURL() {\n        if (txtSkipURL == null) {\n            txtSkipURL = new JTextArea();\n            txtSkipURL.setFont(new java.awt.Font(\"Default\", java.awt.Font.PLAIN, 11));\n    \t    if (Model.getSingleton().getOptionsParam().getViewParam().getWmUiHandlingOption() == 0) {\n    \t    \ttxtSkipURL.setSize(new java.awt.Dimension(290,52));\n    \t    }\n        }\n        return txtSkipURL;\n    }\n",
    "new_code_raw": "    private ZapTextArea getTxtSkipURL() {\n        if (txtSkipURL == null) {\n            txtSkipURL = new ZapTextArea();\n            txtSkipURL.setFont(new java.awt.Font(\"Default\", java.awt.Font.PLAIN, 11));\n    \t    if (Model.getSingleton().getOptionsParam().getViewParam().getWmUiHandlingOption() == 0) {\n    \t    \ttxtSkipURL.setSize(new java.awt.Dimension(290,52));\n    \t    }\n        }\n        return txtSkipURL;\n    }\n"
  },
  {
    "id": "debezium_debezium-754-FirstSentence-0",
    "old_comment_raw": "Converts a value object for an expected JDBC type of  Types#TIMESTAMP.",
    "new_comment_raw": "Converts a value object for an expected JDBC type of  Types#TIMESTAMP.",
    "old_code_raw": "    protected Object convertTimestamp(Field fieldDefn, Object data) {\n        java.util.Date date = null;\n        if (data instanceof java.sql.Timestamp) {\n            // JDBC specification indicates that this will be the canonical object for this JDBC type.\n            date = (java.util.Date) data;\n        } else if (data instanceof java.sql.Date) {\n            // This should still work, even though it should have just date info\n            date = (java.util.Date) data;\n        } else if (data instanceof java.util.Date) {\n            // Possible that some implementations might use this.\n            date = (java.util.Date) data;\n        } else if (data instanceof java.time.LocalDate) {\n            // If we get a local date (no TZ info), we need to just convert to a util.Date (no TZ info) ...\n            java.time.LocalDate local = (java.time.LocalDate) data;\n            date = java.util.Date.from(local.atStartOfDay().toInstant(ZoneOffset.UTC));\n        } else if (data instanceof java.time.LocalDateTime) {\n            // Get the instant in time by changing any date info to the epoch day so we only have time ...\n            java.time.LocalDateTime local = (java.time.LocalDateTime) data;\n            date = java.util.Date.from(local.toInstant(ZoneOffset.UTC));\n        } else {\n            // An unexpected\n            date = unexpectedTimestamp(data, fieldDefn);\n        }\n        return date == null ? null : Timestamp.fromLogical(fieldDefn.schema(), date);\n    }\n",
    "new_code_raw": "    protected Object convertTimestamp(Field fieldDefn, Object data) {\n        java.util.Date date = null;\n        if (data instanceof java.sql.Timestamp) {\n            // JDBC specification indicates that this will be the canonical object for this JDBC type.\n            date = (java.util.Date) data;\n        } else if (data instanceof java.sql.Date) {\n            // This should still work, even though it should have just date info\n            date = (java.util.Date) data;\n        } else if (data instanceof java.util.Date) {\n            // Possible that some implementations might use this.\n            date = (java.util.Date) data;\n        } else if (data instanceof java.time.LocalDate) {\n            // If we get a local date (no TZ info), we need to just convert to a util.Date (no TZ info) ...\n            java.time.LocalDate local = (java.time.LocalDate) data;\n            date = java.util.Date.from(local.atStartOfDay().toInstant(ZoneOffset.UTC));\n        } else if (data instanceof java.time.LocalDateTime) {\n            // Get the instant in time by changing any date info to the epoch day so we only have time ...\n            java.time.LocalDateTime local = (java.time.LocalDateTime) data;\n            date = java.util.Date.from(local.toInstant(ZoneOffset.UTC));\n        } else {\n            // An unexpected\n            date = unexpectedTimestamp(data, fieldDefn);\n        }\n        return date;\n    }\n"
  },
  {
    "id": "apache_calcite-865-FirstSentence-0",
    "old_comment_raw": "Determines if a specified set of columns from a specified relational expression are unique.",
    "new_comment_raw": "Returns the  BuiltInMetadata.ColumnUniqueness#areColumnsUnique(BitSet, boolean) statistic.",
    "old_code_raw": "  public static Boolean areColumnsUnique(RelNode rel, BitSet columns) {\n    return (Boolean) rel.getCluster().getMetadataProvider().getRelMetadata(\n        rel,\n        \"areColumnsUnique\",\n        new Object[]{columns, false});\n  }\n",
    "new_code_raw": "  public static Boolean areColumnsUnique(RelNode rel, BitSet columns) {\n    final BuiltInMetadata.ColumnUniqueness metadata =\n        rel.metadata(BuiltInMetadata.ColumnUniqueness.class);\n    return metadata.areColumnsUnique(columns, false);\n  }\n"
  },
  {
    "id": "pwittchen_ReactiveNetwork-11-FirstSentence-0",
    "old_comment_raw": "Observes connectivity with the Internet with default settings.",
    "new_comment_raw": "Observes connectivity with the Internet with default settings.",
    "old_code_raw": "  public static Observable<Boolean> observeInternetConnectivity() {\n    return observeInternetConnectivity(DEFAULT_INITIAL_PING_INTERVAL_IN_MS,\n        DEFAULT_PING_INTERVAL_IN_MS, DEFAULT_PING_HOST, DEFAULT_PING_PORT,\n        DEFAULT_PING_TIMEOUT_IN_MS, new DefaultSocketErrorHandler());\n  }\n",
    "new_code_raw": "  public static Observable<Boolean> observeInternetConnectivity() {\n    return observeInternetConnectivity(DEFAULT_INITIAL_PING_INTERVAL_IN_MS,\n        DEFAULT_PING_INTERVAL_IN_MS, DEFAULT_PING_HOST, DEFAULT_PING_PORT,\n        DEFAULT_PING_TIMEOUT_IN_MS, new DefaultErrorHandler());\n  }\n"
  },
  {
    "id": "querydsl_querydsl-1435-FirstSentence-0",
    "old_comment_raw": "Expr : left.endsWith(right) (ignore case)",
    "new_comment_raw": "Expr : left.endsWith(right)",
    "old_code_raw": "    public static EBoolean endsWith(Expr<String> left, String right, boolean caseSensitive) {\n        if (caseSensitive){\n            return endsWith(left, right);            \n        }else{\n            return operationFactory.createBoolean(Ops.ENDSWITH_IC, left, exprFactory.createConstant(right));\n        }                \n    }\n",
    "new_code_raw": "    public static EBoolean endsWith(Expr<String> left, String right) {\n        return operationFactory.createBoolean(Ops.ENDSWITH, left, exprFactory\n                .createConstant(right));\n    }\n"
  },
  {
    "id": "apache_calcite-807-FirstSentence-0",
    "old_comment_raw": "Create RelNode tree that produces a list of correlated variables.",
    "new_comment_raw": "Create RelNode tree that produces a list of correlated variables.",
    "old_code_raw": "  private Frame getFrame(RelNode r, boolean safe) {\n    final Frame frame = map.get(r);\n    if (frame == null && safe) {\n      return new Frame(r, r, ImmutableSortedMap.<CorDef, Integer>of(),\n          identityMap(r.getRowType().getFieldCount()));\n    }\n    return frame;\n  }\n",
    "new_code_raw": "  private Frame getFrame(RelNode r, boolean safe) {\n    final Frame frame = map.get(r);\n    if (frame == null && safe) {\n      return new Frame(r, r, ImmutableSortedMap.of(),\n          identityMap(r.getRowType().getFieldCount()));\n    }\n    return frame;\n  }\n"
  },
  {
    "id": "apache_drill-1519-FirstSentence-0",
    "old_comment_raw": "The  #add(Object...) method uses Java variable-length arguments to pass a row of values.",
    "new_comment_raw": "The  #addRow(Object...) method uses Java variable-length arguments to pass a row of values.",
    "old_code_raw": "  public RowSetBuilder addSingleCol(Object value) {\n    return add(new Object[] { value });\n  }\n",
    "new_code_raw": "  public RowSetBuilder addSingleCol(Object value) {\n    return addRow(new Object[] { value });\n  }\n"
  },
  {
    "id": "querydsl_querydsl-385-FirstSentence-0",
    "old_comment_raw": "Clone the state of this query to a new JPAQuery instance with the given EntityManager",
    "new_comment_raw": "Clone the state of this query to a new JPAQuery instance with the given EntityManager",
    "old_code_raw": "    public JPAQuery clone(EntityManager entityManager){\n        return new JPAQuery(new DefaultSessionHolder(entityManager), templates, getMetadata().clone());\n    }\n",
    "new_code_raw": "    public JPAQuery clone(EntityManager entityManager){\n        return new JPAQuery(new DefaultSessionHolder(entityManager), getTemplates(), getMetadata().clone());\n    }\n"
  },
  {
    "id": "yahoo_bullet-core-22-Associations-FirstSentence",
    "old_comment_raw": "Returns if this query should buffer before emitting results.",
    "new_comment_raw": "Returns if this query should buffer before emitting the final results.",
    "old_code_raw": "    public boolean shouldBuffer() {\n        Window window = runningQuery.getQuery().getWindow();\n        boolean noWindow = window == null;\n        // If it's a RAW query without a window, it should be buffered if and only if it timed out. This means that the\n        // query is not yet done. So this tells the driver to buffer the query to wait for more potential results.\n        if (noWindow && isRaw()) {\n            return runningQuery.isTimedOut();\n        }\n        // No window (and not raw) is a duration based query => do buffer. Otherwise, buffer if the window is time based.\n        return noWindow || window.isTimeBased();\n    }\n",
    "new_code_raw": "    public boolean shouldBuffer() {\n        Window window = runningQuery.getQuery().getWindow();\n        boolean noWindow =  window == null;\n        // Only buffer if there is no window (including Raw) or if it's a record based window.\n        return noWindow || !window.isTimeBased();\n    }\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-1629-FirstSentence-0",
    "old_comment_raw": "Retrieve the fetch descriptor associated with the given entity key.",
    "new_comment_raw": "Retrieve the fetch descriptor associated with the given entity key.",
    "old_code_raw": "\tpublic SubselectFetch getSubselect(EntityKey key) {\n\t\treturn (SubselectFetch) subselectsByEntityKey.get(key);\n\t}\n",
    "new_code_raw": "\tpublic SubselectFetch getSubselect(EntityKey key) {\n\t\treturn subselectsByEntityKey.get( key );\n\t}\n"
  },
  {
    "id": "rstudio_rstudio-138-FirstSentence-0",
    "old_comment_raw": "Adds a menu item to the bar containing SafeHtml, that will fire the given command when it is selected.",
    "new_comment_raw": "Adds a menu item to the bar, that will fire the given command when it is selected.",
    "old_code_raw": "  public MenuItem addItem(SafeHtml html, ScheduledCommand cmd) {\n    return addItem(new MenuItem(html, Roles.getMenuitemRole(), false, cmd));\n  }\n",
    "new_code_raw": "  public MenuItem addItem(String text, boolean asHTML, Command cmd) {\n    return addItem(new MenuItem(text, asHTML, cmd));\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-339-FirstSentence-0",
    "old_comment_raw": "Provided we  #supportsInsertSelectIdentity, then attach the \"select identity\" clause to the insert statement.",
    "new_comment_raw": "Provided we  #supportsInsertSelectIdentity, then attach the \"select identity\" clause to the insert statement.",
    "old_code_raw": "\tpublic String appendIdentitySelectToInsert(String insertString) {\n\t\treturn insertString;\n\t}\n",
    "new_code_raw": "\tpublic String appendIdentitySelectToInsert(String insertString) {\n\t\treturn getIdentityColumnSupport().appendIdentitySelectToInsert( insertString );\n\t}\n"
  },
  {
    "id": "eclipse_tcf-79-Associations-FirstSentence",
    "old_comment_raw": "Get the specific column's ContextColumn object.",
    "new_comment_raw": "Get the specific column's ColumnDescriptor object.",
    "old_code_raw": "\tprivate ColumnDescriptor getColumn(int columnIndex) {\n\t\tTree tree = viewer.getTree();\n\t\tTreeColumn column = tree.getColumn(columnIndex);\n\t\tColumnDescriptor context = (ColumnDescriptor) column.getData();\n\t\treturn context;\n\t}\n",
    "new_code_raw": "\tprivate ColumnDescriptor getColumn(int columnIndex) {\n\t\tTree tree = viewer.getTree();\n\t\tTreeColumn column = tree.getColumn(columnIndex);\n\t\tColumnDescriptor descriptor = (ColumnDescriptor) column.getData();\n\t\treturn descriptor;\n\t}\n\n"
  },
  {
    "id": "debezium_debezium-814-FirstSentence-0",
    "old_comment_raw": "Create and return a new Field instance that is a copy of this field but with the given default value.",
    "new_comment_raw": "Create and return a new Field instance that is a copy of this field but with the given default value.",
    "old_code_raw": "    public Field withDefault(boolean defaultValue) {\n        return Field.create(name(), description(), defaultValue);\n    }\n",
    "new_code_raw": "    public Field withDefault(boolean defaultValue) {\n        return new Field(name(), displayName(), type(), width, description(), importance(), dependents,\n                () -> Boolean.valueOf(defaultValue), validator, recommender);\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2420-FirstSentence-0",
    "old_comment_raw": "Create a CoreMap representing a sentence from this protocol buffer.",
    "new_comment_raw": "Create a CoreLabel from its serialized counterpart.",
    "old_code_raw": "  protected CoreMap fromProto(CoreNLPProtos.Sentence proto) {\n    CoreMap sentence = new ArrayCoreMap();\n    // Required fields\n    sentence.set(TokenBeginAnnotation.class, proto.getTokenOffsetBegin());\n    sentence.set(TokenEndAnnotation.class, proto.getTokenOffsetEnd());\n    // Optional fields\n    if (proto.hasSentenceIndex()) { sentence.set(SentenceIndexAnnotation.class, proto.getSentenceIndex()); }\n    if (proto.hasCharacterOffsetBegin()) { sentence.set(CharacterOffsetBeginAnnotation.class, proto.getCharacterOffsetBegin()); }\n    if (proto.hasCharacterOffsetEnd()) { sentence.set(CharacterOffsetEndAnnotation.class, proto.getCharacterOffsetEnd()); }\n    if (proto.hasParseTree()) { sentence.set(TreeAnnotation.class, fromProto(proto.getParseTree())); }\n    // Non-default fields\n    if (proto.hasHasRelationAnnotations() && proto.getHasRelationAnnotations()) {\n      // set entities\n      List<EntityMention> entities = new ArrayList<EntityMention>();\n      for (CoreNLPProtos.Entity entity : proto.getEntityList()) { entities.add(fromProto(entity, sentence)); }\n      sentence.set(EntityMentionsAnnotation.class, entities);\n      // set relations\n      List<RelationMention> relations = new ArrayList<RelationMention>();\n      for (CoreNLPProtos.Relation relation : proto.getRelationList()) { relations.add(fromProto(relation, sentence)); }\n      sentence.set(RelationMentionsAnnotation.class, relations);\n    }\n    // Return\n    return sentence;\n  }\n",
    "new_code_raw": "  protected CoreLabel fromProto(CoreNLPProtos.Token proto) {\n    CoreLabel word = new CoreLabel();\n    // Required fields\n    word.setWord(proto.getWord());\n    // Optional fields\n    if (proto.hasPos()) { word.setTag(proto.getPos()); }\n    if (proto.hasValue()) { word.setValue(proto.getValue()); }\n    if (proto.hasCategory()) { word.setCategory(proto.getCategory()); }\n    if (proto.hasBefore()) { word.setBefore(proto.getBefore()); }\n    if (proto.hasAfter()) { word.setAfter(proto.getAfter()); }\n    if (proto.hasOriginalText()) { word.setOriginalText(proto.getOriginalText()); }\n    if (proto.hasNer()) { word.setNER(proto.getNer()); }\n    if (proto.hasLemma()) { word.setLemma(proto.getLemma()); }\n    if (proto.hasBeginChar()) { word.setBeginPosition(proto.getBeginChar()); }\n    if (proto.hasEndChar()) { word.setEndPosition(proto.getEndChar()); }\n    if (proto.hasSpeaker()) { word.set(SpeakerAnnotation.class, proto.getSpeaker()); }\n    if (proto.hasUtterance()) { word.set(UtteranceAnnotation.class, proto.getUtterance()); }\n    if (proto.hasBeginIndex()) { word.set(BeginIndexAnnotation.class, proto.getBeginIndex()); }\n    if (proto.hasEndIndex()) { word.set(EndIndexAnnotation.class, proto.getEndIndex()); }\n    if (proto.hasTokenBeginIndex()) { word.set(TokenBeginAnnotation.class, proto.getTokenBeginIndex()); }\n    if (proto.hasTokenEndIndex()) { word.set(TokenEndAnnotation.class, proto.getTokenEndIndex()); }\n    if (proto.hasNormalizedNER()) { word.set(NormalizedNamedEntityTagAnnotation.class, proto.getNormalizedNER()); }\n    if (proto.hasTimexValue()) { word.set(TimexAnnotation.class, fromProto(proto.getTimexValue())); }\n    if (proto.hasHasXmlContext() && proto.getHasXmlContext()) { word.set(XmlContextAnnotation.class, proto.getXmlContextList()); }\n    if (proto.hasCorefClusterID()) { word.set(CorefClusterIdAnnotation.class, proto.getCorefClusterID()); }\n    if (proto.hasAnswer()) { word.set(AnswerAnnotation.class, proto.getAnswer()); }\n    // Non-default annotators\n    if (proto.hasGender()) { word.set(GenderAnnotation.class, proto.getGender()); }\n    if (proto.hasTrueCase()) { word.set(TrueCaseAnnotation.class, proto.getTrueCase()); }\n    if (proto.hasTrueCaseText()) { word.set(TrueCaseTextAnnotation.class, proto.getTrueCaseText()); }\n    // Return\n    return word;\n  }\n"
  },
  {
    "id": "RobotiumTech_robotium-1442-FirstSentence-0",
    "old_comment_raw": "Waits for a given view.",
    "new_comment_raw": "Waits for a given view.",
    "old_code_raw": "\tpublic boolean waitForView(View view, int timeout){\n\t\treturn waitForView(view, timeout, true);\n\t}\n",
    "new_code_raw": "\tpublic boolean waitForView(View view, int timeout){\n\t\treturn waitForView(view, timeout, true, false);\n\t}\n"
  },
  {
    "id": "hazelcast_hazelcast-381-Associations-FirstSentence",
    "old_comment_raw": "Checks if a flag is set.",
    "new_comment_raw": "Returns  true if any of the flags supplied in the argument are set.",
    "old_code_raw": "    public boolean isFlagSet(int flag) {\n        return (flags & flag) != 0;\n    }\n",
    "new_code_raw": "    public boolean isFlagSet(int flagsToCheck) {\n        return isFlagSet(flags, flagsToCheck);\n    }\n\n"
  },
  {
    "id": "querydsl_querydsl-833-FirstSentence-0",
    "old_comment_raw": "Return the length of this String",
    "new_comment_raw": "Return the length of this String",
    "old_code_raw": "    public ENumber<Long> length() {\n        if (length == null) {\n            length = ONumber.create(Long.class, Ops.STRING_LENGTH, this);\n        }\n        return length;\n    }\n",
    "new_code_raw": "    public ENumber<Integer> length() {\n        if (length == null) {\n            length = ONumber.create(Integer.class, Ops.STRING_LENGTH, this);\n        }\n        return length;\n    }\n"
  },
  {
    "id": "yahoo_bullet-core-13-Associations-FirstSentence",
    "old_comment_raw": "Parses a Specification out of the query string.",
    "new_comment_raw": "Parses a Query out of the query string.",
    "old_code_raw": "    public static Specification parse(String queryString, BulletConfig config) {\n        Specification specification = GSON.fromJson(queryString, Specification.class);\n        specification.configure(config);\n        return specification;\n    }\n",
    "new_code_raw": "    public static Query parse(String queryString, BulletConfig config) {\n        Query query = GSON.fromJson(queryString, Query.class);\n        query.configure(config);\n        return query;\n    }\n\n"
  },
  {
    "id": "querydsl_querydsl-254-FirstSentence-0",
    "old_comment_raw": "Expr : left.startsWith(right)",
    "new_comment_raw": "Expr : left.startsWith(right)",
    "old_code_raw": "    public static EBoolean startsWith(Expr<String> left, Expr<String> right) {\n        return createBoolean(Ops.STARTSWITH, left, right);\n    }\n",
    "new_code_raw": "    public static EBoolean startsWith(Expr<String> left, Expr<String> right) {\n        return factory.createBoolean(Ops.STARTSWITH, left, right);\n    }\n"
  },
  {
    "id": "apache_empire-db-64-Associations-FirstSentence",
    "old_comment_raw": "Creates and returns a new comparison object for the SQL \"in\" operator.",
    "new_comment_raw": "Creates and returns an expression for the SQL \"in\" operator.",
    "old_code_raw": "    public DBCompareColExpr in(Object value)\n    {\n        return cmp(DBCmpType.IN, listToArray(value));\n    }\n",
    "new_code_raw": "    public final DBCompareColExpr in(Collection<?> values)\n    {\n        if (values==null || values.isEmpty())\n            return cmp(DBCmpType.EQUAL, null);\n        // create expression\n        return cmp(DBCmpType.IN, values);\n    }\n\n"
  },
  {
    "id": "scribejava_scribejava-21-FirstSentence-0",
    "old_comment_raw": "Returns the URL where you should redirect your users to authenticate your application.",
    "new_comment_raw": "Returns the URL where you should redirect your users to authenticate your application.",
    "old_code_raw": "    public String getAuthorizationUrl() {\n        return getAuthorizationUrl(null, null, null);\n    }\n",
    "new_code_raw": "    public String getAuthorizationUrl() {\n        return createAuthorizationUrlBuilder().build();\n    }\n"
  },
  {
    "id": "searchbox_io_Jest-3-FirstSentence-0",
    "old_comment_raw": "Method for getting counts using named filters",
    "new_comment_raw": "Method for getting counts using named filters",
    "old_code_raw": "    public boolean equals(Object obj) {\n        if (obj == null) {\n            return false;\n        }\n        if (obj == this) {\n            return true;\n        }\n        if (obj.getClass() != getClass()) {\n            return false;\n        }\n\n        FiltersAggregation rhs = (FiltersAggregation) obj;\n        return new EqualsBuilder()\n                .appendSuper(super.equals(obj))\n                .append(bucketMap, rhs.bucketMap)\n                .isEquals();\n    }\n",
    "new_code_raw": "    public boolean equals(Object obj) {\n        if (obj == null) {\n            return false;\n        }\n        if (obj == this) {\n            return true;\n        }\n        if (obj.getClass() != getClass()) {\n            return false;\n        }\n\n        FiltersAggregation rhs = (FiltersAggregation) obj;\n        return super.equals(obj) && Objects.equals(bucketMap, rhs.bucketMap);\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-187-Associations-FirstSentence",
    "old_comment_raw": "Returns all currently displayed sentences in string buffer, plain text form",
    "new_comment_raw": "Returns all currently displayed sentences in plain text form.",
    "old_code_raw": "  public StringBuffer getMatchedSentences() {\n    StringBuffer sb = new StringBuffer();\n    for(int i = 0; i < list.getModel().getSize(); i++) {\n      String t = ((TreeFromFile) list.getModel().getElementAt(i)).getLabel().getText();\n      sb.append(t);\n      sb.append(\"\\n\");\n    }\n    return sb;\n  }\n",
    "new_code_raw": "  public String getMatchedSentences() {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0, sz = list.getModel().getSize(); i < sz; i++) {\n      String t = list.getModel().getElementAt(i).getLabel().getText();\n      sb.append(t);\n      sb.append(\"\\n\");\n    }\n    return sb.toString();\n  }\n\n"
  },
  {
    "id": "iSoron_uhabits-27-FirstSentence-0",
    "old_comment_raw": "Returns newest checkmark that has already been computed.",
    "new_comment_raw": "Returns newest checkmark that has already been computed.",
    "old_code_raw": "    protected Checkmark findNewest()\n    {\n        return new Select().from(Checkmark.class)\n                .where(\"habit = ?\", habit.getId())\n                .and(\"timestamp <= ?\", DateHelper.getStartOfToday())\n                .orderBy(\"timestamp desc\")\n                .limit(1)\n                .executeSingle();\n    }\n",
    "new_code_raw": "    protected Checkmark findNewest()\n    {\n        return new Select().from(Checkmark.class)\n                .where(\"habit = ?\", habit.getId())\n                .and(\"timestamp <= ?\", DateUtils.getStartOfToday())\n                .orderBy(\"timestamp desc\")\n                .limit(1)\n                .executeSingle();\n    }\n"
  },
  {
    "id": "apache_lenya-385-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Returns a list of links for a HTTP connection",
    "old_code_raw": "    public static java.util.List handleHTML(HttpURLConnection httpCon)\n        throws java.io.IOException {\n        ContentHandler handler = new HTMLHandler();\n        handler.parse(httpCon.getInputStream());\n\n        if (handler.getRobotFollow()) {\n            java.util.List links = handler.getLinks();\n\n            return links;\n        }\n\n        return null;\n    }\n",
    "new_code_raw": "    public static List handleHTML(HttpURLConnection httpCon) throws IOException {\n        ContentHandler handler = new HTMLHandler();\n        handler.parse(httpCon.getInputStream());\n\n        if (handler.getRobotFollow()) {\n            List links = handler.getLinks();\n            return links;\n        }\n\n        return null;\n    }\n\n"
  },
  {
    "id": "RobotiumTech_robotium-1506-FirstSentence-0",
    "old_comment_raw": "Searches for a text string and returns  true if the searched text is found a given number of times.",
    "new_comment_raw": "Searches for a text string and returns  true if the searched text is found a given number of times.",
    "old_code_raw": "\tpublic boolean searchText(String search, int matches, boolean scroll) {\n\t\treturn searcher.searchText(search, matches, scroll);\n\t}\n",
    "new_code_raw": "\tpublic boolean searchText(String regex, int matches, boolean scroll) {\n\t\treturn searcher.searchText(regex, matches, scroll);\n\t}\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-191-Associations-FirstSentence",
    "old_comment_raw": "Returns all currently displayed sentences in plain text form.",
    "new_comment_raw": "Returns all currently displayed sentences in string buffer, plain text form",
    "old_code_raw": "  public String getMatchedSentences() {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0, sz = list.getModel().getSize(); i < sz; i++) {\n      String t = ((TreeFromFile) list.getModel().getElementAt(i)).getLabel().getText();\n      sb.append(t);\n      sb.append(\"\\n\");\n    }\n    return sb.toString();\n  }\n",
    "new_code_raw": "  public StringBuffer getMatchedSentences() {\n    StringBuffer sb = new StringBuffer();\n    for(int i = 0; i < list.getModel().getSize(); i++) {\n      String t = ((TreeFromFile) list.getModel().getElementAt(i)).getLabel().getText();\n      sb.append(t);\n      sb.append(\"\\n\");\n    }\n    return sb;\n  }\n\n"
  },
  {
    "id": "zaproxy_zaproxy-2053-FirstSentence-0",
    "old_comment_raw": "This method initializes panelCommand",
    "new_comment_raw": "This method initializes panelCommand",
    "old_code_raw": "\tprivate JButton getExportButton() {\n\t\tJButton csvExportButton = new JButton(Constant.messages.getString(\"params.toolbar.button.export\"));\n\t\tcsvExportButton.setIcon(new ImageIcon(ParamsPanel.class.getResource(\"/resource/icon/16/115.png\")));\n\t\tcsvExportButton.addActionListener((new AbstractAction() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tWritableFileChooser chooser = new WritableFileChooser();\n\t\t\t\tchooser.setSelectedFile(new File(Constant.messages.getString(\"params.button.export.default.name\")));\n\t\t\t\tif (chooser\n\t\t\t\t\t\t.showSaveDialog(View.getSingleton().getMainFrame()) == WritableFileChooser.APPROVE_OPTION) {\n\t\t\t\t\tString file = chooser.getSelectedFile().toString();\n\t\t\t\t\tif (!file.endsWith(\".csv\")) {\n\t\t\t\t\t\tfile += \".csv\";\n\t\t\t\t\t}\n\t\t\t\t\ttry (CSVPrinter pw = new CSVPrinter(\n\t\t\t\t\t\t\tFiles.newBufferedWriter(chooser.getSelectedFile().toPath(), StandardCharsets.UTF_8),\n\t\t\t\t\t\t\tCSVFormat.DEFAULT)) {\n\t\t\t\t\t\tpw.printRecord(((ParamsTableModel) paramsTable.getModel()).getColumnNames());\n\t\t\t\t\t\tint rowCount = paramsTable.getRowCount();\n\t\t\t\t\t\tint colCount = paramsTable.getColumnCount();\n\t\t\t\t\t\tfor (int row = 0; row < rowCount; row++) {\n\t\t\t\t\t\t\tList<Object> valueOfRow = new ArrayList<Object>();\n\t\t\t\t\t\t\tfor (int col = 0; col < colCount; col++) {\n\t\t\t\t\t\t\t\tvalueOfRow.add(paramsTable.getValueAt(row, col));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpw.printRecord(valueOfRow);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tJOptionPane.showMessageDialog(View.getSingleton().getMainFrame(),\n\t\t\t\t\t\t\t\tConstant.messages.getString(\"params.button.export.success\"));\n\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\tJOptionPane.showMessageDialog(View.getSingleton().getMainFrame(),\n\t\t\t\t\t\t\t\tConstant.messages.getString(\"params.button.export.error\") + \"\\n\"\n\t\t\t\t\t\t\t\t\t\t+ ex.getLocalizedMessage());\n\t\t\t\t\t\tLOGGER.error(\"Export Failed: \" + ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t\treturn csvExportButton;\n\t}\n",
    "new_code_raw": "\tprivate TableExportButton getExportButton() {\n\t\tif (exportButton == null) {\n\t\t\texportButton = new TableExportButton(getParamsTable());\n\t\t}\n\t\treturn exportButton;\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2596-FirstSentence-0",
    "old_comment_raw": "If a Schema contains a reference to an other Schema with '$ref', returns the referenced Schema or the actual Schema in the other cases.",
    "new_comment_raw": "If a Schema contains a reference to an other Schema with '$ref', returns the referenced Schema if it is found or the actual Schema in the other cases.",
    "old_code_raw": "    public static Schema getReferencedSchema(OpenAPI openAPI, Schema schema) {\n        if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) {\n            String name = getSimpleRef(schema.get$ref());\n            return getSchema(openAPI, name);\n        }\n        return schema;\n    }\n",
    "new_code_raw": "    public static Schema getReferencedSchema(OpenAPI openAPI, Schema schema) {\n        if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) {\n            String name = getSimpleRef(schema.get$ref());\n            Schema referencedSchema = getSchema(openAPI, name);\n            if(referencedSchema != null) {\n                return referencedSchema;\n            }\n        }\n        return schema;\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-1278-FirstSentence-0",
    "old_comment_raw": "Returns a  List of the  GridViews contained in the current  Activity.",
    "new_comment_raw": "Returns a  List of the  GridViews contained in the current  Activity.",
    "old_code_raw": "\tpublic ArrayList<GridView> getCurrentGridViews() {\n\t\tArrayList<GridView> gridViewList = new ArrayList<GridView>();\n\t\tArrayList<View> viewList = getViews();\n\t\tfor(View view : viewList){\n\t\t\tif (view instanceof android.widget.GridView)\n\t\t\t\tgridViewList.add((GridView) view);\n\t\t}\n\t\treturn gridViewList;\n\t}\n",
    "new_code_raw": "\tpublic ArrayList<GridView> getCurrentGridViews() {\n\t\treturn getCurrentViews(GridView.class);\n\t}\n"
  },
  {
    "id": "nelsonsilva_vaadin-50-Associations-FirstSentence",
    "old_comment_raw": "Ensure that correct implementation is used for the component.",
    "new_comment_raw": "Update generic component features.",
    "old_code_raw": "\tpublic boolean updateComponent(Widget component, UIDL uidl,\n\t\t\tboolean manageCaption) {\n\n\t\tif (manageCaption) {\n\t\t\tLayout parent = getParentLayout(component);\n\t\t\tif (parent != null)\n\t\t\t\tparent.updateCaption(component, uidl);\n\t\t}\n\t\t\n\t\tboolean visible = !uidl.getBooleanAttribute(\"invisible\");\n\t\tcomponent.setVisible(visible);\n\t\tif (!visible) return true;\n\t\t\n\t\tif (widgetFactory.isCorrectImplementation(component, uidl))\n\t\t\treturn false;\n\t\tLayout parent = getParentLayout(component);\n\t\tif (parent == null)\n\t\t\treturn false;\n\t\tWidget w = widgetFactory.createWidget(uidl);\n\t\tregisterPaintable(uidl.getId(), (Paintable) w);\n\t\tparent.replaceChildComponent(component, w);\n\t\t((Paintable) w).updateFromUIDL(uidl, this);\n\n\t\treturn true;\n\t}\n",
    "new_code_raw": "\tpublic boolean updateComponent(Widget component, UIDL uidl,\n\t\t\tboolean manageCaption) {\n\n\t\t// Switch to correct implementation if neede\n\t\tif (!widgetFactory.isCorrectImplementation(component, uidl)) {\n\t\t\tLayout parent = getParentLayout(component);\n\t\t\tif (parent != null) {\n\t\t\t\tWidget w = widgetFactory.createWidget(uidl);\n\t\t\t\tregisterPaintable(uidl.getId(), (Paintable) w);\n\t\t\t\tparent.replaceChildComponent(component, w);\n\t\t\t\t((Paintable) w).updateFromUIDL(uidl, this);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Set captions\n\t\t// TODO Manage Error messages\n\t\tif (manageCaption) {\n\t\t\tLayout parent = getParentLayout(component);\n\t\t\tif (parent != null)\n\t\t\t\tparent.updateCaption(component, uidl);\n\t\t}\n\n\t\t// Visibility, Disabling and read-only status\n\t\tif (component instanceof FocusWidget)\n\t\t\t((FocusWidget) component).setEnabled(!uidl\n\t\t\t\t\t.getBooleanAttribute(\"disabled\"));\n\t\tboolean visible = !uidl.getBooleanAttribute(\"invisible\");\n\t\tcomponent.setVisible(visible);\n\t\tif (!visible)\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n"
  },
  {
    "id": "zaproxy_zaproxy-2025-FirstSentence-0",
    "old_comment_raw": "Gets the matching http session for a particular message containing a list of cookies.",
    "new_comment_raw": "Gets the matching http session for a particular message containing a list of cookies.",
    "old_code_raw": "\tprivate HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final HttpSessionTokensSet siteTokens) {\n\n\t\treturn CookieBasedSessionManagementHelper.getMatchingHttpSession(sessions, cookies, siteTokens);\n\t}\n",
    "new_code_raw": "\tprivate HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final HttpSessionTokensSet siteTokens) {\n\t\tCollection<HttpSession> sessionsCopy;\n\t\tsynchronized (sessions) {\n\t\t\tsessionsCopy = new ArrayList<>(sessions);\n\t\t}\n\t\treturn CookieBasedSessionManagementHelper.getMatchingHttpSession(sessionsCopy, cookies, siteTokens);\n\t}\n"
  },
  {
    "id": "mccraigmccraig_prefuse-8-Associations-FirstSentence",
    "old_comment_raw": "Return the GraphItem representing the second (target) node in the edge.",
    "new_comment_raw": "Return the VisualItem representing the second (target) node in the edge.",
    "old_code_raw": "\tpublic NodeItem getSecondNode() {\n\t\treturn m_node2;\n\t} //\n",
    "new_code_raw": "\tpublic Node getSecondNode() {\n\t\treturn m_node2;\n\t} //\n\n"
  },
  {
    "id": "processing_processing-208-FirstSentence-0",
    "old_comment_raw": "Give this thing a  Name instance - a  SimpleName from the",
    "new_comment_raw": "Give this thing a  Name instance - a  SimpleName from the",
    "old_code_raw": "  protected static ASTNode findDeclaration(Name findMe) {\n\n    // WARNING: You're entering the Rube Goldberg territory of Experimental Mode.\n    // To debug this code, thou must take the Recursive Leap of Faith.\n\n    // log(\"entering --findDeclaration1 -- \" + findMe.toString());\n    ASTNode declaringClass = null;\n    ASTNode parent = findMe.getParent();\n    ASTNode ret = null;\n    ArrayList<Integer> constrains = new ArrayList<Integer>();\n    if (parent.getNodeType() == ASTNode.METHOD_INVOCATION) {\n      Expression exp = (Expression) ((MethodInvocation) parent)\n          .getStructuralProperty(MethodInvocation.EXPRESSION_PROPERTY);\n      //TODO: Note the imbalance of constrains.add(ASTNode.METHOD_DECLARATION);\n      // Possibly a bug here. Investigate later.\n      if (((MethodInvocation) parent).getName().toString()\n          .equals(findMe.toString())) {\n        constrains.add(ASTNode.METHOD_DECLARATION);\n\n        if (exp != null) {\n          constrains.add(ASTNode.TYPE_DECLARATION);\n//          log(\"MI EXP: \" + exp.toString() + \" of type \"\n//              + exp.getClass().getName() + \" parent: \" + exp.getParent());\n          if (exp instanceof MethodInvocation) {\n            SimpleType stp = extracTypeInfo(findDeclaration(((MethodInvocation) exp)\n                .getName()));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration(stp.getName());\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains, declaringClass);\n          } else if (exp instanceof FieldAccess) {\n            SimpleType stp = extracTypeInfo(findDeclaration(((FieldAccess) exp)\n                .getName()));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration((stp.getName()));\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains, declaringClass);\n          }\n          if (exp instanceof SimpleName) {\n            SimpleType stp = extracTypeInfo(findDeclaration(((SimpleName) exp)));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration(stp.getName());\n//            log(\"MI.SN \" + getNodeAsString(declaringClass));\n            constrains.add(ASTNode.METHOD_DECLARATION);\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains, declaringClass);\n          }\n\n        }\n      } else {\n        parent = parent.getParent(); // Move one up the ast. V V IMP!!\n      }\n    } else if (parent.getNodeType() == ASTNode.FIELD_ACCESS) {\n      FieldAccess fa = (FieldAccess) parent;\n      Expression exp = fa.getExpression();\n      if (fa.getName().toString().equals(findMe.toString())) {\n        constrains.add(ASTNode.FIELD_DECLARATION);\n\n        if (exp != null) {\n          constrains.add(ASTNode.TYPE_DECLARATION);\n//          log(\"FA EXP: \" + exp.toString() + \" of type \"\n//              + exp.getClass().getName() + \" parent: \" + exp.getParent());\n          if (exp instanceof MethodInvocation) {\n            SimpleType stp = extracTypeInfo(findDeclaration(((MethodInvocation) exp)\n                .getName()));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration(stp.getName());\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains, declaringClass);\n          } else if (exp instanceof FieldAccess) {\n            SimpleType stp = extracTypeInfo(findDeclaration(((FieldAccess) exp)\n                .getName()));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration((stp.getName()));\n            constrains.add(ASTNode.TYPE_DECLARATION);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains, declaringClass);\n          }\n          if (exp instanceof SimpleName) {\n            SimpleType stp = extracTypeInfo(findDeclaration(((SimpleName) exp)));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration(stp.getName());\n//            log(\"FA.SN \" + getNodeAsString(declaringClass));\n            constrains.add(ASTNode.METHOD_DECLARATION);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains, declaringClass);\n          }\n        }\n\n      } else {\n        parent = parent.getParent(); // Move one up the ast. V V IMP!!\n      }\n    } else if (parent.getNodeType() == ASTNode.QUALIFIED_NAME) {\n\n      QualifiedName qn = (QualifiedName) parent;\n      if (!findMe.toString().equals(qn.getQualifier().toString())) {\n\n        SimpleType stp = extracTypeInfo(findDeclaration((qn.getQualifier())));\n//        log(qn.getQualifier() + \"->\" + qn.getName());\n        declaringClass = findDeclaration(stp.getName());\n\n//        log(\"QN decl class: \" + getNodeAsString(declaringClass));\n        constrains.clear();\n        constrains.add(ASTNode.TYPE_DECLARATION);\n        constrains.add(ASTNode.FIELD_DECLARATION);\n        return definedIn(declaringClass, qn.getName().toString(), constrains,\n                         null);\n      }\n      else{\n        if(findMe instanceof QualifiedName){\n          QualifiedName qnn = (QualifiedName) findMe;\n//          log(\"findMe is a QN, \"\n//              + (qnn.getQualifier().toString() + \" other \" + qnn.getName()\n//                  .toString()));\n\n          SimpleType stp = extracTypeInfo(findDeclaration((qnn.getQualifier())));\n          if (stp != null) {\n            declaringClass = findDeclaration(stp.getName());\n            constrains.clear();\n            constrains.add(ASTNode.TYPE_DECLARATION);\n            constrains.add(ASTNode.FIELD_DECLARATION);\n            return definedIn(declaringClass, qnn.getName().toString(),\n                             constrains, null);\n          } else {\n            return null;\n          }\n        }\n      }\n    } else if (parent.getNodeType() == ASTNode.SIMPLE_TYPE) {\n      constrains.add(ASTNode.TYPE_DECLARATION);\n      if (parent.getParent().getNodeType() == ASTNode.CLASS_INSTANCE_CREATION) {\n        constrains.add(ASTNode.CLASS_INSTANCE_CREATION);\n      }\n    } else if (parent.getNodeType() == ASTNode.TYPE_DECLARATION) {\n      // The condition where we look up the name of a class decl\n      TypeDeclaration td = (TypeDeclaration) parent;\n      if (findMe.equals(td.getName())) {\n        return parent;\n      }\n\n    } else if (parent instanceof Expression) {\n//      constrains.add(ASTNode.TYPE_DECLARATION);\n//      constrains.add(ASTNode.METHOD_DECLARATION);\n//      constrains.add(ASTNode.FIELD_DECLARATION);\n    }\n//    else if(findMe instanceof QualifiedName){\n//      QualifiedName qn = (QualifiedName) findMe;\n//      System.out\n//          .println(\"findMe is a QN, \"\n//              + (qn.getQualifier().toString() + \" other \" + qn.getName()\n//                  .toString()));\n//    }\n    while (parent != null) {\n//      log(\"findDeclaration1 -> \" + getNodeAsString(parent));\n      for (Object oprop : parent.structuralPropertiesForType()) {\n        StructuralPropertyDescriptor prop = (StructuralPropertyDescriptor) oprop;\n        if (prop.isChildProperty() || prop.isSimpleProperty()) {\n          if (parent.getStructuralProperty(prop) instanceof ASTNode) {\n//            log(prop + \" C/S Prop of -> \"\n//                + getNodeAsString(parent));\n            ret = definedIn((ASTNode) parent.getStructuralProperty(prop),\n                            findMe.toString(), constrains, declaringClass);\n            if (ret != null)\n              return ret;\n          }\n        } else if (prop.isChildListProperty()) {\n//          log((prop) + \" ChildList props of \"\n//              + getNodeAsString(parent));\n          List<ASTNode> nodelist = (List<ASTNode>) parent\n              .getStructuralProperty(prop);\n          for (ASTNode retNode : nodelist) {\n            ret = definedIn(retNode, findMe.toString(), constrains,\n                            declaringClass);\n            if (ret != null)\n              return ret;\n          }\n        }\n      }\n      parent = parent.getParent();\n    }\n    return null;\n  }\n",
    "new_code_raw": "  protected static ASTNode findDeclaration(Name findMe) {\n\n    // WARNING: You're entering the Rube Goldberg territory of Experimental Mode.\n    // To debug this code, thou must take the Recursive Leap of Faith.\n\n    // log(\"entering --findDeclaration1 -- \" + findMe.toString());\n    ASTNode declaringClass = null;\n    ASTNode parent = findMe.getParent();\n    ASTNode ret = null;\n    ArrayList<Integer> constrains = new ArrayList<Integer>();\n    if (parent.getNodeType() == ASTNode.METHOD_INVOCATION) {\n      Expression exp = (Expression) ((MethodInvocation) parent)\n          .getStructuralProperty(MethodInvocation.EXPRESSION_PROPERTY);\n      //TODO: Note the imbalance of constrains.add(ASTNode.METHOD_DECLARATION);\n      // Possibly a bug here. Investigate later.\n      if (((MethodInvocation) parent).getName().toString()\n          .equals(findMe.toString())) {\n        constrains.add(ASTNode.METHOD_DECLARATION);\n\n        if (exp != null) {\n          constrains.add(ASTNode.TYPE_DECLARATION);\n//          log(\"MI EXP: \" + exp.toString() + \" of type \"\n//              + exp.getClass().getName() + \" parent: \" + exp.getParent());\n          if (exp instanceof MethodInvocation) {\n            SimpleType stp = extracTypeInfo(findDeclaration(((MethodInvocation) exp)\n                .getName()));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration(stp.getName());\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains, declaringClass);\n          } else if (exp instanceof FieldAccess) {\n            SimpleType stp = extracTypeInfo(findDeclaration(((FieldAccess) exp)\n                .getName()));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration((stp.getName()));\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains, declaringClass);\n          }\n          if (exp instanceof SimpleName) {\n            SimpleType stp = extracTypeInfo(findDeclaration(((SimpleName) exp)));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration(stp.getName());\n//            log(\"MI.SN \" + getNodeAsString(declaringClass));\n            constrains.add(ASTNode.METHOD_DECLARATION);\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains, declaringClass);\n          }\n\n        }\n      } else {\n        parent = parent.getParent(); // Move one up the ast. V V IMP!!\n      }\n    } else if (parent.getNodeType() == ASTNode.FIELD_ACCESS) {\n      FieldAccess fa = (FieldAccess) parent;\n      Expression exp = fa.getExpression();\n      if (fa.getName().toString().equals(findMe.toString())) {\n        constrains.add(ASTNode.FIELD_DECLARATION);\n\n        if (exp != null) {\n          constrains.add(ASTNode.TYPE_DECLARATION);\n//          log(\"FA EXP: \" + exp.toString() + \" of type \"\n//              + exp.getClass().getName() + \" parent: \" + exp.getParent());\n          if (exp instanceof MethodInvocation) {\n            SimpleType stp = extracTypeInfo(findDeclaration(((MethodInvocation) exp)\n                .getName()));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration(stp.getName());\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains, declaringClass);\n          } else if (exp instanceof FieldAccess) {\n            SimpleType stp = extracTypeInfo(findDeclaration(((FieldAccess) exp)\n                .getName()));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration((stp.getName()));\n            constrains.add(ASTNode.TYPE_DECLARATION);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains, declaringClass);\n          }\n          if (exp instanceof SimpleName) {\n            SimpleType stp = extracTypeInfo(findDeclaration(((SimpleName) exp)));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration(stp.getName());\n//            log(\"FA.SN \" + getNodeAsString(declaringClass));\n            constrains.add(ASTNode.METHOD_DECLARATION);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains, declaringClass);\n          }\n        }\n\n      } else {\n        parent = parent.getParent(); // Move one up the ast. V V IMP!!\n      }\n    } else if (parent.getNodeType() == ASTNode.QUALIFIED_NAME) {\n\n      QualifiedName qn = (QualifiedName) parent;\n      if (!findMe.toString().equals(qn.getQualifier().toString())) {\n\n        SimpleType stp = extracTypeInfo(findDeclaration((qn.getQualifier())));\n//        log(qn.getQualifier() + \"->\" + qn.getName());\n        if (stp == null) {\n          return null;\n        }\n\n        declaringClass = findDeclaration(stp.getName());\n\n//        log(\"QN decl class: \" + getNodeAsString(declaringClass));\n        constrains.clear();\n        constrains.add(ASTNode.TYPE_DECLARATION);\n        constrains.add(ASTNode.FIELD_DECLARATION);\n        return definedIn(declaringClass, qn.getName().toString(), constrains,\n                         null);\n      }\n      else{\n        if(findMe instanceof QualifiedName){\n          QualifiedName qnn = (QualifiedName) findMe;\n//          log(\"findMe is a QN, \"\n//              + (qnn.getQualifier().toString() + \" other \" + qnn.getName()\n//                  .toString()));\n\n          SimpleType stp = extracTypeInfo(findDeclaration((qnn.getQualifier())));\n          if (stp == null) {\n            return null;\n          }\n          declaringClass = findDeclaration(stp.getName());\n          constrains.clear();\n          constrains.add(ASTNode.TYPE_DECLARATION);\n          constrains.add(ASTNode.FIELD_DECLARATION);\n          return definedIn(declaringClass, qnn.getName().toString(),\n                           constrains, null);\n        }\n      }\n    } else if (parent.getNodeType() == ASTNode.SIMPLE_TYPE) {\n      constrains.add(ASTNode.TYPE_DECLARATION);\n      if (parent.getParent().getNodeType() == ASTNode.CLASS_INSTANCE_CREATION) {\n        constrains.add(ASTNode.CLASS_INSTANCE_CREATION);\n      }\n    } else if (parent.getNodeType() == ASTNode.TYPE_DECLARATION) {\n      // The condition where we look up the name of a class decl\n      TypeDeclaration td = (TypeDeclaration) parent;\n      if (findMe.equals(td.getName())) {\n        return parent;\n      }\n\n    } else if (parent instanceof Expression) {\n//      constrains.add(ASTNode.TYPE_DECLARATION);\n//      constrains.add(ASTNode.METHOD_DECLARATION);\n//      constrains.add(ASTNode.FIELD_DECLARATION);\n    }\n//    else if(findMe instanceof QualifiedName){\n//      QualifiedName qn = (QualifiedName) findMe;\n//      System.out\n//          .println(\"findMe is a QN, \"\n//              + (qn.getQualifier().toString() + \" other \" + qn.getName()\n//                  .toString()));\n//    }\n    while (parent != null) {\n//      log(\"findDeclaration1 -> \" + getNodeAsString(parent));\n      for (Object oprop : parent.structuralPropertiesForType()) {\n        StructuralPropertyDescriptor prop = (StructuralPropertyDescriptor) oprop;\n        if (prop.isChildProperty() || prop.isSimpleProperty()) {\n          if (parent.getStructuralProperty(prop) instanceof ASTNode) {\n//            log(prop + \" C/S Prop of -> \"\n//                + getNodeAsString(parent));\n            ret = definedIn((ASTNode) parent.getStructuralProperty(prop),\n                            findMe.toString(), constrains, declaringClass);\n            if (ret != null)\n              return ret;\n          }\n        } else if (prop.isChildListProperty()) {\n//          log((prop) + \" ChildList props of \"\n//              + getNodeAsString(parent));\n          List<ASTNode> nodelist = (List<ASTNode>) parent\n              .getStructuralProperty(prop);\n          for (ASTNode retNode : nodelist) {\n            ret = definedIn(retNode, findMe.toString(), constrains,\n                            declaringClass);\n            if (ret != null)\n              return ret;\n          }\n        }\n      }\n      parent = parent.getParent();\n    }\n    return null;\n  }\n"
  },
  {
    "id": "ansell_openrdf-sesame-163-Associations-FirstSentence",
    "old_comment_raw": "Encodes a value in a canonical serialized string format, for use in a URL query parameter.",
    "new_comment_raw": "Encodes a value for use in a URL.",
    "old_code_raw": "\tpublic static String encodeValue(Value value) {\r\n\t\tif (value instanceof BNode) {\r\n\t\t\t// SES-2129 special treatment of blank node names to avoid problems with round-tripping.\r\n\t\t\treturn \"_:\" + ((BNode)value).getID();\r\n\t\t}\r\n\t\t\r\n\t\t// for everything else we just use N-Triples serialization.\r\n\t\treturn NTriplesUtil.toNTriplesString(value);\r\n\t}\r\n",
    "new_code_raw": "\tpublic static String encodeValue(Value value) {\r\n\t\treturn NTriplesUtil.toNTriplesString(value);\r\n\t}\r\n\n"
  },
  {
    "id": "runelite_runelite-147-FirstSentence-0",
    "old_comment_raw": "Loads item sprite from game, makes transparent, and generates image",
    "new_comment_raw": "Loads item sprite from game, makes transparent, and generates image",
    "old_code_raw": "\tprivate BufferedImage loadImage(int itemId, int quantity, boolean stackable)\n\t{\n\t\tSpritePixels sprite = client.createItemSprite(itemId, quantity, 1, SpritePixels.DEFAULT_SHADOW_COLOR,\n\t\t\tstackable ? 1 : 0, false, CLIENT_DEFAULT_ZOOM);\n\t\treturn sprite.toBufferedImage();\n\t}\n",
    "new_code_raw": "\tprivate AsyncBufferedImage loadImage(int itemId, int quantity, boolean stackable)\n\t{\n\t\tAsyncBufferedImage img = new AsyncBufferedImage(36, 32, BufferedImage.TYPE_INT_ARGB);\n\t\tclientThread.invokeLater(() ->\n\t\t{\n\t\t\tif (client.getGameState().ordinal() < GameState.LOGIN_SCREEN.ordinal())\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tSpritePixels sprite = client.createItemSprite(itemId, quantity, 1, SpritePixels.DEFAULT_SHADOW_COLOR,\n\t\t\t\tstackable ? 1 : 0, false, CLIENT_DEFAULT_ZOOM);\n\t\t\tif (sprite == null)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsprite.toBufferedImage(img);\n\t\t\timg.changed();\n\t\t\treturn true;\n\t\t});\n\t\treturn img;\n\t}\n"
  },
  {
    "id": "Atmosphere_atmosphere-865-FirstSentence-0",
    "old_comment_raw": "Loads the  JBossWebSocketHandler using reflection as it imports container specific classes.",
    "new_comment_raw": "Loads the  JBossWebSocketHandler u",
    "old_code_raw": "    private HttpEventServlet newWebSocketHandler(AtmosphereConfig config) {\n        try {\n            Class<?> clazz = getClass().getClassLoader().loadClass(WEB_SOCKET_HANDLER);\n            Constructor<?> ctor = clazz.getDeclaredConstructor(new Class[] {AtmosphereConfig.class});\n            return HttpEventServlet.class.cast(ctor.newInstance(config));\n        } catch (Exception e) {\n            logger.error(\"Cannot instantiate JBossWebSocketHandler. Websocket events will not be handled.\", e);\n        }\n        \n        return null;\n    }\n",
    "new_code_raw": "    private HttpEventServlet newWebSocketHandler(AtmosphereConfig config) {\n        try {\n            return new JBossWebSocketHandler(config);\n        } catch (Exception e) {\n            logger.error(\"Cannot instantiate JBossWebSocketHandler. Websocket events will not be handled.\", e);\n        }\n        \n        return null;\n    }\n"
  },
  {
    "id": "Atmosphere_atmosphere-672-FirstSentence-0",
    "old_comment_raw": "All proprietary Comet based  Servlet must invoke the timedout method when the underlying WebServer time out the  AtmosphereResponse.",
    "new_comment_raw": "All proprietary Comet based  Servlet must invoke the timedout method when the underlying WebServer time out the  AtmosphereResponse.",
    "old_code_raw": "    public Action timedout(AtmosphereRequest request, AtmosphereResponse response)\n            throws IOException, ServletException {\n\n        AtmosphereResourceImpl r = null;\n\n        try {\n            SessionTimeoutSupport.restoreTimeout(request);\n\n            if (trackActiveRequest) {\n                long l = (Long) request.getAttribute(MAX_INACTIVE);\n                if (l == -1) {\n                    // The closedDetector closed the connection.\n                    return timedoutAction;\n                }\n                request.setAttribute(MAX_INACTIVE, (long) -1);\n            }\n\n            logger.debug(\"Timing out the connection for request {}\", request);\n\n            // Something went wrong.\n            if (request == null || response == null) {\n                logger.warn(\"Invalid Request/Response: {}/{}\", request, response);\n                return timedoutAction;\n            }\n\n            r = (AtmosphereResourceImpl) request.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n\n            if (r != null && r.isCancelled()) {\n                return cancelledAction;\n            }\n\n            if (r == null) {\n                logger.debug(\"AtmosphereResource was null, failed to timeout AtmosphereRequest {}\", request);\n            }\n\n            if (r != null && r.getAtmosphereResourceEvent().isSuspended()) {\n                r.getAtmosphereResourceEvent().setIsResumedOnTimeout(true);\n\n                Broadcaster b = r.getBroadcaster();\n                if (b instanceof DefaultBroadcaster) {\n                    ((DefaultBroadcaster) b).broadcastOnResume(r);\n                }\n\n                if (request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT) != null) {\n                    r.getAtmosphereResourceEvent().setIsResumedOnTimeout(\n                            (Boolean) request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT));\n                }\n\n                invokeAtmosphereHandler(r);\n            }\n        } catch (Throwable t) {\n            logger.error(\"failed to timeout resource {}\", r, t);\n        } finally {\n            config.framework().notify(Action.TYPE.TIMEOUT, request, response);\n            try {\n                if (r != null) {\n                    r.notifyListeners();\n                    r.setIsInScope(false);\n                    r.cancel();\n                }\n            } catch (Throwable t) {\n                logger.trace(\"timedout\", t);\n            } finally {\n                try {\n                    response.getOutputStream().close();\n                } catch (Throwable t) {\n                    try {\n                        response.getWriter().close();\n                    } catch (Throwable t2) {\n                    }\n                }\n\n                if (r != null) {\n                    r._destroy();\n                }\n            }\n        }\n\n        return timedoutAction;\n    }\n",
    "new_code_raw": "    public Action timedout(AtmosphereRequest request, AtmosphereResponse response)\n            throws IOException, ServletException {\n\n        AtmosphereResourceImpl r = null;\n\n        try {\n            SessionTimeoutSupport.restoreTimeout(request);\n\n            if (trackActiveRequest) {\n                long l = (Long) request.getAttribute(MAX_INACTIVE);\n                if (l == -1) {\n                    // The closedDetector closed the connection.\n                    return timedoutAction;\n                }\n                request.setAttribute(MAX_INACTIVE, (long) -1);\n            }\n\n            logger.debug(\"Timing out the connection for request {}\", request);\n\n            // Something went wrong.\n            if (request == null || response == null) {\n                logger.warn(\"Invalid Request/Response: {}/{}\", request, response);\n                return timedoutAction;\n            }\n\n            r = (AtmosphereResourceImpl) request.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n\n            if (r != null && r.getAtmosphereResourceEvent().isSuspended()) {\n                r.getAtmosphereResourceEvent().setIsResumedOnTimeout(true);\n\n                Broadcaster b = r.getBroadcaster();\n                if (b instanceof DefaultBroadcaster) {\n                    ((DefaultBroadcaster) b).broadcastOnResume(r);\n                }\n\n                if (request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT) != null) {\n                    r.getAtmosphereResourceEvent().setIsResumedOnTimeout(\n                            (Boolean) request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT));\n                }\n\n                invokeAtmosphereHandler(r);\n            }\n        } catch (Throwable t) {\n            logger.error(\"failed to timeout resource {}\", r, t);\n        } finally {\n            config.framework().notify(Action.TYPE.TIMEOUT, request, response);\n            try {\n                if (r != null) {\n                    r.notifyListeners();\n                    r.setIsInScope(false);\n                    r.cancel();\n                }\n            } catch (Throwable t) {\n                logger.trace(\"timedout\", t);\n            } finally {\n\n                try {\n                    response.getOutputStream().close();\n                } catch (Throwable t) {\n                    try {\n                        response.getWriter().close();\n                    } catch (Throwable t2) {\n                    }\n                }\n\n                if (r != null) {\n                    destroyResource(r);\n                }\n            }\n        }\n\n        return timedoutAction;\n    }\n"
  },
  {
    "id": "apache_ant-ivy-46-Associations-FirstSentence",
    "old_comment_raw": "Returns the common base directory between a current base directory and a given file.",
    "new_comment_raw": "Returns the common base directory between the passed file1 and file2.",
    "old_code_raw": "    File getBaseDir(File base, File file) {\n        if (base == null) {\n            return file.getParentFile().getAbsoluteFile();\n        } else {\n            Iterator bases = getParents(base).iterator();\n            Iterator fileParents = getParents(file.getAbsoluteFile()).iterator();\n            File result = null;\n            while (bases.hasNext() && fileParents.hasNext()) {\n                File next = (File) bases.next();\n                if (next.equals(fileParents.next())) {\n                    result = next;\n                } else {\n                    break;\n                }\n            }\n            return result;\n        }\n    }\n",
    "new_code_raw": "    File getBaseDir(final File file1, final File file2) {\n        if (file1 == null || file2 == null) {\n            return null;\n        }\n        final Iterator bases = getParents(file1).iterator();\n        final Iterator fileParents = getParents(file2.getAbsoluteFile()).iterator();\n        File result = null;\n        while (bases.hasNext() && fileParents.hasNext()) {\n            File next = (File) bases.next();\n            if (next.equals(fileParents.next())) {\n                result = next;\n            } else {\n                break;\n            }\n        }\n        return result;\n    }\n\n"
  },
  {
    "id": "RobotiumTech_robotium-1343-FirstSentence-0",
    "old_comment_raw": "Returns an  ArrayList of the  RadioButtons contained in the current  Activity.",
    "new_comment_raw": "Returns an  ArrayList of the  RadioButtons contained in the current  Activity.",
    "old_code_raw": "\tpublic ArrayList<RadioButton> getCurrentRadioButtons() {\n\t\treturn ensureArrayListOrNull(viewFetcher.getCurrentViews(RadioButton.class));\n\t}\n",
    "new_code_raw": "\tpublic ArrayList<RadioButton> getCurrentRadioButtons() {\n\t\treturn viewFetcher.getCurrentViews(RadioButton.class);\n\t}\n"
  },
  {
    "id": "JodaOrg_joda_time-491-FirstSentence-0",
    "old_comment_raw": "Does this time interval contain the specified time interval completely.",
    "new_comment_raw": "Does this time interval contain or equal the specified time interval.",
    "old_code_raw": "    public boolean contains(ReadableInterval interval) {\n        if (interval == null) {\n            return containsNow();\n        }\n        long otherStart = interval.getStartMillis();\n        long otherEnd = interval.getEndMillis();\n        long thisStart = getStartMillis();\n        long thisEnd = getEndMillis();\n        return (otherStart >= thisStart && otherStart < thisEnd && otherEnd <= thisEnd);\n    }\n",
    "new_code_raw": "    public boolean contains(ReadableInterval interval) {\n        if (interval == null) {\n            return containsNow();\n        }\n        long otherStart = interval.getStartMillis();\n        long otherEnd = interval.getEndMillis();\n        long thisStart = getStartMillis();\n        long thisEnd = getEndMillis();\n        return (thisStart <= otherStart && otherStart < thisEnd && otherEnd <= thisEnd) ||\n            (thisStart == otherStart && thisEnd == otherEnd);\n    }\n"
  },
  {
    "id": "querydsl_querydsl-676-FirstSentence-0",
    "old_comment_raw": "Create a new Template expression",
    "new_comment_raw": "Create a new Template expression",
    "old_code_raw": "    public static StringExpression stringTemplate(String template, Object... args) {\n        return StringTemplate.create(template, args);\n    }\n",
    "new_code_raw": "    public static StringExpression stringTemplate(String template, Object... args) {\n        return new StringTemplate(createTemplate(template), ImmutableList.copyOf(args));\n    }\n"
  },
  {
    "id": "JetBrains_adt-tools-base-412-Associations-FirstSentence",
    "old_comment_raw": "Installs a list of  RemotePackage and their dependent packages.",
    "new_comment_raw": "Installs a  RemotePackage and its dependent packages.",
    "old_code_raw": "    private Map<RemotePackage, InstallResultType> installRemotePackages(\n            @NonNull List<RemotePackage> requestPackages,\n            @NonNull RepoManager repoManager,\n            @NonNull Downloader downloader,\n            @NonNull ProgressIndicator progress) {\n\n        List<RemotePackage> remotePackages =\n                InstallerUtil.computeRequiredPackages(\n                        requestPackages, repoManager.getPackages(), progress);\n        Map<RemotePackage, InstallResultType> installResults = new HashMap<>();\n\n        if (remotePackages == null) {\n            requestPackages.forEach(p -> installResults.put(p, InstallResultType.INSTALL_FAIL));\n\n        } else {\n            for (RemotePackage p : remotePackages) {\n                if (p.getLicense() != null && !p.getLicense()\n                        .checkAccepted(repoManager.getLocalPath(), mSdkHandler.getFileOp())) {\n                    progress.setText(\n                            \"The license for package \" + p.getDisplayName() + \" was not accepted. \"\n                                    + \"Please install this package through Android Studio SDK \"\n                                    + \"Manager.\");\n                    installResults.put(p, InstallResultType.LICENSE_FAIL);\n                } else {\n                    Installer installer = SdkInstallerUtil\n                            .findBestInstallerFactory(p, mSdkHandler)\n                            .createInstaller(p, repoManager, downloader, mSdkHandler.getFileOp());\n                    if (installer.prepare(progress) && installer.complete(progress)) {\n                        installResults.put(p, InstallResultType.SUCCESS);\n                    } else {\n                        installResults.put(p, InstallResultType.INSTALL_FAIL);\n                    }\n                }\n            }\n        }\n        return installResults;\n    }\n",
    "new_code_raw": "    private boolean installRemotePackages(\n            @NonNull List<RemotePackage> requestPackages,\n            @NonNull RepoManager repoManager,\n            @NonNull Downloader downloader,\n            @NonNull ProgressIndicator progress) {\n\n        List<RemotePackage> remotePackages =\n                InstallerUtil.computeRequiredPackages(\n                        requestPackages, repoManager.getPackages(), progress);\n\n        if (remotePackages == null) {\n            return false;\n        }\n\n        for (RemotePackage p : remotePackages) {\n            if (p.getLicense() != null && !p.getLicense().checkAccepted(\n                    repoManager.getLocalPath(), mSdkHandler.getFileOp())) {\n                progress.setText(\n                        \"The license for package \" + p.getDisplayName() + \" was not accepted. \"\n                                + \"Please install this package through Android Studio SDK \"\n                                + \"Manager.\");\n                return false;\n            }\n\n            Installer installer = SdkInstallerUtil\n                    .findBestInstallerFactory(p, mSdkHandler)\n                    .createInstaller(p, repoManager, downloader, mSdkHandler.getFileOp());\n            boolean result = installer.prepare(progress)\n                    && installer.complete(progress);\n\n            if (!result) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2007-FirstSentence-0",
    "old_comment_raw": "creates an XmlItem this route creates an XmlItem",
    "new_comment_raw": "creates an XmlItem this route creates an XmlItem",
    "old_code_raw": "    public ApiResponse<Void> createXmlItemWithHttpInfo(XmlItem xmlItem) throws ApiException {\n        okhttp3.Call call = createXmlItemValidateBeforeCall(xmlItem, null, null);\n        return apiClient.execute(call);\n    }\n",
    "new_code_raw": "    public ApiResponse<Void> createXmlItemWithHttpInfo(XmlItem xmlItem) throws ApiException {\n        okhttp3.Call localVarCall = createXmlItemValidateBeforeCall(xmlItem, null, null);\n        return localVarApiClient.execute(localVarCall);\n    }\n"
  },
  {
    "id": "svn2github_fleXive-145-Associations-FirstSentence",
    "old_comment_raw": "Get the global configuration table name including the correct escaped schema",
    "new_comment_raw": "Get the global configuration table name including the correct schema",
    "old_code_raw": "    private String getConfigurationTable(Connection con) {\n        try {\n            if (StorageManager.getStorageImpl(con.getMetaData().getDatabaseProductName()).escapeSchema())\n                return \"\\\"\" + DatabaseConst.getConfigSchema() + \"\\\".\" + TBL_GLOBAL_CONFIG;\n        } catch (SQLException e) {\n            LOG.warn(e);\n        }\n        return DatabaseConst.getConfigSchema() + \".\" + TBL_GLOBAL_CONFIG;\n    }\n",
    "new_code_raw": "    private String getConfigurationTable(Connection con) {\n        try {\n            if (StorageManager.getStorageImpl(con.getMetaData().getDatabaseProductName()).requiresConfigSchema()) {\n                if (DatabaseConst.getConfigSchema().endsWith(\".\"))\n                    return DatabaseConst.getConfigSchema() + TBL_GLOBAL_CONFIG;\n                else\n                    return DatabaseConst.getConfigSchema() + \".\" + TBL_GLOBAL_CONFIG;\n            }\n        } catch (SQLException e) {\n            LOG.warn(e);\n        }\n        return TBL_GLOBAL_CONFIG;\n    }\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2164-FirstSentence-0",
    "old_comment_raw": "Returns a List of children for the current node.",
    "new_comment_raw": "Returns a List of children for the current node.",
    "old_code_raw": "  public List<Tree> getChildrenAsList() {\n    return new ArrayList<Tree>(Arrays.asList(children()));\n  }\n",
    "new_code_raw": "  public List<Tree> getChildrenAsList() {\n    return new ArrayList<>(Arrays.asList(children()));\n  }\n"
  },
  {
    "id": "google_google-api-java-client-46-Associations-FirstSentence",
    "old_comment_raw": "Gets the total number of bytes uploaded by this uploader or  0 for direct uploads when the content length is not known.",
    "new_comment_raw": "Gets the total number of bytes the server received so far or  0 for direct uploads when the content length is not known.",
    "old_code_raw": "  public long getNumBytesUploaded() {\n    return bytesUploaded;\n  }\n",
    "new_code_raw": "  @Deprecated\n  public long getNumBytesUploaded() {\n    return totalBytesServerReceived;\n  }\n\n"
  },
  {
    "id": "zaproxy_zaproxy-2008-FirstSentence-0",
    "old_comment_raw": "Calculates the changes required to uninstall the given add-ons.",
    "new_comment_raw": "Calculates the changes required to uninstall the given add-ons.",
    "old_code_raw": "    public UninstallationResult calculateUninstallChanges(Set<AddOn> selectedAddOns) {\n        List<AddOn> remainingAddOns = new ArrayList<>(installedAddOns.getAddOns());\n        remainingAddOns.removeAll(selectedAddOns);\n\n        Set<AddOn> uninstallations = new HashSet<>();\n        List<AddOn> addOnsToCheck = new ArrayList<>(remainingAddOns);\n        while (!addOnsToCheck.isEmpty()) {\n            AddOn addOn = addOnsToCheck.remove(0);\n            RunRequirements requirements = addOn.calculateRunRequirements(remainingAddOns);\n\n            if (!requirements.hasDependencyIssue()) {\n                addOnsToCheck.removeAll(requirements.getDependencies());\n            } else if (AddOn.InstallationStatus.UNINSTALLATION_FAILED != addOn.getInstallationStatus()) {\n                uninstallations.add(addOn);\n            }\n        }\n\n        for (Iterator<AddOn> it = uninstallations.iterator(); it.hasNext();) {\n            AddOn addOn = it.next();\n            if (addOn.calculateRunRequirements(installedAddOns.getAddOns()).hasDependencyIssue()\n                    && !containsAny(addOn.getIdsAddOnDependencies(), uninstallations)) {\n                it.remove();\n            }\n        }\n\n        uninstallations.addAll(selectedAddOns);\n        return new UninstallationResult(selectedAddOns, uninstallations);\n    }\n",
    "new_code_raw": "    public UninstallationResult calculateUninstallChanges(Set<AddOn> selectedAddOns) {\n        List<AddOn> remainingAddOns = new ArrayList<>(installedAddOns.getAddOns());\n        remainingAddOns.removeAll(selectedAddOns);\n\n        Set<AddOn> uninstallations = new HashSet<>();\n        List<AddOn> addOnsToCheck = new ArrayList<>(remainingAddOns);\n        while (!addOnsToCheck.isEmpty()) {\n            AddOn addOn = addOnsToCheck.remove(0);\n            AddOn.AddOnRunRequirements requirements = addOn.calculateRunRequirements(remainingAddOns);\n\n            if (!requirements.hasDependencyIssue()) {\n                addOnsToCheck.removeAll(requirements.getDependencies());\n            } else if (AddOn.InstallationStatus.UNINSTALLATION_FAILED != addOn.getInstallationStatus()) {\n                uninstallations.add(addOn);\n            }\n        }\n\n        for (Iterator<AddOn> it = uninstallations.iterator(); it.hasNext();) {\n            AddOn addOn = it.next();\n            if (addOn.calculateRunRequirements(installedAddOns.getAddOns()).hasDependencyIssue()\n                    && !containsAny(addOn.getIdsAddOnDependencies(), uninstallations)) {\n                it.remove();\n            }\n        }\n\n        remainingAddOns.removeAll(uninstallations);\n        Set<Extension> extensions = new HashSet<>();\n        for (AddOn addOn : remainingAddOns) {\n            if (addOn.hasExtensionsWithDeps()) {\n                for (Extension ext : addOn.getLoadedExtensions()) {\n                    AddOn.AddOnRunRequirements requirements = addOn.calculateExtensionRunRequirements(ext, remainingAddOns);\n                    if (!requirements.getExtensionRequirements().isEmpty()) {\n                        AddOn.ExtensionRunRequirements extReqs = requirements.getExtensionRequirements().get(0);\n                        if (!extReqs.isRunnable()) {\n                            extensions.add(ext);\n                        }\n                    }\n                }\n            }\n        }\n\n        uninstallations.addAll(selectedAddOns);\n        return new UninstallationResult(selectedAddOns, uninstallations, extensions);\n    }\n"
  },
  {
    "id": "eclipse_rt.equinox.bundles-63-Associations-FirstSentence",
    "old_comment_raw": "Obtains a ISTextExpert instance for processing structured text with the specified type handler and the specified environment.",
    "new_comment_raw": "Obtains a IStructuredTextExpert instance for processing structured text with the specified type handler and the specified environment.",
    "old_code_raw": "\tstatic public ISTextExpert getStatefulExpert(STextTypeHandler handler, STextEnvironment environment) {\n\t\tif (environment == null)\n\t\t\tenvironment = STextEnvironment.DEFAULT;\n\t\treturn new STextImpl(handler, environment, true);\n\t}\n",
    "new_code_raw": "\tstatic public IStructuredTextExpert getStatefulExpert(StructuredTextTypeHandler handler, StructuredTextEnvironment environment) {\n\t\tif (environment == null)\n\t\t\tenvironment = StructuredTextEnvironment.DEFAULT;\n\t\treturn new StructuredTextImpl(handler, environment, true);\n\t}\n\n"
  },
  {
    "id": "JodaOrg_joda_time-1058-FirstSentence-0",
    "old_comment_raw": "Prints a ReadablePartial to a new String.",
    "new_comment_raw": "Prints a ReadablePartial to a new String.",
    "old_code_raw": "    public String print(ReadablePartial partial) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, partial);\n        return buf.toString();\n    }\n",
    "new_code_raw": "    public String print(ReadablePartial partial) {\n        StringBuilder builder = new StringBuilder(requirePrinter().estimatePrintedLength());\n        try {\n            printTo(builder, partial);\n        } catch (IOException e) {\n            // StringBuilder does not throw IOException\n        }\n        return builder.toString();\n    }\n"
  },
  {
    "id": "heuermh_ensembl-rest-client-2-Associations-FirstSentence",
    "old_comment_raw": "Create and return a new feature service with the default server URL.",
    "new_comment_raw": "Create and return a new feature service with the default endpoint URL.",
    "old_code_raw": "    public FeatureService createFeatureService() {\n        return createFeatureService(defaultServerUrl);\n    }\n",
    "new_code_raw": "    public FeatureService createFeatureService() {\n        return createFeatureService(defaultEndpointUrl);\n    }\n\n"
  },
  {
    "id": "MilosKozak_AndroidAPS-125-FirstSentence-0",
    "old_comment_raw": "expect absolute request and allow both absolute and percent response based on pump capabilities",
    "new_comment_raw": "expect absolute request and allow both absolute and percent response based on pump capabilities",
    "old_code_raw": "    public boolean applyAPSRequest(APSResult request, Callback callback) {\n        PumpInterface pump = getActivePump();\n        request.rate = applyBasalConstraints(request.rate);\n        PumpEnactResult result;\n\n        if (!pump.isInitialized()) {\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpNotInitialized));\n            if (callback != null) {\n                callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpNotInitialized)).enacted(false).success(false)).run();\n            }\n            return false;\n        }\n\n        if (pump.isSuspended()) {\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpsuspended));\n            if (callback != null) {\n                callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpsuspended)).enacted(false).success(false)).run();\n            }\n            return false;\n        }\n\n        if (Config.logCongigBuilderActions)\n            log.debug(\"applyAPSRequest: \" + request.toString());\n        if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - pump.getBaseBasalRate()) < pump.getPumpDescription().basalStep) {\n            if (isTempBasalInProgress()) {\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: cancelTempBasal()\");\n                getCommandQueue().cancelTempBasal(false, callback);\n                return true;\n            } else {\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: Basal set correctly\");\n                if (callback != null) {\n                    callback.result(new PumpEnactResult().absolute(request.rate).duration(0).enacted(false).success(true).comment(\"Basal set correctly\")).run();\n                }\n                return false;\n            }\n        } else if (isTempBasalInProgress() && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < pump.getPumpDescription().basalStep) {\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: Temp basal set correctly\");\n            if (callback != null) {\n                callback.result(new PumpEnactResult().absolute(getTempBasalAbsoluteRateHistory()).duration(getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes()).enacted(false).success(true).comment(\"Temp basal set correctly\")).run();\n            }\n            return false;\n        } else {\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: setTempBasalAbsolute()\");\n            getCommandQueue().tempBasalAbsolute(request.rate, request.duration, false, callback);\n            return true;\n        }\n    }\n",
    "new_code_raw": "    public PumpEnactResult applyAPSRequest(APSResult request) {\n        request.rate = applyBasalConstraints(request.rate);\n        PumpEnactResult result;\n\n        if (!isInitialized()) {\n            result = new PumpEnactResult();\n            result.comment = MainApp.sResources.getString(R.string.pumpNotInitialized);\n            result.enacted = false;\n            result.success = false;\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpNotInitialized));\n            return result;\n        }\n\n        if (isSuspended()) {\n            result = new PumpEnactResult();\n            result.comment = MainApp.sResources.getString(R.string.pumpsuspended);\n            result.enacted = false;\n            result.success = false;\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpsuspended));\n            return result;\n        }\n\n        if (Config.logCongigBuilderActions)\n            log.debug(\"applyAPSRequest: \" + request.toString());\n        if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - getBaseBasalRate()) < getPumpDescription().basalStep) {\n            if (isTempBasalInProgress()) {\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: cancelTempBasal()\");\n                result = cancelTempBasal(false);\n            } else {\n                result = new PumpEnactResult();\n                result.absolute = request.rate;\n                result.duration = 0;\n                result.enacted = false;\n                result.comment = \"Basal set correctly\";\n                result.success = true;\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: Basal set correctly\");\n            }\n        } else if (isTempBasalInProgress() && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < getPumpDescription().basalStep) {\n            result = new PumpEnactResult();\n            result.absolute = getTempBasalAbsoluteRateHistory();\n            result.duration = getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes();\n            result.enacted = false;\n            result.comment = \"Temp basal set correctly\";\n            result.success = true;\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: Temp basal set correctly\");\n        } else {\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: setTempBasalAbsolute()\");\n            result = setTempBasalAbsolute(request.rate, request.duration);\n        }\n        return result;\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2592-FirstSentence-0",
    "old_comment_raw": "GET /user/username",
    "new_comment_raw": "GET /user/username",
    "old_code_raw": "        public User executeAs(Function<Response, Response> handler) {\n            Type type = new TypeToken<User>(){}.getType();\n            return getJSON().deserialize(execute(handler).asString(), type);\n        }\n",
    "new_code_raw": "        public User executeAs(Function<Response, Response> handler) {\n            Type type = new TypeToken<User>(){}.getType();\n            return execute(handler).as(type);\n        }\n"
  },
  {
    "id": "apache_kylin-526-FirstSentence-0",
    "old_comment_raw": "Get the parent cuboid really on the spanning tree.",
    "new_comment_raw": "Get the parent cuboid rely on the spanning tree.",
    "old_code_raw": "    public long findBestMatchCuboid(long child) {\n        long parent = getOnTreeParent(child);\n        while (parent > 0) {\n            if (cubeDesc.getAllCuboids().contains(parent)) {\n                break;\n            }\n            parent = getOnTreeParent(parent);\n        }\n\n        if (parent <= 0) {\n            throw new IllegalStateException(\"Can't find valid parent for Cuboid \" + child);\n        }\n        return parent;\n    }\n",
    "new_code_raw": "    public long findBestMatchCuboid(long cuboid) {\n        return findBestMatchCuboid1(cuboid);\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2372-FirstSentence-0",
    "old_comment_raw": "Returns an Iterable of the lines in the file, wrapping the generated",
    "new_comment_raw": "Returns an Iterable of the lines in the file, wrapping the generated",
    "old_code_raw": "      public Iterator<String> iterator() {\n        return new Iterator<String>() {\n\n          protected BufferedReader reader = this.getReader();\n          protected String line = this.getLine();\n\n          public boolean hasNext() {\n            return this.line != null;\n          }\n\n          public String next() {\n            String nextLine = this.line;\n            if (nextLine == null) {\n              throw new NoSuchElementException();\n            }\n            line = getLine();\n            return nextLine;\n          }\n\n          protected String getLine() {\n            try {\n              String result = this.reader.readLine();\n              if (result == null) {\n                this.reader.close();\n              }\n              return result;\n            } catch (IOException e) {\n              throw new RuntimeIOException(e);\n            }\n          }\n\n          protected BufferedReader getReader() {\n            try {\n              InputStream stream = new FileInputStream(file);\n              if (fileInputStreamWrapper != null) {\n                stream = fileInputStreamWrapper.getConstructor(\n                        InputStream.class).newInstance(stream);\n              }\n              return new BufferedReader(new InputStreamReader(stream));\n            } catch (Exception e) {\n              throw new RuntimeIOException(e);\n            }\n          }\n\n          public void remove() {\n            throw new UnsupportedOperationException();\n          }\n        };\n      }\n",
    "new_code_raw": "      public Iterator<String> iterator() {\n        return new Iterator<String>() {\n\n          protected BufferedReader reader = this.getReader();\n          protected String line = this.getLine();\n\n          public boolean hasNext() {\n            return this.line != null;\n          }\n\n          public String next() {\n            String nextLine = this.line;\n            if (nextLine == null) {\n              throw new NoSuchElementException();\n            }\n            line = getLine();\n            return nextLine;\n          }\n\n          protected String getLine() {\n            try {\n              String result = this.reader.readLine();\n              if (result == null) {\n                this.reader.close();\n              }\n              return result;\n            } catch (IOException e) {\n              throw new RuntimeIOException(e);\n            }\n          }\n\n          protected BufferedReader getReader() {\n            try {\n              InputStream stream = new FileInputStream(file);\n              if (fileInputStreamWrapper != null) {\n                stream = fileInputStreamWrapper.getConstructor(\n                        InputStream.class).newInstance(stream);\n              }\n              if (encoding == null) {\n                return new BufferedReader(new InputStreamReader(stream));\n              } else {\n                return new BufferedReader(new InputStreamReader(stream, encoding));\n              }\n            } catch (Exception e) {\n              throw new RuntimeIOException(e);\n            }\n          }\n\n          public void remove() {\n            throw new UnsupportedOperationException();\n          }\n        };\n      }\n"
  },
  {
    "id": "trygvis_jop-154-Associations-FirstSentence",
    "old_comment_raw": "String representation of the signature.",
    "new_comment_raw": "Get a string representation of this member, using the '#' separator for class members.",
    "old_code_raw": "    public String toString(boolean altMemberSep) {\n        StringBuffer s = new StringBuffer();\n        if ( className != null ) {\n            s.append(className);\n        }\n        if (memberName != null) {\n            if ( className != null ) {            \t\n                s.append(altMemberSep ? ALT_MEMBER_SEPARATOR : '.');\n            }\n            s.append(memberName);\n        }\n        if ( descriptor != null && (className == null || memberName != null) ) {\n            s.append(descriptor);\n        }\n        return s.toString();\n    }\n",
    "new_code_raw": "    @Override\n    public String toString() {\n        if (stringRep == null) {\n            stringRep = toString(true);\n        }\n    \treturn stringRep;\n    }\n\n"
  },
  {
    "id": "RobotiumTech_robotium-1386-FirstSentence-0",
    "old_comment_raw": "Returns a Button which shows a given text.",
    "new_comment_raw": "Returns a Button which shows a given text.",
    "old_code_raw": "\tpublic Button getButton(String text, boolean onlyVisible)\n\t{\n\t\treturn viewFetcher.getView(Button.class, text, onlyVisible);\n\t}\n",
    "new_code_raw": "\tpublic Button getButton(String text, boolean onlyVisible)\n\t{\n\t\treturn getter.getView(Button.class, text, onlyVisible);\n\t}\n"
  },
  {
    "id": "signal_agathon-2-Associations-FirstSentence",
    "old_comment_raw": "Return the list of Cassandra instances ordered by position on ring, indicated by token.",
    "new_comment_raw": "Return the set of Cassandra instances.",
    "old_code_raw": "  @GET\n  public List<CassandraInstance> findAll() {\n    return service.findAll();\n  }\n",
    "new_code_raw": "  @GET\n  public Set<CassandraInstance> findAll() {\n    return service.findAll();\n  }\n\n"
  },
  {
    "id": "querydsl_querydsl-501-FirstSentence-0",
    "old_comment_raw": "Create a new PathMetadata for property access",
    "new_comment_raw": "Create a new PathMetadata for property access",
    "old_code_raw": "    public static PathMetadata<String> forProperty(Path<?> parent, String property) {\n        return new PathMetadata<String>(parent, ConstantImpl.create(Assert.hasLength(property,\"property\"), true), PathType.PROPERTY);\n    }\n",
    "new_code_raw": "    public static PathMetadata<String> forProperty(Path<?> parent, String property) {\n        return new PathMetadata<String>(parent, Assert.hasLength(property,\"property\"), PathType.PROPERTY);\n    }\n"
  },
  {
    "id": "apache_lenya-284-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Returns the path to the replication directory",
    "old_code_raw": "    public String getReplicationDirectory() {\n        return replicationDirectory;\n    }\n",
    "new_code_raw": "    public String getReplicationDirectory() {\n        return this.replicationDirectory;\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1621-FirstSentence-0",
    "old_comment_raw": "Override with any special handling of response codes",
    "new_comment_raw": "Override with any special handling of response codes",
    "old_code_raw": "    protected Response findMethodResponse(Map<String, Response> responses) {\n\n        String code = null;\n        for (String responseCode : responses.keySet()) {\n            if (responseCode.startsWith(\"2\") || responseCode.equals(\"default\")) {\n                if (code == null || code.compareTo(responseCode) > 0) {\n                    code = responseCode;\n                }\n            }\n        }\n        if (code == null) {\n            return null;\n        }\n        return responses.get(code);\n    }\n",
    "new_code_raw": "    protected ApiResponse findMethodResponse(ApiResponses responses) {\n        String code = null;\n        for (String responseCode : responses.keySet()) {\n            if (responseCode.startsWith(\"2\") || responseCode.equals(\"default\")) {\n                if (code == null || code.compareTo(responseCode) > 0) {\n                    code = responseCode;\n                }\n            }\n        }\n        if (code == null) {\n            return null;\n        }\n        return responses.get(code);\n    }\n"
  },
  {
    "id": "yahoo_gondola-0-Associations-FirstSentence",
    "old_comment_raw": "Get entry data, read directly from internal data structure.",
    "new_comment_raw": "Returns the value stored at the specified key.",
    "old_code_raw": "    public String getValue(String entryId) throws RecordNotFoundException {\n        if (!entries.containsKey(entryId)) {\n            throw new RecordNotFoundException();\n        }\n        return entries.get(entryId);\n    }\n",
    "new_code_raw": "    public String getValue(String key) throws NotFoundException, NotLeaderException {\n        if (cluster.getLocalRole() != Role.LEADER) {\n            throw new NotLeaderException();\n        }\n        if (!entries.containsKey(key)) {\n            throw new NotFoundException();\n        }\n        String value = entries.get(key);\n        logger.info(String.format(\"Get key %s: %s\", key, value));\n        return value;\n    }\n\n"
  },
  {
    "id": "elastic_elasticsearch_hadoop-2-FirstSentence-0",
    "old_comment_raw": "Seeks the field with the given name in the stream and positions (and returns) the parser to the next available token (value or not).",
    "new_comment_raw": "Seeks the field with the given name in the stream and positions (and returns) the parser to the next available token (value or not).",
    "old_code_raw": "    public static Token seek(String path, Parser parser) {\n        // return current token if no path is given\n        if (!StringUtils.hasText(path)) {\n            return null;\n        }\n\n        List<String> tokens = StringUtils.tokenize(path, \"/\");\n        ListIterator<String> li = tokens.listIterator();\n        return doSeekToken(li.next(), li, parser);\n    }\n",
    "new_code_raw": "    public static Token seek(String path, Parser parser) {\n        // return current token if no path is given\n        if (!StringUtils.hasText(path)) {\n            return null;\n        }\n\n        List<String> tokens = StringUtils.tokenize(path, \"/\");\n        return seek(parser, tokens.toArray(new String[tokens.size()]));\n    }\n"
  },
  {
    "id": "apache_lenya-292-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Get the backup directory",
    "old_code_raw": "    public String getBackupDirectory() {\n        return backupDirectory;\n    }\n",
    "new_code_raw": "    public String getBackupDirectory() {\n        return this.backupDirectory;\n    }\n\n"
  },
  {
    "id": "drtshock_Potato-4-FirstSentence-0",
    "old_comment_raw": "Checks if this potato is baked.",
    "new_comment_raw": "Checks if this potato is baked.",
    "old_code_raw": "    public boolean isBaked() {\n        try {\n            return this.isPutIntoOven();\n        } catch (OvenException e) {\n            return false;\n        }\n    }\n",
    "new_code_raw": "    public boolean isBaked() throws NotDeliciousException {\n        try {\n            long begin = System.currentTimeMillis();\n            boolean isInOven = this.isPutIntoOven();\n            long bakeTime = (System.currentTimeMillis() - begin);\n            if (bakeTime > 1100) throw new NotDeliciousException(NotDeliciousReason.OVERCOOKED);\n            return isInOven;\n        } catch (OvenException e) {\n            return false;\n        }\n    }\n"
  },
  {
    "id": "RSB4760_apq8016_frameworks_support-45-Associations-FirstSentence",
    "old_comment_raw": "Creates a renderscript allocation from a bitmap",
    "new_comment_raw": "Creates an Allocation from a  android.graphics.Bitmap.",
    "old_code_raw": "    static public Allocation createFromBitmap(RenderScript rs, Bitmap b,\n                                              MipmapControl mips,\n                                              int usage) {\n        rs.validate();\n        Type t = typeFromBitmap(rs, b, mips);\n\n        int id = rs.nAllocationCreateFromBitmap(t.getID(rs), mips.mID, b, usage);\n        if (id == 0) {\n            throw new RSRuntimeException(\"Load failed.\");\n        }\n        return new Allocation(id, rs, t, usage);\n    }\n",
    "new_code_raw": "    static public Allocation createFromBitmap(RenderScript rs, Bitmap b,\n                                              MipmapControl mips,\n                                              int usage) {\n        if (rs.isNative) {\n            RenderScriptThunker rst = (RenderScriptThunker)rs;\n            return AllocationThunker.createFromBitmap(rst, b, mips, usage);\n        }\n        rs.validate();\n\n        // WAR undocumented color formats\n        if (b.getConfig() == null) {\n            if ((usage & USAGE_SHARED) != 0) {\n                throw new RSIllegalArgumentException(\"USAGE_SHARED cannot be used with a Bitmap that has a null config.\");\n            }\n            Bitmap newBitmap = Bitmap.createBitmap(b.getWidth(), b.getHeight(), Bitmap.Config.ARGB_8888);\n            Canvas c = new Canvas(newBitmap);\n            c.drawBitmap(b, 0, 0, null);\n            return createFromBitmap(rs, newBitmap, mips, usage);\n        }\n\n        Type t = typeFromBitmap(rs, b, mips);\n\n        // enable optimized bitmap path only with no mipmap and script-only usage\n        if (mips == MipmapControl.MIPMAP_NONE &&\n            t.getElement().isCompatible(Element.RGBA_8888(rs)) &&\n            usage == (USAGE_SHARED | USAGE_SCRIPT)) {\n            int id = rs.nAllocationCreateBitmapBackedAllocation(t.getID(rs), mips.mID, b, usage);\n            if (id == 0) {\n                throw new RSRuntimeException(\"Load failed.\");\n            }\n\n            // keep a reference to the Bitmap around to prevent GC\n            Allocation alloc = new Allocation(id, rs, t, usage);\n            alloc.setBitmap(b);\n            return alloc;\n        }\n\n\n        int id = rs.nAllocationCreateFromBitmap(t.getID(rs), mips.mID, b, usage);\n        if (id == 0) {\n            throw new RSRuntimeException(\"Load failed.\");\n        }\n        return new Allocation(id, rs, t, usage);\n    }\n\n"
  },
  {
    "id": "apache_calcite-383-FirstSentence-0",
    "old_comment_raw": "Computes the row type of an  Aggregate before it exists.",
    "new_comment_raw": "Computes the row type of an  Aggregate before it exists.",
    "old_code_raw": "  public boolean isValid(Litmus litmus) {\n    return super.isValid(litmus)\n        && litmus.check(Util.isDistinct(getRowType().getFieldNames()), getRowType());\n  }\n",
    "new_code_raw": "  public boolean isValid(Litmus litmus) {\n    return super.isValid(litmus)\n        && litmus.check(Util.isDistinct(getRowType().getFieldNames()),\n            \"distinct field names: {}\", getRowType());\n  }\n"
  },
  {
    "id": "caillette_novelang-2-Associations-FirstSentence",
    "old_comment_raw": "Returns the sibling on the right of the end of given  Treepath.",
    "new_comment_raw": "Returns the sibling on the left of the bottom of given  Treepath.",
    "old_code_raw": "  public static Treepath getNextSibling( Treepath treepath ) {\n    throw new UnsupportedOperationException( \"getNextSibling\" ) ;\n  }\n",
    "new_code_raw": "  public static Treepath getNextSibling( Treepath treepath ) {\n    if( treepath.getHeight() < 2 ) {\n      throw new IllegalArgumentException( \"Treepath must have minimum height of 2\" ) ;\n    }\n    final Tree treeToMove = treepath.getBottom() ;\n    final Tree parent = treepath.getTreeAtHeight( 1 ) ;\n    for( int i = 0 ; i < parent.getChildCount() - 1 ; i++ ) {\n      final Tree child = parent.getChildAt( i ) ;\n      if( child == treeToMove ) {\n        return Treepath.create( treepath.getParent(), parent.getChildAt( i + 1 ) ) ;\n      }\n    }\n    throw new IllegalArgumentException( \"No next sibling\" ) ;\n  }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-889-FirstSentence-0",
    "old_comment_raw": "Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZ).",
    "new_comment_raw": "Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZ).",
    "old_code_raw": "    public String toString() {\n        return ISODateTimeFormat.getInstance(getChronology()).dateTime().print(this);\n    }\n",
    "new_code_raw": "    public String toString() {\n        return ISODateTimeFormat.getInstance().dateTime().print(this);\n    }\n"
  },
  {
    "id": "apache_geronimo-javamail-6-Associations-FirstSentence",
    "old_comment_raw": "Evaluate a PLAIN login challenge, returning the a result string that should satisfy the clallenge.",
    "new_comment_raw": "Evaluate a PLAIN login challenge, returning the a result string that should satisfy the challenge.",
    "old_code_raw": "    public byte[] evaluateChallenge(byte[] challenge) throws MessagingException {\n        try {\n            // get the username and password in an UTF-8 encoding to create the\n            // token\n            byte[] userBytes = username.getBytes(\"UTF-8\");\n            byte[] passBytes = password.getBytes(\"UTF-8\");\n\n            // our token has two copies of the username, one copy of the\n            // password, and nulls\n            // between\n            byte[] tokenBytes = new byte[(userBytes.length * 2) + passBytes.length + 2];\n\n            System.arraycopy(userBytes, 0, tokenBytes, 0, userBytes.length);\n            System.arraycopy(userBytes, 0, tokenBytes, userBytes.length + 1, userBytes.length);\n            System.arraycopy(passBytes, 0, tokenBytes, (userBytes.length * 2) + 2, passBytes.length);\n\n            complete = true;\n            return tokenBytes;\n\n        } catch (UnsupportedEncodingException e) {\n            // got an error, fail this\n            throw new MessagingException(\"Invalid encoding\");\n        }\n    }\n",
    "new_code_raw": "    public byte[] evaluateChallenge(byte[] challenge) throws MessagingException {\n        try {\n\n            String result = \"\\0\"+username+\"\\0\"+password;\n\n            if(authzid != null && authzid.length() > 0) {\n                result = authzid+result;\n            }\n\n            complete = true;\n            return result.getBytes(\"UTF-8\");\n\n        } catch (UnsupportedEncodingException e) {\n            // got an error, fail this\n            throw new MessagingException(\"Invalid encoding\");\n        }\n    }\n\n"
  },
  {
    "id": "zaproxy_zaproxy-2308-FirstSentence-0",
    "old_comment_raw": "Gets the given  start and  end view positions offset to a header.",
    "new_comment_raw": "Gets the given  start and  end view positions offset to a header.",
    "old_code_raw": "    public static int[] getViewToHeaderPosition(JTextArea view, int start, int end) {\n        validateView(view);\n        validateStartEnd(start, end, view.getDocument().getLength());\n        return getViewToHeaderPositionImpl(view, start, end);\n    }\n",
    "new_code_raw": "    public static int[] getViewToHeaderPosition(JTextArea view, int start, int end) {\n        validateView(view);\n        validateStartEnd(start, end);\n\n        if (!isValidStartEndForLength(start, end, view.getDocument().getLength())) {\n            return INVALID_POSITION;\n        }\n\n        return getViewToHeaderPositionImpl(view, start, end);\n    }\n"
  },
  {
    "id": "apache_axis1-java-151-Associations-FirstSentence",
    "old_comment_raw": "Return XML schema for the specified type, suitable for insertion into the &lt;types&gt; element of a WSDL document.",
    "new_comment_raw": "Return XML schema for the specified type, suitable for insertion into the &lt;types&gt; element of a WSDL document, or underneath an &lt;element&gt; or &lt;attribute&gt; declaration.",
    "old_code_raw": "    public boolean writeSchema(Types types) throws Exception {\n        return false;\n    }\n",
    "new_code_raw": "    public Element writeSchema(Class javaType, Types types) throws Exception {\n        return null;\n    }\n\n"
  },
  {
    "id": "zaproxy_zaproxy-1994-FirstSentence-0",
    "old_comment_raw": "Gets the quality or status of the given passive  scanner.",
    "new_comment_raw": "Gets the quality or status of the given passive  scanner.",
    "old_code_raw": "\tpublic static String getPluginQuality(PluginPassiveScanner scanner) {\n        String scannerPackage = scanner.getClass().getCanonicalName();\n        String scannerName = scanner.getName();\n        \n        return (getSpecificQuality(scannerName, scannerPackage));\n        \n        }\n",
    "new_code_raw": "\tpublic static String getPluginQuality(PluginPassiveScanner scanner) {\n//        String scannerPackage = scanner.getClass().getCanonicalName();\n        String scannerName = scanner.getName();\n        \n        return (getSpecificQuality(scannerName, scanner));\n        \n        }\n"
  },
  {
    "id": "apache_calcite-avatica-16-Associations-FirstSentence",
    "old_comment_raw": "Looks up a field with a given name and if found returns its ordinal.",
    "new_comment_raw": "Looks up a field with a given name, returning null if not found.",
    "old_code_raw": "    public static int lookupField(\n        final RelDataType rowType,\n        String columnName)\n    {\n        final RelDataTypeField [] fields = rowType.getFields();\n        for (int i = 0; i < fields.length; i++) {\n            RelDataTypeField field = fields[i];\n            if (field.getName().equals(columnName)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n",
    "new_code_raw": "    public static RelDataTypeField lookupField(\n        final RelDataType rowType,\n        String columnName)\n    {\n        final RelDataTypeField [] fields = rowType.getFields();\n        for (int i = 0; i < fields.length; i++) {\n            RelDataTypeField field = fields[i];\n            if (field.getName().equals(columnName)) {\n                return field;\n            }\n        }\n        return null;\n    }\n\n"
  },
  {
    "id": "querydsl_querydsl-244-FirstSentence-0",
    "old_comment_raw": "Expr : left.lastIndexOf(right)",
    "new_comment_raw": "Expr : left.lastIndexOf(right)",
    "old_code_raw": "    public static ENumber<Integer> lastIndexOf(Expr<String> left, String right) {\n        return createNumber(Integer.class,Ops.LAST_INDEX, left, createConstant(right));\n    }\n",
    "new_code_raw": "    public static ENumber<Integer> lastIndexOf(Expr<String> left, String right) {\n        return factory.createNumber(Integer.class,Ops.LAST_INDEX, left, factory.createConstant(right));\n    }\n"
  },
  {
    "id": "dropwizard_dropwizard-0-Associations-FirstSentence",
    "old_comment_raw": "Converts the given object into a JSON AST.",
    "new_comment_raw": "Converts the given object into a canonical JSON string.",
    "old_code_raw": "    public static JsonNode asJson(Object object) throws IOException {\n        return JSON.writeValueAsTree(object);\n    }\n",
    "new_code_raw": "    public static String asJson(Object object) throws IOException {\n        return JSON.writeValueAsString(object);\n    }\n\n"
  },
  {
    "id": "zaproxy_zaproxy-1298-FirstSentence-0",
    "old_comment_raw": "This method initializes tableAuth",
    "new_comment_raw": "This method initializes tableAuth",
    "old_code_raw": "\tprivate JTable getTableExtension() {\n\t\tif (tableExt == null) {\n\t\t\ttableExt = new JTable();\n\t\t\ttableExt.setModel(getExtensionModel());\n\t\t\ttableExt.setRowHeight(DisplayUtils.getScaledSize(18));\n\t\t\ttableExt.getColumnModel().getColumn(0).setPreferredWidth(DisplayUtils.getScaledSize(70));\n\t\t\ttableExt.getColumnModel().getColumn(1).setPreferredWidth(DisplayUtils.getScaledSize(70));\n\t\t\ttableExt.getColumnModel().getColumn(2).setPreferredWidth(DisplayUtils.getScaledSize(120));\n\t\t\ttableExt.getColumnModel().getColumn(3).setPreferredWidth(DisplayUtils.getScaledSize(220));\n\t\t\t\n\t\t\tListSelectionListener sl = new ListSelectionListener() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void valueChanged(ListSelectionEvent arg0) {\n\t        \t\tif (tableExt.getSelectedRow() > -1) {\n\t        \t\t\tExtension ext = ((OptionsExtensionTableModel)tableExt.getModel()).getExtension(\n\t        \t\t\t\t\ttableExt.getSelectedRow());\n\t        \t\t\tif (ext != null) {\n\t        \t\t\t\ttry {\n\t\t\t\t\t\t\t\textName.setText(ext.getUIName());\n\t\t\t\t\t\t\t\tboolean addOnExtension = ext.getAddOn() != null;\n\t\t\t\t\t\t\t\taddOnNameLabel.setVisible(addOnExtension);\n\t\t\t\t\t\t\t\taddOnName.setVisible(addOnExtension);\n\t\t\t\t\t\t\t\taddOnName.setText(addOnExtension ? ext.getAddOn().getName() : \"\");\n\t\t\t\t\t\t\t\textDescription.setText(ext.getDescription());\n\t\t\t\t\t\t\t\tif (ext.getAuthor() != null) {\n\t\t\t\t\t\t\t\t\textAuthor.setText(ext.getAuthor());\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\textAuthor.setText(\"\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (ext.getURL() != null) {\n\t\t\t\t\t\t\t\t\textURL.setText(ext.getURL().toString());\n\t\t\t\t\t\t\t\t\tgetUrlLaunchButton().setEnabled(true);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\textURL.setText(\"\");\n\t\t\t\t\t\t\t\t\tgetUrlLaunchButton().setEnabled(false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\t// Just to be safe\n\t\t\t\t\t\t\t\tlog.error(e.getMessage(), e);\n\t\t\t\t\t\t\t}\n\t        \t\t\t}\n\t        \t\t}\n\t\t\t\t}};\n\t\t\t\n\t\t\ttableExt.getSelectionModel().addListSelectionListener(sl);\n\t\t\ttableExt.getColumnModel().getSelectionModel().addListSelectionListener(sl);\n\t\t\t\n\t\t}\n\t\treturn tableExt;\n\t}\n",
    "new_code_raw": "\tprivate JXTable getTableExtension() {\n\t\tif (tableExt == null) {\n\t\t\ttableExt = new JXTable();\n\t\t\ttableExt.setModel(getExtensionModel());\n\t\t\ttableExt.setRowHeight(DisplayUtils.getScaledSize(18));\n\t\t\ttableExt.getColumnModel().getColumn(0).setPreferredWidth(DisplayUtils.getScaledSize(70));\n\t\t\ttableExt.getColumnModel().getColumn(1).setPreferredWidth(DisplayUtils.getScaledSize(70));\n\t\t\ttableExt.getColumnModel().getColumn(2).setPreferredWidth(DisplayUtils.getScaledSize(120));\n\t\t\ttableExt.getColumnModel().getColumn(3).setPreferredWidth(DisplayUtils.getScaledSize(220));\n\t\t\ttableExt.setSortOrder(3, SortOrder.ASCENDING);\n\t\t\t\n\t\t\tListSelectionListener sl = new ListSelectionListener() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void valueChanged(ListSelectionEvent arg0) {\n\t        \t\tint selectedRow = tableExt.getSelectedRow();\n\t        \t\tif (selectedRow > -1) {\n\t        \t\t\tExtension ext = getExtensionModel().getExtension(tableExt.convertRowIndexToModel(selectedRow));\n\t        \t\t\tif (ext != null) {\n\t        \t\t\t\ttry {\n\t\t\t\t\t\t\t\textName.setText(ext.getUIName());\n\t\t\t\t\t\t\t\textDescription.setText(ext.getDescription());\n\t\t\t\t\t\t\t\tif (ext.getAuthor() != null) {\n\t\t\t\t\t\t\t\t\textAuthor.setText(ext.getAuthor());\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\textAuthor.setText(\"\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (ext.getURL() != null) {\n\t\t\t\t\t\t\t\t\textURL.setText(ext.getURL().toString());\n\t\t\t\t\t\t\t\t\tgetUrlLaunchButton().setEnabled(true);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\textURL.setText(\"\");\n\t\t\t\t\t\t\t\t\tgetUrlLaunchButton().setEnabled(false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\t// Just to be safe\n\t\t\t\t\t\t\t\tlog.error(e.getMessage(), e);\n\t\t\t\t\t\t\t}\n\t        \t\t\t}\n\t        \t\t}\n\t\t\t\t}};\n\t\t\t\n\t\t\ttableExt.getSelectionModel().addListSelectionListener(sl);\n\t\t\ttableExt.setColumnControlVisible(true);\n\t\t}\n\t\treturn tableExt;\n\t}\n"
  },
  {
    "id": "apache_lenya-393-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Get the list of src attributes for images",
    "old_code_raw": "    public ArrayList getImageSrcs() {\n        return img_src;\n    }\n",
    "new_code_raw": "    public ArrayList getImageSrcs() {\n        return this.img_src;\n    }\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-1969-FirstSentence-0",
    "old_comment_raw": "Determine which daughter of the current parse tree is the head.",
    "new_comment_raw": "Determine which daughter of the current parse tree is the head.",
    "old_code_raw": "  protected Tree determineNonTrivialHead(Tree t, Tree parent) {\n    String motherCat = tlp.basicCategory(t.label().value());\n\n    if (DEBUG) {\n      System.err.println(\"At \" + motherCat + \", my parent is \" + parent);\n    }\n\n    if (motherCat.equals(\"SBARQ\")) { \n      if (!makeCopulaHead) {\n        for (TregexPattern pattern : headOfCopulaTregex) {\n          TregexMatcher matcher = pattern.matcher(t);\n          if (matcher.matchesAt(t)) {\n            return matcher.getNode(\"head\");\n          }\n        }\n      }\n\n      // if none of the above patterns match, use the standard method\n    }\n\n    // do VPs with auxiliary as special case\n    if ((motherCat.equals(\"VP\") || motherCat.equals(\"SQ\") || motherCat.equals(\"SINV\"))) {\n      Tree[] kids = t.children();\n      // try to find if there is an auxiliary verb\n\n      if (DEBUG) {\n        System.err.println(\"Semantic head finder: at VP\");\n        System.err.println(\"Class is \" + t.getClass().getName());\n        t.pennPrint(System.err);\n        //System.err.println(\"hasVerbalAuxiliary = \" + hasVerbalAuxiliary(kids, verbalAuxiliaries));\n      }\n\n      // looks for auxiliaries\n      if (hasVerbalAuxiliary(kids, verbalAuxiliaries, true) || hasPassiveProgressiveAuxiliary(kids)) {\n        // String[] how = new String[] {\"left\", \"VP\", \"ADJP\", \"NP\"};\n        // Including NP etc seems okay for copular sentences but is\n        // problematic for other auxiliaries, like 'he has an answer'\n        // But maybe doing ADJP is fine!\n        String[] how = { \"left\", \"VP\", \"ADJP\" };\n        Tree pti = traverseLocate(kids, how, false);\n        if (DEBUG) {\n          System.err.println(\"Determined head (case 1) for \" + t.value() + \" is: \" + pti);\n        }\n        if (pti != null) {\n          return pti;\n        // } else {\n          // System.err.println(\"------\");\n          // System.err.println(\"SemanticHeadFinder failed to reassign head for\");\n          // t.pennPrint(System.err);\n          // System.err.println(\"------\");\n        }\n      }\n\n      // looks for copular verbs\n      if (hasVerbalAuxiliary(kids, copulars, false) && ! isExistential(t, parent) && ! isWHQ(t, parent)) {\n        String[] how;\n        if (motherCat.equals(\"SQ\")) {\n          how = new String[]{\"right\", \"VP\", \"ADJP\", \"NP\", \"WHADJP\", \"WHNP\"};\n        } else {\n          how = new String[]{\"left\", \"VP\", \"ADJP\", \"NP\", \"WHADJP\", \"WHNP\"};\n        }\n        Tree pti = traverseLocate(kids, how, false);\n        // don't allow a temporal to become head\n        if (pti != null && pti.label() != null && pti.label().value().contains(\"-TMP\")) {\n          pti = null;\n        }\n        // In SQ, only allow an NP to become head if there is another one to the left (then it's probably predicative)\n        if (motherCat.equals(\"SQ\") && pti != null && pti.label() != null && pti.label().value().startsWith(\"NP\")) {\n            boolean foundAnotherNp = false;\n            for (Tree kid : kids) {\n              if (kid == pti) {\n                break;\n              } else if (kid.label() != null && kid.label().value().startsWith(\"NP\")) {\n                foundAnotherNp = true;\n                break;\n              }\n            }\n          if ( ! foundAnotherNp) {\n            pti = null;\n          }\n        }\n\n        if (DEBUG) {\n          System.err.println(\"Determined head (case 2) for \" + t.value() + \" is: \" + pti);\n        }\n        if (pti != null) {\n          return pti;\n        } else {\n          if (DEBUG) {\n            System.err.println(\"------\");\n            System.err.println(\"SemanticHeadFinder failed to reassign head for\");\n            t.pennPrint(System.err);\n            System.err.println(\"------\");\n          }\n        }\n      }\n    }\n\n    Tree hd = super.determineNonTrivialHead(t, parent);\n\n    /* ----\n    // This should now be handled at the AbstractCollinsHeadFinder level, so see if we can comment this out\n    // Heuristically repair punctuation heads\n    Tree[] hdChildren = hd.children();\n    if (hdChildren != null && hdChildren.length > 0 &&\n        hdChildren[0].isLeaf()) {\n      if (tlp.isPunctuationWord(hdChildren[0].label().value())) {\n         Tree[] tChildren = t.children();\n         if (DEBUG) {\n           System.err.printf(\"head is punct: %s\\n\", hdChildren[0].label());\n         }\n         for (int i = tChildren.length - 1; i >= 0; i--) {\n           if (!tlp.isPunctuationWord(tChildren[i].children()[0].label().value())) {\n             hd = tChildren[i];\n             if (DEBUG) {\n               System.err.printf(\"New head of %s is %s%n\", hd.label(), hd.children()[0].label());\n             }\n             break;\n           }\n         }\n      }\n    }\n    */\n\n    if (DEBUG) {\n      System.err.println(\"Determined head (case 3) for \" + t.value() + \" is: \" + hd);\n    }\n    return hd;\n  }\n",
    "new_code_raw": "  protected Tree determineNonTrivialHead(Tree t, Tree parent) {\n    String motherCat = tlp.basicCategory(t.label().value());\n\n    if (DEBUG) {\n      System.err.println(\"At \" + motherCat + \", my parent is \" + parent);\n    }\n\n    // do VPs with auxiliary as special case\n    if ((motherCat.equals(\"VP\") || motherCat.equals(\"SQ\") || motherCat.equals(\"SINV\"))) {\n      Tree[] kids = t.children();\n      // try to find if there is an auxiliary verb\n\n      if (DEBUG) {\n        System.err.println(\"Semantic head finder: at VP\");\n        System.err.println(\"Class is \" + t.getClass().getName());\n        t.pennPrint(System.err);\n        //System.err.println(\"hasVerbalAuxiliary = \" + hasVerbalAuxiliary(kids, verbalAuxiliaries));\n      }\n\n      // looks for auxiliaries\n      if (hasVerbalAuxiliary(kids, verbalAuxiliaries, true) || hasPassiveProgressiveAuxiliary(kids)) {\n        // String[] how = new String[] {\"left\", \"VP\", \"ADJP\", \"NP\"};\n        // Including NP etc seems okay for copular sentences but is\n        // problematic for other auxiliaries, like 'he has an answer'\n        // But maybe doing ADJP is fine!\n        String[] how = { \"left\", \"VP\", \"ADJP\" };\n        Tree pti = traverseLocate(kids, how, false);\n        if (DEBUG) {\n          System.err.println(\"Determined head (case 1) for \" + t.value() + \" is: \" + pti);\n        }\n        if (pti != null) {\n          return pti;\n        // } else {\n          // System.err.println(\"------\");\n          // System.err.println(\"SemanticHeadFinder failed to reassign head for\");\n          // t.pennPrint(System.err);\n          // System.err.println(\"------\");\n        }\n      }\n\n      // looks for copular verbs\n      if (hasVerbalAuxiliary(kids, copulars, false) && ! isExistential(t, parent) && ! isWHQ(t, parent)) {\n        String[] how;\n        if (motherCat.equals(\"SQ\")) {\n          how = new String[]{\"right\", \"VP\", \"ADJP\", \"NP\", \"WHADJP\", \"WHNP\"};\n        } else {\n          how = new String[]{\"left\", \"VP\", \"ADJP\", \"NP\", \"WHADJP\", \"WHNP\"};\n        }\n        Tree pti = traverseLocate(kids, how, false);\n        // don't allow a temporal to become head\n        if (pti != null && pti.label() != null && pti.label().value().contains(\"-TMP\")) {\n          pti = null;\n        }\n        // In SQ, only allow an NP to become head if there is another one to the left (then it's probably predicative)\n        if (motherCat.equals(\"SQ\") && pti != null && pti.label() != null && pti.label().value().startsWith(\"NP\")) {\n            boolean foundAnotherNp = false;\n            for (Tree kid : kids) {\n              if (kid == pti) {\n                break;\n              } else if (kid.label() != null && kid.label().value().startsWith(\"NP\")) {\n                foundAnotherNp = true;\n                break;\n              }\n            }\n          if ( ! foundAnotherNp) {\n            pti = null;\n          }\n        }\n\n        if (DEBUG) {\n          System.err.println(\"Determined head (case 2) for \" + t.value() + \" is: \" + pti);\n        }\n        if (pti != null) {\n          return pti;\n        } else {\n          if (DEBUG) {\n            System.err.println(\"------\");\n            System.err.println(\"SemanticHeadFinder failed to reassign head for\");\n            t.pennPrint(System.err);\n            System.err.println(\"------\");\n          }\n        }\n      }\n    }\n\n    Tree hd = super.determineNonTrivialHead(t, parent);\n\n    /* ----\n    // This should now be handled at the AbstractCollinsHeadFinder level, so see if we can comment this out\n    // Heuristically repair punctuation heads\n    Tree[] hdChildren = hd.children();\n    if (hdChildren != null && hdChildren.length > 0 &&\n        hdChildren[0].isLeaf()) {\n      if (tlp.isPunctuationWord(hdChildren[0].label().value())) {\n         Tree[] tChildren = t.children();\n         if (DEBUG) {\n           System.err.printf(\"head is punct: %s\\n\", hdChildren[0].label());\n         }\n         for (int i = tChildren.length - 1; i >= 0; i--) {\n           if (!tlp.isPunctuationWord(tChildren[i].children()[0].label().value())) {\n             hd = tChildren[i];\n             if (DEBUG) {\n               System.err.printf(\"New head of %s is %s%n\", hd.label(), hd.children()[0].label());\n             }\n             break;\n           }\n         }\n      }\n    }\n    */\n\n    if (DEBUG) {\n      System.err.println(\"Determined head (case 3) for \" + t.value() + \" is: \" + hd);\n    }\n    return hd;\n  }\n"
  },
  {
    "id": "galderz_rhq-66-Associations-FirstSentence",
    "old_comment_raw": "Removes the content source from this channel, if it exists.",
    "new_comment_raw": "Removes the content source from this repo, if it exists.",
    "old_code_raw": "    public ChannelContentSource removeContentSource(ContentSource contentSource) {\n        if ((this.channelContentSources == null) || (contentSource == null)) {\n            return null;\n        }\n\n        ChannelContentSource doomed = null;\n\n        for (ChannelContentSource ccs : this.channelContentSources) {\n            if (contentSource.equals(ccs.getChannelContentSourcePK().getContentSource())) {\n                doomed = ccs;\n                break;\n            }\n        }\n\n        if (doomed != null) {\n            this.channelContentSources.remove(doomed);\n        }\n\n        return doomed;\n    }\n",
    "new_code_raw": "    public RepoContentSource removeContentSource(ContentSource contentSource) {\n        if ((this.repoContentSources == null) || (contentSource == null)) {\n            return null;\n        }\n\n        RepoContentSource doomed = null;\n\n        for (RepoContentSource ccs : this.repoContentSources) {\n            if (contentSource.equals(ccs.getRepoContentSourcePK().getContentSource())) {\n                doomed = ccs;\n                break;\n            }\n        }\n\n        if (doomed != null) {\n            this.repoContentSources.remove(doomed);\n        }\n\n        return doomed;\n    }\n\n"
  },
  {
    "id": "SeleniumHQ_selenium-627-FirstSentence-0",
    "old_comment_raw": "Returns whether an instance of Chrome is currently connected",
    "new_comment_raw": "Returns whether an instance of Chrome is currently connected",
    "old_code_raw": "  boolean hasClient() {\n    return listeningThread != null && listeningThread.hasClient;\n  }\n",
    "new_code_raw": "  boolean hasClient() {\n    return listeningThread != null && listeningThread.hasClient && !listeningThread.sockets.isEmpty();\n  }\n"
  },
  {
    "id": "eclipse_mylyn.reviews-7-Associations-FirstSentence",
    "old_comment_raw": "Returns the meta object for the containment reference '  org.eclipse.mylyn.reviews.core.model.IChange#getState State'.",
    "new_comment_raw": "Returns the meta object for the attribute ' org.eclipse.mylyn.reviews.core.model.IChange#getState State'.",
    "old_code_raw": "\tpublic EReference getChange_State() {\n\t\treturn (EReference) changeEClass.getEStructuralFeatures().get(5);\n\t}\n",
    "new_code_raw": "\tpublic EAttribute getChange_State() {\n\t\treturn (EAttribute) changeEClass.getEStructuralFeatures().get(5);\n\t}\n\n"
  },
  {
    "id": "LawnchairLauncher_Lawnchair-54-FirstSentence-0",
    "old_comment_raw": "Creates a new UserFolder, inflated from R.layout.user_folder.",
    "new_comment_raw": "Creates a new UserFolder, inflated from R.layout.user_folder.",
    "old_code_raw": "    static Folder fromXml(Launcher launcher) {\n        return (Folder) launcher.getLayoutInflater().inflate(\n                FeatureFlags.LAUNCHER3_DISABLE_ICON_NORMALIZATION\n                        ? R.layout.user_folder : R.layout.user_folder_icon_normalized, null);\n    }\n",
    "new_code_raw": "    static Folder fromXml(Launcher launcher) {\n        return (Folder) launcher.getLayoutInflater()\n                .inflate(R.layout.user_folder_icon_normalized, null);\n    }\n"
  },
  {
    "id": "albfan_sqlworkbenchj-32-Associations-FirstSentence",
    "old_comment_raw": "Return a String to recreate the GRANTs given for the passed table.",
    "new_comment_raw": "Return the GRANTs for the given table",
    "old_code_raw": "\tpublic DataStore getTableGrants(TableIdentifier table)\n\t{\n\t\tString[] columns = new String[] { \"TABLENAME\", \"GRANTOR\", \"GRANTEE\", \"PRIVILEGE\", \"GRANTABLE\" };\n\t\tint[] colTypes = new int[] { Types.VARCHAR, Types.VARCHAR, Types.VARCHAR, Types.VARCHAR, Types.VARCHAR };\n\t\tDataStore result = new DataStore(columns, colTypes);\n\t\tResultSet rs = null;\n\t\ttry\n\t\t{\n\t\t\tTableIdentifier tbl = table.createCopy();\n\t\t\ttbl.adjustCase(this.dbConnection);\n\t\t\trs = this.metaData.getTablePrivileges(tbl.getCatalog(), tbl.getSchema(), tbl.getTableName());\n\t\t\twhile (rs.next())\n\t\t\t{\n\t\t\t\tint row = result.addRow();\n\t\t\t\tresult.setValue(row, COLUMN_IDX_TABLE_GRANTS_OBJECT_NAME, rs.getString(3));\n\t\t\t\tresult.setValue(row, COLUMN_IDX_TABLE_GRANTS_GRANTOR, rs.getString(4));\n\t\t\t\tresult.setValue(row, COLUMN_IDX_TABLE_GRANTS_GRANTEE, rs.getString(5));\n\t\t\t\tresult.setValue(row, COLUMN_IDX_TABLE_GRANTS_PRIV, rs.getString(6));\n\t\t\t\tresult.setValue(row, COLUMN_IDX_TABLE_GRANTS_GRANTABLE, rs.getString(7));\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tLogMgr.logError(\"DbMetadata.getTableGrants()\", \"Error when retrieving table privileges\",e);\n\t\t\tresult.reset();\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttry { rs.close(); } catch (Throwable th) {}\n\t\t}\n\t\treturn result;\n\t}\n",
    "new_code_raw": "\tpublic Collection<TableGrant> getTableGrants(TableIdentifier table)\n\t{\n\t\tCollection<TableGrant> result = new HashSet<TableGrant>();\n\t\tResultSet rs = null;\n\t\ttry\n\t\t{\n\t\t\tTableIdentifier tbl = table.createCopy();\n\t\t\ttbl.adjustCase(this.dbConnection);\n\t\t\trs = this.metaData.getTablePrivileges(tbl.getCatalog(), tbl.getSchema(), tbl.getTableName());\n\t\t\twhile (rs.next())\n\t\t\t{\n\t\t\t\tString from = rs.getString(4);\n\t\t\t\tString to = rs.getString(5);\n\t\t\t\tString what = rs.getString(6);\n\t\t\t\tboolean grantable = StringUtil.stringToBool(rs.getString(7));\n\t\t\t\tTableGrant grant = new TableGrant(to, what, grantable);\n\t\t\t\tresult.add(grant);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tLogMgr.logError(\"DbMetadata.getTableGrants()\", \"Error when retrieving table privileges\",e);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttry { rs.close(); } catch (Throwable th) {}\n\t\t}\n\t\treturn result;\n\t}\n\n"
  },
  {
    "id": "Tamsiree_RxTool-11-FirstSentence-0",
    "old_comment_raw": "Disable tiling of the image.",
    "new_comment_raw": "Disable tiling of the image.",
    "old_code_raw": "    public ImageSource tilingDisabled() {\n        return tiling(false);\n    }\n",
    "new_code_raw": "    public ImageSource tilingDisabled() {\n        return setTiling(false);\n    }\n"
  },
  {
    "id": "apache_jsecurity-45-Associations-FirstSentence",
    "old_comment_raw": "First authenticates the AuthenticationToken argument, and if successful, constructs a SecurityContext instance representing the authenticated account's identity.",
    "new_comment_raw": "First authenticates the AuthenticationToken argument, and if successful, constructs a Subject instance representing the authenticated account's identity.",
    "old_code_raw": "    public SecurityContext login(AuthenticationToken token) throws AuthenticationException {\r\n        Account account;\r\n        try {\r\n            account = authenticate(token);\r\n            rememberMeSuccessfulLogin(token, account);\r\n        } catch (AuthenticationException ae) {\r\n            rememberMeFailedLogin(token, ae);\r\n            throw ae; //propagate\r\n        }\r\n        SecurityContext secCtx = createSecurityContext(token, account);\r\n        assertCreation(secCtx);\r\n        bind(secCtx);\r\n        return secCtx;\r\n    }\r\n",
    "new_code_raw": "    public Subject login(AuthenticationToken token) throws AuthenticationException {\r\n        Account account;\r\n        try {\r\n            account = authenticate(token);\r\n            rememberMeSuccessfulLogin(token, account);\r\n        } catch (AuthenticationException ae) {\r\n            rememberMeFailedLogin(token, ae);\r\n            throw ae; //propagate\r\n        }\r\n        Subject secCtx = createSubject(token, account);\r\n        assertCreation(secCtx);\r\n        bind(secCtx);\r\n        return secCtx;\r\n    }\r\n\n"
  },
  {
    "id": "LawnchairLauncher_Lawnchair-21-FirstSentence-0",
    "old_comment_raw": "Find the virtual view id corresponding to the top left corner of any drop region by which the passed id is contained.",
    "new_comment_raw": "Find the virtual view id corresponding to the top left corner of any drop region by which the passed id is contained.",
    "old_code_raw": "        protected int intersectsValidDropTarget(int id) {\n            LauncherAccessibilityDelegate delegate =\n                    LauncherAppState.getInstance().getAccessibilityDelegate();\n            LauncherAccessibilityDelegate.DragInfo dragInfo = delegate.getDragInfo();\n\n            int y = id % mCountY;\n            int x = id / mCountY;\n\n            if (dragInfo.dragType == DragType.WIDGET) {\n                // For a widget, every cell must be vacant. In addition, we will return any valid\n                // drop target by which the passed id is contained.\n                boolean fits = false;\n\n                // These represent the amount that we can back off if we hit a problem. They\n                // get consumed as we move up and to the right, trying new regions.\n                int spanX = dragInfo.info.spanX;\n                int spanY = dragInfo.info.spanY;\n\n                for (int m = 0; m < spanX; m++) {\n                    for (int n = 0; n < spanY; n++) {\n\n                        fits = true;\n                        int x0 = x - m;\n                        int y0 = y - n;\n\n                        if (x0 < 0 || y0 < 0) continue;\n\n                        for (int i = x0; i < x0 + spanX; i++) {\n                            if (!fits) break;\n                            for (int j = y0; j < y0 + spanY; j++) {\n                                if (i >= mCountX || j >= mCountY || mOccupied[i][j]) {\n                                    fits = false;\n                                    break;\n                                }\n                            }\n                        }\n                        if (fits) {\n                            return x0 * mCountY + y0;\n                        }\n                    }\n                }\n                return -1;\n            } else {\n                // For an icon, we simply check the view directly below\n                View child = getChildAt(x, y);\n                if (child == null || child == dragInfo.item) {\n                    // Empty cell. Good for an icon or folder.\n                    return id;\n                } else if (dragInfo.dragType != DragType.FOLDER) {\n                    // For icons, we can consider cells that have another icon or a folder.\n                    ItemInfo info = (ItemInfo) child.getTag();\n                    if (info instanceof AppInfo || info instanceof FolderInfo ||\n                            info instanceof ShortcutInfo) {\n                        return id;\n                    }\n                }\n                return -1;\n            }\n        }\n",
    "new_code_raw": "        protected int intersectsValidDropTarget(int id) {\n            LauncherAccessibilityDelegate delegate =\n                    LauncherAppState.getInstance().getAccessibilityDelegate();\n            if (delegate == null) {\n                return -1;\n            }\n\n            int y = id % mCountY;\n            int x = id / mCountY;\n            LauncherAccessibilityDelegate.DragInfo dragInfo = delegate.getDragInfo();\n\n            if (dragInfo.dragType == DragType.WIDGET) {\n                // For a widget, every cell must be vacant. In addition, we will return any valid\n                // drop target by which the passed id is contained.\n                boolean fits = false;\n\n                // These represent the amount that we can back off if we hit a problem. They\n                // get consumed as we move up and to the right, trying new regions.\n                int spanX = dragInfo.info.spanX;\n                int spanY = dragInfo.info.spanY;\n\n                for (int m = 0; m < spanX; m++) {\n                    for (int n = 0; n < spanY; n++) {\n\n                        fits = true;\n                        int x0 = x - m;\n                        int y0 = y - n;\n\n                        if (x0 < 0 || y0 < 0) continue;\n\n                        for (int i = x0; i < x0 + spanX; i++) {\n                            if (!fits) break;\n                            for (int j = y0; j < y0 + spanY; j++) {\n                                if (i >= mCountX || j >= mCountY || mOccupied[i][j]) {\n                                    fits = false;\n                                    break;\n                                }\n                            }\n                        }\n                        if (fits) {\n                            return x0 * mCountY + y0;\n                        }\n                    }\n                }\n                return -1;\n            } else {\n                // For an icon, we simply check the view directly below\n                View child = getChildAt(x, y);\n                if (child == null || child == dragInfo.item) {\n                    // Empty cell. Good for an icon or folder.\n                    return id;\n                } else if (dragInfo.dragType != DragType.FOLDER) {\n                    // For icons, we can consider cells that have another icon or a folder.\n                    ItemInfo info = (ItemInfo) child.getTag();\n                    if (info instanceof AppInfo || info instanceof FolderInfo ||\n                            info instanceof ShortcutInfo) {\n                        return id;\n                    }\n                }\n                return -1;\n            }\n        }\n"
  },
  {
    "id": "apache_sentry-10-Associations-FirstSentence",
    "old_comment_raw": "Make fully qualified URI based on the default file system Scheme and Authority",
    "new_comment_raw": "Make fully qualified URI if Scheme and/or Authority is missing, based on the default file system Scheme and Authority.",
    "old_code_raw": "  private static URI makeFullQualifiedURI(String uriName) throws IOException, URISyntaxException {\n    Path uriPath = new Path(uriName);\n\n    if (uriPath.isAbsoluteAndSchemeAuthorityNull()) {\n\n      URI defaultUri = FileSystem.getDefaultUri(CONF);\n      uriPath = uriPath.makeQualified(defaultUri, uriPath);\n      return uriPath.toUri();\n    }\n\n    return new URI(uriName);\n  }\n",
    "new_code_raw": "  private static URI makeFullQualifiedURI(String uriName) throws IOException {\n    Path uriPath = new Path(uriName);\n    if (isNormalized(uriName) && uriPath.isUriPathAbsolute()) {\n      // add scheme and/or authority if either is missing\n      if ((uriPath.toUri().getScheme() == null || uriPath.toUri().getAuthority() == null)) {\n        URI defaultUri = FileSystem.getDefaultUri(CONF);\n        uriPath = uriPath.makeQualified(defaultUri, uriPath);\n      }\n      return uriPath.toUri();\n    } else { // relative URI path is unacceptable\n      return null;\n    }\n  }\n\n"
  },
  {
    "id": "runelite_runelite-140-FirstSentence-0",
    "old_comment_raw": "Rotate the vertex by the given orientation",
    "new_comment_raw": "Rotate the vertex by the given orientation",
    "old_code_raw": "\tpublic Vertex rotate(int orientation)\n\t{\n\t\tint sin = Perspective.SINE[orientation];\n\t\tint cos = Perspective.COSINE[orientation];\n\n\t\treturn new Vertex(\n\t\t\tx * cos + z * sin >> 16,\n\t\t\ty,\n\t\t\tz * cos - x * sin >> 16\n\t\t);\n\t}\n",
    "new_code_raw": "\tpublic Vertex rotate(int orientation)\n\t{\n\t\t// models are orientated north (1024) and there are 2048 angles total\n\t\torientation = (orientation + 1024) % 2048;\n\n\t\tif (orientation == 0)\n\t\t{\n\t\t\treturn this;\n\t\t}\n\n\t\tint sin = Perspective.SINE[orientation];\n\t\tint cos = Perspective.COSINE[orientation];\n\n\t\treturn new Vertex(\n\t\t\tx * cos + z * sin >> 16,\n\t\t\ty,\n\t\t\tz * cos - x * sin >> 16\n\t\t);\n\t}\n"
  },
  {
    "id": "nickman_qreactor-2-Associations-FirstSentence",
    "old_comment_raw": "Returns",
    "new_comment_raw": "Returns the queue file roll cycle",
    "old_code_raw": "\tpublic RollCycle getRollCycle() {\n\t\treturn rollCycle;\n\t}\n",
    "new_code_raw": "\tpublic RollCycle getRollCycle() {\n\t\treturn queue.rollCycle();\n\t}\n\n"
  },
  {
    "id": "wildfly_quickstart-19-FirstSentence-0",
    "old_comment_raw": "Looks up and returns the proxy to remote stateless calculator bean",
    "new_comment_raw": "Looks up and returns the proxy to remote stateless calculator bean",
    "old_code_raw": "    private static RemoteCalculator lookupRemoteStatelessCalculator() throws NamingException {\n        final Hashtable<String, String> jndiProperties = new Hashtable<>();\n        jndiProperties.put(Context.URL_PKG_PREFIXES, \"org.jboss.ejb.client.naming\");\n        final Context context = new InitialContext(jndiProperties);\n\n        // The JNDI lookup name for a stateless session bean has the syntax of:\n        // ejb:<appName>/<moduleName>/<distinctName>/<beanName>!<viewClassName>\n        //\n        // <appName> The application name is the name of the EAR that the EJB is deployed in\n        // (without the .ear). If the EJB JAR is not deployed in an EAR then this is\n        // blank. The app name can also be specified in the EAR's application.xml\n        //\n        // <moduleName> By the default the module name is the name of the EJB JAR file (without the\n        // .jar suffix). The module name might be overridden in the ejb-jar.xml\n        //\n        // <distinctName> : EAP allows each deployment to have an (optional) distinct name.\n        // This example does not use this so leave it blank.\n        //\n        // <beanName> : The name of the session been to be invoked.\n        //\n        // <viewClassName>: The fully qualified classname of the remote interface. Must include\n        // the whole package name.\n\n        // let's do the lookup\n        return (RemoteCalculator) context.lookup(\"ejb:/jboss-ejb-remote-server-side/CalculatorBean!\"\n            + RemoteCalculator.class.getName());\n    }\n",
    "new_code_raw": "    private static RemoteCalculator lookupRemoteStatelessCalculator() throws NamingException {\n        final Hashtable<String, String> jndiProperties = new Hashtable<>();\n        jndiProperties.put(Context.URL_PKG_PREFIXES, \"org.jboss.ejb.client.naming\");\n        final Context context = new InitialContext(jndiProperties);\n\n        // The JNDI lookup name for a stateless session bean has the syntax of:\n        // ejb:<appName>/<moduleName>/<distinctName>/<beanName>!<viewClassName>\n        //\n        // <appName> The application name is the name of the EAR that the EJB is deployed in\n        // (without the .ear). If the EJB JAR is not deployed in an EAR then this is\n        // blank. The app name can also be specified in the EAR's application.xml\n        //\n        // <moduleName> By the default the module name is the name of the EJB JAR file (without the\n        // .jar suffix). The module name might be overridden in the ejb-jar.xml\n        //\n        // <distinctName> : EAP allows each deployment to have an (optional) distinct name.\n        // This example does not use this so leave it blank.\n        //\n        // <beanName> : The name of the session been to be invoked.\n        //\n        // <viewClassName>: The fully qualified classname of the remote interface. Must include\n        // the whole package name.\n\n        // let's do the lookup\n        return (RemoteCalculator) context.lookup(\"ejb:/ejb-remote-server-side/CalculatorBean!\"\n            + RemoteCalculator.class.getName());\n    }\n"
  },
  {
    "id": "yahoo_fili-42-Associations-FirstSentence",
    "old_comment_raw": "Build a DruidDimensionsLoader.",
    "new_comment_raw": "Build a DimensionValueLoadTask.",
    "old_code_raw": "    protected DruidDimensionsLoader buildDruidDimensionsLoader(\n            DruidWebService webService,\n            PhysicalTableDictionary physicalTableDictionary,\n            DimensionDictionary dimensionDictionary\n    ) {\n        return new DruidDimensionsLoader(\n                physicalTableDictionary,\n                dimensionDictionary,\n                webService\n        );\n    }\n",
    "new_code_raw": "    protected DimensionValueLoadTask buildDruidDimensionsLoader(\n            DruidWebService webService,\n            PhysicalTableDictionary physicalTableDictionary,\n            DimensionDictionary dimensionDictionary\n    ) {\n        DruidDimensionValueLoader druidDimensionRowProvider = new DruidDimensionValueLoader(\n                physicalTableDictionary,\n                dimensionDictionary,\n                webService\n        );\n        return new DimensionValueLoadTask(Collections.singletonList(druidDimensionRowProvider));\n    }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-465-FirstSentence-0",
    "old_comment_raw": "Does this time interval overlap the specified time interval.",
    "new_comment_raw": "Does this time interval overlap the specified time interval.",
    "old_code_raw": "    public boolean overlaps(ReadableInterval interval) {\n        if (interval == null) {\n            throw new IllegalArgumentException(\"The time interval must not be null\");\n        }\n        long otherStart = interval.getStartMillis();\n        long otherEnd = interval.getEndMillis();\n        long thisStart = getStartMillis();\n        long thisEnd = getEndMillis();\n        return (thisStart < otherEnd && otherStart < thisEnd);\n    }\n",
    "new_code_raw": "    public boolean overlaps(ReadableInterval interval) {\n        if (interval == null) {\n            return containsNow();\n        }\n        long otherStart = interval.getStartMillis();\n        long otherEnd = interval.getEndMillis();\n        long thisStart = getStartMillis();\n        long thisEnd = getEndMillis();\n        return (thisStart < otherEnd && otherStart < thisEnd);\n    }\n"
  },
  {
    "id": "vbehar_jenkins-rundeck-plugin-2-Associations-FirstSentence",
    "old_comment_raw": "prepares an url-encoded HTTP queryString containing the group/job and the options.",
    "new_comment_raw": "prepare the  HttpClient's queryString containing the group/job and the options.",
    "old_code_raw": "    private String prepareQueryString(String groupPath, String jobName, Properties options) {\n        List<NameValuePair> parameters = new ArrayList<NameValuePair>();\n\n        parameters.add(new BasicNameValuePair(\"groupPath\", groupPath));\n        parameters.add(new BasicNameValuePair(\"jobName\", jobName));\n\n        if (options != null) {\n            for (Entry<Object, Object> option : options.entrySet()) {\n                parameters.add(new BasicNameValuePair(\"extra.command.option.\" + option.getKey(),\n                                                      String.valueOf(option.getValue())));\n            }\n        }\n\n        return URLEncodedUtils.format(parameters, HTTP.UTF_8);\n    }\n",
    "new_code_raw": "    private NameValuePair[] prepareQueryString(String groupPath, String jobName, Properties options) {\n        List<NameValuePair> queryString = new ArrayList<NameValuePair>();\n\n        queryString.add(new NameValuePair(\"groupPath\", groupPath));\n        queryString.add(new NameValuePair(\"jobName\", jobName));\n\n        if (options != null) {\n            for (Entry<Object, Object> option : options.entrySet()) {\n                queryString.add(new NameValuePair(\"extra.command.option.\" + option.getKey(),\n                                                  String.valueOf(option.getValue())));\n            }\n        }\n\n        return queryString.toArray(new NameValuePair[queryString.size()]);\n    }\n\n"
  },
  {
    "id": "wdullaer_MaterialDateTimePicker-4-FirstSentence-0",
    "old_comment_raw": "Gets the colorAccent from the current context, if possible/available",
    "new_comment_raw": "Gets the colorAccent from the current context, if possible/available",
    "old_code_raw": "    public static int getAccentColorFromThemeIfAvailable(Context context) {\n        TypedValue typedValue = new TypedValue();\n        // First, try the android:colorAccent\n        if (Build.VERSION.SDK_INT >= 21) {\n            context.getTheme().resolveAttribute(android.R.attr.colorAccent, typedValue, true);\n            return typedValue.data;\n        }\n        // Next, try colorAccent from support lib\n        int colorAccentResId = context.getResources().getIdentifier(\"colorAccent\", \"attr\", context.getPackageName());\n        if (colorAccentResId != 0 && context.getTheme().resolveAttribute(colorAccentResId, typedValue, true)) {\n            return typedValue.data;\n        }\n        // Return the value in mdtp_accent_color\n        return Utils.getColor(context, R.color.mdtp_accent_color);\n    }\n",
    "new_code_raw": "    public static int getAccentColorFromThemeIfAvailable(Context context) {\n        TypedValue typedValue = new TypedValue();\n        // First, try the android:colorAccent\n        if (Build.VERSION.SDK_INT >= 21) {\n            context.getTheme().resolveAttribute(android.R.attr.colorAccent, typedValue, true);\n            return typedValue.data;\n        }\n        // Next, try colorAccent from support lib\n        int colorAccentResId = context.getResources().getIdentifier(\"colorAccent\", \"attr\", context.getPackageName());\n        if (colorAccentResId != 0 && context.getTheme().resolveAttribute(colorAccentResId, typedValue, true)) {\n            return typedValue.data;\n        }\n        // Return the value in mdtp_accent_color\n        return ContextCompat.getColor(context, R.color.mdtp_accent_color);\n    }\n"
  },
  {
    "id": "apache_lenya-282-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Returns the path to the authoring tree",
    "old_code_raw": "    public String getTreeAuthoringPath() {\n        return treeAuthoringPath;\n    }\n",
    "new_code_raw": "    public String getTreeAuthoringPath() {\n        return this.treeAuthoringPath;\n    }\n\n"
  },
  {
    "id": "SeleniumHQ_selenium-631-FirstSentence-0",
    "old_comment_raw": "Locates the Chrome executable on the current platform.",
    "new_comment_raw": "Locates the Chrome executable on the current platform.",
    "old_code_raw": "  protected String getChromeFile() throws IOException {\n    String chromeFileString = System.getProperty(\"webdriver.chrome.bin\");\n    if (chromeFileString == null) {\n      if (Platform.getCurrent().is(Platform.WINDOWS)) {\n        chromeFileString = getWindowsBinaryLocation();\n      } else if (Platform.getCurrent().is(Platform.UNIX)) {\n        chromeFileString = \"/usr/bin/google-chrome\";\n      } else if (Platform.getCurrent().is(Platform.MAC)) {\n        String[] paths = new String[] {\n          \"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome\",\n          \"/Users/\" + System.getProperty(\"user.name\") +\n              \"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome\"};\n        for (String path : paths) {\n          File binary = new File(path);\n          if (binary.exists()) {\n            chromeFileString = binary.getCanonicalFile().getAbsoluteFile().toString();\n            break;\n          }\n        }\n      } else {\n        throw new WebDriverException(\"Unsupported operating system.  \" +\n            \"Could not locate Chrome.  Set webdriver.chrome.bin\");\n      }\n      if (chromeFileString == null ||\n          !new File(chromeFileString.toString()).exists()) {\n        throw new WebDriverException(\"Couldn't locate Chrome.  \" +\n            \"Set webdriver.chrome.bin\");\n      }\n    }\n    return chromeFileString;\n  }\n",
    "new_code_raw": "  protected String getChromeFile() throws IOException {\n    if (!isChromeBinaryLocationKnown()) {\n      chromeBinaryLocation = System.getProperty(\"webdriver.chrome.bin\");\n      if (chromeBinaryLocation == null) {\n        if (Platform.getCurrent().is(Platform.WINDOWS)) {\n          chromeBinaryLocation = getWindowsBinaryLocation();\n        } else if (Platform.getCurrent().is(Platform.UNIX)) {\n          chromeBinaryLocation = \"/usr/bin/google-chrome\";\n        } else if (Platform.getCurrent().is(Platform.MAC)) {\n          String[] paths = new String[] {\n            \"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome\",\n            \"/Users/\" + System.getProperty(\"user.name\") +\n                \"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome\"};\n          for (String path : paths) {\n            File binary = new File(path);\n            if (binary.exists()) {\n              chromeBinaryLocation = binary.getCanonicalFile().getAbsoluteFile().toString();\n              break;\n            }\n          }\n        } else {\n          throw new WebDriverException(\"Unsupported operating system.  \" +\n              \"Could not locate Chrome.  Set webdriver.chrome.bin\");\n        }\n      }\n      if (!isChromeBinaryLocationKnown()) {\n        throw new WebDriverException(\"Couldn't locate Chrome.  \" +\n            \"Set webdriver.chrome.bin\");\n      }\n    }\n    return chromeBinaryLocation;\n  }\n"
  },
  {
    "id": "apache_lenya-323-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Generate a parse exception",
    "old_code_raw": "    final public ParseException generateParseException() {\n        jj_expentries.removeAllElements();\n\n        boolean[] la1tokens = new boolean[27];\n\n        for (int i = 0; i < 27; i++) {\n            la1tokens[i] = false;\n        }\n\n        if (jj_kind >= 0) {\n            la1tokens[jj_kind] = true;\n            jj_kind = -1;\n        }\n\n        for (int i = 0; i < 13; i++) {\n            if (jj_la1[i] == jj_gen) {\n                for (int j = 0; j < 32; j++) {\n                    if ((jj_la1_0[i] & (1 << j)) != 0) {\n                        la1tokens[j] = true;\n                    }\n                }\n            }\n        }\n\n        for (int i = 0; i < 27; i++) {\n            if (la1tokens[i]) {\n                jj_expentry = new int[1];\n                jj_expentry[0] = i;\n                jj_expentries.addElement(jj_expentry);\n            }\n        }\n\n        jj_endpos = 0;\n        jj_rescan_token();\n        jj_add_error_token(0, 0);\n\n        int[][] exptokseq = new int[jj_expentries.size()][];\n\n        for (int i = 0; i < jj_expentries.size(); i++) {\n            exptokseq[i] = (int[]) jj_expentries.elementAt(i);\n        }\n\n        return new ParseException(token, exptokseq, tokenImage);\n    }\n",
    "new_code_raw": "    final public ParseException generateParseException() {\n        this.jj_expentries.removeAllElements();\n\n        boolean[] la1tokens = new boolean[27];\n\n        for (int i = 0; i < 27; i++) {\n            la1tokens[i] = false;\n        }\n\n        if (this.jj_kind >= 0) {\n            la1tokens[this.jj_kind] = true;\n            this.jj_kind = -1;\n        }\n\n        for (int i = 0; i < 13; i++) {\n            if (this.jj_la1[i] == this.jj_gen) {\n                for (int j = 0; j < 32; j++) {\n                    if ((this.jj_la1_0[i] & (1 << j)) != 0) {\n                        la1tokens[j] = true;\n                    }\n                }\n            }\n        }\n\n        for (int i = 0; i < 27; i++) {\n            if (la1tokens[i]) {\n                this.jj_expentry = new int[1];\n                this.jj_expentry[0] = i;\n                this.jj_expentries.addElement(this.jj_expentry);\n            }\n        }\n\n        this.jj_endpos = 0;\n        jj_rescan_token();\n        jj_add_error_token(0, 0);\n\n        int[][] exptokseq = new int[this.jj_expentries.size()][];\n\n        for (int i = 0; i < this.jj_expentries.size(); i++) {\n            exptokseq[i] = (int[]) this.jj_expentries.elementAt(i);\n        }\n\n        return new ParseException(this.token, exptokseq, tokenImage);\n    }\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2270-FirstSentence-0",
    "old_comment_raw": "Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.",
    "new_comment_raw": "Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.",
    "old_code_raw": "  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n              {\n                if (invertible) {\n            // prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            // System.err.println(\"At end of text making after: |\" + str + \"|\");\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n            // System.err.println(\"prevWord is |\" + prevWord.get(CoreAnnotations.TextAnnotation.class) + \"|, its after is |\" +\n            //         prevWord.get(CoreAnnotations.AfterAnnotation.class) + \"|\");\n            prevWordAfter.setLength(0);\n          }\n          return null;\n              }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { String str = yytext();\n          int first = str.codePointAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\",\n                          yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n            }\n          case 74: break;\n          case 2: \n            { return getNext(\"<\", yytext());\n            }\n          case 75: break;\n          case 3: \n            { return getNext();\n            }\n          case 76: break;\n          case 4: \n            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n            }\n          case 77: break;\n          case 5: \n            { if (tokenizeNLs) {\n                      return getNext(AbstractTokenizer.NEWLINE_TOKEN, yytext()); // for tokenizing newliens\n                  } else if (invertible) {\n                    // System.err.println(\"Appending newline: |\" + yytext() + \"|\");\n                    prevWordAfter.append(yytext());\n                  }\n            }\n          case 78: break;\n          case 6: \n            { final String origTxt = yytext();\n                          String tok = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} (2) to recognize \" + origTxt + \" as \" + tok +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(tok, origTxt);\n            }\n          case 79: break;\n          case 7: \n            { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n            }\n          case 80: break;\n          case 8: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (3) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 81: break;\n          case 9: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 82: break;\n          case 10: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 83: break;\n          case 11: \n            { return getNext(\">\", yytext());\n            }\n          case 84: break;\n          case 12: \n            { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n            }\n          case 85: break;\n          case 13: \n            { handleHyphenatedNumber(yytext());\n                          if (DEBUG) { logger.info(\"Used {NUMBER} to recognize \" + yytext() + \" as \" + removeFromNumber(yytext())); }\n                          return getNext(removeFromNumber(yytext()), yytext());\n            }\n          case 86: break;\n          case 14: \n            { return handleEllipsis(yytext());\n            }\n          case 87: break;\n          case 15: \n            { // breakByHyphens(yytext()); // this is causing fail of attempted to pushback too much!\n                  String tok = yytext();\n                  /* A THING can contain quote like O'Malley */\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {THING} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 88: break;\n          case 16: \n            { String txt = yytext();\n                  String norm = normalizeFractions(yytext());\n                  if (DEBUG) { logger.info(\"Used {FRAC2} to recognize \" + txt + \" as \" + norm +\n                                       \"; normalizeFractions=\" + normalizeFractions +\n                                       \", escapeForwardSlashAsterisk=\" + escapeForwardSlashAsterisk); }\n                  return getNext(norm, txt);\n            }\n          case 89: break;\n          case 17: \n            { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext());\n                        } else {\n                            return getNext(minimallyNormalizeCurrency(yytext()), yytext());\n                          }\n            }\n          case 90: break;\n          case 18: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 91: break;\n          case 19: \n            { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 92: break;\n          case 20: \n            { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 93: break;\n          case 21: \n            { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 94: break;\n          case 22: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 95: break;\n          case 23: \n            { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 96: break;\n          case 24: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 97: break;\n          case 25: \n            { String tok = yytext();\n                        String norm = processCp1252misc(tok);\n                        if (DEBUG) { logger.info(\"Used {CP1252_MISC_SYMBOL} to recognize \" + tok + \" as \" + norm); }\n                        return getNext(norm, tok);\n            }\n          case 98: break;\n          case 26: \n            { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n            }\n          case 99: break;\n          case 27: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 15;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 100: break;\n          case 28: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext();\n            }\n          case 101: break;\n          case 29: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {REDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 102: break;\n          case 30: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {APOWORD} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 103: break;\n          case 31: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                                   String norm = handleQuotes(tok, true);\n                                   if (DEBUG) { logger.info(\"Used {DBLQUOT} to recognize \" + tok + \" as \" + norm +\n                                                            \"; probablyLeft=\" + true); }\n                                   return getNext(norm, tok);\n            }\n          case 104: break;\n          case 32: \n            { String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {PROG_LANGS} to recognize \" + tok + \" as \" + tok); }\n                    return getNext(tok, tok);\n            }\n          case 105: break;\n          case 33: \n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 106: break;\n          case 34: \n            { breakByHyphens(yytext());\n                  if (DEBUG) { logger.info(\"Used {HTHING} to recognize \" + yytext() + \" as \" + removeSoftHyphens(yytext())); }\n                  return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 107: break;\n          case 35: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 3;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 4;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tok = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} to recognize \" + origTxt + \" as \" + tok +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(tok, origTxt);\n            }\n          case 108: break;\n          case 36: \n            { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 109: break;\n          case 37: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 110: break;\n          case 38: \n            { // this one should only match if we're basically at the end of file\n                          // since the last one matches two things, even newlines (if not tokenize per line)\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n            }\n          case 111: break;\n          case 39: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 112: break;\n          case 40: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { // Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  // can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  /* invert single quote - often but not always right */\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 113: break;\n          case 41: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {REDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 114: break;\n          case 42: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { // Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  // can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  /* invert single quote - often but not always right */\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 115: break;\n          case 43: \n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 116: break;\n          case 44: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {SREDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 117: break;\n          case 45: \n            { if (splitAssimilations) {\n                      yypushback(2);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 118: break;\n          case 46: \n            { String txt = yytext();\n                  // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...\n                  if (strictTreebank3) {\n                    int spaceIndex = indexOfSpace(txt);\n                    if (spaceIndex >= 0) {\n                      yypushback(txt.length() - spaceIndex);\n                      return getNext();\n                    }\n                  }\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '/');\n                  }\n                  if (normalizeSpace) {\n                    txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n            }\n          case 119: break;\n          case 47: \n            { return getNormalizedAmpNext();\n            }\n          case 120: break;\n          case 48: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 121: break;\n          case 49: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 122: break;\n          case 50: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 5;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 6;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n            }\n          case 123: break;\n          case 51: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 17;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 124: break;\n          case 52: \n            { String txt = yytext();\n                  String normTok = txt;\n                  if (escapeForwardSlashAsterisk) {\n                    normTok = delimit(normTok, '*');\n                  }\n                  if (DEBUG) { logger.info(\"Used {SWEARING} to recognize \" + txt + \" as \" + normTok); }\n                  return getNext(normTok, txt);\n            }\n          case 125: break;\n          case 53: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 126: break;\n          case 54: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 127: break;\n          case 55: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 22;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 128: break;\n          case 56: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 18;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 19;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 129: break;\n          case 57: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 130: break;\n          case 58: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 21;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 131: break;\n          case 59: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 132: break;\n          case 60: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                  breakByHyphens(tok);\n                  tok = yytext();\n                  String norm = removeSoftHyphens(tok);\n                  if (DEBUG) { logger.info(\"Used {HTHING} (2) to recognize \" + tok + \" as \" + norm); }\n                  return getNext(norm, tok);\n            }\n          case 133: break;\n          case 61: \n            { if (splitAssimilations) {\n                      yypushback(3);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 134: break;\n          case 62: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNormalizedAmpNext();\n            }\n          case 135: break;\n          case 63: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 9;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 136: break;\n          case 64: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { return getNext();\n            }\n          case 137: break;\n          case 65: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 14;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 138: break;\n          case 66: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 8;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 139: break;\n          case 67: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 13;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 140: break;\n          case 68: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 141: break;\n          case 69: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);\n            { return getNext();\n            }\n          case 142: break;\n          case 70: \n            // lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { return getNext();\n            }\n          case 143: break;\n          case 71: \n            { String txt = yytext();\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          if (DEBUG) { logger.info(\"Used {PHONE} to recognize \" + yytext() + \" as \" + txt); }\n                          return getNext(txt, yytext());\n            }\n          case 144: break;\n          case 72: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 25;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 145: break;\n          case 73: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 24;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 146: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n",
    "new_code_raw": "  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n              {\n                if (invertible) {\n            // prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            // System.err.println(\"At end of text making after: |\" + str + \"|\");\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n            // System.err.println(\"prevWord is |\" + prevWord.get(CoreAnnotations.TextAnnotation.class) + \"|, its after is |\" +\n            //         prevWord.get(CoreAnnotations.AfterAnnotation.class) + \"|\");\n            prevWordAfter.setLength(0);\n          }\n          return null;\n              }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { String str = yytext();\n          int first = str.codePointAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\",\n                          yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n            }\n          case 77: break;\n          case 2: \n            { return getNext(\"<\", yytext());\n            }\n          case 78: break;\n          case 3: \n            { return getNext();\n            }\n          case 79: break;\n          case 4: \n            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n            }\n          case 80: break;\n          case 5: \n            { if (tokenizeNLs) {\n                      return getNext(AbstractTokenizer.NEWLINE_TOKEN, yytext()); // for tokenizing newliens\n                  } else if (invertible) {\n                    // System.err.println(\"Appending newline: |\" + yytext() + \"|\");\n                    prevWordAfter.append(yytext());\n                  }\n            }\n          case 81: break;\n          case 6: \n            { final String origTxt = yytext();\n                          String tok = LexerUtils.removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} (2) to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 82: break;\n          case 7: \n            { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n            }\n          case 83: break;\n          case 8: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (3) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 84: break;\n          case 9: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 85: break;\n          case 10: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 86: break;\n          case 11: \n            { return getNext(\">\", yytext());\n            }\n          case 87: break;\n          case 12: \n            { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n            }\n          case 88: break;\n          case 13: \n            { handleHyphenatedNumber(yytext());\n                          if (DEBUG) { logger.info(\"Used {NUMBER} to recognize \" + yytext() + \" as \" + removeFromNumber(yytext())); }\n                          return getNext(removeFromNumber(yytext()), yytext());\n            }\n          case 89: break;\n          case 14: \n            { return handleEllipsis(yytext());\n            }\n          case 90: break;\n          case 15: \n            { // breakByHyphens(yytext()); // this is causing fail of attempted to pushback too much!\n                  String tok = yytext();\n                  /* A THING can contain quote like O'Malley */\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {THING} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 91: break;\n          case 16: \n            { String txt = yytext();\n                  String norm = normalizeFractions(yytext());\n                  if (DEBUG) { logger.info(\"Used {FRAC2} to recognize \" + txt + \" as \" + norm +\n                                       \"; normalizeFractions=\" + normalizeFractions +\n                                       \", escapeForwardSlashAsterisk=\" + escapeForwardSlashAsterisk); }\n                  return getNext(norm, txt);\n            }\n          case 92: break;\n          case 17: \n            { if (normalizeCurrency) {\n                            return getNext(LexerUtils.normalizeCurrency(yytext()), yytext());\n                        } else {\n                            return getNext(LexerUtils.minimallyNormalizeCurrency(yytext()), yytext());\n                          }\n            }\n          case 93: break;\n          case 18: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 94: break;\n          case 19: \n            { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 95: break;\n          case 20: \n            { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 96: break;\n          case 21: \n            { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 97: break;\n          case 22: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 98: break;\n          case 23: \n            { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 99: break;\n          case 24: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 100: break;\n          case 25: \n            { String tok = yytext();\n                        String norm = LexerUtils.processCp1252misc(tok);\n                        if (DEBUG) { logger.info(\"Used {CP1252_MISC_SYMBOL} to recognize \" + tok + \" as \" + norm); }\n                        return getNext(norm, tok);\n            }\n          case 101: break;\n          case 26: \n            { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n            }\n          case 102: break;\n          case 27: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 15;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 103: break;\n          case 28: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext();\n            }\n          case 104: break;\n          case 29: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {REDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 105: break;\n          case 30: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {APOWORD} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 106: break;\n          case 31: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                                   String norm = handleQuotes(tok, true);\n                                   if (DEBUG) { logger.info(\"Used {DBLQUOT} to recognize \" + tok + \" as \" + norm +\n                                                            \"; probablyLeft=\" + true); }\n                                   return getNext(norm, tok);\n            }\n          case 107: break;\n          case 32: \n            { String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {PROG_LANGS} to recognize \" + tok + \" as \" + tok); }\n                    return getNext(tok, tok);\n            }\n          case 108: break;\n          case 33: \n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 109: break;\n          case 34: \n            { breakByHyphens(yytext());\n                  if (DEBUG) { logger.info(\"Used {HTHING} to recognize \" + yytext() + \" as \" + LexerUtils.removeSoftHyphens(yytext())); }\n                  return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext());\n            }\n          case 110: break;\n          case 35: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 3;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 4;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tok = LexerUtils.removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 111: break;\n          case 36: \n            { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 112: break;\n          case 37: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String origTok = yytext();\n                          String norm = LexerUtils.removeSoftHyphens(origTok);\n                          if (DEBUG) { logger.info(\"Used {WORD} (3) to recognize \" + origTok + \" as \" + norm); }\n                          return getNext(norm, origTok);\n            }\n          case 113: break;\n          case 38: \n            { // this one should only match if we're basically at the end of file\n                          // since the last one matches two things, even newlines (if not tokenize per line)\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n            }\n          case 114: break;\n          case 39: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 115: break;\n          case 40: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { // Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  // can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  /* invert single quote - often but not always right */\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 116: break;\n          case 41: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {REDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 117: break;\n          case 42: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { // Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  // can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  /* invert single quote - often but not always right */\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 118: break;\n          case 43: \n            { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext());\n            }\n          case 119: break;\n          case 44: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {SREDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 120: break;\n          case 45: \n            { if (splitAssimilations) {\n                      yypushback(2);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 121: break;\n          case 46: \n            { String txt = yytext();\n                  // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...\n                  if (strictTreebank3) {\n                    int spaceIndex = indexOfSpace(txt);\n                    if (spaceIndex >= 0) {\n                      yypushback(txt.length() - spaceIndex);\n                      return getNext();\n                    }\n                  }\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '/');\n                  }\n                  if (normalizeSpace) {\n                    txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n            }\n          case 122: break;\n          case 47: \n            { final String origTxt = yytext();\n                          String tok;\n                          if (normalizeAmpersandEntity) {\n                            tok = LexerUtils.normalizeAmp(origTxt);\n                          } else {\n                            tok = origTxt;\n                          }\n                          if (DEBUG) { logger.info(\"Used {THINGA} (2) to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 123: break;\n          case 48: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 124: break;\n          case 49: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 125: break;\n          case 50: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 5;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 6;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tok = LexerUtils.removeSoftHyphens(origTxt);\n                          if (DEBUG) { logger.info(\"Used {SWORD} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 126: break;\n          case 51: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 17;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 127: break;\n          case 52: \n            { String txt = yytext();\n                  String normTok = txt;\n                  if (escapeForwardSlashAsterisk) {\n                    normTok = delimit(normTok, '*');\n                  }\n                  if (DEBUG) { logger.info(\"Used {SWEARING} to recognize \" + txt + \" as \" + normTok); }\n                  return getNext(normTok, txt);\n            }\n          case 128: break;\n          case 53: \n            { final String origTxt = yytext();\n                  String tok;\n                  if (normalizeAmpersandEntity) {\n                    tok = LexerUtils.normalizeAmp(origTxt);\n                  } else {\n                    tok = origTxt;\n                  }\n                  if (DEBUG) { logger.info(\"Used {TBSPEC} to recognize \" + origTxt + \" as \" + tok); }\n                  return getNext(tok, origTxt);\n            }\n          case 129: break;\n          case 54: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 130: break;\n          case 55: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 131: break;\n          case 56: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 22;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 132: break;\n          case 57: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 18;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 19;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 133: break;\n          case 58: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 134: break;\n          case 59: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 21;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 135: break;\n          case 60: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 136: break;\n          case 61: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                  breakByHyphens(tok);\n                  tok = yytext();\n                  String norm = LexerUtils.removeSoftHyphens(tok);\n                  if (DEBUG) { logger.info(\"Used {HTHING} (2) to recognize \" + tok + \" as \" + norm); }\n                  return getNext(norm, tok);\n            }\n          case 137: break;\n          case 62: \n            { if (splitAssimilations) {\n                      yypushback(3);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 138: break;\n          case 63: \n            { final String origTxt = yytext();\n                          String tok;\n                          if (normalizeAmpersandEntity) {\n                            tok = LexerUtils.normalizeAmp(origTxt);\n                          } else {\n                            tok = origTxt;\n                          }\n                          if (DEBUG) { logger.info(\"Used {SPAMP} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 139: break;\n          case 64: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext());\n            }\n          case 140: break;\n          case 65: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { final String origTxt = yytext();\n                          String tok;\n                          if (normalizeAmpersandEntity) {\n                            tok = LexerUtils.normalizeAmp(origTxt);\n                          } else {\n                            tok = origTxt;\n                          }\n                          if (DEBUG) { logger.info(\"Used {THINGA} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 141: break;\n          case 66: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 9;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 142: break;\n          case 67: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { return getNext();\n            }\n          case 143: break;\n          case 68: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 14;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 144: break;\n          case 69: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 8;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 145: break;\n          case 70: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 13;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 146: break;\n          case 71: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 147: break;\n          case 72: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);\n            { return getNext();\n            }\n          case 148: break;\n          case 73: \n            // lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { return getNext();\n            }\n          case 149: break;\n          case 74: \n            { String txt = yytext();\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          if (DEBUG) { logger.info(\"Used {PHONE} to recognize \" + yytext() + \" as \" + txt); }\n                          return getNext(txt, yytext());\n            }\n          case 150: break;\n          case 75: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 25;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 151: break;\n          case 76: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 24;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 152: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n"
  },
  {
    "id": "apache_lenya-396-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Get a list of all links",
    "old_code_raw": "    public ArrayList getAllLinkHRefs() {\n        return link_href_all;\n    }\n",
    "new_code_raw": "    public ArrayList getAllLinkHRefs() {\n        return this.link_href_all;\n    }\n\n"
  },
  {
    "id": "LawnchairLauncher_Lawnchair-92-FirstSentence-0",
    "old_comment_raw": "Creates a view representing a shortcut.",
    "new_comment_raw": "Creates a view representing a shortcut.",
    "old_code_raw": "    View createShortcut(ShortcutInfo info) {\n        return createShortcut(R.layout.application,\n                (ViewGroup) mWorkspace.getChildAt(mWorkspace.getCurrentPage()), info);\n    }\n",
    "new_code_raw": "    View createShortcut(ShortcutInfo info) {\n        return createShortcut(R.layout.application,\n                (ViewGroup) mWorkspace.getChildAt(mWorkspace.getCurrentScreen()), info);\n    }\n"
  },
  {
    "id": "facebook_fresco-30-Associations-FirstSentence",
    "old_comment_raw": "Allocate a bitmap with the specified width and height.",
    "new_comment_raw": "Allocate a bitmap that has a backing memory allocacation of 'size' bytes.",
    "old_code_raw": "  @Override\n  protected Bitmap alloc(int size) {\n    return Bitmap.createBitmap(1, size, Bitmaps.BITMAP_CONFIG);\n  }\n",
    "new_code_raw": "  @Override\n  protected Bitmap alloc(int size) {\n    return Bitmap.createBitmap(\n        1,\n        (int) Math.ceil(size / (double) BitmapUtil.RGB_565_BYTES_PER_PIXEL),\n        Bitmap.Config.RGB_565);\n  }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2152-FirstSentence-0",
    "old_comment_raw": "To test \\&quot;client\\&quot; model",
    "new_comment_raw": "To test \\&quot;client\\&quot; model",
    "old_code_raw": "    public Mono<Client> testClientModel(Client body) throws RestClientException {\n        Object postBody = body;\n        \n        // verify the required parameter 'body' is set\n        if (body == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling testClientModel\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"/fake\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "new_code_raw": "    public Mono<Client> testClientModel(Client body) throws RestClientException {\n        Object postBody = body;\n        \n        // verify the required parameter 'body' is set\n        if (body == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling testClientModel\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"/fake\").build().toUriString();\n\n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType);\n    }\n"
  },
  {
    "id": "yahoo_elide-58-Associations-FirstSentence",
    "old_comment_raw": "All Paths are 'tagged' in swagger with the final entity type name in the path.",
    "new_comment_raw": "All Paths are 'tagged' in swagger with the root entity name in the path.",
    "old_code_raw": "        private String getTag() {\n            return dictionary.getJsonAliasFor(type);\n        }\n",
    "new_code_raw": "        private String getTag() {\n            if (lineage.isEmpty()) {\n                return name;\n            } else {\n                return lineage.get(0).getName();\n            }\n        }\n\n"
  },
  {
    "id": "apache_activemq-1117-FirstSentence-0",
    "old_comment_raw": "Used to determine if the broker can dispatch to the consumer.",
    "new_comment_raw": "Used to determine if the broker can dispatch to the consumer.",
    "old_code_raw": "    public boolean isFull() {\n        return dispatched.size() - prefetchExtension.get() >= info.getPrefetchSize();\n    }\n",
    "new_code_raw": "    public boolean isFull() {\n        return getPrefetchSize() == 0 ? prefetchExtension.get() == 0 : dispatched.size() - prefetchExtension.get() >= info.getPrefetchSize();\n    }\n"
  },
  {
    "id": "biddyweb_checker-framework-34-Associations-FirstSentence",
    "old_comment_raw": "Gets the element for the method corresponding to this invocation.",
    "new_comment_raw": "Gets the element for the declaration corresponding to this use of an element.",
    "old_code_raw": "    public static final ExecutableElement elementFromUse(MethodInvocationTree node) {\n        return (ExecutableElement)TreeInfo.symbol((JCTree)node.getMethodSelect());\n    }\n",
    "new_code_raw": "    public static final Element elementFromUse(ExpressionTree node) {\n        return InternalUtils.symbol(node);\n    }\n\n"
  },
  {
    "id": "processing_processing-63-FirstSentence-0",
    "old_comment_raw": "Get the full length of this movie (in seconds).",
    "new_comment_raw": "Get the full length of this movie (in seconds).",
    "old_code_raw": "  public float duration() {\n    float sec = gplayer.queryDuration().toSeconds();\n    float nanosec = gplayer.queryDuration().getNanoSeconds();\n    return sec + GSVideo.nanoSecToSecFrac(nanosec);\n  }  \n",
    "new_code_raw": "  public float duration() {\n    float sec = gplayer.queryDuration().toSeconds();\n    float nanosec = gplayer.queryDuration().getNanoSeconds();\n    return sec + Video.nanoSecToSecFrac(nanosec);\n  }  \n"
  },
  {
    "id": "debezium_debezium-29-FirstSentence-0",
    "old_comment_raw": "Converts a value from its logical format (BigDecimal) to its encoded format - a struct containing the scale of the number and a binary representation of the number.",
    "new_comment_raw": "Converts a value from its logical format to its encoded format - a struct containing the scale of the number and a binary representation of the number.",
    "old_code_raw": "    public static Struct fromLogical(Schema schema, SpecialValueDecimal value) {\n        Struct result = new Struct(schema);\n        final BigDecimal decimalValue = value.getDecimalValue().orElse(null);\n        assert decimalValue != null : \"Unable to encode special value\";\n        result.put(VALUE_FIELD, decimalValue.unscaledValue().toByteArray());\n        result.put(SCALE_FIELD, decimalValue.scale());\n        return result;\n    }\n",
    "new_code_raw": "    public static Struct fromLogical(Schema schema, SpecialValueDecimal value) {\n        return fromLogical(schema, value.getDecimalValue().orElse(null));\n    }\n"
  },
  {
    "id": "debezium_debezium-1123-FirstSentence-0",
    "old_comment_raw": "Get a  Struct representation of the source  #partition(String) partition and  #lastOffset(String) offset information.",
    "new_comment_raw": "Get a  Struct representation of the source  #partition(String) partition and  #lastOffset(String) offset information.",
    "old_code_raw": "    public Struct offsetStructForEvent(String replicaSetName, Document oplogEvent) {\n        Position position = INITIAL_POSITION;\n        String namespace = \"\";\n        if (oplogEvent != null) {\n            BsonTimestamp ts = extractEventTimestamp(oplogEvent);\n            Long opId = oplogEvent.getLong(\"h\");\n            position = new Position(ts, opId);\n            namespace = oplogEvent.getString(\"ns\");\n        }\n        positionsByReplicaSetName.put(replicaSetName, position);\n        return offsetStructFor(replicaSetName, namespace, position, isInitialSyncOngoing(replicaSetName));\n    }\n",
    "new_code_raw": "    public Struct offsetStructForEvent(String replicaSetName, Document oplogEvent) {\n        Position position = INITIAL_POSITION;\n        String namespace = \"\";\n        if (oplogEvent != null) {\n            BsonTimestamp ts = extractEventTimestamp(oplogEvent);\n            Long opId = oplogEvent.getLong(\"h\");\n            position = new Position(ts, opId);\n            namespace = oplogEvent.getString(\"ns\");\n        }\n        positionsByReplicaSetName.put(replicaSetName, position);\n        return offsetStructFor(replicaSetName, CollectionId.parse(replicaSetName + \".\" + namespace), position, isInitialSyncOngoing(replicaSetName));\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2561-FirstSentence-0",
    "old_comment_raw": "Convert Swagger Operation object to Codegen Operation object (without providing a Swagger object)",
    "new_comment_raw": "Convert Swagger Operation object to Codegen Operation object",
    "old_code_raw": "    public CodegenOperation fromOperation(String path, String httpMethod, Operation operation, Map<String, Model> definitions) {\n        return fromOperation(path, httpMethod, operation, definitions, null);\n    }\n",
    "new_code_raw": "    public CodegenOperation fromOperation(String path, String httpMethod, Operation operation, Map<String, Model> definitions, Swagger swagger) {\n        CodegenOperation op = CodegenModelFactory.newInstance(CodegenModelType.OPERATION);\n        Set<String> imports = new HashSet<String>();\n        op.vendorExtensions = operation.getVendorExtensions();\n\n        String operationId = getOrGenerateOperationId(operation, path, httpMethod);\n        operationId = removeNonNameElementToCamelCase(operationId);\n        op.path = path;\n        op.operationId = toOperationId(operationId);\n        op.summary = escapeText(operation.getSummary());\n        op.unescapedNotes = operation.getDescription();\n        op.notes = escapeText(operation.getDescription());\n        op.tags = operation.getTags();\n        op.hasConsumes = false;\n        op.hasProduces = false;\n\n        List<String> consumes = new ArrayList<String>();\n        if (operation.getConsumes() != null) {\n            if (operation.getConsumes().size() > 0) {\n                // use consumes defined in the operation\n                consumes = operation.getConsumes();\n            } else {\n                // empty list, do nothing to override global setting\n            }\n        } else if (swagger != null && swagger.getConsumes() != null && swagger.getConsumes().size() > 0) {\n            // use consumes defined globally\n            consumes = swagger.getConsumes();\n            LOGGER.debug(\"No consumes defined in operation. Using global consumes (\" + swagger.getConsumes() + \") for \" + op.operationId);\n        }\n\n        // if \"consumes\" is defined (per operation or using global definition)\n        if (consumes != null && consumes.size() > 0) {\n            List<Map<String, String>> c = new ArrayList<Map<String, String>>();\n            int count = 0;\n            for (String key : consumes) {\n                Map<String, String> mediaType = new HashMap<String, String>();\n                // escape quotation to avoid code injection\n                mediaType.put(\"mediaType\", escapeText(escapeQuotationMark(key)));\n                count += 1;\n                if (count < consumes.size()) {\n                    mediaType.put(\"hasMore\", \"true\");\n                } else {\n                    mediaType.put(\"hasMore\", null);\n                }\n                c.add(mediaType);\n            }\n            op.consumes = c;\n            op.hasConsumes = true;\n        }\n\n        List<String> produces = new ArrayList<String>();\n        if (operation.getProduces() != null) {\n            if (operation.getProduces().size() > 0) {\n                // use produces defined in the operation\n                produces = operation.getProduces();\n            } else {\n                // empty list, do nothing to override global setting\n            }\n        } else if (swagger != null && swagger.getProduces() != null && swagger.getProduces().size() > 0) {\n            // use produces defined globally\n            produces = swagger.getProduces();\n            LOGGER.debug(\"No produces defined in operation. Using global produces (\" + swagger.getProduces() + \") for \" + op.operationId);\n        }\n\n        // if \"produces\" is defined (per operation or using global definition)\n        if (produces != null && produces.size() > 0) {\n            List<Map<String, String>> c = new ArrayList<Map<String, String>>();\n            int count = 0;\n            for (String key : produces) {\n                Map<String, String> mediaType = new HashMap<String, String>();\n                // escape quotation to avoid code injection\n                mediaType.put(\"mediaType\", escapeText(escapeQuotationMark(key)));\n                count += 1;\n                if (count < produces.size()) {\n                    mediaType.put(\"hasMore\", \"true\");\n                } else {\n                    mediaType.put(\"hasMore\", null);\n                }\n                c.add(mediaType);\n            }\n            op.produces = c;\n            op.hasProduces = true;\n        }\n\n        if (operation.getResponses() != null && !operation.getResponses().isEmpty()) {\n            Response methodResponse = findMethodResponse(operation.getResponses());\n\n            for (Map.Entry<String, Response> entry : operation.getResponses().entrySet()) {\n                Response response = entry.getValue();\n                CodegenResponse r = fromResponse(entry.getKey(), response);\n                r.hasMore = true;\n                if (r.baseType != null &&\n                        !defaultIncludes.contains(r.baseType) &&\n                        !languageSpecificPrimitives.contains(r.baseType)) {\n                    imports.add(r.baseType);\n                }\n                r.isDefault = response == methodResponse;\n                op.responses.add(r);\n                if (r.isBinary && r.isDefault){\n                    op.isResponseBinary = Boolean.TRUE;\n                }\n            }\n            op.responses.get(op.responses.size() - 1).hasMore = false;\n\n            if (methodResponse != null) {\n                if (methodResponse.getSchema() != null) {\n                    CodegenProperty cm = fromProperty(\"response\", methodResponse.getSchema());\n\n                    Property responseProperty = methodResponse.getSchema();\n\n                    if (responseProperty instanceof ArrayProperty) {\n                        ArrayProperty ap = (ArrayProperty) responseProperty;\n                        CodegenProperty innerProperty = fromProperty(\"response\", ap.getItems());\n                        op.returnBaseType = innerProperty.baseType;\n                    } else {\n                        if (cm.complexType != null) {\n                            op.returnBaseType = cm.complexType;\n                        } else {\n                            op.returnBaseType = cm.baseType;\n                        }\n                    }\n                    op.examples = new ExampleGenerator(definitions).generate(methodResponse.getExamples(), operation.getProduces(), responseProperty);\n                    op.defaultResponse = toDefaultValue(responseProperty);\n                    op.returnType = cm.datatype;\n                    op.hasReference = definitions != null && definitions.containsKey(op.returnBaseType);\n\n                    // lookup discriminator\n                    if (definitions != null) {\n                        Model m = definitions.get(op.returnBaseType);\n                        if (m != null) {\n                            CodegenModel cmod = fromModel(op.returnBaseType, m, definitions);\n                            op.discriminator = cmod.discriminator;\n                        }\n                    }\n\n                    if (cm.isContainer != null) {\n                        op.returnContainer = cm.containerType;\n                        if (\"map\".equals(cm.containerType)) {\n                            op.isMapContainer = Boolean.TRUE;\n                        } else if (\"list\".equalsIgnoreCase(cm.containerType)) {\n                            op.isListContainer = Boolean.TRUE;\n                        } else if (\"array\".equalsIgnoreCase(cm.containerType)) {\n                            op.isListContainer = Boolean.TRUE;\n                        }\n                    } else {\n                        op.returnSimpleType = true;\n                    }\n                    if (languageSpecificPrimitives().contains(op.returnBaseType) || op.returnBaseType == null) {\n                        op.returnTypeIsPrimitive = true;\n                    }\n                }\n                addHeaders(methodResponse, op.responseHeaders);\n            }\n        }\n\n        List<Parameter> parameters = operation.getParameters();\n        CodegenParameter bodyParam = null;\n        List<CodegenParameter> allParams = new ArrayList<CodegenParameter>();\n        List<CodegenParameter> bodyParams = new ArrayList<CodegenParameter>();\n        List<CodegenParameter> pathParams = new ArrayList<CodegenParameter>();\n        List<CodegenParameter> queryParams = new ArrayList<CodegenParameter>();\n        List<CodegenParameter> headerParams = new ArrayList<CodegenParameter>();\n        List<CodegenParameter> cookieParams = new ArrayList<CodegenParameter>();\n        List<CodegenParameter> formParams = new ArrayList<CodegenParameter>();\n\n        if (parameters != null) {\n            for (Parameter param : parameters) {\n                CodegenParameter p = fromParameter(param, imports);\n                // rename parameters to make sure all of them have unique names\n                if (ensureUniqueParams) {\n                    while (true) {\n                        boolean exists = false;\n                        for (CodegenParameter cp : allParams) {\n                            if (p.paramName.equals(cp.paramName)) {\n                                exists = true;\n                                break;\n                            }\n                        }\n                        if (exists) {\n                            p.paramName = generateNextName(p.paramName);\n                        } else {\n                            break;\n                        }\n                    }\n                }\n\n                // set isPrimitiveType and baseType for allParams\n                /*if (languageSpecificPrimitives.contains(p.baseType)) {\n                    p.isPrimitiveType = true;\n                    p.baseType = getSwaggerType(p);\n                }*/\n\n\n                allParams.add(p);\n                // Issue #2561 (neilotoole) : Moved setting of is<Type>Param flags\n                // from here to fromParameter().\n                if (param instanceof QueryParameter) {\n                    queryParams.add(p.copy());\n                } else if (param instanceof PathParameter) {\n                    pathParams.add(p.copy());\n                } else if (param instanceof HeaderParameter) {\n                    headerParams.add(p.copy());\n                } else if (param instanceof CookieParameter) {\n                    cookieParams.add(p.copy());\n                } else if (param instanceof BodyParameter) {\n                    bodyParam = p;\n                    bodyParams.add(p.copy());\n                } else if (param instanceof FormParameter) {\n                    formParams.add(p.copy());\n                }\n                if (p.required == null || !p.required) {\n                    op.hasOptionalParams = true;\n                }\n            }\n        }\n        for (String i : imports) {\n            if (needToImport(i)) {\n                op.imports.add(i);\n            }\n        }\n        op.bodyParam = bodyParam;\n        op.httpMethod = httpMethod.toUpperCase();\n\n        // move \"required\" parameters in front of \"optional\" parameters\n        if (sortParamsByRequiredFlag) {\n          Collections.sort(allParams, new Comparator<CodegenParameter>() {\n              @Override\n              public int compare(CodegenParameter one, CodegenParameter another) {\n                  boolean oneRequired = one.required == null ? false : one.required;\n                  boolean anotherRequired = another.required == null ? false : another.required;\n                  if (oneRequired == anotherRequired) return 0;\n                  else if (oneRequired) return -1;\n                  else return 1;\n              }\n          });\n        }\n        op.allParams = addHasMore(allParams);\n        op.bodyParams = addHasMore(bodyParams);\n        op.pathParams = addHasMore(pathParams);\n        op.queryParams = addHasMore(queryParams);\n        op.headerParams = addHasMore(headerParams);\n        // op.cookieParams = cookieParams;\n        op.formParams = addHasMore(formParams);\n        // legacy support\n        op.nickname = op.operationId;\n\n        if (op.allParams.size() > 0) {\n            op.hasParams = true;\n        }\n        op.externalDocs = operation.getExternalDocs();\n\n        // set Restful Flag\n        op.isRestfulShow = op.isRestfulShow();\n        op.isRestfulIndex = op.isRestfulIndex();\n        op.isRestfulCreate = op.isRestfulCreate();\n        op.isRestfulUpdate = op.isRestfulUpdate();\n        op.isRestfulDestroy = op.isRestfulDestroy();\n        op.isRestful = op.isRestful();\n\n        return op;\n    }\n"
  },
  {
    "id": "SeleniumHQ_selenium-559-FirstSentence-0",
    "old_comment_raw": "When initializing the profile, Opera rapidly starts, stops, restarts and stops again; we need to wait a bit to make sure the file lock is really gone.",
    "new_comment_raw": "When initializing the profile, Opera rapidly starts, stops, restarts and stops again; we need to wait a bit to make sure the file lock is really gone.",
    "old_code_raw": "    private boolean makeSureFileLockRemainsGone(File lock, long timeToWait) {\n        for (long start = System.currentTimeMillis(); System.currentTimeMillis() < start + timeToWait;) {\n            AsyncExecute.sleepTight(500);\n            if (lock.exists()) return false;\n        }\n        if (!lock.exists()) return true;\n        return false;\n    }\n",
    "new_code_raw": "    private boolean makeSureFileLockRemainsGone(File lock, long timeToWait) {\n        for (long start = System.currentTimeMillis(); System.currentTimeMillis() < start + timeToWait;) {\n            AsyncExecute.sleepTight(500);\n            if (lock.exists()) return false;\n        }\n        return !lock.exists();\n    }\n"
  },
  {
    "id": "apache_jclouds-358-Associations-FirstSentence",
    "old_comment_raw": "Returns the providers that have at least one common ISO 3166 code and are of the given type.",
    "new_comment_raw": "Returns the providers that have at least one common ISO 3166 code and are of the given contextWrappableAs.",
    "old_code_raw": "   public static Iterable<ProviderMetadata<?, ?, ?, ?>> collocatedWith(ProviderMetadata<?, ?, ?, ?> providerMetadata,\n         ApiType type) {\n      return filter(all(),\n            Predicates.and(ProviderPredicates.intersectingIso3166Code(providerMetadata), ProviderPredicates.type(type)));\n   }\n",
    "new_code_raw": "   public static Iterable<ProviderMetadata> collocatedWith(ProviderMetadata providerMetadata,\n            TypeToken<? extends Wrapper> contextWrappableAs) {\n      return filter(all(), Predicates.and(ProviderPredicates.intersectingIso3166Code(providerMetadata),\n               ProviderPredicates.contextWrappableAs(contextWrappableAs)));\n   }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-799-FirstSentence-0",
    "old_comment_raw": "Get the days field type.",
    "new_comment_raw": "Get the days field type.",
    "old_code_raw": "    public static DurationFieldType days() {\n        return DAYS;\n    }\n",
    "new_code_raw": "    public static DurationFieldType days() {\n        return DAYS_TYPE;\n    }\n"
  },
  {
    "id": "RSB4760_apq8016_packages_apps_Settings-10-Associations-FirstSentence",
    "old_comment_raw": "Creates a  UserAdapter if there is more than one profile on the device.",
    "new_comment_raw": "Creates a  UserSpinnerAdapter if there is more than one profile on the device.",
    "old_code_raw": "    public static UserAdapter createUserSpinnerAdapter(UserManager userManager,\n            Context context) {\n        List<UserHandle> userProfiles = userManager.getUserProfiles();\n        if (userProfiles.size() < 2) {\n            return null;\n        }\n\n        UserHandle myUserHandle = new UserHandle(UserHandle.myUserId());\n        // The first option should be the current profile\n        userProfiles.remove(myUserHandle);\n        userProfiles.add(0, myUserHandle);\n\n        return createUserAdapter(userManager, context, userProfiles);\n    }\n",
    "new_code_raw": "    public static UserSpinnerAdapter createUserSpinnerAdapter(UserManager userManager,\n            Context context) {\n        List<UserHandle> userProfiles = userManager.getUserProfiles();\n        if (userProfiles.size() < 2) {\n            return null;\n        }\n\n        UserHandle myUserHandle = new UserHandle(UserHandle.myUserId());\n        // The first option should be the current profile\n        userProfiles.remove(myUserHandle);\n        userProfiles.add(0, myUserHandle);\n\n        ArrayList<UserDetails> userDetails = new ArrayList<UserDetails>(userProfiles.size());\n        final int count = userProfiles.size();\n        for (int i = 0; i < count; i++) {\n            userDetails.add(new UserDetails(userProfiles.get(i), userManager, context));\n        }\n        return new UserSpinnerAdapter(context, userDetails);\n    }\n\n"
  },
  {
    "id": "SeleniumHQ_selenium-727-FirstSentence-0",
    "old_comment_raw": "An expectation for checking child WebElement as a part of parent element to be visible",
    "new_comment_raw": "An expectation for checking child WebElement as a part of parent element to be visible",
    "old_code_raw": "      public List<WebElement> apply(WebDriver webDriver) {\n        Boolean displayed = false;\n        Boolean exists = false;\n        try {\n          exists =\n            element.findElements(sub_locator).size()\n            > 0; //duplicating search is to avoid dom rebuilding problems\n          displayed = element.findElement(sub_locator).isDisplayed();\n        } catch (Exception e) {/**/}\n        return (exists && displayed) ? element.findElements(sub_locator) : null;\n      }\n",
    "new_code_raw": "      public List<WebElement> apply(WebDriver webDriver) {\n        Boolean displayed = false;\n        Boolean exists = false;\n        try {\n          exists =\n            findElements(sub_locator, webDriver).size() > 0;\n          //duplicating search is to avoid dom rebuilding problems\n          displayed = findElement(sub_locator, webDriver).isDisplayed();\n        } catch (Exception e) {/**/}\n        return (exists && displayed) ? findElements(sub_locator, webDriver) : null;\n      }\n"
  },
  {
    "id": "twitter_commons-34-Associations-FirstSentence",
    "old_comment_raw": "Returns  TwitterTokenStream to tokenize a text.",
    "new_comment_raw": "Returns  TokenStream to tokenize a text.",
    "old_code_raw": "  public TwitterTokenStream getDefaultTokenStream() {\n    return tokenizationStream;\n  }\n",
    "new_code_raw": "  public TokenStream getDefaultTokenStream() {\n    return tokenizationStream;\n  }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2156-FirstSentence-0",
    "old_comment_raw": "Find pet by ID",
    "new_comment_raw": "Find pet by ID",
    "old_code_raw": "    public Mono<Pet> getPetById(Long petId) throws RestClientException {\n        Object postBody = null;\n        \n        // verify the required parameter 'petId' is set\n        if (petId == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling getPetById\");\n        }\n        \n        // create path and map variables\n        final Map<String, Object> uriVariables = new HashMap<String, Object>();\n        uriVariables.put(\"petId\", petId);\n        String path = UriComponentsBuilder.fromPath(\"/pet/{petId}\").buildAndExpand(uriVariables).toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application/xml\", \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"api_key\" };\n\n        ParameterizedTypeReference<Pet> returnType = new ParameterizedTypeReference<Pet>() {};\n        return apiClient.invokeAPI(path, HttpMethod.GET, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "new_code_raw": "    public Mono<Pet> getPetById(Long petId) throws RestClientException {\n        Object postBody = null;\n        \n        // verify the required parameter 'petId' is set\n        if (petId == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling getPetById\");\n        }\n        \n        // create path and map variables\n        final Map<String, Object> uriVariables = new HashMap<String, Object>();\n        uriVariables.put(\"petId\", petId);\n        String path = UriComponentsBuilder.fromPath(\"/pet/{petId}\").buildAndExpand(uriVariables).toUriString();\n\n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application/xml\", \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"api_key\" };\n\n        ParameterizedTypeReference<Pet> returnType = new ParameterizedTypeReference<Pet>() {};\n        return apiClient.invokeAPI(path, HttpMethod.GET, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType);\n    }\n"
  },
  {
    "id": "apache_sentry-47-Associations-FirstSentence",
    "old_comment_raw": "Gets sentry role objects for a given groupName from the persistence layer",
    "new_comment_raw": "Return set of roles corresponding to the groups provided.",
    "old_code_raw": "  public Set<TSentryRole> getTSentryRolesByGroupName(Set<String> groupNames,\n      boolean checkAllGroups) throws Exception {\n    Set<MSentryRole> roleSet = Sets.newHashSet();\n    for (String groupName : groupNames) {\n      try {\n        roleSet.addAll(getMSentryRolesByGroupName(groupName));\n      } catch (SentryNoSuchObjectException e) {\n        // if we are checking for all the given groups, then continue searching\n        if (!checkAllGroups) {\n          throw e;\n        }\n      }\n    }\n    return convertToTSentryRoles(roleSet);\n  }\n",
    "new_code_raw": "  public Set<TSentryRole> getTSentryRolesByGroupName(final Set<String> groupNames,\n                                                     final boolean checkAllGroups) throws Exception {\n    if (groupNames.isEmpty()) {\n      return Collections.emptySet();\n    }\n\n    return tm.executeTransaction(\n            new TransactionBlock<Set<TSentryRole>>() {\n              @Override\n              public Set<TSentryRole> execute(PersistenceManager pm) throws Exception {\n\n                pm.setDetachAllOnCommit(false); // No need to detach objects\n\n                // Pre-allocate large sets for role names and results.\n                // roleNames is used to avoid adding the same role mutiple times into\n                // result. The result is set, but comparisons between TSentryRole objects\n                // is more expensive then String comparisons.\n                Set<String> roleNames = new HashSet<>(1024);\n                Set<TSentryRole> result = new HashSet<>(1024);\n\n                for(String group: groupNames) {\n                  if (group == null) {\n                    // Special case - return all roles\n                    List<MSentryRole> roles = getAllRoles(pm);\n                    for (MSentryRole role: roles) {\n                      result.add(convertToTSentryRole(role));\n                    }\n                    return result;\n                  }\n\n                  // Find group by name and all roles belonging to this group\n                  String trimmedGroup = group.trim();\n                  Query query = pm.newQuery(MSentryGroup.class);\n                  query.setFilter(\"this.groupName == :groupName\");\n                  query.setUnique(true);\n                  MSentryGroup mGroup = (MSentryGroup) query.execute(trimmedGroup);\n                  if (mGroup != null) {\n                    // For each unique role found, add a new TSentryRole version of the role to result.\n                    for (MSentryRole role: mGroup.getRoles()) {\n                      String roleName = role.getRoleName();\n                      if (roleNames.add(roleName)) {\n                        result.add(convertToTSentryRole(role));\n                      }\n                    }\n                  } else if (!checkAllGroups) {\n                      throw noSuchGroup(trimmedGroup);\n                  }\n                  query.closeAll();\n                }\n                return result;\n              }\n            });\n  }\n\n"
  },
  {
    "id": "apache_calcite-582-FirstSentence-0",
    "old_comment_raw": "Boxes a type, if it is primitive, and returns the type name.",
    "new_comment_raw": "Boxes a type, if it is primitive, and returns the type name.",
    "old_code_raw": "    static String boxClassName(Type type) {\n        if (!(type instanceof Class)) {\n            return type.toString();\n        }\n        Class clazz = (Class) type;\n        if (clazz.isPrimitive()) {\n            return PRIMITIVES.get(clazz).getSimpleName();\n        } else {\n            return className(clazz);\n        }\n    }\n",
    "new_code_raw": "    static String boxClassName(Type type) {\n        if (!(type instanceof Class)) {\n            return type.toString();\n        }\n        Primitive primitive = Primitive.of(type);\n        if (primitive != null) {\n            return primitive.boxClass.getSimpleName();\n        } else {\n            return className(type);\n        }\n    }\n"
  },
  {
    "id": "apache_drill-1506-FirstSentence-0",
    "old_comment_raw": "Create DrillFileSystem for given proxyUserName, configuration and stats.",
    "new_comment_raw": "Create DrillFileSystem for given proxyUserName and configuration.",
    "old_code_raw": "  public static DrillFileSystem createFileSystem(String proxyUserName, Configuration fsConf, OperatorStats stats) {\n    return createFileSystem(createProxyUgi(proxyUserName), fsConf, stats);\n  }\n",
    "new_code_raw": "  public static DrillFileSystem createFileSystem(String proxyUserName, Configuration fsConf) {\n    return createFileSystem(createProxyUgi(proxyUserName), fsConf, null);\n  }\n"
  },
  {
    "id": "querydsl_querydsl-496-FirstSentence-0",
    "old_comment_raw": "Get a this == right expression",
    "new_comment_raw": "Get a this == right expression",
    "old_code_raw": "    public BooleanExpression eq(Expression<? super T> right) {\n        if (primitive) {\n            return BooleanOperation.create(Ops.EQ_PRIMITIVE, this, right);\n        } else {\n            return BooleanOperation.create(Ops.EQ_OBJECT, this, right);\n        }\n    }\n",
    "new_code_raw": "    public BooleanExpression eq(Expression<? super T> right) {\n        return BooleanOperation.create(Ops.EQ, this, right);\n    }\n"
  },
  {
    "id": "mukteshkrmishra_javasimon-58-Associations-FirstSentence",
    "old_comment_raw": "Returns collection containing all existing Simons matching the pattern (can be  null).",
    "new_comment_raw": "Returns collection containing all existing Simons accepted by specified  SimonFilter.",
    "old_code_raw": "\tpublic static Collection<Simon> getSimons(SimonPattern pattern) {\n\t\treturn manager.getSimons(pattern);\n\t}\n",
    "new_code_raw": "\tpublic static Collection<Simon> getSimons(SimonFilter simonFilter) {\n\t\treturn manager.getSimons(simonFilter);\n\t}\n\n"
  },
  {
    "id": "apache_activemq-42-FirstSentence-0",
    "old_comment_raw": "Creates a QueueReceiver object to receive messages from the specified queue using a message selector.",
    "new_comment_raw": "Creates a QueueReceiver object to receive messages from the specified queue using a message selector.",
    "old_code_raw": "    public QueueReceiver createReceiver(Queue queue, String messageSelector) throws JMSException {\n        checkClosed();\n        return new ActiveMQQueueReceiver(this, getNextConsumerId(), ActiveMQMessageTransformation\n                .transformDestination(queue), messageSelector, this.connection.getPrefetchPolicy().getQueuePrefetch(), asyncDispatch);\n    }\n",
    "new_code_raw": "    public QueueReceiver createReceiver(Queue queue, String messageSelector) throws JMSException {\n        checkClosed();\n        ActiveMQPrefetchPolicy prefetchPolicy = this.connection.getPrefetchPolicy();\n        return new ActiveMQQueueReceiver(this, getNextConsumerId(), ActiveMQMessageTransformation\n                .transformDestination(queue), messageSelector, prefetchPolicy.getQueuePrefetch(), \n                prefetchPolicy.getMaximumPendingMessageLimit(), asyncDispatch);\n    }\n"
  },
  {
    "id": "jenkinsci_scm-api-plugin-4-Associations-FirstSentence",
    "old_comment_raw": "Looks up a specific revision based on some SCM-specific set of permissible syntaxes.",
    "new_comment_raw": "Looks up a specific thingName based on some SCM-specific set of permissible syntaxes.",
    "old_code_raw": "    @CheckForNull\n    public final SCMRevision fetch(@NonNull String revision, @CheckForNull TaskListener listener)\n            throws IOException, InterruptedException {\n        return retrieve(revision, defaultListener(listener));\n    }\n",
    "new_code_raw": "    @CheckForNull\n    public final SCMRevision fetch(@NonNull String thingName, @CheckForNull TaskListener listener)\n            throws IOException, InterruptedException {\n        return retrieve(thingName, defaultListener(listener));\n    }\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2100-FirstSentence-0",
    "old_comment_raw": "A little utility function to make sure a SemanticGraph is a tree.",
    "new_comment_raw": "A little utility function to make sure a SemanticGraph is a tree.",
    "old_code_raw": "  public static boolean isTree(SemanticGraph tree) {\n    for (IndexedWord vertex : tree.vertexSet()) {\n      if (tree.getRoots().contains(vertex)) {\n        if (tree.incomingEdgeIterator(vertex).hasNext()) {\n          return false;\n        }\n      } else {\n        Iterator<SemanticGraphEdge> iter = tree.incomingEdgeIterator(vertex);\n        if (!iter.hasNext()) {\n          return false;\n        }\n        iter.next();\n        if (iter.hasNext()) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n",
    "new_code_raw": "  public static boolean isTree(SemanticGraph tree) {\n    for (IndexedWord vertex : tree.vertexSet()) {\n      // Check one and only one incoming edge\n      if (tree.getRoots().contains(vertex)) {\n        if (tree.incomingEdgeIterator(vertex).hasNext()) {\n          return false;\n        }\n      } else {\n        Iterator<SemanticGraphEdge> iter = tree.incomingEdgeIterator(vertex);\n        if (!iter.hasNext()) {\n          return false;\n        }\n        iter.next();\n        if (iter.hasNext()) {\n          return false;\n        }\n      }\n      // Check incoming and outgoing edges match\n      for (SemanticGraphEdge edge : tree.outgoingEdgeIterable(vertex)) {\n        boolean foundReverse = false;\n        for (SemanticGraphEdge reverse : tree.incomingEdgeIterable(edge.getDependent())) {\n          if (reverse == edge) { foundReverse = true; }\n        }\n        if (!foundReverse) {\n          return false;\n        }\n      }\n      for (SemanticGraphEdge edge : tree.incomingEdgeIterable(vertex)) {\n        boolean foundReverse = false;\n        for (SemanticGraphEdge reverse : tree.outgoingEdgeIterable(edge.getGovernor())) {\n          if (reverse == edge) { foundReverse = true; }\n        }\n        if (!foundReverse) {\n          return false;\n        }\n      }\n    }\n    // Check topological sort -- sometimes fails?\n//    try {\n//      tree.topologicalSort();\n//    } catch (Exception e) {\n//      e.printStackTrace();\n//      return false;\n//    }\n    return true;\n  }\n"
  },
  {
    "id": "Atmosphere_atmosphere-861-FirstSentence-0",
    "old_comment_raw": "Invoke the proprietary  CometSupport",
    "new_comment_raw": "Invoke the proprietary  AsyncSupport",
    "old_code_raw": "    public Action doCometSupport(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException {\n        req.setAttribute(BROADCASTER_FACTORY, broadcasterFactory);\n        req.setAttribute(PROPERTY_USE_STREAM, useStreamForFlushingComments);\n        req.setAttribute(BROADCASTER_CLASS, broadcasterClassName);\n        req.setAttribute(ATMOSPHERE_CONFIG, config);\n\n        Action a = null;\n        try {\n            if ((config.getInitParameter(ALLOW_QUERYSTRING_AS_REQUEST) != null\n                    || (isIECandidate(req) || req.getParameter(HeaderConfig.JSONP_CALLBACK_NAME) != null))\n                    && req.getAttribute(WebSocket.WEBSOCKET_SUSPEND) == null) {\n\n                Map<String, String> headers = configureQueryStringAsRequest(req);\n                String body = headers.remove(ATMOSPHERE_POST_BODY);\n                if (body != null && body.isEmpty()) {\n                    body = null;\n                }\n\n                req.headers(headers)\n                   .method(body != null && req.getMethod().equalsIgnoreCase(\"GET\") ? \"POST\" : req.getMethod());\n\n                if (body != null) {\n                   req.body(body);\n                }\n\n                a = cometSupport.service(req, res);\n            } else {\n                return cometSupport.service(req, res);\n            }\n        } catch (IllegalStateException ex) {\n            if (ex.getMessage() != null && (ex.getMessage().startsWith(\"Tomcat failed\") || ex.getMessage().startsWith(\"JBoss failed\") )) {\n                if (!isFilter) {\n                    logger.warn(\"Failed using comet support: {}, error: {} Is the Nio or Apr Connector enabled?\", cometSupport.getClass().getName(),\n                            ex.getMessage());\n                    logger.warn(\"Using BlockingIOCometSupport.\");\n                }\n                logger.trace(ex.getMessage(), ex);\n\n                cometSupport = new BlockingIOCometSupport(config);\n                doCometSupport(req, res);\n            } else {\n                logger.error(\"AtmosphereServlet exception\", ex);\n                throw ex;\n            }\n        } finally {\n            if (req != null && a != null && a.type != Action.TYPE.SUSPEND) {\n                req.destroy();\n                res.destroy();\n            }\n        }\n        return null;\n    }\n",
    "new_code_raw": "    public Action doCometSupport(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException {\n        req.setAttribute(BROADCASTER_FACTORY, broadcasterFactory);\n        req.setAttribute(PROPERTY_USE_STREAM, useStreamForFlushingComments);\n        req.setAttribute(BROADCASTER_CLASS, broadcasterClassName);\n        req.setAttribute(ATMOSPHERE_CONFIG, config);\n\n        Action a = null;\n        try {\n            if ((config.getInitParameter(ALLOW_QUERYSTRING_AS_REQUEST) != null\n                    || (isIECandidate(req) || req.getParameter(HeaderConfig.JSONP_CALLBACK_NAME) != null))\n                    && req.getAttribute(WebSocket.WEBSOCKET_SUSPEND) == null) {\n\n                Map<String, String> headers = configureQueryStringAsRequest(req);\n                String body = headers.remove(ATMOSPHERE_POST_BODY);\n                if (body != null && body.isEmpty()) {\n                    body = null;\n                }\n\n                req.headers(headers)\n                   .method(body != null && req.getMethod().equalsIgnoreCase(\"GET\") ? \"POST\" : req.getMethod());\n\n                if (body != null) {\n                   req.body(body);\n                }\n\n                a = asyncSupport.service(req, res);\n            } else {\n                return asyncSupport.service(req, res);\n            }\n        } catch (IllegalStateException ex) {\n            if (ex.getMessage() != null && (ex.getMessage().startsWith(\"Tomcat failed\") || ex.getMessage().startsWith(\"JBoss failed\") )) {\n                if (!isFilter) {\n                    logger.warn(\"Failed using comet support: {}, error: {} Is the Nio or Apr Connector enabled?\", asyncSupport.getClass().getName(),\n                            ex.getMessage());\n                    logger.warn(\"Using BlockingIOCometSupport.\");\n                }\n                logger.trace(ex.getMessage(), ex);\n\n                asyncSupport = new BlockingIOCometSupport(config);\n                doCometSupport(req, res);\n            } else {\n                logger.error(\"AtmosphereServlet exception\", ex);\n                throw ex;\n            }\n        } finally {\n            if (req != null && a != null && a.type != Action.TYPE.SUSPEND) {\n                req.destroy();\n                res.destroy();\n            }\n        }\n        return null;\n    }\n"
  },
  {
    "id": "debezium_debezium-769-FirstSentence-0",
    "old_comment_raw": "Obtain a new  Builder instance that can be used to construct runnable  EmbeddedConnector instances.",
    "new_comment_raw": "Obtain a new  Builder instance that can be used to construct runnable  EmbeddedConnector instances.",
    "old_code_raw": "    public static Builder create() {\n        return new Builder() {\n            private Configuration config;\n            private OffsetBackingStore offsetStore;\n            private OffsetCommitPolicy offsetCommitPolicy;\n            private Consumer<SourceRecord> consumer;\n            private ClassLoader classLoader;\n            private Clock clock;\n\n            @Override\n            public Builder using(Configuration config) {\n                this.config = config;\n                return this;\n            }\n\n            @Override\n            public Builder using(OffsetBackingStore offsetStore) {\n                this.offsetStore = offsetStore;\n                return this;\n            }\n\n            @Override\n            public Builder using(OffsetCommitPolicy policy) {\n                this.offsetCommitPolicy = policy;\n                return this;\n            }\n\n            @Override\n            public Builder using(ClassLoader classLoader) {\n                this.classLoader = classLoader;\n                return this;\n            }\n\n            @Override\n            public Builder using(Clock clock) {\n                this.clock = clock;\n                return this;\n            }\n\n            @Override\n            public Builder notifying(Consumer<SourceRecord> consumer) {\n                this.consumer = consumer;\n                return this;\n            }\n\n            @Override\n            public EmbeddedConnector build() {\n                if (offsetStore == null) offsetStore = new MemoryOffsetBackingStore();\n                if (offsetCommitPolicy == null) offsetCommitPolicy = OffsetCommitPolicy.always();\n                if (classLoader == null) classLoader = getClass().getClassLoader();\n                if (clock == null) clock = Clock.system();\n                Objects.requireNonNull(config, \"A connector configuration must be specified.\");\n                Objects.requireNonNull(consumer, \"A connector consumer must be specified.\");\n                return new EmbeddedConnector(config, offsetStore, offsetCommitPolicy, classLoader, clock, consumer);\n            }\n\n        };\n    }\n",
    "new_code_raw": "    public static Builder create() {\n        return new Builder() {\n            private Configuration config;\n            private Consumer<SourceRecord> consumer;\n            private ClassLoader classLoader;\n            private Clock clock;\n\n            @Override\n            public Builder using(Configuration config) {\n                this.config = config;\n                return this;\n            }\n\n            @Override\n            public Builder using(ClassLoader classLoader) {\n                this.classLoader = classLoader;\n                return this;\n            }\n\n            @Override\n            public Builder using(Clock clock) {\n                this.clock = clock;\n                return this;\n            }\n\n            @Override\n            public Builder notifying(Consumer<SourceRecord> consumer) {\n                this.consumer = consumer;\n                return this;\n            }\n\n            @Override\n            public EmbeddedConnector build() {\n                if (classLoader == null) classLoader = getClass().getClassLoader();\n                if (clock == null) clock = Clock.system();\n                Objects.requireNonNull(config, \"A connector configuration must be specified.\");\n                Objects.requireNonNull(consumer, \"A connector consumer must be specified.\");\n                return new EmbeddedConnector(config, classLoader, clock, consumer);\n            }\n\n        };\n    }\n"
  },
  {
    "id": "apache_tuscany-sca-1.x-56-Associations-FirstSentence",
    "old_comment_raw": "Returns the ScopeContext for the MODULE scope that will be associated with this deployment unit.",
    "new_comment_raw": "Returns the ScopeContainer for the MODULE scope that will be associated with this deployment unit.",
    "old_code_raw": "    public ScopeContext getModuleScope() {\n        return moduleScope;\n    }\n",
    "new_code_raw": "    public ScopeContainer getModuleScope() {\n        return moduleScope;\n    }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-791-FirstSentence-0",
    "old_comment_raw": "Get the year of century field type.",
    "new_comment_raw": "Get the year of century field type.",
    "old_code_raw": "    public static DateTimeFieldType yearOfCentury() {\n        return YEAR_OF_CENTURY;\n    }\n",
    "new_code_raw": "    public static DateTimeFieldType yearOfCentury() {\n        return YEAR_OF_CENTURY_TYPE;\n    }\n"
  },
  {
    "id": "apache_drill-1531-FirstSentence-0",
    "old_comment_raw": "Expects principal of the format primary/instance@REALM.",
    "new_comment_raw": "Expects principal of the format primary/instance@REALM or primary@REALM.",
    "old_code_raw": "  public static String[] splitPrincipalIntoParts(final String principal) {\n    final String[] components = principal.split(\"[/@]\");\n    checkState(components.length == 3);\n    checkNotNull(components[0]);\n    checkNotNull(components[1]);\n    checkNotNull(components[2]);\n    return components;\n  }\n",
    "new_code_raw": "  public static String[] splitPrincipalIntoParts(final String principal) {\n    final String[] components = principal.split(\"[/@]\");\n    checkState(components.length < 4);\n    checkState(components.length > 1);\n    checkNotNull(components[0]);\n    checkNotNull(components[1]);\n\n    if (components.length == 2) {\n      return new String[] { components[0], \"\", components[1] };\n    } else {\n      checkNotNull(components[2]);\n      return components;\n    }\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-659-FirstSentence-0",
    "old_comment_raw": "Returns a DurationField representing seconds.",
    "new_comment_raw": "Returns a DurationField representing seconds.",
    "old_code_raw": "    public DurationField seconds() {\n        return UnsupportedDurationField.INSTANCE;\n    }\n",
    "new_code_raw": "    public DurationField seconds() {\n        return UnsupportedDurationField.getInstance(\"seconds\");\n    }\n"
  },
  {
    "id": "rstudio_rstudio-132-FirstSentence-0",
    "old_comment_raw": "Given a URL, attempt to infer and return the hostname from the URL.",
    "new_comment_raw": "Given a URL, attempt to return the host portion (not including the port).",
    "old_code_raw": "   public static String getHostFromUrl(String url)\n   {\n      // no work to do\n      if (url.indexOf('/') == -1)\n         return url;\n      \n      // presume no protocol; if present, skip those slashes\n      int slashes = 0;\n      if (url.contains(\"://\"))\n         slashes += 2;\n      \n      // split on slashes and return first component\n      String[] parts = url.split(\"/\");\n      if (parts.length < slashes)\n         return url;\n      return parts[slashes];\n   }\n",
    "new_code_raw": "   public static String getHostFromUrl(String url)\n   {\n      String authority = getAuthorityFromUrl(url);\n      \n      // no port\n      int idx = authority.indexOf(\":\");\n      if (idx == -1)\n         return authority;\n      \n      // port, return only the portion preceding the port\n      return authority.substring(0, idx);\n   }\n"
  },
  {
    "id": "JodaOrg_joda_time-786-FirstSentence-0",
    "old_comment_raw": "Get the year of a week based year field type.",
    "new_comment_raw": "Get the year of a week based year field type.",
    "old_code_raw": "    public static DateTimeFieldType weekyear() {\n        return WEEKYEAR;\n    }\n",
    "new_code_raw": "    public static DateTimeFieldType weekyear() {\n        return WEEKYEAR_TYPE;\n    }\n"
  },
  {
    "id": "Omegaphora_dalvik-1410-Associations-FirstSentence",
    "old_comment_raw": "Helper method to return the constant string for a  CstInsn in human form.",
    "new_comment_raw": "Helper method to return a constant string.",
    "old_code_raw": "    protected static String cstString(DalvInsn insn) {\n        CstInsn ci = (CstInsn) insn;\n        Constant cst = ci.getConstant();\n\n        return cst instanceof CstString ? ((CstString) cst).toQuoted() : cst.toHuman();\n    }\n",
    "new_code_raw": "    protected static String cstString(DalvInsn insn) {\n        CstInsn ci = (CstInsn) insn;\n        Constant cst = ci.getConstant();\n\n        return cst.toHuman();\n    }\n\n"
  },
  {
    "id": "pedrovgs_EffectiveAndroidUI-1-FirstSentence-0",
    "old_comment_raw": "We should return a full clone of TvShow objects inside catalog because all this data is in memory and anyone can change it if we don't return only copies, but this is just a sample!",
    "new_comment_raw": "We should return a full clone of TvShow objects inside catalog because all this data is in memory and anyone can change it if we don't return only copies, but this is just a sample!",
    "old_code_raw": "  public Collection<TvShow> getTvShows() {\n    return (Set<TvShow>) tvShows.clone();\n  }\n",
    "new_code_raw": "  public Collection<TvShow> getTvShows() {\n    return (Set<TvShow>) ((LinkedHashSet<TvShow>) tvShows).clone();\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-493-FirstSentence-0",
    "old_comment_raw": "Does this time interval contain or equal the specified time interval.",
    "new_comment_raw": "Does this time interval contain the specified time interval.",
    "old_code_raw": "    public boolean contains(ReadableInterval interval) {\n        if (interval == null) {\n            return containsNow();\n        }\n        long otherStart = interval.getStartMillis();\n        long otherEnd = interval.getEndMillis();\n        long thisStart = getStartMillis();\n        long thisEnd = getEndMillis();\n        return (thisStart <= otherStart && otherStart < thisEnd && otherEnd <= thisEnd) ||\n            (thisStart == otherStart && thisEnd == otherEnd);\n    }\n",
    "new_code_raw": "    public boolean contains(ReadableInterval interval) {\n        if (interval == null) {\n            return containsNow();\n        }\n        long otherStart = interval.getStartMillis();\n        long otherEnd = interval.getEndMillis();\n        long thisStart = getStartMillis();\n        long thisEnd = getEndMillis();\n        return (thisStart <= otherStart && otherStart < thisEnd && otherEnd <= thisEnd);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1973-FirstSentence-0",
    "old_comment_raw": "Escapes a reserved word as defined in the `reservedWords` array.",
    "new_comment_raw": "Escapes a reserved word as defined in the `reservedWords` array.",
    "old_code_raw": "    public String escapeReservedWord(String name) {\n        // Can't start with an underscore, as our fields need to start with an\n        // UppercaseLetter so that Go treats them as public/visible.\n\n        // Options?\n        // - MyName\n        // - AName\n        // - TheName\n        // - XName\n        // - X_Name\n        // ... or maybe a suffix?\n        // - Name_ ... think this will work.\n        if (this.reservedWordsMappings().containsKey(name)) {\n            return this.reservedWordsMappings().get(name);\n        }\n        return camelize(name) + '_';\n    }\n",
    "new_code_raw": "    public String escapeReservedWord(String name) {\n        // Can't start with an underscore, as our fields need to start with an\n        // UppercaseLetter so that Go treats them as public/visible.\n\n        // Options?\n        // - MyName\n        // - AName\n        // - TheName\n        // - XName\n        // - X_Name\n        // ... or maybe a suffix?\n        // - Name_ ... think this will work.\n        if (this.reservedWordsMappings().containsKey(name)) {\n            return this.reservedWordsMappings().get(name);\n        }\n        return org.openapitools.codegen.utils.StringUtils.camelize(name) + '_';\n    }\n"
  },
  {
    "id": "apache_tomee-64-Associations-FirstSentence",
    "old_comment_raw": "Gets an integer value of the request method.",
    "new_comment_raw": "Gets the request method.",
    "old_code_raw": "    public int getMethod() {\n        return method;\n    }\n",
    "new_code_raw": "    public Method getMethod() {\n        return method;\n    }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-916-FirstSentence-0",
    "old_comment_raw": "Converts an old style id to a new style id.",
    "new_comment_raw": "Converts an old style id to a new style id.",
    "old_code_raw": "    private static int parseOffset(String str) {\n        Chronology chrono;\n        if (cDefault != null) {\n            chrono = ISOChronology.getInstanceUTC();\n        } else {\n            // Can't use a real chronology if called during class\n            // initialization. Offset parser doesn't need it anyhow.\n            chrono = new BaseChronology() {\n                public DateTimeZone getZone() {\n                    return null;\n                }\n                public Chronology withUTC() {\n                    return this;\n                }\n                public Chronology withZone(DateTimeZone zone) {\n                    return this;\n                }\n                public String toString() {\n                    return getClass().getName();\n                }\n            };\n        }\n\n        return -(int) offsetFormatter().parseMillis(str, chrono);\n    }\n",
    "new_code_raw": "    private static int parseOffset(String str) {\n        Chronology chrono;\n        if (cDefault != null) {\n            chrono = ISOChronology.getInstanceUTC();\n        } else {\n            // Can't use a real chronology if called during class\n            // initialization. Offset parser doesn't need it anyhow.\n            chrono = new BaseChronology() {\n                public DateTimeZone getZone() {\n                    return null;\n                }\n                public Chronology withUTC() {\n                    return this;\n                }\n                public Chronology withZone(DateTimeZone zone) {\n                    return this;\n                }\n                public String toString() {\n                    return getClass().getName();\n                }\n            };\n        }\n\n        return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);\n    }\n"
  },
  {
    "id": "debezium_debezium-9-FirstSentence-0",
    "old_comment_raw": "Create and return a new Field instance that that is a copy of this field but that uses the supplied predicate during  Field#validate(Configuration, Consumer).",
    "new_comment_raw": "Create and return a new Field instance that is a copy of this field but that in addition to  #validator() existing validation the supplied validation function(s) are also used.",
    "old_code_raw": "    public Field withValidation(Predicate<String>... predicates) {\n        return new Field(name(), description(), defaultValueGenerator, (config, field, problems) -> {\n            String value = config.getString(field);\n            for (Predicate<String> predicate : predicates) {\n                if (predicate != null) {\n                    try {\n                        if (!predicate.test(value)) {\n                            problems.accept(\"The \" + field.name() + \" value '\" + value + \"' is not valid\");\n                            return 1;\n                        }\n                    } catch (Throwable t) {\n                        problems.accept(\"The \" + field.name() + \" value '\" + value + \"' is not allowed: \" + t.getMessage());\n                        return 1;\n                    }\n                }\n            }\n            return 0;\n        });\n    }\n",
    "new_code_raw": "    public Field withValidation(Validator... validators) {\n        Validator actualValidator = validator;\n        for (Validator validator : validators) {\n            if (validator != null) actualValidator = validator.and(actualValidator);\n        }\n        return new Field(name(), displayName(), type(), width(), description(), importance(), dependents,\n                defaultValueGenerator, actualValidator, recommender);\n    }\n"
  },
  {
    "id": "apache_drill-1117-FirstSentence-0",
    "old_comment_raw": "Checks if this function replacement is needed.",
    "new_comment_raw": "Checks if this function replacement is needed.",
    "old_code_raw": "  private String functionReplacement(FunctionCall functionCall) {\n    String funcName = functionCall.getName();\n      if (functionCall.args.size() > 0) {\n          MajorType majorType =  functionCall.args.get(0).getMajorType();\n          DataMode dataMode = majorType.getMode();\n          MinorType minorType = majorType.getMinorType();\n          if (optionManager != null\n              && optionManager.getOption(ExecConstants.CAST_TO_NULLABLE_NUMERIC).bool_val\n              && CastFunctions.isReplacementNeeded(funcName, minorType)) {\n              funcName = CastFunctions.getReplacingCastFunction(funcName, dataMode, minorType);\n          }\n      }\n\n    return funcName;\n  }\n",
    "new_code_raw": "  private String functionReplacement(FunctionCall functionCall) {\n    String funcName = functionCall.getName();\n    if (functionCall.args.size() == 0) {\n      return funcName;\n    }\n    boolean castToNullableNumeric = optionManager != null &&\n                  optionManager.getOption(ExecConstants.CAST_TO_NULLABLE_NUMERIC_OPTION);\n    if (! castToNullableNumeric) {\n      return funcName;\n    }\n    MajorType majorType =  functionCall.args.get(0).getMajorType();\n    DataMode dataMode = majorType.getMode();\n    MinorType minorType = majorType.getMinorType();\n    if (CastFunctions.isReplacementNeeded(funcName, minorType)) {\n        funcName = CastFunctions.getReplacingCastFunction(funcName, dataMode, minorType);\n    }\n\n    return funcName;\n  }\n"
  },
  {
    "id": "apache_lenya-334-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Get the column position",
    "old_code_raw": "    public final int getEndColumn() {\n        return bufcolumn[bufpos];\n    }\n",
    "new_code_raw": "    public final int getEndColumn() {\n        return this.bufcolumn[this.bufpos];\n    }\n\n"
  },
  {
    "id": "debezium_debezium-891-FirstSentence-0",
    "old_comment_raw": "Converts a value object for an expected JDBC type of  Types#INTEGER.",
    "new_comment_raw": "Converts a value object for an expected JDBC type of  Types#INTEGER.",
    "old_code_raw": "    protected Object convertBigInt(Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0L;\n        }\n        if (data instanceof Long) return data;\n        if (data instanceof Number) {\n            Number value = (Number) data;\n            return new Long(value.longValue());\n        }\n        if (data instanceof Boolean) {\n            return NumberConversions.getLong((Boolean) data);\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n",
    "new_code_raw": "    protected Object convertBigInt(Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0L;\n        }\n        if (data instanceof Long) return data;\n        if (data instanceof Number) {\n            Number value = (Number) data;\n            return Long.valueOf(value.longValue());\n        }\n        if (data instanceof Boolean) {\n            return NumberConversions.getLong((Boolean) data);\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n"
  },
  {
    "id": "nelsonsilva_vaadin-180-Associations-FirstSentence",
    "old_comment_raw": "Tests if the editor is in word-wrap mode.",
    "new_comment_raw": "Tests if the text area is in word-wrap mode.",
    "old_code_raw": "    @Override\n    public boolean isWordwrap() {\n        // TODO implement here once the API from TextField is removed\n        return super.isWordwrap();\n    }\n",
    "new_code_raw": "    public boolean isWordwrap() {\n        return wordwrap;\n    }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-856-FirstSentence-0",
    "old_comment_raw": "Instructs the printer to emit a numeric secondOfDay field.",
    "new_comment_raw": "Instructs the printer to emit a numeric secondOfDay field.",
    "old_code_raw": "    public DateTimeFormatterBuilder appendSecondOfDay(final int minDigits) {\n        return appendDecimal(iChronoUTC.secondOfDay(), minDigits, 5);\n    }\n",
    "new_code_raw": "    public DateTimeFormatterBuilder appendSecondOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.secondOfDay(), minDigits, 5);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2598-FirstSentence-0",
    "old_comment_raw": "If a ApiResponse contains a reference to an other ApiResponse with '$ref', returns the referenced ApiResponse or the actual ApiResponse in the other cases.",
    "new_comment_raw": "If a ApiResponse contains a reference to an other ApiResponse with '$ref', returns the referenced ApiResponse if it is found or the actual ApiResponse in the other cases.",
    "old_code_raw": "    public static ApiResponse getReferencedApiResponse(OpenAPI openAPI, ApiResponse apiResponse) {\n        if (apiResponse != null && StringUtils.isNotEmpty(apiResponse.get$ref())) {\n            String name = getSimpleRef(apiResponse.get$ref());\n            return getApiResponse(openAPI, name);\n        }\n        return apiResponse;\n    }\n",
    "new_code_raw": "    public static ApiResponse getReferencedApiResponse(OpenAPI openAPI, ApiResponse apiResponse) {\n        if (apiResponse != null && StringUtils.isNotEmpty(apiResponse.get$ref())) {\n            String name = getSimpleRef(apiResponse.get$ref());\n            ApiResponse referencedApiResponse = getApiResponse(openAPI, name);\n            if(referencedApiResponse != null) {\n                return referencedApiResponse;\n            }\n        }\n        return apiResponse;\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2557-FirstSentence-0",
    "old_comment_raw": "Logs user into the system",
    "new_comment_raw": "Logs user into the system",
    "old_code_raw": "  public String loginUser(String username, String password) throws ApiException {\n    Object localVarPostBody = null;\n    \n    // create path and map variables\n    String localVarPath = \"/user/login\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n    \n    localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"username\", username));\n    \n    localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"password\", password));\n    \n\n    \n\n    \n\n    final String[] localVarAccepts = {\n      \"application/json\", \"application/xml\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    \n    GenericType<String> localVarReturnType = new GenericType<String>() {};\n    return apiClient.invokeAPI(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n    \n  }\n",
    "new_code_raw": "  public String loginUser(String username, String password) throws ApiException {\n    Object postBody = null;\n    \n    // create path and map variables\n    String path = \"/user/login\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    Map<String, String> headerParams = new HashMap<String, String>();\n    Map<String, Object> formParams = new HashMap<String, Object>();\n\n    \n    queryParams.addAll(apiClient.parameterToPairs(\"\", \"username\", username));\n    \n    queryParams.addAll(apiClient.parameterToPairs(\"\", \"password\", password));\n    \n\n    \n\n    \n\n    final String[] accepts = {\n      \"application/json\", \"application/xml\"\n    };\n    final String accept = apiClient.selectHeaderAccept(accepts);\n\n    final String[] contentTypes = {\n      \n    };\n    final String contentType = apiClient.selectHeaderContentType(contentTypes);\n\n    String[] authNames = new String[] {  };\n\n    \n    GenericType<String> returnType = new GenericType<String>() {};\n    return apiClient.invokeAPI(path, \"GET\", queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    \n  }\n"
  },
  {
    "id": "Graylog2_graylog2-server-25-Associations-FirstSentence",
    "old_comment_raw": "Try to get the primary  java.net.InetAddress of the primary network interface with fallback to the local loopback address (usually  127.0.0.1 or  ::1.",
    "new_comment_raw": "Try to get the primary  InetAddress of the primary network interface with fallback to the local loopback address (usually  127.0.0.1 or  ::1.",
    "old_code_raw": "    public static InetAddress guessPrimaryNetworkAddress() throws SocketException {\n        final Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n\n        if (interfaces != null) {\n            for (NetworkInterface interf : Collections.list(interfaces)) {\n                if (!interf.isLoopback() && interf.isUp()) {\n                    // Interface is not loopback and up. Try to get the first address.\n                    for (InetAddress addr : Collections.list(interf.getInetAddresses())) {\n                        if (addr instanceof Inet4Address) {\n                            return addr;\n                        }\n                    }\n                }\n            }\n        }\n\n        return InetAddress.getLoopbackAddress();\n    }\n",
    "new_code_raw": "    public static InetAddress guessPrimaryNetworkAddress(boolean preferIPv4) throws SocketException {\n        final Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n\n        if (interfaces != null) {\n            for (NetworkInterface interf : Collections.list(interfaces)) {\n                if (!interf.isLoopback() && interf.isUp()) {\n                    // Interface is not loopback and up. Try to get the first address.\n                    for (InetAddress addr : Collections.list(interf.getInetAddresses())) {\n                        if (preferIPv4 && addr instanceof Inet4Address) {\n                            return addr;\n                        }\n                        if (!preferIPv4 && addr instanceof Inet6Address) {\n                            return addr;\n                        }\n                    }\n                }\n            }\n        }\n\n        return InetAddress.getLoopbackAddress();\n    }\n\n"
  },
  {
    "id": "SeleniumHQ_selenium-545-FirstSentence-0",
    "old_comment_raw": "Schedules the specified command to be retrieved by the next call to handle command result, and returns the result of that command.",
    "new_comment_raw": "Schedules the specified command to be retrieved by the next call to handle command result, and returns the result of that command.",
    "old_code_raw": "    public String doCommand(String command, String field, String value) {\n        resultExpected = true;\n        doCommandWithoutWaitingForAResponse(command, field, value);\n        try {\n            return (String) queueGet(\"commandResultHolder\", commandResultHolder);\n        } catch (SeleniumCommandTimedOutException e) {\n            return \"ERROR: Command timed out\";\n        }\n        finally {\n            resultExpected = false;\n        }\n    }\n",
    "new_code_raw": "    public String doCommand(String command, String field, String value) {\n        resultExpected = true;\n        doCommandWithoutWaitingForAResponse(command, field, value);\n        try {\n            return queueGetResult(\"doCommand\");\n        }\n        finally {\n            resultExpected = false;\n        }\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-452-FirstSentence-0",
    "old_comment_raw": "Removes a converter from the set of converters, by index.",
    "new_comment_raw": "Removes a converter from the set of converters.",
    "old_code_raw": "    public DurationConverter removeDurationConverter(int index) throws SecurityException {\n        checkAlterDurationConverters();\n        DurationConverter[] removed = new DurationConverter[1];\n        iDurationConverters = iDurationConverters.remove(index, removed);\n        return removed[0];\n    }\n",
    "new_code_raw": "    public DurationConverter removeDurationConverter(DurationConverter converter)\n            throws SecurityException {\n        \n        checkAlterDurationConverters();\n        if (converter == null) {\n            return null;\n        }\n        DurationConverter[] removed = new DurationConverter[1];\n        iDurationConverters = iDurationConverters.remove(converter, removed);\n        return removed[0];\n    }\n"
  },
  {
    "id": "processing_processing-214-FirstSentence-0",
    "old_comment_raw": "Maps offset from java code to pde code.",
    "new_comment_raw": "Maps offset from java code to pde code.",
    "old_code_raw": "  protected int[] JavaToPdeOffsets(int line, int offset) {\n    int codeIndex = 0;\n\n    int x = line - mainClassOffset;\n    if (x < 0) {\n      // log(\"Negative line number \"\n      // + problem.getSourceLineNumber() + \" , offset \"\n      // + mainClassOffset);\n      x = line - 2; // Another -1 for 0 index\n      if (x < programImports.size() && x >= 0) {\n        ImportStatement is = programImports.get(x);\n        // log(is.importName + \", \" + is.tab + \", \"\n        // + is.lineNumber);\n        return new int[] { is.getTab(), is.getLineNumber() };\n      } else {\n\n        // Some seriously ugly stray error, just can't find the source\n        // line! Simply return first line for first tab.\n        return  new int[] { 0, 1 };\n      }\n\n    }\n\n    try {\n      for (SketchCode sc : editor.getSketch().getCode()) {\n        if (sc.isExtension(\"pde\")) {\n          int len;\n          if (editor.getSketch().getCurrentCode().equals(sc)) {\n            len = Util.countLines(sc.getDocumentText()) + 1;\n          } else {\n            len = Util.countLines(sc.getProgram()) + 1;\n          }\n\n          // log(\"x,len, CI: \" + x + \",\" + len + \",\"\n          // + codeIndex);\n\n          if (x >= len) {\n\n            // We're in the last tab and the line count is greater\n            // than the no.\n            // of lines in the tab,\n            if (codeIndex >= editor.getSketch().getCodeCount() - 1) {\n              // log(\"Exceeds lc \" + x + \",\" + len\n              // + problem.toString());\n              // x = len\n              x = editor.getSketch().getCode(codeIndex)\n                  .getLineCount();\n              // TODO: Obtain line having last non-white space\n              // character in the code.\n              break;\n            } else {\n              x -= len;\n              codeIndex++;\n            }\n          } else {\n\n            if (codeIndex >= editor.getSketch().getCodeCount()) {\n              codeIndex = editor.getSketch().getCodeCount() - 1;\n            }\n            break;\n          }\n\n        }\n      }\n    } catch (Exception e) {\n      System.err.println(\"Error inside ErrorCheckerService.JavaToPdeOffset()\");\n      e.printStackTrace();\n    }\n    return new int[] { codeIndex, x };\n  }\n",
    "new_code_raw": "  protected int[] JavaToPdeOffsets(int line, int offset) {\n\n    return new int[] { 0, 0 }; // TODO\n\n    /*\n    int codeIndex = 0;\n\n    int x = line - mainClassOffset;\n    if (x < 0) {\n      // log(\"Negative line number \"\n      // + problem.getSourceLineNumber() + \" , offset \"\n      // + mainClassOffset);\n      x = line - 2; // Another -1 for 0 index\n      if (x < programImports.size() && x >= 0) {\n        ImportStatement is = programImports.get(x);\n        // log(is.importName + \", \" + is.tab + \", \"\n        // + is.lineNumber);\n        return new int[] { 0, 0 }; // TODO\n      } else {\n\n        // Some seriously ugly stray error, just can't find the source\n        // line! Simply return first line for first tab.\n        return  new int[] { 0, 1 };\n      }\n\n    }\n\n    try {\n      for (SketchCode sc : editor.getSketch().getCode()) {\n        if (sc.isExtension(\"pde\")) {\n          int len;\n          if (editor.getSketch().getCurrentCode().equals(sc)) {\n            len = Util.countLines(sc.getDocumentText()) + 1;\n          } else {\n            len = Util.countLines(sc.getProgram()) + 1;\n          }\n\n          // log(\"x,len, CI: \" + x + \",\" + len + \",\"\n          // + codeIndex);\n\n          if (x >= len) {\n\n            // We're in the last tab and the line count is greater\n            // than the no.\n            // of lines in the tab,\n            if (codeIndex >= editor.getSketch().getCodeCount() - 1) {\n              // log(\"Exceeds lc \" + x + \",\" + len\n              // + problem.toString());\n              // x = len\n              x = editor.getSketch().getCode(codeIndex)\n                  .getLineCount();\n              // TODO: Obtain line having last non-white space\n              // character in the code.\n              break;\n            } else {\n              x -= len;\n              codeIndex++;\n            }\n          } else {\n\n            if (codeIndex >= editor.getSketch().getCodeCount()) {\n              codeIndex = editor.getSketch().getCodeCount() - 1;\n            }\n            break;\n          }\n\n        }\n      }\n    } catch (Exception e) {\n      System.err.println(\"Error inside ErrorCheckerService.JavaToPdeOffset()\");\n      e.printStackTrace();\n    }\n    return new int[] { codeIndex, x };\n    */\n  }\n"
  },
  {
    "id": "apache_lenya-291-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Get the RCML directory",
    "old_code_raw": "    public String getRCMLDirectory() {\n        return rcmlDirectory;\n    }\n",
    "new_code_raw": "    public String getRCMLDirectory() {\n        return this.rcmlDirectory;\n    }\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2087-FirstSentence-0",
    "old_comment_raw": "Get the typed dependencies after collapsing them.",
    "new_comment_raw": "Get the typed dependencies after collapsing them.",
    "old_code_raw": "  public Collection<TypedDependency> typedDependenciesCollapsed() {\n    return typedDependenciesCollapsed(false);\n  }\n",
    "new_code_raw": "  public Collection<TypedDependency> typedDependenciesCollapsed() {\n    return typedDependenciesCollapsed(Extras.NONE);\n  }\n"
  },
  {
    "id": "apache_empire-db-22-Associations-FirstSentence",
    "old_comment_raw": "Returns an error, because querys could't add new records to the database.",
    "new_comment_raw": "Returns an error, because it is not possible to add a record to a query.",
    "old_code_raw": "    @Override\n    public boolean createRecord(DBRecord rec, Connection conn)\n    {\n        return error(Errors.NotImplemented, \"addRecord\");\n    }\n",
    "new_code_raw": "    @Override\n    public void createRecord(DBRecord rec, Connection conn)\n    {\n        throw new NotImplementedException(this, \"createRecord\");\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1795-FirstSentence-0",
    "old_comment_raw": "Get user by user name",
    "new_comment_raw": "Get user by user name",
    "old_code_raw": "  public User getUserByName (String username) throws ApiException {\n    Object postBody = null;\n    \n    // verify the required parameter 'username' is set\n    if (username == null) {\n       throw new ApiException(400, \"Missing the required parameter 'username' when calling getUserByName\");\n    }\n    \n\n    // create path and map variables\n    String path = \"/user/{username}\".replaceAll(\"\\\\{format\\\\}\",\"json\")\n      .replaceAll(\"\\\\{\" + \"username\" + \"\\\\}\", apiClient.escapeString(username.toString()));\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    Map<String, String> headerParams = new HashMap<String, String>();\n    Map<String, Object> formParams = new HashMap<String, Object>();\n\n    \n\n    \n\n    \n\n    final String[] accepts = {\n      \"application/json\", \"application/xml\"\n    };\n    final String accept = apiClient.selectHeaderAccept(accepts);\n\n    final String[] contentTypes = {\n      \n    };\n    final String contentType = apiClient.selectHeaderContentType(contentTypes);\n\n    String[] authNames = new String[] {  };\n    \n    TypeRef returnType = new TypeRef<User>() {};\n    return apiClient.invokeAPI(path, \"GET\", queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    \n  }\n",
    "new_code_raw": "  public User getUserByName (String username) throws ApiException {\n    Object postBody = null;\n    byte[] postBinaryBody = null;\n    \n     // verify the required parameter 'username' is set\n     if (username == null) {\n        throw new ApiException(400, \"Missing the required parameter 'username' when calling getUserByName\");\n     }\n     \n    // create path and map variables\n    String path = \"/user/{username}\".replaceAll(\"\\\\{format\\\\}\",\"json\")\n      .replaceAll(\"\\\\{\" + \"username\" + \"\\\\}\", apiClient.escapeString(username.toString()));\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    Map<String, String> headerParams = new HashMap<String, String>();\n    Map<String, Object> formParams = new HashMap<String, Object>();\n\n    \n\n    \n\n    \n\n    final String[] accepts = {\n      \"application/json\", \"application/xml\"\n    };\n    final String accept = apiClient.selectHeaderAccept(accepts);\n\n    final String[] contentTypes = {\n      \n    };\n    final String contentType = apiClient.selectHeaderContentType(contentTypes);\n\n    String[] authNames = new String[] {  };\n\n    \n\n    \n    \n    TypeRef returnType = new TypeRef<User>() {};\n    return apiClient.invokeAPI(path, \"GET\", queryParams, postBody, postBinaryBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    \n    \n\n\n  }\n"
  },
  {
    "id": "eclipse_reddeer-35-Associations-FirstSentence",
    "old_comment_raw": "Checks if toolitem is selected",
    "new_comment_raw": "Finds out whether specified  ToolItem is selected or not.",
    "old_code_raw": "\tpublic boolean isSelected(final ToolItem w) {\n\t\tboolean selectionState = Display.syncExec(new ResultRunnable<Boolean>() {\n\t\t\t@Override\n\t\t\tpublic Boolean run() {\n\t\t\t\t\treturn w.getSelection(); \n\t\t\t}\n\t\t});\n\t\treturn selectionState;\n\t}\n",
    "new_code_raw": "\tpublic boolean isSelected(final ToolItem toolItem) {\n\t\tboolean selectionState = Display.syncExec(new ResultRunnable<Boolean>() {\n\t\t\t@Override\n\t\t\tpublic Boolean run() {\n\t\t\t\t\treturn toolItem.getSelection(); \n\t\t\t}\n\t\t});\n\t\treturn selectionState;\n\t}\n\n"
  },
  {
    "id": "JodaOrg_joda_time-436-FirstSentence-0",
    "old_comment_raw": "Set the Year of a week based year component of the specified time instant.",
    "new_comment_raw": "Set the Year of a week based year component of the specified time instant.",
    "old_code_raw": "    public long set(long millis, int year) {\n        super.verifyValueBounds(Math.abs(year),\n                                iChronology.getMinYear(), iChronology.getMaxYear());\n        //\n        // Do nothing if no real change is requested.\n        //\n        int thisWeekyear = get( millis );\n        if ( thisWeekyear == year ) {\n            return millis;\n        }\n        //\n        // Calculate the DayOfWeek (to be preserved).\n        //\n        int thisDow = iChronology.dayOfWeek().get( millis );\n        //\n        // Calculate the maximum weeks in the target year.\n        //\n        int weeksInFromYear = iChronology.getWeeksInYear( thisWeekyear );\n        int weeksInToYear = iChronology.getWeeksInYear( year );\n        int maxOutWeeks = (weeksInToYear < weeksInFromYear) ?\n            weeksInToYear : weeksInFromYear;\n        //\n        // Get the current week of the year. This will be preserved in\n        // the output unless it is greater than the maximum possible\n        // for the target weekyear.  In that case it is adjusted\n        // to the maximum possible.\n        //\n        int setToWeek = iChronology.weekOfWeekyear().get( millis );\n        if ( setToWeek > maxOutWeeks ) {\n            setToWeek = maxOutWeeks;\n        }\n        //\n        // Get a wroking copy of the current date-time.\n        // This can be a convenience for debugging.\n        //\n        long workMillis = millis; // Get a copy\n        //\n        // Attempt to get close to the proper weekyear.\n        // Note - we cannot currently call ourself, so we just call\n        // set for the year.  This at least gets us close.\n        //\n        workMillis = iChronology.year().set( workMillis, year );\n        //\n        // Calculate the weekyear number for the get close to value\n        // (which might not be equal to the year just set).\n        //\n        int workWoyYear = iChronology.weekyear().get( workMillis );\n\n        // *TEMP Debugging\n        /*\n        MutableDateTime temp = new MutableDateTime(workMillis,\n            ISOChronology.getInstance());\n        System.out.println(\"Current mdt value 01: \"\n            + temp\n            + \" \" + workWoyYear\n        );\n        System.out.println(\"->Temp: \" + temp.toString()\n            + \" WOYYr=\" + temp.getWeekyear()\n            + \" WOYWk=\" + temp.getWeekOfWeekyear()\n            + \" DoW=\" + temp.getDayOfWeek()\n        );\n        */\n\n        //\n        // At most we are off by one year, which can be \"fixed\" by\n        // adding/subtracting a week.\n        //\n        if ( workWoyYear < year ) {\n            // System.out.println(\"Year: Adding \"+workWoyYear+\" \"+year);\n            workMillis += DateTimeConstants.MILLIS_PER_WEEK;\n        } else if ( workWoyYear > year ) {\n            // System.out.println(\"Year: Subing \"+workWoyYear+\" \"+year);\n            workMillis -= DateTimeConstants.MILLIS_PER_WEEK;\n        }\n        //\n        // Set the proper week in the current weekyear.\n        //\n\n        // BEGIN: possible set WeekOfWeekyear logic.\n        int currentWoyWeek = iChronology.weekOfWeekyear().get( workMillis );\n        // No range check required (we already know it is OK).\n        workMillis = workMillis + (setToWeek - currentWoyWeek)\n            * (long)DateTimeConstants.MILLIS_PER_WEEK;\n        // END: possible set WeekOfWeekyear logic.\n\n        //\n        // Reset DayOfWeek to previous value.\n        //\n        workMillis = iChronology.dayOfWeek().set( workMillis, thisDow );\n        //\n        // Return result.\n        //\n        return workMillis;\n    }\n",
    "new_code_raw": "    public long set(long instant, int year) {\n        Utils.verifyValueBounds(this, Math.abs(year),\n                                iChronology.getMinYear(), iChronology.getMaxYear());\n        //\n        // Do nothing if no real change is requested.\n        //\n        int thisWeekyear = get( instant );\n        if ( thisWeekyear == year ) {\n            return instant;\n        }\n        //\n        // Calculate the DayOfWeek (to be preserved).\n        //\n        int thisDow = iChronology.dayOfWeek().get( instant );\n        //\n        // Calculate the maximum weeks in the target year.\n        //\n        int weeksInFromYear = iChronology.getWeeksInYear( thisWeekyear );\n        int weeksInToYear = iChronology.getWeeksInYear( year );\n        int maxOutWeeks = (weeksInToYear < weeksInFromYear) ?\n            weeksInToYear : weeksInFromYear;\n        //\n        // Get the current week of the year. This will be preserved in\n        // the output unless it is greater than the maximum possible\n        // for the target weekyear.  In that case it is adjusted\n        // to the maximum possible.\n        //\n        int setToWeek = iChronology.weekOfWeekyear().get( instant );\n        if ( setToWeek > maxOutWeeks ) {\n            setToWeek = maxOutWeeks;\n        }\n        //\n        // Get a wroking copy of the current date-time.\n        // This can be a convenience for debugging.\n        //\n        long workInstant = instant; // Get a copy\n        //\n        // Attempt to get close to the proper weekyear.\n        // Note - we cannot currently call ourself, so we just call\n        // set for the year.  This at least gets us close.\n        //\n        workInstant = iChronology.year().set( workInstant, year );\n        //\n        // Calculate the weekyear number for the get close to value\n        // (which might not be equal to the year just set).\n        //\n        int workWoyYear = iChronology.weekyear().get( workInstant );\n\n        //\n        // At most we are off by one year, which can be \"fixed\" by\n        // adding/subtracting a week.\n        //\n        if ( workWoyYear < year ) {\n            workInstant += DateTimeConstants.MILLIS_PER_WEEK;\n        } else if ( workWoyYear > year ) {\n            workInstant -= DateTimeConstants.MILLIS_PER_WEEK;\n        }\n        //\n        // Set the proper week in the current weekyear.\n        //\n\n        // BEGIN: possible set WeekOfWeekyear logic.\n        int currentWoyWeek = iChronology.weekOfWeekyear().get( workInstant );\n        // No range check required (we already know it is OK).\n        workInstant = workInstant + (setToWeek - currentWoyWeek)\n            * (long)DateTimeConstants.MILLIS_PER_WEEK;\n        // END: possible set WeekOfWeekyear logic.\n\n        //\n        // Reset DayOfWeek to previous value.\n        //\n        workInstant = iChronology.dayOfWeek().set( workInstant, thisDow );\n        //\n        // Return result.\n        //\n        return workInstant;\n    }\n"
  },
  {
    "id": "kyleduo_SwitchButton-9-FirstSentence-0",
    "old_comment_raw": "return the status based on position of thumb",
    "new_comment_raw": "return the status based on position of thumb",
    "old_code_raw": "    private boolean getStatusBasedOnPos() {\n        return getProcess() > 0.5f;\n    }\n",
    "new_code_raw": "    private boolean getStatusBasedOnPos() {\n        return getProgress() > 0.5f;\n    }\n"
  },
  {
    "id": "Atmosphere_atmosphere-79-Associations-FirstSentence",
    "old_comment_raw": "Return the  org.atmosphere.cpr.MetaBroadcaster",
    "new_comment_raw": "Return the  DefaultMetaBroadcaster",
    "old_code_raw": "    public static MetaBroadcaster metaBroadcaster() {\n        return metaBroadcaster;\n    }\n",
    "new_code_raw": "    public static DefaultMetaBroadcaster metaBroadcaster() {\n        return metaBroadcaster;\n    }\n\n"
  },
  {
    "id": "debezium_debezium-1001-FirstSentence-0",
    "old_comment_raw": "Converts a value object for an expected JDBC type of  Types#TIMESTAMP to  java.util.Date values representing milliseconds past epoch.",
    "new_comment_raw": "Converts a value object for an expected JDBC type of  Types#TIMESTAMP to  java.util.Date values representing milliseconds past epoch.",
    "old_code_raw": "    protected Object convertTimestampToEpochMillisAsDate(Column column, Field fieldDefn, Object data) {\n        if (data == null && !fieldDefn.schema().isOptional()) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return new java.util.Date(0L); // return epoch\n        }\n        try {\n            return new java.util.Date(Timestamp.toEpochMillis(data, adjuster));\n        } catch (IllegalArgumentException e) {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n    }\n",
    "new_code_raw": "    protected Object convertTimestampToEpochMillisAsDate(Column column, Field fieldDefn, Object data) {\n        // epoch is the fallback value\n        return convertValue(column, fieldDefn, data, 0L, (r) -> {\n            try {\n                r.deliver(new java.util.Date(Timestamp.toEpochMillis(data, adjuster)));\n            } catch (IllegalArgumentException e) {\n            }\n        });\n    }\n"
  },
  {
    "id": "SeleniumHQ_selenium-831-FirstSentence-0",
    "old_comment_raw": "Convert an object that may or may not be a JSONArray or JSONObject into its JSON string representation, handling the case where it is neither in a graceful way.",
    "new_comment_raw": "Convert an object that may or may not be a JsonElement into its JSON string representation, handling the case where it is neither in a graceful way.",
    "old_code_raw": "  public String convert(Object object) {\n    if (object == null) {\n      return null;\n    }\n\n    try {\n      Object converted = convertObject(object, MAX_DEPTH);\n      if (converted instanceof JSONObject\n          || converted instanceof JSONArray\n          || converted instanceof String\n          || converted instanceof Number) {\n        return converted.toString();\n      }\n\n      return String.valueOf(object);\n    } catch (Exception e) {\n      throw new WebDriverException(\"Unable to convert: \" + object, e);\n    }\n  }\n",
    "new_code_raw": "  public String convert(Object object) {\n    if (object == null) {\n      return null;\n    }\n\n    try {\n      JsonElement json = convertObject(object);\n      return new GsonBuilder().serializeNulls().create().toJson(json);\n    } catch (Exception e) {\n      throw new WebDriverException(\"Unable to convert: \" + object, e);\n    }\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1744-FirstSentence-0",
    "old_comment_raw": "Find pet by ID",
    "new_comment_raw": "Find pet by ID",
    "old_code_raw": "  public Pet getPetById (Long petId) throws ApiException {\n    Object postBody = null;\n    \n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n       throw new ApiException(400, \"Missing the required parameter 'petId' when calling getPetById\");\n    }\n    \n\n    // create path and map variables\n    String path = \"/pet/{petId}\".replaceAll(\"\\\\{format\\\\}\",\"json\")\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString()));\n\n    // query params\n    Map<String, String> queryParams = new HashMap<String, String>();\n    Map<String, String> headerParams = new HashMap<String, String>();\n    Map<String, String> formParams = new HashMap<String, String>();\n\n    \n    \n    String[] contentTypes = {\n      \n    };\n\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if(contentType.startsWith(\"multipart/form-data\")) {\n      boolean hasFields = false;\n      FormDataMultiPart mp = new FormDataMultiPart();\n      \n      if(hasFields)\n        postBody = mp;\n    }\n    else {\n      \n    }\n\n    try {\n      String response = apiInvoker.invokeAPI(basePath, path, \"GET\", queryParams, postBody, headerParams, formParams, contentType);\n      if(response != null){\n        return (Pet) ApiInvoker.deserialize(response, \"\", Pet.class);\n      }\n      else {\n        return null;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n",
    "new_code_raw": "  public Pet getPetById (Long petId) throws ApiException {\n    Object postBody = null;\n    \n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n       throw new ApiException(400, \"Missing the required parameter 'petId' when calling getPetById\");\n    }\n    \n\n    // create path and map variables\n    String path = \"/pet/{petId}\".replaceAll(\"\\\\{format\\\\}\",\"json\")\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString()));\n\n    // query params\n    Map<String, String> queryParams = new HashMap<String, String>();\n    Map<String, String> headerParams = new HashMap<String, String>();\n    Map<String, String> formParams = new HashMap<String, String>();\n\n    \n    \n    String[] contentTypes = {\n      \n    };\n\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if(contentType.startsWith(\"multipart/form-data\")) {\n      boolean hasFields = false;\n      FormDataMultiPart mp = new FormDataMultiPart();\n      \n      if(hasFields)\n        postBody = mp;\n    }\n    else {\n      \n    }\n\n    try {\n      String response = apiClient.invokeAPI(path, \"GET\", queryParams, postBody, headerParams, formParams, contentType);\n      if(response != null){\n        return (Pet) apiClient.deserialize(response, \"\", Pet.class);\n      }\n      else {\n        return null;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n"
  },
  {
    "id": "trygvis_jop-161-Associations-FirstSentence",
    "old_comment_raw": "Parse a signature, with or without classname, with or without descriptor.",
    "new_comment_raw": "Parse a member ID, with or without classname, with or without descriptor.",
    "old_code_raw": "    public static MemberID parse(String signature) {\n        return parse(signature, false, AppInfo.getSingleton().getClassPath());\n    }\n",
    "new_code_raw": "    public static MemberID parse(String memberID) {\n        return parse(memberID, false, AppInfo.getSingleton().getClassPath());\n    }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-503-FirstSentence-0",
    "old_comment_raw": "Gets the default zone provider.",
    "new_comment_raw": "Gets the default zone provider.",
    "old_code_raw": "    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignored\n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        } else {\n            validateProvider(provider);\n        }\n        return provider;\n    }\n",
    "new_code_raw": "    private static Provider getDefaultProvider() {\n        // approach 1\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    Provider provider = (Provider) Class.forName(providerClass).newInstance();\n                    return validateProvider(provider);\n                } catch (Exception ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignored\n        }\n        // approach 2\n        try {\n            String dataFolder = System.getProperty(\"org.joda.time.DateTimeZone.Folder\");\n            if (dataFolder != null) {\n                try {\n                    Provider provider = new ZoneInfoProvider(new File(dataFolder));\n                    return validateProvider(provider);\n                } catch (Exception ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignored\n        }\n        // approach 3\n        try {\n            Provider provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            return validateProvider(provider);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        // approach 4\n        return new UTCProvider();\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2275-FirstSentence-0",
    "old_comment_raw": "Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.",
    "new_comment_raw": "Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.",
    "old_code_raw": "  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n              {\n                if (invertible) {\n            // prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            // System.err.println(\"At end of text making after: |\" + str + \"|\");\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n            // System.err.println(\"prevWord is |\" + prevWord.get(CoreAnnotations.TextAnnotation.class) + \"|, its after is |\" +\n            //         prevWord.get(CoreAnnotations.AfterAnnotation.class) + \"|\");\n            prevWordAfter.setLength(0);\n          }\n          return null;\n              }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { String str = yytext();\n          int first = str.codePointAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\",\n                          yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n            }\n          case 77: break;\n          case 2: \n            { return getNext(\"<\", yytext());\n            }\n          case 78: break;\n          case 3: \n            { return getNext();\n            }\n          case 79: break;\n          case 4: \n            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n            }\n          case 80: break;\n          case 5: \n            { if (tokenizeNLs) {\n                      return getNext(AbstractTokenizer.NEWLINE_TOKEN, yytext()); // for tokenizing newliens\n                  } else if (invertible) {\n                    // System.err.println(\"Appending newline: |\" + yytext() + \"|\");\n                    prevWordAfter.append(yytext());\n                  }\n            }\n          case 81: break;\n          case 6: \n            { final String origTxt = yytext();\n                          String tok = LexerUtils.removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} (2) to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 82: break;\n          case 7: \n            { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n            }\n          case 83: break;\n          case 8: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (3) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 84: break;\n          case 9: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 85: break;\n          case 10: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 86: break;\n          case 11: \n            { return getNext(\">\", yytext());\n            }\n          case 87: break;\n          case 12: \n            { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n            }\n          case 88: break;\n          case 13: \n            { handleHyphenatedNumber(yytext());\n                          if (DEBUG) { logger.info(\"Used {NUMBER} to recognize \" + yytext() + \" as \" + removeFromNumber(yytext())); }\n                          return getNext(removeFromNumber(yytext()), yytext());\n            }\n          case 89: break;\n          case 14: \n            { return handleEllipsis(yytext());\n            }\n          case 90: break;\n          case 15: \n            { // breakByHyphens(yytext()); // this is causing fail of attempted to pushback too much!\n                  String tok = yytext();\n                  /* A THING can contain quote like O'Malley */\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {THING} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 91: break;\n          case 16: \n            { String txt = yytext();\n                  String norm = normalizeFractions(yytext());\n                  if (DEBUG) { logger.info(\"Used {FRAC2} to recognize \" + txt + \" as \" + norm +\n                                       \"; normalizeFractions=\" + normalizeFractions +\n                                       \", escapeForwardSlashAsterisk=\" + escapeForwardSlashAsterisk); }\n                  return getNext(norm, txt);\n            }\n          case 92: break;\n          case 17: \n            { if (normalizeCurrency) {\n                            return getNext(LexerUtils.normalizeCurrency(yytext()), yytext());\n                        } else {\n                            return getNext(LexerUtils.minimallyNormalizeCurrency(yytext()), yytext());\n                          }\n            }\n          case 93: break;\n          case 18: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 94: break;\n          case 19: \n            { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 95: break;\n          case 20: \n            { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 96: break;\n          case 21: \n            { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 97: break;\n          case 22: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 98: break;\n          case 23: \n            { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 99: break;\n          case 24: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 100: break;\n          case 25: \n            { String tok = yytext();\n                        String norm = LexerUtils.processCp1252misc(tok);\n                        if (DEBUG) { logger.info(\"Used {CP1252_MISC_SYMBOL} to recognize \" + tok + \" as \" + norm); }\n                        return getNext(norm, tok);\n            }\n          case 101: break;\n          case 26: \n            { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n            }\n          case 102: break;\n          case 27: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 15;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 103: break;\n          case 28: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext();\n            }\n          case 104: break;\n          case 29: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {REDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 105: break;\n          case 30: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {APOWORD} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 106: break;\n          case 31: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                                   String norm = handleQuotes(tok, true);\n                                   if (DEBUG) { logger.info(\"Used {DBLQUOT} to recognize \" + tok + \" as \" + norm +\n                                                            \"; probablyLeft=\" + true); }\n                                   return getNext(norm, tok);\n            }\n          case 107: break;\n          case 32: \n            { String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {PROG_LANGS} to recognize \" + tok + \" as \" + tok); }\n                    return getNext(tok, tok);\n            }\n          case 108: break;\n          case 33: \n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 109: break;\n          case 34: \n            { breakByHyphens(yytext());\n                  if (DEBUG) { logger.info(\"Used {HTHING} to recognize \" + yytext() + \" as \" + LexerUtils.removeSoftHyphens(yytext())); }\n                  return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext());\n            }\n          case 110: break;\n          case 35: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 3;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 4;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tok = LexerUtils.removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 111: break;\n          case 36: \n            { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 112: break;\n          case 37: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String origTok = yytext();\n                          String norm = LexerUtils.removeSoftHyphens(origTok);\n                          if (DEBUG) { logger.info(\"Used {WORD} (3) to recognize \" + origTok + \" as \" + norm); }\n                          return getNext(norm, origTok);\n            }\n          case 113: break;\n          case 38: \n            { // this one should only match if we're basically at the end of file\n                          // since the last one matches two things, even newlines (if not tokenize per line)\n                          return processAbbrev1();\n            }\n          case 114: break;\n          case 39: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 115: break;\n          case 40: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { // Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  // can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  /* invert single quote - often but not always right */\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 116: break;\n          case 41: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {REDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 117: break;\n          case 42: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { // Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  // can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  /* invert single quote - often but not always right */\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 118: break;\n          case 43: \n            { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext());\n            }\n          case 119: break;\n          case 44: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {SREDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 120: break;\n          case 45: \n            { if (splitAssimilations) {\n                      yypushback(2);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 121: break;\n          case 46: \n            { String txt = yytext();\n                  // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...\n                  if (strictTreebank3) {\n                    int spaceIndex = indexOfSpace(txt);\n                    if (spaceIndex >= 0) {\n                      yypushback(txt.length() - spaceIndex);\n                      return getNext();\n                    }\n                  }\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '/');\n                  }\n                  if (normalizeSpace) {\n                    txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n            }\n          case 122: break;\n          case 47: \n            { final String origTxt = yytext();\n                          String tok;\n                          if (normalizeAmpersandEntity) {\n                            tok = LexerUtils.normalizeAmp(origTxt);\n                          } else {\n                            tok = origTxt;\n                          }\n                          if (DEBUG) { logger.info(\"Used {THINGA} (2) to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 123: break;\n          case 48: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 124: break;\n          case 49: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 125: break;\n          case 50: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 5;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 6;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tok = LexerUtils.removeSoftHyphens(origTxt);\n                          if (DEBUG) { logger.info(\"Used {SWORD} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 126: break;\n          case 51: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 17;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 127: break;\n          case 52: \n            { String txt = yytext();\n                  String normTok = txt;\n                  if (escapeForwardSlashAsterisk) {\n                    normTok = delimit(normTok, '*');\n                  }\n                  if (DEBUG) { logger.info(\"Used {SWEARING} to recognize \" + txt + \" as \" + normTok); }\n                  return getNext(normTok, txt);\n            }\n          case 128: break;\n          case 53: \n            { final String origTxt = yytext();\n                  String tok;\n                  if (normalizeAmpersandEntity) {\n                    tok = LexerUtils.normalizeAmp(origTxt);\n                  } else {\n                    tok = origTxt;\n                  }\n                  if (DEBUG) { logger.info(\"Used {TBSPEC} to recognize \" + origTxt + \" as \" + tok); }\n                  return getNext(tok, origTxt);\n            }\n          case 129: break;\n          case 54: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 130: break;\n          case 55: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 131: break;\n          case 56: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 22;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 132: break;\n          case 57: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 18;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 19;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 133: break;\n          case 58: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 134: break;\n          case 59: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 21;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 135: break;\n          case 60: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 136: break;\n          case 61: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                  breakByHyphens(tok);\n                  tok = yytext();\n                  String norm = LexerUtils.removeSoftHyphens(tok);\n                  if (DEBUG) { logger.info(\"Used {HTHING} (2) to recognize \" + tok + \" as \" + norm); }\n                  return getNext(norm, tok);\n            }\n          case 137: break;\n          case 62: \n            { if (splitAssimilations) {\n                      yypushback(3);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 138: break;\n          case 63: \n            { final String origTxt = yytext();\n                          String tok;\n                          if (normalizeAmpersandEntity) {\n                            tok = LexerUtils.normalizeAmp(origTxt);\n                          } else {\n                            tok = origTxt;\n                          }\n                          if (DEBUG) { logger.info(\"Used {SPAMP} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 139: break;\n          case 64: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext());\n            }\n          case 140: break;\n          case 65: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { final String origTxt = yytext();\n                          String tok;\n                          if (normalizeAmpersandEntity) {\n                            tok = LexerUtils.normalizeAmp(origTxt);\n                          } else {\n                            tok = origTxt;\n                          }\n                          if (DEBUG) { logger.info(\"Used {THINGA} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 141: break;\n          case 66: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 9;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 142: break;\n          case 67: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { return getNext();\n            }\n          case 143: break;\n          case 68: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 14;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 144: break;\n          case 69: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 8;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 145: break;\n          case 70: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 13;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 146: break;\n          case 71: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 147: break;\n          case 72: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);\n            { return getNext();\n            }\n          case 148: break;\n          case 73: \n            // lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { return getNext();\n            }\n          case 149: break;\n          case 74: \n            { String txt = yytext();\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          if (DEBUG) { logger.info(\"Used {PHONE} to recognize \" + yytext() + \" as \" + txt); }\n                          return getNext(txt, yytext());\n            }\n          case 150: break;\n          case 75: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 25;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 151: break;\n          case 76: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 24;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 152: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n",
    "new_code_raw": "  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n              {\n                if (invertible) {\n            // prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            // System.err.println(\"At end of text making after: |\" + str + \"|\");\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n            // System.err.println(\"prevWord is |\" + prevWord.get(CoreAnnotations.TextAnnotation.class) + \"|, its after is |\" +\n            //         prevWord.get(CoreAnnotations.AfterAnnotation.class) + \"|\");\n            prevWordAfter.setLength(0);\n          }\n          return null;\n              }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { String str = yytext();\n          int first = str.codePointAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\",\n                          yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n            }\n          case 79: break;\n          case 2: \n            { return getNext(\"<\", yytext());\n            }\n          case 80: break;\n          case 3: \n            { return getNext();\n            }\n          case 81: break;\n          case 4: \n            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n            }\n          case 82: break;\n          case 5: \n            { if (tokenizeNLs) {\n                      return getNext(AbstractTokenizer.NEWLINE_TOKEN, yytext()); // for tokenizing newliens\n                  } else if (invertible) {\n                    // System.err.println(\"Appending newline: |\" + yytext() + \"|\");\n                    prevWordAfter.append(yytext());\n                  }\n            }\n          case 83: break;\n          case 6: \n            { final String origTxt = yytext();\n                          String tok = LexerUtils.removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} (2) to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 84: break;\n          case 7: \n            { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n            }\n          case 85: break;\n          case 8: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (3) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 86: break;\n          case 9: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 87: break;\n          case 10: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 88: break;\n          case 11: \n            { return getNext(\">\", yytext());\n            }\n          case 89: break;\n          case 12: \n            { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n            }\n          case 90: break;\n          case 13: \n            { handleHyphenatedNumber(yytext());\n                          if (DEBUG) { logger.info(\"Used {NUMBER} to recognize \" + yytext() + \" as \" + removeFromNumber(yytext())); }\n                          return getNext(removeFromNumber(yytext()), yytext());\n            }\n          case 91: break;\n          case 14: \n            { return handleEllipsis(yytext());\n            }\n          case 92: break;\n          case 15: \n            { // breakByHyphens(yytext()); // this is causing fail of attempted to pushback too much!\n                  String tok = yytext();\n                  /* A THING can contain quote like O'Malley */\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {THING} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 93: break;\n          case 16: \n            { String txt = yytext();\n                  String norm = normalizeFractions(yytext());\n                  if (DEBUG) { logger.info(\"Used {FRAC2} to recognize \" + txt + \" as \" + norm +\n                                       \"; normalizeFractions=\" + normalizeFractions +\n                                       \", escapeForwardSlashAsterisk=\" + escapeForwardSlashAsterisk); }\n                  return getNext(norm, txt);\n            }\n          case 94: break;\n          case 17: \n            { if (normalizeCurrency) {\n                            return getNext(LexerUtils.normalizeCurrency(yytext()), yytext());\n                        } else {\n                            return getNext(LexerUtils.minimallyNormalizeCurrency(yytext()), yytext());\n                          }\n            }\n          case 95: break;\n          case 18: \n            { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 96: break;\n          case 19: \n            { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 97: break;\n          case 20: \n            { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 98: break;\n          case 21: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 99: break;\n          case 22: \n            { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 100: break;\n          case 23: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 101: break;\n          case 24: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 102: break;\n          case 25: \n            { String tok = yytext();\n                        String norm = LexerUtils.processCp1252misc(tok);\n                        if (DEBUG) { logger.info(\"Used {CP1252_MISC_SYMBOL} to recognize \" + tok + \" as \" + norm); }\n                        return getNext(norm, tok);\n            }\n          case 103: break;\n          case 26: \n            { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n            }\n          case 104: break;\n          case 27: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 17;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 18;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 105: break;\n          case 28: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext();\n            }\n          case 106: break;\n          case 29: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {REDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 107: break;\n          case 30: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {APOWORD} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 108: break;\n          case 31: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                                   String norm = handleQuotes(tok, true);\n                                   if (DEBUG) { logger.info(\"Used {DBLQUOT} to recognize \" + tok + \" as \" + norm +\n                                                            \"; probablyLeft=\" + true); }\n                                   return getNext(norm, tok);\n            }\n          case 109: break;\n          case 32: \n            { String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {PROG_LANGS} to recognize \" + tok + \" as \" + tok); }\n                    return getNext(tok, tok);\n            }\n          case 110: break;\n          case 33: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 8;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { String txt = yytext();\n                  if (DEBUG) { logger.info(\"Used {DIGIT}/{SEP_SUFFIX} to recognize \" + txt); }\n                  return getNext(txt, txt);\n            }\n          case 111: break;\n          case 34: \n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 112: break;\n          case 35: \n            { breakByHyphens(yytext());\n                  if (DEBUG) { logger.info(\"Used {HTHING} to recognize \" + yytext() + \" as \" + LexerUtils.removeSoftHyphens(yytext())); }\n                  return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext());\n            }\n          case 113: break;\n          case 36: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 3;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 4;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tok = LexerUtils.removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 114: break;\n          case 37: \n            { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 115: break;\n          case 38: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String origTok = yytext();\n                          String norm = LexerUtils.removeSoftHyphens(origTok);\n                          if (DEBUG) { logger.info(\"Used {WORD} (3) to recognize \" + origTok + \" as \" + norm); }\n                          return getNext(norm, origTok);\n            }\n          case 116: break;\n          case 39: \n            { // this one should only match if we're basically at the end of file\n                          // since the last one matches two things, even newlines (if not tokenize per line)\n                          return processAbbrev1();\n            }\n          case 117: break;\n          case 40: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 118: break;\n          case 41: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { // Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  // can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  /* invert single quote - often but not always right */\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 119: break;\n          case 42: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {REDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 120: break;\n          case 43: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { // Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  // can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  /* invert single quote - often but not always right */\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 121: break;\n          case 44: \n            { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext());\n            }\n          case 122: break;\n          case 45: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {SREDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 123: break;\n          case 46: \n            { if (splitAssimilations) {\n                      yypushback(2);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 124: break;\n          case 47: \n            { String txt = yytext();\n                  // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...\n                  if (strictTreebank3) {\n                    int spaceIndex = indexOfSpace(txt);\n                    if (spaceIndex >= 0) {\n                      yypushback(txt.length() - spaceIndex);\n                      return getNext();\n                    }\n                  }\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '/');\n                  }\n                  if (normalizeSpace) {\n                    txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n            }\n          case 125: break;\n          case 48: \n            { final String origTxt = yytext();\n                          String tok;\n                          if (normalizeAmpersandEntity) {\n                            tok = LexerUtils.normalizeAmp(origTxt);\n                          } else {\n                            tok = origTxt;\n                          }\n                          if (DEBUG) { logger.info(\"Used {THINGA} (2) to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 126: break;\n          case 49: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 127: break;\n          case 50: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 128: break;\n          case 51: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 5;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 6;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tok = LexerUtils.removeSoftHyphens(origTxt);\n                          if (DEBUG) { logger.info(\"Used {SWORD} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 129: break;\n          case 52: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 19;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 18;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 130: break;\n          case 53: \n            { String txt = yytext();\n                  String normTok = txt;\n                  if (escapeForwardSlashAsterisk) {\n                    normTok = delimit(normTok, '*');\n                  }\n                  if (DEBUG) { logger.info(\"Used {SWEARING} to recognize \" + txt + \" as \" + normTok); }\n                  return getNext(normTok, txt);\n            }\n          case 131: break;\n          case 54: \n            { final String origTxt = yytext();\n                  String tok;\n                  if (normalizeAmpersandEntity) {\n                    tok = LexerUtils.normalizeAmp(origTxt);\n                  } else {\n                    tok = origTxt;\n                  }\n                  if (DEBUG) { logger.info(\"Used {TBSPEC} to recognize \" + origTxt + \" as \" + tok); }\n                  return getNext(tok, origTxt);\n            }\n          case 132: break;\n          case 55: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 133: break;\n          case 56: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 13;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 134: break;\n          case 57: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 22;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 24;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 135: break;\n          case 58: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 21;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 136: break;\n          case 59: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 13;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 137: break;\n          case 60: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 22;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 23;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 138: break;\n          case 61: \n            { String txt = yytext();\n                          String norm = txt;\n                          if (escapeForwardSlashAsterisk) {\n                            norm = delimit(norm, '/');\n                            norm = delimit(norm, '*');\n                          }\n                          if (DEBUG) { logger.info(\"Used {LIKELYURL} to recognize \" + txt + \" as \" + norm); }\n                          return getNext(norm, txt);\n            }\n          case 139: break;\n          case 62: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                  breakByHyphens(tok);\n                  tok = yytext();\n                  String norm = LexerUtils.removeSoftHyphens(tok);\n                  if (DEBUG) { logger.info(\"Used {HTHING} (2) to recognize \" + tok + \" as \" + norm); }\n                  return getNext(norm, tok);\n            }\n          case 140: break;\n          case 63: \n            { if (splitAssimilations) {\n                      yypushback(3);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 141: break;\n          case 64: \n            { final String origTxt = yytext();\n                          String tok;\n                          if (normalizeAmpersandEntity) {\n                            tok = LexerUtils.normalizeAmp(origTxt);\n                          } else {\n                            tok = origTxt;\n                          }\n                          if (DEBUG) { logger.info(\"Used {SPAMP} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 142: break;\n          case 65: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext());\n            }\n          case 143: break;\n          case 66: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { final String origTxt = yytext();\n                          String tok;\n                          if (normalizeAmpersandEntity) {\n                            tok = LexerUtils.normalizeAmp(origTxt);\n                          } else {\n                            tok = origTxt;\n                          }\n                          if (DEBUG) { logger.info(\"Used {THINGA} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 144: break;\n          case 67: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 9;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 145: break;\n          case 68: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { return getNext();\n            }\n          case 146: break;\n          case 69: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 14;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 147: break;\n          case 70: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 9;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 10;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 148: break;\n          case 71: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 14;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 15;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 149: break;\n          case 72: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 150: break;\n          case 73: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);\n            { return getNext();\n            }\n          case 151: break;\n          case 74: \n            // lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { return getNext();\n            }\n          case 152: break;\n          case 75: \n            { String txt = yytext();\n                          String norm = txt;\n                          if (escapeForwardSlashAsterisk) {\n                            norm = delimit(norm, '/');\n                            norm = delimit(norm, '*');\n                          }\n                          if (DEBUG) { logger.info(\"Used {FULLURL} to recognize \" + txt + \" as \" + norm); }\n                          return getNext(norm, txt);\n            }\n          case 153: break;\n          case 76: \n            { String txt = yytext();\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          if (DEBUG) { logger.info(\"Used {PHONE} to recognize \" + yytext() + \" as \" + txt); }\n                          return getNext(txt, yytext());\n            }\n          case 154: break;\n          case 77: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 25;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 27;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 155: break;\n          case 78: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 25;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 26;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 156: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n"
  },
  {
    "id": "kaendfinger_pircbotx-105-Associations-FirstSentence",
    "old_comment_raw": "Returns the encoding used to send and receive lines from the IRC server, or null if not set.",
    "new_comment_raw": "Returns the encoding used to send and receive lines from the IRC server.",
    "old_code_raw": "\tpublic String getEncoding() {\r\n\t\treturn _charset;\r\n\t}\r\n",
    "new_code_raw": "\tpublic Charset getEncoding() {\r\n\t\treturn _charset;\r\n\t}\r\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-378-FirstSentence-0",
    "old_comment_raw": "Returns the label associated with the current node, or null if there is no label.",
    "new_comment_raw": "Returns the label associated with the current node, or null if there is no label.",
    "old_code_raw": "  public CoreLabel label() {\n    return label;\n  }\n",
    "new_code_raw": "  public CyclicCoreLabel label() {\n    return label;\n  }\n"
  },
  {
    "id": "jenkinsci_scm-api-plugin-8-Associations-FirstSentence",
    "old_comment_raw": "SPI for  #fetchActions(SCMHead, TaskListener).",
    "new_comment_raw": "SPI for  #fetchActions(SCMHead, SCMHeadEvent, TaskListener).",
    "old_code_raw": "    @NonNull\n    protected Map<Class<? extends Action>, Action> retrieveActions(@NonNull SCMHead head,\n                                                                   @NonNull TaskListener listener)\n            throws IOException, InterruptedException {\n        return Collections.emptyMap();\n    }\n",
    "new_code_raw": "    @NonNull\n    protected List<Action> retrieveActions(@NonNull SCMHead head,\n                                           @NonNull SCMHeadEvent event,\n                                           @NonNull TaskListener listener)\n            throws IOException, InterruptedException {\n        return Collections.emptyList();\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1985-FirstSentence-0",
    "old_comment_raw": "Get the actual schema from aliases.",
    "new_comment_raw": "Get the actual schema from aliases.",
    "old_code_raw": "    public static Schema unaliasSchema(Map<String, Schema> allSchemas, Schema schema) {\n        if (allSchemas == null || allSchemas.isEmpty()) {\n            LOGGER.warn(\"allSchemas cann't be null/empty in unaliasSchema. Returned 'schema'\");\n            return schema;\n        }\n\n        if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) {\n            Schema ref = allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()));\n            if (ref == null) {\n                LOGGER.warn(\"{} is not defined\", schema.get$ref());\n                return schema;\n            } else if (ref.getEnum() != null && !ref.getEnum().isEmpty()) {\n                // top-level enum class\n                return schema;\n            } else if (isArraySchema(ref) || isComposedSchema(ref)) { // array def should be created as models\n                return schema;\n            } else if (isMapSchema(ref)) {\n                if (ref.getProperties() != null && !ref.getProperties().isEmpty()) // has properties\n                    return schema; // treat it as model\n                else {\n                    // treat it as a typical map\n                    /* TODO unalias the map item if it's an alias\n                    if (ref.getAdditionalProperties() != null) {\n\n                        Schema innerSchema = (Schema) ref.getAdditionalProperties();\n                        if (StringUtils.isNotEmpty(innerSchema.get$ref())) { // map item is a ref to something else\n                            //Schema unaliasInnerSchema = unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(innerSchema.get$ref())));\n                            //ref.setAdditionalProperties(unaliasInnerSchema);\n                        }\n                    }*/\n                    return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n                }\n            } else if (isObjectSchema(ref)) { // model\n                return schema;\n            } else {\n                return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n            }\n        }\n        return schema;\n    }\n",
    "new_code_raw": "    public static Schema unaliasSchema(Map<String, Schema> allSchemas, Schema schema) {\n        if (allSchemas == null || allSchemas.isEmpty()) {\n            // skip the warning as the spec can have no model defined\n            //LOGGER.warn(\"allSchemas cannot be null/empty in unaliasSchema. Returned 'schema'\");\n            return schema;\n        }\n\n        if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) {\n            Schema ref = allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()));\n            if (ref == null) {\n                LOGGER.warn(\"{} is not defined\", schema.get$ref());\n                return schema;\n            } else if (ref.getEnum() != null && !ref.getEnum().isEmpty()) {\n                // top-level enum class\n                return schema;\n            } else if (isFreeFormObject(ref)) {\n                return schema;\n            } else if (isArraySchema(ref) || isComposedSchema(ref)) { // array def should be created as models\n                return schema;\n            } else if (isMapSchema(ref)) {\n                if (ref.getProperties() != null && !ref.getProperties().isEmpty()) // has properties\n                    return schema; // treat it as model\n                else {\n                    // treat it as a typical map\n                    /* TODO unalias the map item if it's an alias\n                    if (ref.getAdditionalProperties() != null) {\n\n                        Schema innerSchema = (Schema) ref.getAdditionalProperties();\n                        if (StringUtils.isNotEmpty(innerSchema.get$ref())) { // map item is a ref to something else\n                            //Schema unaliasInnerSchema = unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(innerSchema.get$ref())));\n                            //ref.setAdditionalProperties(unaliasInnerSchema);\n                        }\n                    }*/\n                    return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n                }\n            } else if (isObjectSchema(ref)) { // model\n                return schema;\n            } else {\n                return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n            }\n        }\n        return schema;\n    }\n"
  },
  {
    "id": "eclipse_tcf-91-Associations-FirstSentence",
    "old_comment_raw": "Judges if the node is an ancestor of the target node.",
    "new_comment_raw": "Judges if the object1 is an ancestor of the object2.",
    "old_code_raw": "\tprivate boolean isAncestorOf(Object node, Object target) {\r\n\t\tif (target == null) return false;\r\n\t\tObject parent = getParent(target);\r\n\t\tif (parent == node) return true;\r\n\t\treturn isAncestorOf(node, parent);\r\n   }\r\n",
    "new_code_raw": "\tprivate boolean isAncestorOf(Object object1, Object object2) {\r\n\t\tif (object2 == null) return false;\r\n\t\tObject parent = getParent(object2);\r\n\t\tif (parent == object1) return true;\r\n\t\treturn isAncestorOf(object1, parent);\r\n   }\r\n\n"
  },
  {
    "id": "JodaOrg_joda_time-479-FirstSentence-0",
    "old_comment_raw": "Append a separator, which is output only if fields are printed before the separator.",
    "new_comment_raw": "Append a separator, which is output only if fields are printed before the separator.",
    "old_code_raw": "    public PeriodFormatterBuilder appendSeparatorIfFieldsBefore(String text) {\n        return appendSeparator(text, text, true, false);\n    }\n",
    "new_code_raw": "    public PeriodFormatterBuilder appendSeparatorIfFieldsBefore(String text) {\n        return appendSeparator(text, text, null, true, false);\n    }\n"
  },
  {
    "id": "cemcatik_jtds-84-Associations-FirstSentence",
    "old_comment_raw": "Queue up update counts until the end of the response is reached or a ResultSet is encountered into  #resultQueue.",
    "new_comment_raw": "Queue up update counts into  #resultQueue until the end of the response is reached or a ResultSet is encountered.",
    "old_code_raw": "    private boolean processResults(boolean returnKeys, boolean update) throws SQLException {\n        while (!tds.isEndOfResponse()) {\n            if (!tds.getMoreResults()) {\n                if (tds.isUpdateCount()) {\n                    if (update && connection.isLastUpdateCount()) {\n                        resultQueue.clear();\n                    }\n                    resultQueue.addLast(new Integer(tds.getUpdateCount()));\n                }\n            } else {\n                if (returnKeys) {\n                    // This had better be the generated key\n                    // FIXME We could use SELECT @@IDENTITY AS jTDS_SOMETHING and check the column name to make sure\n                    if (tds.getNextRow()) {\n                        genKeyResultSet = new CachedResultSet(this,\n                                tds.getColumns(),\n                                tds.getRowData());\n                    }\n                } else {\n                    // TODO Should we allow execution of multiple statements via executeUpdate?\n                    if (update && resultQueue.isEmpty()) {\n                        throw new SQLException(\n                                Messages.get(\"error.statement.nocount\"), \"07000\");\n                    }\n\n                    JtdsResultSet rs = new JtdsResultSet(\n                            this,\n                            ResultSet.TYPE_FORWARD_ONLY,\n                            ResultSet.CONCUR_READ_ONLY,\n                            tds.getColumns(),\n                            false);\n\n                    if (resultQueue.isEmpty()) {\n                        // This is the first result. Return it.\n                        currentResult = rs;\n                        return true;\n                    } else {\n                        // There were some update counts before. Queue it.\n                        resultQueue.add(rs);\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n",
    "new_code_raw": "    private boolean processResults(boolean returnKeys, boolean update) throws SQLException {\n        if (!resultQueue.isEmpty()) {\n            throw new IllegalStateException(\n                    \"There should be no queued results.\");\n        }\n\n        while (!tds.isEndOfResponse()) {\n            if (!tds.getMoreResults()) {\n                if (tds.isUpdateCount()) {\n                    if (update && connection.isLastUpdateCount()) {\n                        resultQueue.clear();\n                    }\n                    resultQueue.addLast(new Integer(tds.getUpdateCount()));\n                }\n            } else {\n                if (returnKeys) {\n                    // This had better be the generated key\n                    // FIXME We could use SELECT @@IDENTITY AS jTDS_SOMETHING and check the column name to make sure\n                    if (tds.getNextRow()) {\n                        genKeyResultSet = new CachedResultSet(this,\n                                tds.getColumns(),\n                                tds.getRowData());\n                    }\n                } else {\n                    // TODO Should we allow execution of multiple statements via executeUpdate?\n                    if (update && resultQueue.isEmpty()) {\n                        throw new SQLException(\n                                Messages.get(\"error.statement.nocount\"), \"07000\");\n                    }\n\n                    resultQueue.add(new JtdsResultSet(\n                            this,\n                            ResultSet.TYPE_FORWARD_ONLY,\n                            ResultSet.CONCUR_READ_ONLY,\n                            tds.getColumns()));\n                    break;\n                }\n            }\n        }\n\n        return !resultQueue.isEmpty();\n    }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-518-FirstSentence-0",
    "old_comment_raw": "Instructs the printer to emit a numeric minuteOfDay field.",
    "new_comment_raw": "Instructs the printer to emit a numeric minuteOfDay field.",
    "old_code_raw": "    public DateTimeFormatterBuilder appendMinuteOfDay(final int minDigits) {\n        return appendNumeric(iChronoUTC.minuteOfDay(), minDigits, 4);\n    }\n",
    "new_code_raw": "    public DateTimeFormatterBuilder appendMinuteOfDay(final int minDigits) {\n        return appendDecimal(iChronoUTC.minuteOfDay(), minDigits, 4);\n    }\n"
  },
  {
    "id": "apache_jsecurity-54-Associations-FirstSentence",
    "old_comment_raw": "Returns true if the method has a JSecurity RolesRequired or PermissionsRequired annotation, false otherwise.",
    "new_comment_raw": "Returns true if the method has a JSecurity RequiresRoles or RequiresPermissions annotation, false otherwise.",
    "old_code_raw": "    public boolean matches( Method method, Class targetClass) {\n        return ( (method.getAnnotation( PermissionsRequired.class ) != null ) ||\n                 (method.getAnnotation( RolesRequired.class ) != null ) );\n    }\n",
    "new_code_raw": "    public boolean matches( Method method, Class targetClass) {\n        return ( (method.getAnnotation( RequiresPermissions.class ) != null ) ||\n                 (method.getAnnotation( RequiresRoles.class ) != null ) );\n    }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-911-FirstSentence-0",
    "old_comment_raw": "Gets the amount by which this field is leap.",
    "new_comment_raw": "Gets the amount by which this field is leap.",
    "old_code_raw": "    public int getLeapAmount() {\n        return getField().getLeapAmount(getReadableInstant().getMillis());\n    }\n",
    "new_code_raw": "    public int getLeapAmount() {\n        return getField().getLeapAmount(getMillis());\n    }\n"
  },
  {
    "id": "ansell_openrdf-sesame-130-Associations-FirstSentence",
    "old_comment_raw": "Retrieve the currently specified  TransactionIsolation level.",
    "new_comment_raw": "Retrieve the currently specified  IsolationLevel level.",
    "old_code_raw": "\tprotected TransactionIsolation getTransactionIsolation() {\r\n\t\treturn this.transactionIsolationLevel;\r\n\t}\r\n",
    "new_code_raw": "\tprotected IsolationLevel getTransactionIsolation() {\r\n\t\treturn this.transactionIsolationLevel;\r\n\t}\r\n\n"
  },
  {
    "id": "querydsl_querydsl-234-FirstSentence-0",
    "old_comment_raw": "Expr : left || right",
    "new_comment_raw": "Expr : left || right",
    "old_code_raw": "    public static EBoolean contains(Expr<String> left, String right) {\n        return createBoolean(Ops.CONTAINS, left, createConstant(right));\n    }\n",
    "new_code_raw": "    public static EBoolean contains(Expr<String> left, String right) {\n        return factory.createBoolean(Ops.CONTAINS, left, factory.createConstant(right));\n    }\n"
  },
  {
    "id": "travis_cosmo-33-Associations-FirstSentence",
    "old_comment_raw": "Returns an array of codes representing all supported component types (see specific type constants).",
    "new_comment_raw": "Returns an array of all supported component types",
    "old_code_raw": "    public static int[] getAllSupportedComponentTypes() {\n        return SUPPORTED_COMPONENT_TYPES;\n    }\n",
    "new_code_raw": "    public static Set<String> getAllSupportedComponentTypes() {\n        return SUPPORTED_COMPONENT_TYPES;\n    }\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-1691-FirstSentence-0",
    "old_comment_raw": "Are there any paths currently tracked here?",
    "new_comment_raw": "Are there any paths currently tracked here?",
    "old_code_raw": "\tpublic boolean isEmpty() {\n\t\treturn propertyPathsByTransientEntity.isEmpty();\n\t}\n",
    "new_code_raw": "\tpublic boolean isEmpty() {\n\t\treturn propertyPathsByTransientEntity == null || propertyPathsByTransientEntity.isEmpty();\n\t}\n"
  },
  {
    "id": "apache_qpid-jms-8-Associations-FirstSentence",
    "old_comment_raw": "Get properties from an object",
    "new_comment_raw": "Get properties from an object using reflection.",
    "old_code_raw": "    public static Map<String, String> getProperties(Object object) throws Exception {\n        Map<String, String> props = new LinkedHashMap<String, String>();\n        BeanInfo beanInfo = Introspector.getBeanInfo(object.getClass());\n        Object[] NULL_ARG = {};\n        PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();\n        if (propertyDescriptors != null) {\n            for (int i = 0; i < propertyDescriptors.length; i++) {\n                PropertyDescriptor pd = propertyDescriptors[i];\n                if (pd.getReadMethod() != null && !pd.getName().equals(\"class\") && !pd.getName().equals(\"properties\") && !pd.getName().equals(\"reference\")) {\n                    Object value = pd.getReadMethod().invoke(object, NULL_ARG);\n                    if (value != null) {\n                        if (value instanceof Boolean || value instanceof Number || value instanceof String || value instanceof URI || value instanceof URL) {\n                            props.put(pd.getName(), (\"\" + value));\n                        } else if (value instanceof SSLContext) {\n                            // ignore this one..\n                        } else {\n                            Map<String, String> inner = getProperties(value);\n                            for (Map.Entry<String, String> entry : inner.entrySet()) {\n                                props.put(pd.getName() + \".\" + entry.getKey(), entry.getValue());\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return props;\n    }\n",
    "new_code_raw": "    public static Map<String, String> getProperties(Object object) throws Exception {\n        if (object == null) {\n            return Collections.emptyMap();\n        }\n\n        Map<String, String> props = new LinkedHashMap<String, String>();\n        BeanInfo beanInfo = Introspector.getBeanInfo(object.getClass());\n        Object[] NULL_ARG = {};\n        PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();\n        if (propertyDescriptors != null) {\n            for (int i = 0; i < propertyDescriptors.length; i++) {\n                PropertyDescriptor pd = propertyDescriptors[i];\n                if (pd.getReadMethod() != null && !pd.getName().equals(\"class\") && !pd.getName().equals(\"properties\") && !pd.getName().equals(\"reference\")) {\n                    Object value = pd.getReadMethod().invoke(object, NULL_ARG);\n                    if (value != null) {\n                        if (value instanceof Boolean || value instanceof Number || value instanceof String || value instanceof URI || value instanceof URL) {\n                            props.put(pd.getName(), (\"\" + value));\n                        } else if (value instanceof SSLContext) {\n                            // ignore this one..\n                        } else {\n                            Map<String, String> inner = getProperties(value);\n                            for (Map.Entry<String, String> entry : inner.entrySet()) {\n                                props.put(pd.getName() + \".\" + entry.getKey(), entry.getValue());\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return props;\n    }\n\n"
  },
  {
    "id": "theDazzler_droidicon-1-FirstSentence-0",
    "old_comment_raw": "Loads a  Typeface for the given icon font.",
    "new_comment_raw": "Loads a  Typeface for the given icon font.",
    "old_code_raw": "    public int getIconUtfValue(String icon) {\n        return iconMap.get(icon);\n    }\n",
    "new_code_raw": "    public int getIconUtfValue(String icon) {\n        if (iconMap.containsKey(icon)) {\n            return iconMap.get(icon);\n        } else {\n            return 0;\n        }\n    }\n"
  },
  {
    "id": "apache_jsecurity-15-Associations-FirstSentence",
    "old_comment_raw": "Returns true if the method has a JSecurity HasRole or Implies annotation, false otherwise.",
    "new_comment_raw": "Returns true if the method has a JSecurity RolesRequired or PermissionRequired annotation, false otherwise.",
    "old_code_raw": "    public boolean matches( Method method, Class targetClass) {\n        return ( (method.getAnnotation( Implies.class ) != null ) ||\n                 (method.getAnnotation( HasRole.class ) != null ) );\n    }\n",
    "new_code_raw": "    public boolean matches( Method method, Class targetClass) {\n        return ( (method.getAnnotation( PermissionRequired.class ) != null ) ||\n                 (method.getAnnotation( RolesRequired.class ) != null ) );\n    }\n\n"
  },
  {
    "id": "debezium_debezium-1006-FirstSentence-0",
    "old_comment_raw": "Converts a value object for an expected JDBC type of  Types#DATE to the number of days past epoch.",
    "new_comment_raw": "Converts a value object for an expected JDBC type of  Types#DATE to the number of days past epoch.",
    "old_code_raw": "    protected Object convertDateToEpochDays(Column column, Field fieldDefn, Object data) {\n        if (data == null && !fieldDefn.schema().isOptional()) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0; // return epoch\n        }\n        try {\n            return Date.toEpochDay(data, adjuster);\n        } catch (IllegalArgumentException e) {\n            logger.warn(\"Unexpected JDBC DATE value for field {} with schema {}: class={}, value={}\", fieldDefn.name(),\n                        fieldDefn.schema(), data.getClass(), data);\n            return handleUnknownData(column, fieldDefn, data);\n        }\n    }\n",
    "new_code_raw": "    protected Object convertDateToEpochDays(Column column, Field fieldDefn, Object data) {\n        // epoch is the fallback value\n        return convertValue(column, fieldDefn, data, 0, (r) -> {\n            try {\n                r.deliver(Date.toEpochDay(data, adjuster));\n            } catch (IllegalArgumentException e) {\n                logger.warn(\"Unexpected JDBC DATE value for field {} with schema {}: class={}, value={}\", fieldDefn.name(),\n                            fieldDefn.schema(), data.getClass(), data);\n            }\n        });\n    }\n"
  },
  {
    "id": "apache_axis1-java-113-Associations-FirstSentence",
    "old_comment_raw": "Returns an Iterator that can be used to get all of the ports specified in the WSDL file associated with this Service (if there is a WSDL file).",
    "new_comment_raw": "Returns an Iterator for the list of QNames of service endpoints grouped by this service",
    "old_code_raw": "    public Iterator getPorts() throws ServiceException {\n        if (wsdlService == null || wsdlService.getPorts() == null){\n            // Return an empty iterator;\n            return new Vector().iterator();\n        }\n        return wsdlService.getPorts().values().iterator();\n    }\n",
    "new_code_raw": "    public Iterator getPorts() throws ServiceException {\n        if (wsdlService == null || wsdlService.getPorts() == null){\n            // Return an empty iterator;\n            return new Vector().iterator();\n        }\n        return wsdlService.getPorts().keySet().iterator();\n    }\n\n"
  },
  {
    "id": "querydsl_querydsl-535-FirstSentence-0",
    "old_comment_raw": "Create a left is not null expression",
    "new_comment_raw": "Create a left is not null expression",
    "old_code_raw": "    public static Predicate isNotNull(Expression<?> left) {\n        return new PredicateOperation(Ops.IS_NOT_NULL, left);\n    }   \n",
    "new_code_raw": "    public static Predicate isNotNull(Expression<?> left) {\n        return PredicateOperation.create(Ops.IS_NOT_NULL, left);\n    }   \n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2365-FirstSentence-0",
    "old_comment_raw": "Given a  Tree node  t, attempts to return a list of nodes to which node  t has this grammatical relation, with  t as the governor.",
    "new_comment_raw": "Given a Tree node t, attempts to return a list of nodes to which node t has this grammatical relation.",
    "old_code_raw": "  public Collection<TreeGraphNode> getRelatedNodes(TreeGraphNode t, TreeGraphNode root, HeadFinder headFinder) {\n    Set<TreeGraphNode> nodeList = new ArraySet<>();\n    for (TregexPattern p : targetPatterns) {    // cdm: I deleted: && nodeList.isEmpty()\n      // Initialize the TregexMatcher with the HeadFinder so that we\n      // can use the same HeadFinder through the entire process of\n      // building the dependencies\n      TregexMatcher m = p.matcher(root, headFinder);\n      while (m.findAt(t)) {\n        TreeGraphNode target = (TreeGraphNode) m.getNode(\"target\");\n        if (target == null) {\n          throw new AssertionError(\"Expression has no target: \" + p);\n        }\n        nodeList.add(target);\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \"-\" + t.headWordNode() + \", \" + m.getNode(\"target\") + \"-\" + ((TreeGraphNode) m.getNode(\"target\")).headWordNode() + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\"))\n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n",
    "new_code_raw": "  public Collection<Tree> getRelatedNodes(Tree t, Tree root) {\n    if (root.value() == null) {\n      root.setValue(\"ROOT\");  // todo: cdm: it doesn't seem like this line should be here\n    }\n    Set<Tree> nodeList = new LinkedHashSet<Tree>();\n    for (TregexPattern p : targetPatterns) {    // cdm: I deleted: && nodeList.isEmpty()\n      TregexMatcher m = p.matcher(root);\n      while (m.findAt(t)) {\n        nodeList.add(m.getNode(\"target\"));\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\")) \n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n"
  },
  {
    "id": "processing_processing-408-FirstSentence-0",
    "old_comment_raw": "Get cache storage data for the specified renderer.",
    "new_comment_raw": "Get cache storage data for the specified renderer.",
    "old_code_raw": "  public PMetadata getCache(PGraphics renderer) {\n    return g.getCache(renderer);\n  }\n",
    "new_code_raw": "  public Object getCache(PGraphics renderer) {\n    return g.getCache(renderer);\n  }\n"
  },
  {
    "id": "mukteshkrmishra_javasimon-20-Associations-FirstSentence",
    "old_comment_raw": "Returns name, state and stats of the Simon as a human readable string.",
    "new_comment_raw": "Returns name and state of the Simon as a human readable string.",
    "old_code_raw": "\t@Override\n\tpublic String toString() {\n\t\treturn \"[\" + name + \" \" + state + \"/stats=\" + getStatProcessor().getType() + \"]\";\n\t}\n",
    "new_code_raw": "\t@Override\n\tpublic String toString() {\n\t\treturn \"[\" + name + \" \" + state + \"]\";\n\t}\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1085-FirstSentence-0",
    "old_comment_raw": "Get binary",
    "new_comment_raw": "Get binary",
    "old_code_raw": "  public byte[] getBinary() {\n    return binary;\n  }\n",
    "new_code_raw": "  public AsyncFile getBinary() {\n    return binary;\n  }\n"
  },
  {
    "id": "RSB4760_apq8016_frameworks_support-50-Associations-FirstSentence",
    "old_comment_raw": "Gets the total duration of the content to be played as a floating point number of seconds.",
    "new_comment_raw": "Gets the total duration of the content to be played as a long integer number of milliseconds.",
    "old_code_raw": "    public double getContentDuration() {\n        return mBundle.getDouble(KEY_CONTENT_DURATION, -1);\n    }\n",
    "new_code_raw": "    public long getContentDuration() {\n        return mBundle.getLong(KEY_CONTENT_DURATION, -1);\n    }\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-1718-FirstSentence-0",
    "old_comment_raw": "Add a cacheable mapping file.",
    "new_comment_raw": "Add a cacheable mapping file.",
    "old_code_raw": "\tpublic Configuration addCacheableFile(String xmlFile) throws MappingException {\n\t\treturn addCacheableFile( new File( xmlFile ) );\n\t}\n",
    "new_code_raw": "\tpublic Configuration addCacheableFile(String xmlFile) throws MappingException {\n\t\tmetadataSources.addCacheableFile( xmlFile );\n\t\treturn this;\n\t}\n"
  },
  {
    "id": "pwittchen_ReactiveNetwork-27-FirstSentence-0",
    "old_comment_raw": "Observe WiFi signal level.",
    "new_comment_raw": "Observes WiFi signal level.",
    "old_code_raw": "  public Observable<Integer> observeWifiSignalLevel(final Context context, final int numLevels) {\n    final WifiManager wifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);\n\n    final IntentFilter filter = new IntentFilter();\n    filter.addAction(WifiManager.RSSI_CHANGED_ACTION);\n\n    return Observable.create(new Observable.OnSubscribe<Integer>() {\n\n      @Override\n      public void call(final Subscriber<? super Integer> subscriber) {\n        final BroadcastReceiver receiver = new BroadcastReceiver() {\n          @Override\n          public void onReceive(Context context, Intent intent) {\n            int level = WifiManager.calculateSignalLevel(wifiManager.getConnectionInfo().getRssi(), numLevels);\n            subscriber.onNext(level);\n          }\n        };\n\n        context.registerReceiver(receiver, filter);\n\n        subscriber.add(unsubscribeInUiThread(new Action0() {\n          @Override\n          public void call() {\n            context.unregisterReceiver(receiver);\n          }\n        }));\n      }\n    }).defaultIfEmpty(0);\n  }\n",
    "new_code_raw": "  public Observable<Integer> observeWifiSignalLevel(final Context context, final int numLevels) {\n    final WifiManager wifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);\n\n    final IntentFilter filter = new IntentFilter();\n    filter.addAction(WifiManager.RSSI_CHANGED_ACTION);\n\n    return Observable.create(new Observable.OnSubscribe<Integer>() {\n\n      @Override public void call(final Subscriber<? super Integer> subscriber) {\n        final BroadcastReceiver receiver = new BroadcastReceiver() {\n          @Override public void onReceive(Context context, Intent intent) {\n            final int rssi = wifiManager.getConnectionInfo().getRssi();\n            final int level = WifiManager.calculateSignalLevel(rssi, numLevels);\n            subscriber.onNext(level);\n          }\n        };\n\n        context.registerReceiver(receiver, filter);\n\n        subscriber.add(unsubscribeInUiThread(new Action0() {\n          @Override public void call() {\n            context.unregisterReceiver(receiver);\n          }\n        }));\n      }\n    }).defaultIfEmpty(0);\n  }\n"
  },
  {
    "id": "apache_calcite-621-FirstSentence-0",
    "old_comment_raw": "Derives an alias for a node, and invents a mangled identifier if it cannot.",
    "new_comment_raw": "Derives an alias for a node, and invents a mangled identifier if it cannot.",
    "old_code_raw": "  public static String getAlias(SqlNode node, int ordinal) {\n    switch (node.getKind()) {\n    case AS:\n      // E.g. \"1 + 2 as foo\" --> \"foo\"\n      return ((SqlCall) node).getOperands()[1].toString();\n\n    case OVER:\n      // E.g. \"bids over w\" --> \"bids\"\n      return getAlias(((SqlCall) node).getOperands()[0], ordinal);\n\n    case IDENTIFIER:\n      // E.g. \"foo.bar\" --> \"bar\"\n      final String[] names = ((SqlIdentifier) node).names;\n      return names[names.length - 1];\n\n    default:\n      if (ordinal < 0) {\n        return null;\n      } else {\n        return SqlUtil.deriveAliasFromOrdinal(ordinal);\n      }\n    }\n  }\n",
    "new_code_raw": "  public static String getAlias(SqlNode node, int ordinal) {\n    switch (node.getKind()) {\n    case AS:\n      // E.g. \"1 + 2 as foo\" --> \"foo\"\n      return ((SqlCall) node).getOperands()[1].toString();\n\n    case OVER:\n      // E.g. \"bids over w\" --> \"bids\"\n      return getAlias(((SqlCall) node).getOperands()[0], ordinal);\n\n    case IDENTIFIER:\n      // E.g. \"foo.bar\" --> \"bar\"\n      return Util.last(((SqlIdentifier) node).names);\n\n    default:\n      if (ordinal < 0) {\n        return null;\n      } else {\n        return SqlUtil.deriveAliasFromOrdinal(ordinal);\n      }\n    }\n  }\n"
  },
  {
    "id": "codehaus_loom-17-Associations-FirstSentence",
    "old_comment_raw": "Return the  org.jcontainer.loom.components.util.metadata.ComponentMetaData for specified component entry.",
    "new_comment_raw": "Return the ComponentTemplate for specified component entry.",
    "old_code_raw": "    protected ComponentMetaData getMetaData( final Object entry )\n    {\n        return (ComponentMetaData)entry;\n    }\n",
    "new_code_raw": "    protected ComponentTemplate getMetaData( final Object entry )\n    {\n        return (ComponentTemplate)entry;\n    }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-1028-FirstSentence-0",
    "old_comment_raw": "Returns a basic formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, three digit millis, and time zone offset (HHmmss.SSSZ).",
    "new_comment_raw": "Returns a basic formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, three digit millis, and time zone offset (HHmmss.SSSZ).",
    "old_code_raw": "    public static DateTimeFormatter basicTime() {\n        if (bt == null) {\n            bt = new DateTimeFormatterBuilder()\n                .appendFixedDecimal(DateTimeFieldType.hourOfDay(), 2)\n                .appendFixedDecimal(DateTimeFieldType.minuteOfHour(), 2)\n                .appendFixedDecimal(DateTimeFieldType.secondOfMinute(), 2)\n                .appendLiteral('.')\n                .appendFractionOfSecond(3, 9)\n                .appendTimeZoneOffset(\"Z\", false, 2, 2)\n                .toFormatter();\n        }\n        return bt;\n    }\n",
    "new_code_raw": "    public static DateTimeFormatter basicTime() {\n        return Constants.bt;\n    }\n"
  },
  {
    "id": "spajus_gmail4j-2-Associations-FirstSentence",
    "old_comment_raw": "Returns list of unread priority  GmailMessage objects",
    "new_comment_raw": "Returns list of unread/read priority  GmailMessage objects based on the  unreadOnly value",
    "old_code_raw": "    public List<GmailMessage> getPriorityMessages(){\n        try {\n            final List<GmailMessage> unreadPriority = new ArrayList<GmailMessage>();\n            final Store store = openGmailStore();\n            Folder folder = getFolder(ImapGmailLabel.IMPORTANT.getName(),store);\n            folder.open(Folder.READ_ONLY);\n            for (final Message msg : folder.search(new FlagTerm(\n                    new Flags(Flags.Flag.SEEN), false))) {\n                unreadPriority.add(new JavaMailGmailMessage(msg));\n            }\n            \n            return unreadPriority;\n        } catch (final Exception e) {\n            throw new GmailException(\"Failed getting unread priority messages\", e);\n        }\n    }\n",
    "new_code_raw": "    public List<GmailMessage> getPriorityMessages(boolean unreadOnly){\n        try {\n            final List<GmailMessage> priorityMessages = new ArrayList<GmailMessage>();\n            final Store store = openGmailStore();\n            Folder folder = getFolder(ImapGmailLabel.IMPORTANT.getName(),store);\n            folder.open(Folder.READ_ONLY); \n            for (final Message msg : folder.search(new FlagTerm(\n                    new Flags(Flags.Flag.SEEN), !unreadOnly))) {\n                priorityMessages.add(new JavaMailGmailMessage(msg));\n            }\n            \n            return priorityMessages;\n        } catch (final Exception e) {\n            throw new GmailException(\"Failed getting priority messages\", e);\n        }\n    }\n\n"
  },
  {
    "id": "Atmosphere_atmosphere-673-FirstSentence-0",
    "old_comment_raw": "All proprietary Comet based  Servlet must invoke the cancelled method when the underlying WebServer detect that the client closed the connection.",
    "new_comment_raw": "All proprietary Comet based  Servlet must invoke the cancelled method when the underlying WebServer detect that the client closed the connection.",
    "old_code_raw": "    public Action cancelled(AtmosphereRequest req, AtmosphereResponse res)\n            throws IOException, ServletException {\n\n        synchronized (req) {\n            SessionTimeoutSupport.restoreTimeout(req);\n\n            AtmosphereResourceImpl r = null;\n            try {\n                if (trackActiveRequest) {\n                    try {\n                        long l = (Long) req.getAttribute(MAX_INACTIVE);\n                        if (l == -1) {\n                            // The closedDetector closed the connection.\n                            return timedoutAction;\n                        }\n                        req.setAttribute(MAX_INACTIVE, (long) -1);\n                        // GlassFish\n                    } catch (NullPointerException ex) {\n                        // Request is no longer active, return\n                        return cancelledAction;\n\n                    }\n                }\n\n                r = (AtmosphereResourceImpl) req.resource();\n                if (r != null) {\n                    logger.debug(\"Cancelling the connection for AtmosphereResource {}\", r.uuid());\n\n                    if (r.isCancelled()) {\n                        logger.trace(\"{} is already cancelled\", r.uuid());\n                        return cancelledAction;\n                    }\n                    r.getAtmosphereResourceEvent().setCancelled(true);\n                    invokeAtmosphereHandler(r);\n\n                    try {\n                        r.getResponse().getOutputStream().close();\n                    } catch (Throwable t) {\n                        try {\n                            r.getResponse().getWriter().close();\n                        } catch (Throwable t2) {\n                        }\n                    }\n                }  else {\n                    logger.debug(\"AtmosphereResource was null, failed to cancel AtmosphereRequest {}\", req);\n                }\n            } catch (Throwable ex) {\n                // Something wrong happenned, ignore the exception\n                logger.debug(\"failed to cancel resource: {}\", r == null ? \"\" : r.uuid() , ex);\n            } finally {\n                config.framework().notify(Action.TYPE.CANCELLED, req, res);\n                try {\n                    if (r != null) {\n                        r.notifyListeners();\n                        r.setIsInScope(false);\n                        r.cancel();\n                    }\n                } catch (Throwable t) {\n                    logger.debug(\"cancel\", t);\n                } finally {\n                    if (r != null) {\n                        r._destroy();\n                    }\n                }\n            }\n        }\n\n        return cancelledAction;\n    }\n",
    "new_code_raw": "    public Action cancelled(AtmosphereRequest req, AtmosphereResponse res)\n            throws IOException, ServletException {\n\n        synchronized (req) {\n            SessionTimeoutSupport.restoreTimeout(req);\n\n            AtmosphereResourceImpl r = null;\n            try {\n                if (trackActiveRequest) {\n                    long l = (Long) req.getAttribute(MAX_INACTIVE);\n                    if (l == -1) {\n                        // The closedDetector closed the connection.\n                        return timedoutAction;\n                    }\n                    req.setAttribute(MAX_INACTIVE, (long) -1);\n                }\n\n                logger.debug(\"Cancelling the connection for request {}\", req);\n\n                r = (AtmosphereResourceImpl) req.resource();\n                if (r != null) {\n                    r.getAtmosphereResourceEvent().setCancelled(true);\n                    invokeAtmosphereHandler(r);\n\n                    try {\n                        r.getResponse().getOutputStream().close();\n                    } catch (Throwable t) {\n                        try {\n                            r.getResponse().getWriter().close();\n                        } catch (Throwable t2) {\n                        }\n                    }\n                }\n            } catch (Throwable ex) {\n                // Something wrong happenned, ignore the exception\n                logger.debug(\"failed to cancel resource: \" + r, ex);\n            } finally {\n                config.framework().notify(Action.TYPE.CANCELLED, req, res);\n                try {\n                    if (r != null) {\n                        r.notifyListeners();\n                        r.setIsInScope(false);\n                        r.cancel();\n                    }\n                } catch (Throwable t) {\n                    logger.trace(\"cancel\", t);\n                } finally {\n                    if (r != null) {\n                        destroyResource(r);\n                    }\n                }\n            }\n        }\n\n        return cancelledAction;\n    }\n"
  },
  {
    "id": "apache_empire-db-13-Associations-FirstSentence",
    "old_comment_raw": "Returns a one dimensional array from an sql query.",
    "new_comment_raw": "Adds the first column of a query result to a collection.",
    "old_code_raw": "    public <T> List<T> querySimpleList(Class<T> c, String sqlCmd, Connection conn)\n    {   // Execute the  Statement\n        if (checkOpen()==false)\n            return null;\n        // Debug\n        ResultSet rs = null;\n        try\n        {\t// Check Open\n            if (checkOpen()==false)\n                return null;\n            // Debug\n            long start = System.currentTimeMillis();\n            if (log.isInfoEnabled())\n                log.info(\"executing: \" + sqlCmd);\n            // Get the next Value\n            rs = driver.executeQuery(sqlCmd, null, false, conn);\n            if (rs == null)\n            { // Error\n                error(driver);\n                return null;\n            }\n            // Check Result\n            List<T> result = new ArrayList<T>();\n            while (rs.next())\n            {\n                T item = ObjectUtils.convert(c, rs.getObject(1));\n                result.add(item);\n            }\n            // No Value\n            if (log.isInfoEnabled())\n                log.info(\"querySimpleList retured \"+String.valueOf(result.size())+\" items. Query completed in \" + String.valueOf(System.currentTimeMillis() - start) + \" ms\");\n            clearError();\n            return result;\n        } catch (ClassCastException e) \n        {   \n            log.error(\"querySingleValue cast exception: \", e);\n            error(Errors.Exception, e);\n            return null;\n        } catch (SQLException e) \n        {\n            log.error(\"querySimpleList exception: \", e);\n            error(DBErrors.QueryFailed, e);\n            return null;\n        } finally\n        { // Cleanup\n            closeResultSet(rs);\n        }\n    }\n",
    "new_code_raw": "    public <T> int querySimpleList(Class<T> c, String sqlCmd, Connection conn, Collection<T> result)\n    {   // Check status\n        if (checkOpen()==false)\n            return -1;\n        // Start query\n        ResultSet rs = null;\n        try\n        {   // Log performance\n            long start = System.currentTimeMillis();\n            if (log.isInfoEnabled())\n                log.info(\"executing: \" + sqlCmd);\n            // Get the next Value\n            rs = driver.executeQuery(sqlCmd, null, false, conn);\n            if (rs == null)\n            { // Error\n                error(driver);\n                return -1;\n            }\n            // Check Result\n            int count=0;\n            while (rs.next())\n            {\n                T item = ObjectUtils.convert(c, rs.getObject(1));\n                result.add(item);\n                count++;\n            }\n            // No Value\n            if (log.isInfoEnabled())\n                log.info(\"querySimpleList retured \"+String.valueOf(count)+\" items. Query completed in \" + String.valueOf(System.currentTimeMillis() - start) + \" ms\");\n            clearError();\n            return count;\n        } catch (ClassCastException e) \n        {   \n            log.error(\"querySingleValue cast exception: \", e);\n            error(Errors.Exception, e);\n            return -1;\n        } catch (SQLException e) \n        {\n            log.error(\"querySimpleList exception: \", e);\n            error(DBErrors.QueryFailed, e);\n            return -1;\n        } finally\n        { // Cleanup\n            closeResultSet(rs);\n        }\n    }\n\n"
  },
  {
    "id": "RobotiumTech_robotium-1314-FirstSentence-0",
    "old_comment_raw": "Scrolls up the screen.",
    "new_comment_raw": "Scrolls up the screen.",
    "old_code_raw": "\tpublic boolean scrollUp(){\n\t\treturn scroller.scrollUp();\n\t}\n",
    "new_code_raw": "\tpublic boolean scrollUp(){\n\t\treturn scroller.scroll(Scroller.Direction.UP);\n\t}\n"
  },
  {
    "id": "twitter_commons-40-Associations-FirstSentence",
    "old_comment_raw": "Returns a new TwitterTokenStream which provides the same output as the original TwitterTokenStream.",
    "new_comment_raw": "Returns a new TokenStream which provides the same output as the original TokenStream.",
    "old_code_raw": "  public TwitterTokenStream duplicate() {\n    DuplicatedTokenStream duplicate = new DuplicatedTokenStream(inputStream);\n    duplicatedStreams.add(duplicate);\n\n    return duplicate;\n  }\n",
    "new_code_raw": "  public TokenStream duplicate() {\n    DuplicatedTokenStream duplicate = new DuplicatedTokenStream(inputStream);\n    duplicatedStreams.add(duplicate);\n\n    return duplicate;\n  }\n\n"
  },
  {
    "id": "sarxos_webcam_capture-16-FirstSentence-0",
    "old_comment_raw": "Is discovery service running?",
    "new_comment_raw": "Is discovery service running?",
    "old_code_raw": "\tpublic boolean isRunning() {\n\t\treturn running;\n\t}\n",
    "new_code_raw": "\tpublic boolean isRunning() {\n\t\treturn running.get();\n\t}\n"
  },
  {
    "id": "JodaOrg_joda_time-451-FirstSentence-0",
    "old_comment_raw": "Removes a converter from the set of converters, by index.",
    "new_comment_raw": "Removes a converter from the set of converters.",
    "old_code_raw": "    public InstantConverter removeInstantConverter(int index) throws SecurityException {\n        checkAlterInstantConverters();\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(index, removed);\n        return removed[0];\n    }\n",
    "new_code_raw": "    public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }\n"
  },
  {
    "id": "apache_avro-33-FirstSentence-0",
    "old_comment_raw": "Gets the writer schema of the AvroKey datum that is being serialized/deserialized.",
    "new_comment_raw": "Gets the writer schema of the AvroKey datum that is being serialized/deserialized.",
    "old_code_raw": "  public static Schema getKeyWriterSchema(Configuration conf) {\n    String json = conf.get(CONF_KEY_WRITER_SCHEMA);\n    return null == json ? null : Schema.parse(json);\n  }\n",
    "new_code_raw": "  public static Schema getKeyWriterSchema(Configuration conf) {\n    String json = conf.get(CONF_KEY_WRITER_SCHEMA);\n    return null == json ? null : new Schema.Parser().parse(json);\n  }\n"
  },
  {
    "id": "dustin_java-memcached-client-0-Associations-FirstSentence",
    "old_comment_raw": "Get the values for multiple keys from the cache.",
    "new_comment_raw": "Get with a single key.",
    "old_code_raw": "\tpublic Map<String, Object> get(String... keys) {\n\t\tfinal Map<String, Object> rv=new ConcurrentHashMap<String, Object>();\n\t\tfinal AtomicInteger requests=new AtomicInteger();\n\t\tfinal SynchronizationObject<AtomicInteger> sync\n\t\t\t=new SynchronizationObject<AtomicInteger>(requests);\n\t\tGetOperation.Callback cb=new GetOperation.Callback() {\n\t\t\t\tpublic void getComplete() {\n\t\t\t\t\trequests.decrementAndGet();\n\t\t\t\t\tsync.set(requests);\n\t\t\t\t}\n\t\t\t\tpublic void gotData(String k, int flags, byte[] data) {\n\t\t\t\t\trv.put(k, transcoder.decode(new CachedData(flags, data)));\n\t\t\t\t}\n\t\t};\n\t\t// Break the gets down into groups by key\n\t\tMap<Integer, Collection<String>> chunks\n\t\t\t=new HashMap<Integer, Collection<String>>();\n\t\tfor(String key : keys) {\n\t\t\tint which=getServerForKey(key);\n\t\t\tCollection<String> ks=chunks.get(which);\n\t\t\tif(ks == null) {\n\t\t\t\tks=new ArrayList<String>();\n\t\t\t\tchunks.put(which, ks);\n\t\t\t}\n\t\t\tks.add(key);\n\t\t}\n\t\tfor(Map.Entry<Integer, Collection<String>> me : chunks.entrySet()) {\n\t\t\trequests.incrementAndGet();\n\t\t\taddOp(me.getKey(), new GetOperation(me.getValue(), cb));\n\t\t}\n\t\ttry {\n\t\t\tsync.waitUntilTrue(\n\t\t\t\t\tnew SynchronizationObject.Predicate<AtomicInteger>() {\n\t\t\t\t\t\tpublic boolean evaluate(AtomicInteger val) {\n\t\t\t\t\t\t\treturn val.get() == 0;\n\t\t\t\t\t\t}},\n\t\t\t\t\tLong.MAX_VALUE, TimeUnit.SECONDS);\n\t\t} catch (InterruptedException e) {\n\t\t\tthrow new RuntimeException(\"Interrupted waiting for results\", e);\n\t\t} catch (TimeoutException e) {\n\t\t\tthrow new RuntimeException(\"Timed out waiting forever\", e);\n\t\t}\n\t\treturn rv;\n\t}\n",
    "new_code_raw": "\tpublic Object get(long timeout, String key) throws TimeoutException {\n\t\tSynchronizationObject<CachedData[]> sync=setupGet(key);\n\t\twaitForNotNull(timeout, sync);\n\t\tCachedData[] rvContainer=sync.get();\n\t\tassert rvContainer.length == 1;\n\t\tObject rv=null;\n\t\tif(rvContainer[0] != null) {\n\t\t\trv=transcoder.decode(rvContainer[0]);\n\t\t}\n\t\treturn rv;\n\t}\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2181-FirstSentence-0",
    "old_comment_raw": "Output the proper model name (capitalized).",
    "new_comment_raw": "Output the proper model name (capitalized).",
    "old_code_raw": "    public String toModelName(final String name) {\n        String result = super.toModelName(name);\n        if (result.matches(\"^\\\\d.*\") || result.startsWith(\"_\")) {\n            result = \"Model_\" + result;\n        }\n        return result.replaceAll(\"[\\\\.-]\", \"_\").replaceAll(\"__+\", \"_\");\n    }\n",
    "new_code_raw": "    public String toModelName(final String name) {\n        String result = camelize(sanitizeName(name));\n\n        if (!StringUtils.isEmpty(modelNamePrefix)) {\n            result = modelNamePrefix + \"_\" + result;\n        }\n\n        // model name cannot use reserved keyword, e.g. return\n        if (isReservedWord(name)) {\n            String modelName = \"Model_\" + result;\n            LOGGER.warn(name + \" (reserved word) cannot be used as model name. Renamed to \" + modelName);\n            return modelName;\n        }\n\n        // model name starts with number\n        if (result.matches(\"^\\\\d.*\")) {\n            String modelName = \"Model_\" + result; // e.g. 200Response => Model_200Response (after camelize)\n            LOGGER.warn(name + \" (model name starts with number) cannot be used as model name. Renamed to \" + modelName);\n            return modelName;\n        }\n\n        if (languageSpecificPrimitives.contains(result)) {\n            String modelName = \"Model_\" + result;\n            LOGGER.warn(name + \" (model name matches existing language type) cannot be used as a model name. Renamed to \" + modelName);\n            return modelName;\n        }\n\n        if (!StringUtils.isEmpty(modelNameSuffix)) {\n            result = result + \"_\" + modelNameSuffix;\n        }\n\n        return result;\n    }\n"
  },
  {
    "id": "realityforge_arez-33-Associations-FirstSentence",
    "old_comment_raw": "Invoke  #observe() on the supplied object.",
    "new_comment_raw": "Invoke  #observe() on the supplied object if any.",
    "old_code_raw": "  static boolean observe( @Nonnull final Object object )\n  {\n    return asComponentObservable( object ).observe();\n  }\n",
    "new_code_raw": "  static boolean observe( @Nullable final Object object )\n  {\n    return !( object instanceof ComponentObservable ) || asComponentObservable( object ).observe();\n  }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2625-FirstSentence-0",
    "old_comment_raw": "uploads an image",
    "new_comment_raw": "uploads an image",
    "old_code_raw": "  public void uploadFile (Long petId, String additionalMetadata, File file) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = null;\n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'petId' when calling uploadFile\",\n        new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFile\"));\n    }\n\n    // create path and map variables\n    String path = \"/pet/{petId}/uploadImage\".replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString()));\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n      \"multipart/form-data\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      if (additionalMetadata != null) {\n        localVarBuilder.addTextBody(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      if (file != null) {\n        localVarBuilder.addBinaryBody(\"file\", file);\n      }\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n      formParams.put(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata));\n    }\n\n    String[] authNames = new String[] { \"petstore_auth\" };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n       if (ex.getCause() instanceof VolleyError) {\n         VolleyError volleyError = (VolleyError)ex.getCause();\n         if (volleyError.networkResponse != null) {\n           throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n         }\n       }\n       throw ex;\n    } catch (TimeoutException ex) {\n       throw ex;\n    }\n  }\n",
    "new_code_raw": "  public ApiResponse uploadFile (Long petId, String additionalMetadata, File file) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = null;\n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'petId' when calling uploadFile\",\n        new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFile\"));\n    }\n\n    // create path and map variables\n    String path = \"/pet/{petId}/uploadImage\".replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString()));\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n      \"multipart/form-data\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      if (additionalMetadata != null) {\n        localVarBuilder.addTextBody(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      if (file != null) {\n        localVarBuilder.addBinaryBody(\"file\", file);\n      }\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n      formParams.put(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata));\n    }\n\n    String[] authNames = new String[] { \"petstore_auth\" };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return (ApiResponse) ApiInvoker.deserialize(localVarResponse, \"\", ApiResponse.class);\n      } else {\n         return null;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n"
  },
  {
    "id": "greatman_Craftconomy-0-Associations-FirstSentence",
    "old_comment_raw": "Get the player balance.",
    "new_comment_raw": "Get the default balance in the specific world",
    "old_code_raw": "\tpublic double getBalance()\r\n\t{\r\n\t\treturn balance;\r\n\t}\r\n",
    "new_code_raw": "\tpublic double getBalance(World world)\r\n\t{\r\n\t\tif (!Config.multiWorld)\r\n\t\t\treturn getBalance(CurrencyHandler.getCurrency(Config.currencyDefault, true));\r\n\t\treturn getBalance(CurrencyHandler.getCurrency(Config.currencyDefault, true),world);\r\n\t}\r\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2075-FirstSentence-0",
    "old_comment_raw": "Checks whether property names have breaking characters like ':', '-'.",
    "new_comment_raw": "Checks whether property names have breaking characters like ':', '-'.",
    "old_code_raw": "    private boolean propertyHasBreakingCharacters(String str) {\n        final String regex = \"^.*[+*:;,.()-]+.*$\";\n        final Pattern pattern = Pattern.compile(regex);\n        final Matcher matcher = pattern.matcher(str);\n        boolean matches = matcher.matches();\n        return matches;\n    }\n",
    "new_code_raw": "    private boolean propertyHasBreakingCharacters(String str) {\n        final String regex = \"^.*[+*:;,.()-]+.*$\";\n        final Pattern pattern = Pattern.compile(regex);\n        final Matcher matcher = pattern.matcher(str);\n        return matcher.matches();\n    }\n"
  },
  {
    "id": "heuermh_ensembl-rest-client-8-Associations-FirstSentence",
    "old_comment_raw": "Create and return a new sequence service with the default server URL.",
    "new_comment_raw": "Create and return a new sequence service with the default endpoint URL.",
    "old_code_raw": "    public SequenceService createSequenceService() {\n        return createSequenceService(defaultServerUrl);\n    }\n",
    "new_code_raw": "    public SequenceService createSequenceService() {\n        return createSequenceService(defaultEndpointUrl);\n    }\n\n"
  },
  {
    "id": "processing_processing-45-FirstSentence-0",
    "old_comment_raw": "Return a scanner for creating Processing partitions.",
    "new_comment_raw": "Return a scanner for creating Processing partitions.",
    "old_code_raw": "\t public ProcessingPartitionScanner getProcessingPartitionScanner() {\n\t\tif (fPartitionScanner == null)\n\t\t\tfPartitionScanner= new ProcessingPartitionScanner();\n\t\treturn fPartitionScanner;\n\t}\n",
    "new_code_raw": "\t public ProcessingPartitionScanner getProcessingPartitionScanner() {\n\t\treturn (fPartitionScanner == null) ? new ProcessingPartitionScanner() : fPartitionScanner;\n\t}\n"
  },
  {
    "id": "apache_lenya-365-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Obtain the reader",
    "old_code_raw": "    public Reader getReader() {\n        debug(\"\\nContents: \" + contentsBuffer.toString());\n\n        return new StringReader(contentsBuffer.toString());\n    }\n",
    "new_code_raw": "    public Reader getReader() {\n        debug(\"\\nContents: \" + this.contentsBuffer.toString());\n\n        return new StringReader(this.contentsBuffer.toString());\n    }\n\n"
  },
  {
    "id": "apache_avro-50-FirstSentence-0",
    "old_comment_raw": "Takes a  Resolver.Action for resolving two schemas and returns the start symbol for a grammar that implements that resolution.",
    "new_comment_raw": "Takes a  Resolver.Action for resolving two schemas and returns the start symbol for a grammar that implements that resolution.",
    "old_code_raw": "  private Symbol generate(Resolver.Action action, Map<Object, Symbol> seen) throws IOException {\n    if (action instanceof Resolver.DoNothing) {\n      return simpleGen(action.writer, seen);\n\n    } else if (action instanceof Resolver.ErrorAction) {\n      return Symbol.error(action.toString());\n\n    } else if (action instanceof Resolver.Skip) {\n      return Symbol.skipAction(simpleGen(action.writer, seen));\n\n    } else if (action instanceof Resolver.Promote) {\n      return Symbol.resolve(simpleGen(action.writer, seen), simpleGen(action.reader, seen));\n\n    } else if (action.writer.getType() == Schema.Type.ARRAY) {\n      Symbol es = generate(((Resolver.Container) action).elementAction, seen);\n      return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END, es), Symbol.ARRAY_START);\n\n    } else if (action.writer.getType() == Schema.Type.MAP) {\n      Symbol es = generate(((Resolver.Container) action).elementAction, seen);\n      return Symbol.seq(Symbol.repeat(Symbol.MAP_END, es, Symbol.STRING), Symbol.MAP_START);\n\n    } else if (action.writer.getType() == Schema.Type.UNION) {\n      if (((Resolver.WriterUnion) action).unionEquiv)\n        return simpleGen(action.writer, seen);\n      Resolver.Action[] branches = ((Resolver.WriterUnion) action).actions;\n      Symbol[] symbols = new Symbol[branches.length];\n      String[] labels = new String[branches.length];\n      int i = 0;\n      for (Resolver.Action branch : branches) {\n        symbols[i] = generate(branch, seen);\n        labels[i] = action.writer.getTypes().get(i).getFullName();\n        i++;\n      }\n      return Symbol.seq(Symbol.alt(symbols, labels), Symbol.WRITER_UNION_ACTION);\n\n    } else if (action instanceof Resolver.ReaderUnion) {\n      Resolver.ReaderUnion ru = (Resolver.ReaderUnion) action;\n      Symbol s = generate(ru.actualAction, seen);\n      return Symbol.seq(Symbol.unionAdjustAction(ru.firstMatch, s), Symbol.UNION);\n\n    } else if (action instanceof Resolver.EnumAdjust) {\n      Resolver.EnumAdjust e = (Resolver.EnumAdjust) action;\n      Object[] adjs = new Object[e.adjustments.length];\n      for (int i = 0; i < adjs.length; i++)\n        adjs[i] = (0 <= e.adjustments[i] ? new Integer(e.adjustments[i])\n            : \"No match for \" + e.writer.getEnumSymbols().get(i));\n      return Symbol.seq(Symbol.enumAdjustAction(e.reader.getEnumSymbols().size(), adjs), Symbol.ENUM);\n\n    } else if (action instanceof Resolver.RecordAdjust) {\n      Symbol result = seen.get(action);\n      if (result == null) {\n        final Resolver.RecordAdjust ra = (Resolver.RecordAdjust) action;\n        int defaultCount = ra.readerOrder.length - ra.firstDefault;\n        int count = 1 + ra.fieldActions.length + 3 * defaultCount;\n        Symbol[] production = new Symbol[count];\n        result = Symbol.seq(production);\n        seen.put(action, result);\n        production[--count] = Symbol.fieldOrderAction(ra.readerOrder);\n        for (Resolver.Action wfa : ra.fieldActions)\n          production[--count] = generate(wfa, seen);\n        for (int i = ra.firstDefault; i < ra.readerOrder.length; i++) {\n          Schema.Field rf = ra.readerOrder[i];\n          byte[] bb = getBinary(rf.schema(), Accessor.defaultValue(rf));\n          production[--count] = Symbol.defaultStartAction(bb);\n          production[--count] = simpleGen(rf.schema(), seen);\n          production[--count] = Symbol.DEFAULT_END_ACTION;\n        }\n      }\n      return result;\n    }\n\n    throw new IllegalArgumentException(\"Unrecognized Resolver.Action: \" + action);\n  }\n",
    "new_code_raw": "  private Symbol generate(Resolver.Action action, Map<Object, Symbol> seen) throws IOException {\n    if (action instanceof Resolver.DoNothing) {\n      return simpleGen(action.writer, seen);\n\n    } else if (action instanceof Resolver.ErrorAction) {\n      return Symbol.error(action.toString());\n\n    } else if (action instanceof Resolver.Skip) {\n      return Symbol.skipAction(simpleGen(action.writer, seen));\n\n    } else if (action instanceof Resolver.Promote) {\n      return Symbol.resolve(simpleGen(action.writer, seen), simpleGen(action.reader, seen));\n\n    } else if (action instanceof Resolver.ReaderUnion) {\n      Resolver.ReaderUnion ru = (Resolver.ReaderUnion) action;\n      Symbol s = generate(ru.actualAction, seen);\n      return Symbol.seq(Symbol.unionAdjustAction(ru.firstMatch, s), Symbol.UNION);\n\n    } else if (action.writer.getType() == Schema.Type.ARRAY) {\n      Symbol es = generate(((Resolver.Container) action).elementAction, seen);\n      return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END, es), Symbol.ARRAY_START);\n\n    } else if (action.writer.getType() == Schema.Type.MAP) {\n      Symbol es = generate(((Resolver.Container) action).elementAction, seen);\n      return Symbol.seq(Symbol.repeat(Symbol.MAP_END, es, Symbol.STRING), Symbol.MAP_START);\n\n    } else if (action.writer.getType() == Schema.Type.UNION) {\n      if (((Resolver.WriterUnion) action).unionEquiv)\n        return simpleGen(action.writer, seen);\n      Resolver.Action[] branches = ((Resolver.WriterUnion) action).actions;\n      Symbol[] symbols = new Symbol[branches.length];\n      String[] labels = new String[branches.length];\n      int i = 0;\n      for (Resolver.Action branch : branches) {\n        symbols[i] = generate(branch, seen);\n        labels[i] = action.writer.getTypes().get(i).getFullName();\n        i++;\n      }\n      return Symbol.seq(Symbol.alt(symbols, labels), Symbol.WRITER_UNION_ACTION);\n    } else if (action instanceof Resolver.EnumAdjust) {\n      Resolver.EnumAdjust e = (Resolver.EnumAdjust) action;\n      Object[] adjs = new Object[e.adjustments.length];\n      for (int i = 0; i < adjs.length; i++)\n        adjs[i] = (0 <= e.adjustments[i] ? new Integer(e.adjustments[i])\n            : \"No match for \" + e.writer.getEnumSymbols().get(i));\n      return Symbol.seq(Symbol.enumAdjustAction(e.reader.getEnumSymbols().size(), adjs), Symbol.ENUM);\n\n    } else if (action instanceof Resolver.RecordAdjust) {\n      Symbol result = seen.get(action);\n      if (result == null) {\n        final Resolver.RecordAdjust ra = (Resolver.RecordAdjust) action;\n        int defaultCount = ra.readerOrder.length - ra.firstDefault;\n        int count = 1 + ra.fieldActions.length + 3 * defaultCount;\n        Symbol[] production = new Symbol[count];\n        result = Symbol.seq(production);\n        seen.put(action, result);\n        production[--count] = Symbol.fieldOrderAction(ra.readerOrder);\n        for (Resolver.Action wfa : ra.fieldActions)\n          production[--count] = generate(wfa, seen);\n        for (int i = ra.firstDefault; i < ra.readerOrder.length; i++) {\n          Schema.Field rf = ra.readerOrder[i];\n          byte[] bb = getBinary(rf.schema(), Accessor.defaultValue(rf));\n          production[--count] = Symbol.defaultStartAction(bb);\n          production[--count] = simpleGen(rf.schema(), seen);\n          production[--count] = Symbol.DEFAULT_END_ACTION;\n        }\n      }\n      return result;\n    }\n\n    throw new IllegalArgumentException(\"Unrecognized Resolver.Action: \" + action);\n  }\n"
  },
  {
    "id": "apache_axis1-java-86-Associations-FirstSentence",
    "old_comment_raw": "Not implemented yet",
    "new_comment_raw": "Return either an instance of a generated stub, if it can be found, or a dynamic proxy for the given proxy interface.",
    "old_code_raw": "    public Remote getPort(QName portName, Class proxyInterface)\n                           throws ServiceException {\n        return getPort(null, portName, proxyInterface);\n    }\n",
    "new_code_raw": "    public Remote getPort(QName portName, Class proxyInterface)\n                           throws ServiceException {\n        // First, try to find a generated stub.  If that\n        // returns null, then find a dynamic stub.\n        Remote stub = getGeneratedStub(portName, proxyInterface);\n        return stub != null ? stub : getPort(null, portName, proxyInterface);\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2167-FirstSentence-0",
    "old_comment_raw": "Test serialization of outer number types 200 - Output number",
    "new_comment_raw": "Test serialization of outer number types 200 - Output number",
    "old_code_raw": "    public Mono<BigDecimal> fakeOuterNumberSerialize(BigDecimal body) throws RestClientException {\n        Object postBody = body;\n        \n        String path = UriComponentsBuilder.fromPath(\"/fake/outer/number\").build().toUriString();\n\n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"*/*\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<BigDecimal> returnType = new ParameterizedTypeReference<BigDecimal>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "new_code_raw": "    public Mono<BigDecimal> fakeOuterNumberSerialize(BigDecimal body) throws RestClientException {\n        Object postBody = body;\n        \n        // create path and map variables\n        final Map<String, Object> pathParams = new HashMap<String, Object>();\n\n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"*/*\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<BigDecimal> returnType = new ParameterizedTypeReference<BigDecimal>() {};\n        return apiClient.invokeAPI(\"/fake/outer/number\", HttpMethod.POST, pathParams, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType);\n    }\n"
  },
  {
    "id": "processing_processing-189-FirstSentence-0",
    "old_comment_raw": "A classpath, separated by the path separator, will contain a series of .jar/.zip files or directories containing .class files, or containing subdirectories that have .class files.",
    "new_comment_raw": "A classpath, separated by the path separator, will contain a series of .jar/.zip files or directories containing .class files, or containing subdirectories that have .class files.",
    "old_code_raw": "  static public String[] packageListFromClassPath(String path) {\n    Map<String, Object> map = new HashMap<String, Object>();\n    String pieces[] =\n      PApplet.split(path, File.pathSeparatorChar);\n\n    for (int i = 0; i < pieces.length; i++) {\n      //System.out.println(\"checking piece '\" + pieces[i] + \"'\");\n      if (pieces[i].length() == 0) continue;\n\n      if (pieces[i].toLowerCase().endsWith(\".jar\") ||\n          pieces[i].toLowerCase().endsWith(\".zip\")) {\n        //System.out.println(\"checking \" + pieces[i]);\n        packageListFromZip(pieces[i], map);\n\n      } else {  // it's another type of file or directory\n        File dir = new File(pieces[i]);\n        if (dir.exists() && dir.isDirectory()) {\n          packageListFromFolder(dir, null, map);\n          //importCount = magicImportsRecursive(dir, null,\n          //                                  map);\n                                              //imports, importCount);\n        }\n      }\n    }\n    int mapCount = map.size();\n    String output[] = new String[mapCount];\n    int index = 0;\n    Set<String> set = map.keySet();\n    for (String s : set) {\n      output[index++] = s.replace('/', '.');\n    }\n    //System.arraycopy(imports, 0, output, 0, importCount);\n    //PApplet.printarr(output);\n    return output;\n  }\n",
    "new_code_raw": "  static public StringList packageListFromClassPath(String path) {\n//    Map<String, Object> map = new HashMap<String, Object>();\n    StringList list = new StringList();\n    String pieces[] =\n      PApplet.split(path, File.pathSeparatorChar);\n\n    for (int i = 0; i < pieces.length; i++) {\n      //System.out.println(\"checking piece '\" + pieces[i] + \"'\");\n      if (pieces[i].length() == 0) continue;\n\n      if (pieces[i].toLowerCase().endsWith(\".jar\") ||\n          pieces[i].toLowerCase().endsWith(\".zip\")) {\n        //System.out.println(\"checking \" + pieces[i]);\n        packageListFromZip(pieces[i], list);\n\n      } else {  // it's another type of file or directory\n        File dir = new File(pieces[i]);\n        if (dir.exists() && dir.isDirectory()) {\n          packageListFromFolder(dir, null, list);\n          //importCount = magicImportsRecursive(dir, null,\n          //                                  map);\n                                              //imports, importCount);\n        }\n      }\n    }\n//    int mapCount = map.size();\n//    String output[] = new String[mapCount];\n//    int index = 0;\n//    Set<String> set = map.keySet();\n//    for (String s : set) {\n//      output[index++] = s.replace('/', '.');\n//    }\n//    return output;\n    StringList outgoing = new StringList(list.size());\n    for (String item : list) {\n      outgoing.append(item.replace('/', '.'));\n    }\n    return outgoing;\n  }\n"
  },
  {
    "id": "biddyweb_checker-framework-128-Associations-FirstSentence",
    "old_comment_raw": "Check that the annotation in the Value Checker hierarchy has a value of some kind.",
    "new_comment_raw": "To make these numerous calls to check if an annotation is UnknownVal or ArrayLen a little nicer looking",
    "old_code_raw": "        private boolean nonValueAnno(AnnotatedTypeMirror mirror) {\n            AnnotationMirror valueAnno = getValueAnnotation(mirror);\n            return AnnotationUtils.areSameIgnoringValues(valueAnno, UNKNOWNVAL)\n                    || AnnotationUtils.areSameByClass(valueAnno,\n                            BottomVal.class)\n                    || AnnotationUtils\n                            .areSameIgnoringValues(\n                                    mirror.getAnnotationInHierarchy(ARRAYLEN),\n                                    ARRAYLEN);\n        }\n",
    "new_code_raw": "        private boolean nonValueAnno(AnnotatedTypeMirror mirror) {\n            return AnnotationUtils.areSameIgnoringValues(\n                    getValueAnnotation(mirror), UNKNOWNVAL)\n                    || AnnotationUtils\n                            .areSameIgnoringValues(\n                                    mirror.getAnnotationInHierarchy(ARRAYLEN),\n                                    ARRAYLEN);\n        }\n\n"
  },
  {
    "id": "daimajia_AndroidImageSlider-0-FirstSentence-0",
    "old_comment_raw": "get current slider.",
    "new_comment_raw": "get current slider.",
    "old_code_raw": "    public BaseSliderView getCurrentSlider(){\n\n        if(getRealAdapter() == null)\n            return null;\n\n        int count = getRealAdapter().getCount();\n        int realCount = mViewPager.getCurrentItem() % count;\n        return  getRealAdapter().getSliderView(realCount);\n    }\n",
    "new_code_raw": "    public BaseSliderView getCurrentSlider(){\n\n        if(getRealAdapter() == null)\n            throw new IllegalStateException(\"You did not set a slider adapter\");\n\n        int count = getRealAdapter().getCount();\n        int realCount = mViewPager.getCurrentItem() % count;\n        return  getRealAdapter().getSliderView(realCount);\n    }\n"
  },
  {
    "id": "SeleniumHQ_selenium-825-FirstSentence-0",
    "old_comment_raw": "UNIXy-only: walk a PATH to locate binaries with a specified name.",
    "new_comment_raw": "Walk a PATH to locate binaries with a specified name.",
    "old_code_raw": "  private static File findBinary(String... binaryNames) {\n    final String[] paths = System.getenv(\"PATH\").split(File.pathSeparator);\n    for (String binaryName : binaryNames) {\n      for (String path : paths) {\n        File file = new File(path, binaryName);\n        if (file.exists()) {\n          return file;\n        }\n      }\n    }\n    return null;\n  }\n",
    "new_code_raw": "  private static File findBinary(String... binaryNames) {\n    final String[] paths = System.getenv(\"PATH\").split(File.pathSeparator);\n    for (String binaryName : binaryNames) {\n      for (String path : paths) {\n        File file = new File(path, binaryName);\n        if (file.exists()) {\n          return file;\n        }\n        if (Platform.getCurrent().is(Platform.WINDOWS)) {\n          File exe = new File(path, binaryName + \".exe\");\n          if (exe.exists()) {\n            return exe;\n          }\n        }\n      }\n    }\n    return null;\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-946-FirstSentence-0",
    "old_comment_raw": "Gets the millis, which is the Calendar millis value.",
    "new_comment_raw": "Gets the millis, which is the Calendar millis value.",
    "old_code_raw": "    public long getInstantMillis(Object object, Chronology chrono) {\n        return ((Calendar) object).getTime().getTime();\n    }\n",
    "new_code_raw": "    public long getInstantMillis(Object object, Chronology chrono) {\n        Calendar calendar = (Calendar) object;\n        long millisLocal = calendar.getTime().getTime() +\n            calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);\n        DateTimeZone tz = DateTimeZone.forTimeZone(calendar.getTimeZone());\n        return millisLocal - tz.getOffsetFromLocal(millisLocal);\n    }\n"
  },
  {
    "id": "ariejan_slick2d-53-Associations-FirstSentence",
    "old_comment_raw": "Get the x location of the center of this circle",
    "new_comment_raw": "Get the x location of the left side of this shape.",
    "old_code_raw": "    public float getX() {\r\n        return center[0];\r\n    }\r\n",
    "new_code_raw": "    public float getX() {\r\n        if(left == null) {\r\n            calculateLeft();\r\n        }\r\n\r\n        return left.floatValue();\r\n    }\r\n\n"
  },
  {
    "id": "JodaOrg_joda_time-568-FirstSentence-0",
    "old_comment_raw": "Rounds to the lowest whole unit of this field on a copy of this DateTime.",
    "new_comment_raw": "Rounds to the lowest whole unit of this field on a copy of this DateTime.",
    "old_code_raw": "    public DateTime roundFloorCopy() {\n        DateTime instant = iInstant;\n        return (DateTime)instant.toCopy(iField.roundFloor(instant.getMillis()));\n    }\n",
    "new_code_raw": "    public DateTime roundFloorCopy() {\n        DateTime instant = iInstant;\n        return (DateTime)instant.withMillis(iField.roundFloor(instant.getMillis()));\n    }\n"
  },
  {
    "id": "timyates_groovy-stream-0-Associations-FirstSentence",
    "old_comment_raw": "Construct a  Stream that iterates every  Object in an array.",
    "new_comment_raw": "Construct a  Stream that for every element, returns  object.",
    "old_code_raw": "    @SuppressWarnings(\"unchecked\")\n    public static <T> Stream<T> from( T[] array ) {\n        return new Stream<T>( primitiveArrayToList( array ).iterator(), null ) ;\n    }\n",
    "new_code_raw": "    public static <T> Stream<T> from( T object ) {\n        return new Stream<T>( new RepeatingObjectIterator<T>( object ), null ) ;\n    }\n\n"
  },
  {
    "id": "apache_avro-10-FirstSentence-0",
    "old_comment_raw": "Gets the configured compression codec from the task context.",
    "new_comment_raw": "Gets the configured compression codec from the task context.",
    "old_code_raw": "  protected static CodecFactory getCompressionCodec(TaskAttemptContext context) {\n    if (FileOutputFormat.getCompressOutput(context)) {\n      // Deflate compression.\n      int compressionLevel = context.getConfiguration().getInt(\n          org.apache.avro.mapred.AvroOutputFormat.DEFLATE_LEVEL_KEY,\n          org.apache.avro.mapred.AvroOutputFormat.DEFAULT_DEFLATE_LEVEL);\n      return CodecFactory.deflateCodec(compressionLevel);\n    }\n\n    // No compression.\n    return CodecFactory.nullCodec();\n  }\n",
    "new_code_raw": "  protected static CodecFactory getCompressionCodec(TaskAttemptContext context) {\n    if (FileOutputFormat.getCompressOutput(context)) {\n      // Default to deflate compression.\n      String outputCodec = context.getConfiguration()\n        .get(AvroJob.CONF_OUTPUT_CODEC, DataFileConstants.DEFLATE_CODEC);\n      if (DataFileConstants.DEFLATE_CODEC.equals(outputCodec)) {\n        int compressionLevel = context.getConfiguration().getInt(\n            org.apache.avro.mapred.AvroOutputFormat.DEFLATE_LEVEL_KEY,\n            org.apache.avro.mapred.AvroOutputFormat.DEFAULT_DEFLATE_LEVEL);\n        return CodecFactory.deflateCodec(compressionLevel);\n      } else {\n        return CodecFactory.fromString(outputCodec);\n      }\n    }\n\n    // No compression.\n    return CodecFactory.nullCodec();\n  }\n"
  },
  {
    "id": "apache_drill-1427-FirstSentence-0",
    "old_comment_raw": "Function resolves the schema and invokes the drop method.",
    "new_comment_raw": "Function resolves the schema and invokes the drop method (while IF EXISTS statement is used function invokes the drop method only if table exists).",
    "old_code_raw": "  public PhysicalPlan getPlan(SqlNode sqlNode) throws ValidationException, RelConversionException, IOException {\n\n    SqlDropTable dropTableNode = ((SqlDropTable) sqlNode);\n    SqlIdentifier tableIdentifier = dropTableNode.getTableIdentifier();\n\n    SchemaPlus defaultSchema = config.getConverter().getDefaultSchema();\n    AbstractSchema drillSchema = null;\n\n    if (tableIdentifier != null) {\n      drillSchema = SchemaUtilites.resolveToMutableDrillSchema(defaultSchema, dropTableNode.getSchema());\n    }\n\n    String tableName = ((SqlDropTable) sqlNode).getName();\n    if (drillSchema == null) {\n      throw UserException.validationError()\n          .message(\"Invalid table_name [%s]\", tableName)\n          .build(logger);\n    }\n\n    drillSchema.dropTable(tableName);\n\n    return DirectPlan.createDirectPlan(context, true,\n        String.format(\"Table [%s] %s\", tableName, \"dropped\"));\n  }\n",
    "new_code_raw": "  public PhysicalPlan getPlan(SqlNode sqlNode) throws ValidationException, RelConversionException, IOException {\n\n    SqlDropTable dropTableNode = ((SqlDropTable) sqlNode);\n    SqlIdentifier tableIdentifier = dropTableNode.getTableIdentifier();\n\n    SchemaPlus defaultSchema = config.getConverter().getDefaultSchema();\n    AbstractSchema drillSchema = null;\n\n    if (tableIdentifier != null) {\n      drillSchema = SchemaUtilites.resolveToMutableDrillSchema(defaultSchema, dropTableNode.getSchema());\n    }\n\n    String tableName = dropTableNode.getName();\n    if (drillSchema == null) {\n      throw UserException.validationError()\n          .message(\"Invalid table_name [%s]\", tableName)\n          .build(logger);\n    }\n\n    if (dropTableNode.checkTableExistence()) {\n      final Table tableToDrop = SqlHandlerUtil.getTableFromSchema(drillSchema, tableName);\n      if (tableToDrop == null || tableToDrop.getJdbcTableType() != Schema.TableType.TABLE) {\n        return DirectPlan.createDirectPlan(context, true,\n            String.format(\"Table [%s] not found\", tableName));\n      }\n    }\n\n    drillSchema.dropTable(tableName);\n\n    return DirectPlan.createDirectPlan(context, true,\n        String.format(\"Table [%s] %s\", tableName, \"dropped\"));\n  }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2202-FirstSentence-0",
    "old_comment_raw": "Score the given input, returning both the classification decision and the probability of that decision.",
    "new_comment_raw": "Score the given input, returning both the classification decision and the probability of that decision.",
    "old_code_raw": "  public static void main(String[] args) throws IOException, ClassNotFoundException {\n    RedwoodConfiguration.standard().apply();  // Disable SLF4J crap.\n    ArgumentParser.fillOptions(KBPStatisticalExtractor.class, args);  // Fill command-line options\n\n    // Load the test (or dev) data\n    forceTrack(\"Test data\");\n    List<Pair<KBPInput, String>> testExamples = KBPRelationExtractor.readDataset(TEST_FILE);\n    log.info(\"Read \" + testExamples.size() + \" examples\");\n    endTrack(\"Test data\");\n\n    // If we can't find an existing model, train one\n    if (!IOUtils.existsInClasspathOrFileSystem(MODEL_FILE)) {\n      forceTrack(\"Training data\");\n      List<Pair<KBPInput, String>> trainExamples = KBPRelationExtractor.readDataset(TRAIN_FILE);\n      log.info(\"Read \" + trainExamples.size() + \" examples\");\n      log.info(\"\" + trainExamples.stream().map(Pair::second).filter(NO_RELATION::equals).count() + \" are \" + NO_RELATION);\n      endTrack(\"Training data\");\n\n      // Featurize + create the dataset\n      forceTrack(\"Creating dataset\");\n      RVFDataset<String, String> dataset = new RVFDataset<>();\n      final AtomicInteger i = new AtomicInteger(0);\n      long beginTime = System.currentTimeMillis();\n      trainExamples.stream().parallel().forEach(example -> {\n        if (i.incrementAndGet() % 1000 == 0) {\n          log.info(\"[\" + Redwood.formatTimeDifference(System.currentTimeMillis() - beginTime) +\n              \"] Featurized \" + i.get() + \" / \" + trainExamples.size() + \" examples\");\n        }\n        Counter<String> features = features(example.first);  // This takes a while per example\n        synchronized (dataset) {\n          dataset.add(new RVFDatum<>(features, example.second));\n        }\n      });\n      trainExamples.clear();  // Free up some memory\n      endTrack(\"Creating dataset\");\n\n      // Train the classifier\n      log.info(\"Training classifier:\");\n      Classifier<String, String> classifier = trainMultinomialClassifier(dataset, FEATURE_THRESHOLD, SIGMA);\n      dataset.clear();  // Free up some memory\n\n      // Save the classifier\n      IOUtils.writeObjectToFile(new KBPStatisticalExtractor(classifier), MODEL_FILE);\n    }\n\n    // Read either a newly-trained or pre-trained model\n    Object model = IOUtils.readObjectFromURLOrClasspathOrFileSystem(MODEL_FILE);\n    KBPStatisticalExtractor classifier;\n    if (model instanceof Classifier) {\n      //noinspection unchecked\n      classifier = new KBPStatisticalExtractor((Classifier<String, String>) model);\n    } else {\n      classifier = ((KBPStatisticalExtractor) model);\n    }\n\n    // Evaluate the model\n    forceTrack(\"Test accuracy\");\n    Accuracy accuracy = new Accuracy();\n    AtomicInteger testI = new AtomicInteger(0);\n    forceTrack(\"Featurizing\");\n    testExamples.stream().parallel().forEach( example -> {\n      Pair<String, Double> predicted = classifier.classify(example.first);\n      synchronized (accuracy) {\n        accuracy.predict(Collections.singleton(predicted.first), Collections.singleton(example.second));\n      }\n      if (testI.incrementAndGet() % 1000 == 0) {\n        log(\"[\" + testI.get() + \" / \" + testExamples.size() + \"]  \" + accuracy.toOneLineString());\n      }\n    });\n    endTrack(\"Featurizing\");\n    log(accuracy.toString());\n    endTrack(\"Test accuracy\");\n  }\n",
    "new_code_raw": "  public static void main(String[] args) throws IOException, ClassNotFoundException {\n    RedwoodConfiguration.standard().apply();  // Disable SLF4J crap.\n    ArgumentParser.fillOptions(KBPStatisticalExtractor.class, args);  // Fill command-line options\n\n    // Load the test (or dev) data\n    forceTrack(\"Test data\");\n    List<Pair<KBPInput, String>> testExamples = KBPRelationExtractor.readDataset(TEST_FILE);\n    log.info(\"Read \" + testExamples.size() + \" examples\");\n    endTrack(\"Test data\");\n\n    // If we can't find an existing model, train one\n    if (!IOUtils.existsInClasspathOrFileSystem(MODEL_FILE)) {\n      forceTrack(\"Training data\");\n      List<Pair<KBPInput, String>> trainExamples = KBPRelationExtractor.readDataset(TRAIN_FILE);\n      log.info(\"Read \" + trainExamples.size() + \" examples\");\n      log.info(\"\" + trainExamples.stream().map(Pair::second).filter(NO_RELATION::equals).count() + \" are \" + NO_RELATION);\n      endTrack(\"Training data\");\n\n      // Featurize + create the dataset\n      forceTrack(\"Creating dataset\");\n      RVFDataset<String, String> dataset = new RVFDataset<>();\n      final AtomicInteger i = new AtomicInteger(0);\n      long beginTime = System.currentTimeMillis();\n      trainExamples.stream().parallel().forEach(example -> {\n        if (i.incrementAndGet() % 1000 == 0) {\n          log.info(\"[\" + Redwood.formatTimeDifference(System.currentTimeMillis() - beginTime) +\n              \"] Featurized \" + i.get() + \" / \" + trainExamples.size() + \" examples\");\n        }\n        Counter<String> features = features(example.first);  // This takes a while per example\n        synchronized (dataset) {\n          dataset.add(new RVFDatum<>(features, example.second));\n        }\n      });\n      trainExamples.clear();  // Free up some memory\n      endTrack(\"Creating dataset\");\n\n      // Train the classifier\n      log.info(\"Training classifier:\");\n      Classifier<String, String> classifier = trainMultinomialClassifier(dataset, FEATURE_THRESHOLD, SIGMA);\n      dataset.clear();  // Free up some memory\n\n      // Save the classifier\n      IOUtils.writeObjectToFile(new KBPStatisticalExtractor(classifier), MODEL_FILE);\n    }\n\n    // Read either a newly-trained or pre-trained model\n    Object model = IOUtils.readObjectFromURLOrClasspathOrFileSystem(MODEL_FILE);\n    KBPStatisticalExtractor classifier;\n    if (model instanceof Classifier) {\n      //noinspection unchecked\n      classifier = new KBPStatisticalExtractor((Classifier<String, String>) model);\n    } else {\n      classifier = ((KBPStatisticalExtractor) model);\n    }\n\n    // Evaluate the model\n    classifier.computeAccuracy(testExamples.stream(), PREDICTIONS.map(x -> {\n      try {\n        return \"stdout\".equalsIgnoreCase(x) ? System.out : new PrintStream(new FileOutputStream(x));\n      } catch (IOException e) {\n        throw new RuntimeIOException(e);\n      }\n    }));\n  }\n"
  },
  {
    "id": "codehaus_cake-4-Associations-FirstSentence",
    "old_comment_raw": "Analogous to  #get(WithAttributes) except returning a primitive char.",
    "new_comment_raw": "Extracts the attribute map from the specified  WithAttributes and returns the value of this attribute from the map.",
    "old_code_raw": "    public char get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n",
    "new_code_raw": "    public char get(WithAttributes withAttributes) {\r\n        return withAttributes.getAttributes().get(this);\r\n    }\r\n\n"
  },
  {
    "id": "apache_calcite-818-FirstSentence-0",
    "old_comment_raw": "Determines the origin of a  RelNode, provided it maps to a single table, optionally with filtering and projection.",
    "new_comment_raw": "Determines the origin of a  RelNode, provided it maps to a single table, optionally with filtering and projection.",
    "old_code_raw": "  public RelOptTable getTableOrigin(RelNode rel) {\n    // Determine the simple origin of the first column in the\n    // RelNode.  If it's simple, then that means that the underlying\n    // table is also simple, even if the column itself is derived.\n    final Set<RelColumnOrigin> colOrigins = getColumnOrigins(rel, 0);\n    if (colOrigins == null || colOrigins.size() == 0) {\n      return null;\n    }\n    return colOrigins.iterator().next().getOriginTable();\n  }\n",
    "new_code_raw": "  public RelOptTable getTableOrigin(RelNode rel) {\n    // Determine the simple origin of the first column in the\n    // RelNode.  If it's simple, then that means that the underlying\n    // table is also simple, even if the column itself is derived.\n    if (rel.getRowType().getFieldCount() == 0) {\n      return null;\n    }\n    final Set<RelColumnOrigin> colOrigins = getColumnOrigins(rel, 0);\n    if (colOrigins == null || colOrigins.size() == 0) {\n      return null;\n    }\n    return colOrigins.iterator().next().getOriginTable();\n  }\n"
  },
  {
    "id": "alibaba_jstorm-110-FirstSentence-0",
    "old_comment_raw": "If it is backend, please set resultHandler, such as DefaultExecuteResultHandler If it is frontend, ByteArrayOutputStream.toString get the result ",
    "new_comment_raw": "Attention",
    "old_code_raw": "    public static ByteArrayOutputStream launchProcess(String command, final Map environment, final String workDir, ExecuteResultHandler resultHandler)\n            throws IOException {\n\n        String[] cmdlist = command.split(\" \");\n\n        CommandLine cmd = new CommandLine(cmdlist[0]);\n        for (String cmdItem : cmdlist) {\n            if (StringUtils.isBlank(cmdItem) == false) {\n                cmd.addArgument(cmdItem);\n            }\n        }\n\n        DefaultExecutor executor = new DefaultExecutor();\n\n        executor.setExitValue(0);\n        if (StringUtils.isBlank(workDir) == false) {\n            executor.setWorkingDirectory(new File(workDir));\n        }\n\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n\n        PumpStreamHandler streamHandler = new PumpStreamHandler(out, out);\n        if (streamHandler != null) {\n            executor.setStreamHandler(streamHandler);\n        }\n\n        try {\n            if (resultHandler == null) {\n                executor.execute(cmd, environment);\n            } else {\n                executor.execute(cmd, environment, resultHandler);\n            }\n        } catch (ExecuteException e) {\n\n            // @@@@\n            // failed to run command\n        }\n\n        return out;\n\n    }\n",
    "new_code_raw": "    public static String launchProcess(final String command, final Map<String, String> environment, boolean backend) throws IOException {\n        String[] cmds = command.split(\" \");\n\n        ArrayList<String> cmdList = new ArrayList<String>();\n        for (String tok : cmds) {\n            if (!StringUtils.isBlank(tok)) {\n                cmdList.add(tok);\n            }\n        }\n\n        return launchProcess(command, cmdList, environment, backend);\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1674-FirstSentence-0",
    "old_comment_raw": "Build a Hibernate Type that incorporates the JPA AttributeConverter.",
    "new_comment_raw": "Build a Hibernate Type that incorporates the JPA AttributeConverter.",
    "old_code_raw": "\tprivate Type buildAttributeConverterTypeAdapter() {\n\t\t// todo : validate the number of columns present here?\n\n\t\tfinal Class entityAttributeJavaType = jpaAttributeConverterDefinition.getEntityAttributeType();\n\t\tfinal Class databaseColumnJavaType = jpaAttributeConverterDefinition.getDatabaseColumnType();\n\n\n\t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n\t\t// the AttributeConverter to resolve the corresponding descriptor.\n\t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n\n\n\t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer <-> String\n\t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n\t\t//\t\tcorresponding to the AttributeConverter's declared \"databaseColumnJavaType\" (how we read that value out\n\t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n\t\t// \t\tVARCHAR/CHAR\n\t\tfinal int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n\t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptor = SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n\t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n\t\t// \t\tillustration, this should be the type descriptor for Strings\n\t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n\t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n\t\t// \t\tprocess...\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(\n\t\t\t\tjpaAttributeConverterDefinition.getAttributeConverter(),\n\t\t\t\tsqlTypeDescriptor,\n\t\t\t\tintermediateJavaTypeDescriptor\n\t\t);\n\n\t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n\n\t\tfinal String name = \"BasicType adapter for AttributeConverter<\" + entityAttributeJavaType + \",\" + databaseColumnJavaType + \">\";\n\t\treturn new AttributeConverterTypeAdapter( sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor, name );\n\t}\n",
    "new_code_raw": "\tprivate Type buildAttributeConverterTypeAdapter() {\n\t\t// todo : validate the number of columns present here?\n\n\t\tfinal Class entityAttributeJavaType = jpaAttributeConverterDefinition.getEntityAttributeType();\n\t\tfinal Class databaseColumnJavaType = jpaAttributeConverterDefinition.getDatabaseColumnType();\n\n\n\t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n\t\t// the AttributeConverter to resolve the corresponding descriptor.\n\t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n\n\n\t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer <-> String\n\t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n\t\t//\t\tcorresponding to the AttributeConverter's declared \"databaseColumnJavaType\" (how we read that value out\n\t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n\t\t// \t\tVARCHAR/CHAR\n\t\tfinal int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n\t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptor = SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n\t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n\t\t// \t\tillustration, this should be the type descriptor for Strings\n\t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n\t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n\t\t// \t\tprocess...\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(\n\t\t\t\tjpaAttributeConverterDefinition.getAttributeConverter(),\n\t\t\t\tsqlTypeDescriptor,\n\t\t\t\tintermediateJavaTypeDescriptor\n\t\t);\n\n\t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n\n\t\tfinal String name = String.format(\n\t\t\t\t\"BasicType adapter for AttributeConverter<%s,%s>\",\n\t\t\t\tentityAttributeJavaType.getSimpleName(),\n\t\t\t\tdatabaseColumnJavaType.getSimpleName()\n\t\t);\n\t\treturn new AttributeConverterTypeAdapter(\n\t\t\t\tname,\n\t\t\t\tjpaAttributeConverterDefinition.getAttributeConverter(),\n\t\t\t\tsqlTypeDescriptorAdapter,\n\t\t\t\tentityAttributeJavaTypeDescriptor\n\t\t);\n\t}\n"
  },
  {
    "id": "frohoff_jdk6-38-Associations-FirstSentence",
    "old_comment_raw": "Creates and returns a  PaintContext used to generate a solid color field pattern.",
    "new_comment_raw": "Creates and returns a  PaintContext used to generate a solid color pattern.",
    "old_code_raw": "    public synchronized PaintContext createContext(ColorModel cm, Rectangle r,\n                                                   Rectangle2D r2d,\n                                                   AffineTransform xform,\n                                                   RenderingHints hints) {\n      if (context == null || \n          context.getRGB() != getRGB())\n      {\n          context = new ColorPaintContext(getRGB(), cm);\n      }\n      return context;\n    }\n",
    "new_code_raw": "    public synchronized PaintContext createContext(ColorModel cm, Rectangle r,\n                                                   Rectangle2D r2d,\n                                                   AffineTransform xform,\n                                                   RenderingHints hints) {\n        return new ColorPaintContext(getRGB(), cm);\n    }\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-1609-FirstSentence-0",
    "old_comment_raw": "Some dialect-specific LIMIT clauses require the maximum last row number (aka, first_row_number + total_row_count), while others require the maximum returned row count (the total maximum number of rows to return).",
    "new_comment_raw": "Some dialect-specific LIMIT clauses require the maximum last row number (aka, first_row_number + total_row_count), while others require the maximum returned row count (the total maximum number of rows to return).",
    "old_code_raw": "\tprivate static int getMaxOrLimit(final RowSelection selection, final Dialect dialect) {\n\t\tfinal int firstRow = dialect.convertToFirstRowValue( getFirstRow( selection ) );\n\t\tfinal int lastRow = selection.getMaxRows().intValue();\n\t\tif ( dialect.useMaxForLimit() ) {\n\t\t\treturn lastRow + firstRow;\n\t\t}\n\t\telse {\n\t\t\treturn lastRow;\n\t\t}\n\t}\n",
    "new_code_raw": "\tprivate static int getMaxOrLimit(final RowSelection selection, final Dialect dialect) {\n\t\tfinal int firstRow = dialect.convertToFirstRowValue( getFirstRow( selection ) );\n\t\tfinal int lastRow = selection.getMaxRows();\n\t\treturn dialect.useMaxForLimit() ? lastRow + firstRow : lastRow;\n\t}\n"
  },
  {
    "id": "justinedelson_felix-211-Associations-FirstSentence",
    "old_comment_raw": "Returns the list of initial ServiceReference objects that will be tracked by this ServiceTracker object.",
    "new_comment_raw": "Returns the list of initial ServiceReferences that will be tracked by this ServiceTracker.",
    "old_code_raw": "\tprivate ServiceReference[] getInitialReferences(boolean trackAllServices,\n\t\t\tString trackClass, String filterString)\n\t\t\tthrows InvalidSyntaxException {\n\t\tif (trackAllServices) {\n\t\t\treturn context.getAllServiceReferences(trackClass, filterString);\n\t\t}\n\t\telse {\n\t\t\treturn context.getServiceReferences(trackClass, filterString);\n\t\t}\n\t}\n",
    "new_code_raw": "\tprivate ServiceReference[] getInitialReferences(boolean trackAllServices,\n\t\t\tString className, String filterString)\n\t\t\tthrows InvalidSyntaxException {\n\t\tif (trackAllServices) {\n\t\t\treturn context.getAllServiceReferences(className, filterString);\n\t\t}\n\t\treturn context.getServiceReferences(className, filterString);\n\t}\n\n"
  },
  {
    "id": "SeleniumHQ_selenium-666-FirstSentence-0",
    "old_comment_raw": "Converts a thrown error into the corresponding status code.",
    "new_comment_raw": "Converts a thrown error into the corresponding status code.",
    "old_code_raw": "  public int toStatusCode(Throwable thrown) {\n    if (thrown == null) {\n      return SUCCESS;\n    } else if (thrown instanceof InvalidCookieDomainException) {\n      return INVALID_COOKIE_DOMAIN;\n    } else if (thrown instanceof UnableToSetCookieException) {\n      return UNABLE_TO_SET_COOKIE;\n    } else if (thrown instanceof NoSuchWindowException) {\n      return NO_SUCH_WINDOW;\n    } else if (thrown instanceof InvalidSelectorException) {\n      return INVALID_SELECTOR_ERROR;\n    } else if (thrown instanceof NoSuchElementException) {\n      return NO_SUCH_ELEMENT;\n    } else if (thrown instanceof NoSuchFrameException) {\n      return NO_SUCH_FRAME;\n    } else if (thrown instanceof StaleElementReferenceException) {\n      return STALE_ELEMENT_REFERENCE;\n    } else if (thrown instanceof ElementNotVisibleException) {\n      return ELEMENT_NOT_VISIBLE;\n    } else if (thrown instanceof InvalidElementStateException) {\n      return INVALID_ELEMENT_STATE;\n    } else if (thrown instanceof XPathLookupException) {\n      return XPATH_LOOKUP_ERROR;\n    } else if (thrown instanceof TimeoutException) {\n      return ASYNC_SCRIPT_TIMEOUT;\n    } else if (thrown instanceof InvalidCoordinatesException) {\n      return INVALID_ELEMENT_COORDINATES;\n    } else if (thrown instanceof ImeNotAvailableException) {\n      return IME_NOT_AVAILABLE;\n    } else if (thrown instanceof ImeActivationFailedException) {\n      return IME_ENGINE_ACTIVATION_FAILED;\n    } else if (thrown instanceof NoAlertPresentException) {\n      return NO_ALERT_PRESENT;\n    } else {\n      return UNHANDLED_ERROR;\n    }\n  }\n",
    "new_code_raw": "  public int toStatusCode(Throwable thrown) {\n    if (thrown == null) {\n      return SUCCESS;\n    } else if (thrown instanceof InvalidCookieDomainException) {\n      return INVALID_COOKIE_DOMAIN;\n    } else if (thrown instanceof UnableToSetCookieException) {\n      return UNABLE_TO_SET_COOKIE;\n    } else if (thrown instanceof NoSuchWindowException) {\n      return NO_SUCH_WINDOW;\n    } else if (thrown instanceof InvalidSelectorException) {\n      return INVALID_SELECTOR_ERROR;\n    } else if (thrown instanceof NoSuchElementException) {\n      return NO_SUCH_ELEMENT;\n    } else if (thrown instanceof NoSuchFrameException) {\n      return NO_SUCH_FRAME;\n    } else if (thrown instanceof StaleElementReferenceException) {\n      return STALE_ELEMENT_REFERENCE;\n    } else if (thrown instanceof ElementNotVisibleException) {\n      return ELEMENT_NOT_VISIBLE;\n    } else if (thrown instanceof InvalidElementStateException) {\n      return INVALID_ELEMENT_STATE;\n    } else if (thrown instanceof XPathLookupException) {\n      return XPATH_LOOKUP_ERROR;\n    } else if (thrown instanceof TimeoutException) {\n      return ASYNC_SCRIPT_TIMEOUT;\n    } else if (thrown instanceof InvalidCoordinatesException) {\n      return INVALID_ELEMENT_COORDINATES;\n    } else if (thrown instanceof ImeNotAvailableException) {\n      return IME_NOT_AVAILABLE;\n    } else if (thrown instanceof ImeActivationFailedException) {\n      return IME_ENGINE_ACTIVATION_FAILED;\n    } else if (thrown instanceof NoAlertPresentException) {\n      return NO_ALERT_PRESENT;\n    } else if (thrown instanceof MoveTargetOutOfBoundsException) {\n      return MOVE_TARGET_OUT_OF_BOUNDS;\n    } else {\n      return UNHANDLED_ERROR;\n    }\n  }\n"
  },
  {
    "id": "eclipse_mylyn.reviews-3-Associations-FirstSentence",
    "old_comment_raw": "Returns the meta object for the containment reference list '  org.eclipse.mylyn.reviews.core.model.IComment#getReplies Replies'.",
    "new_comment_raw": "Returns the meta object for the reference list ' org.eclipse.mylyn.reviews.core.model.IComment#getReplies Replies'.",
    "old_code_raw": "\tpublic EReference getComment_Replies() {\n\t\treturn (EReference) commentEClass.getEStructuralFeatures().get(4);\n\t}\n",
    "new_code_raw": "\tpublic EReference getComment_Replies() {\n\t\treturn (EReference) commentEClass.getEStructuralFeatures().get(3);\n\t}\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-1514-FirstSentence-0",
    "old_comment_raw": "Locate the contained tuplizer responsible for the given entity-mode.",
    "new_comment_raw": "Locate the contained tuplizer responsible for the given entity-mode.",
    "old_code_raw": "\tpublic Tuplizer getTuplizerOrNull(EntityMode entityMode) {\n\t\treturn ( Tuplizer ) tuplizers.get( entityMode );\n\t}\n",
    "new_code_raw": "\tpublic Tuplizer getTuplizerOrNull(EntityMode entityMode) {\n\t\treturn tuplizers.get( entityMode );\n\t}\n"
  },
  {
    "id": "dustin_java-memcached-client-17-Associations-FirstSentence",
    "old_comment_raw": "Asynchronously get a bunch of objects from the cache and decode them with the given transcoder.",
    "new_comment_raw": "Varargs wrapper for asynchronous bulk gets.",
    "old_code_raw": "\tpublic Future<Map<String, Object>> asyncGetBulk(Collection<String> keys) {\n\t\treturn asyncGetBulk(keys, transcoder);\n\t}\n",
    "new_code_raw": "\tpublic Future<Map<String, Object>> asyncGetBulk(String... keys) {\n\t\treturn asyncGetBulk(Arrays.asList(keys));\n\t}\n\n"
  },
  {
    "id": "apache_drill-157-FirstSentence-0",
    "old_comment_raw": "Generates a user error message that has the following structure:",
    "new_comment_raw": "Generates a user error message that has the following structure:",
    "old_code_raw": "  private String generateMessage() {\n    return errorType + \" ERROR: \" + super.getMessage() + \"\\n\\n\" +\n      context.generateContextMessage();\n  }\n",
    "new_code_raw": "  private String generateMessage(boolean includeErrorIdAndIdentity) {\n    return errorType + \" ERROR: \" + super.getMessage() + \"\\n\\n\" +\n        context.generateContextMessage(includeErrorIdAndIdentity);\n  }\n"
  },
  {
    "id": "dropwizard_dropwizard-71-Associations-FirstSentence",
    "old_comment_raw": "Builds the  RxClient instance.",
    "new_comment_raw": "Builds the  Client instance with a custom reactive client provider.",
    "old_code_raw": "    public <RX extends RxInvoker> RxClient<RX> buildRx(String name, Class<RX> invokerType) {\n        return Rx.from(build(name), invokerType, executorService);\n    }\n",
    "new_code_raw": "    public <RX extends RxInvokerProvider> Client buildRx(String name, Class<RX> invokerType) {\n        return build(name).register(invokerType);\n    }\n\n"
  },
  {
    "id": "apache_drill-1260-FirstSentence-0",
    "old_comment_raw": "Internal method to build the set of column readers needed for this row set.",
    "new_comment_raw": "Internal method to build the set of column readers needed for this row set.",
    "old_code_raw": "  protected RowSetReader buildReader(ReaderIndex rowIndex) {\n    return new RowSetReaderBuilder().buildReader(this, rowIndex);\n  }\n",
    "new_code_raw": "  protected RowSetReader buildReader(ReaderIndex rowIndex) {\n    return SimpleReaderBuilder.build(container(), schema, rowIndex);\n  }\n"
  },
  {
    "id": "dougm_hudson-plugins-8-Associations-FirstSentence",
    "old_comment_raw": "Returns all the warnings in this package.",
    "new_comment_raw": "Returns all warnings for this package details view.",
    "old_code_raw": "    public Collection<Warning> getWarnings() {\n        return project.getWarnings(packageName);\n    }\n",
    "new_code_raw": "    public Set<Warning> getWarnings() {\n        return Collections.unmodifiableSet(project.getWarnings(packageName));\n    }\n\n"
  },
  {
    "id": "graphql_java_graphql_java-406-FirstSentence-0",
    "old_comment_raw": "Returns the key of this MergedField for the overall result.",
    "new_comment_raw": "Returns the key of this MergedField for the overall result.",
    "old_code_raw": "    public String getResultKey() {\n        Field singleField = getSingleField();\n        if (singleField.getAlias() != null) {\n            return singleField.getAlias();\n        }\n        return singleField.getName();\n    }\n",
    "new_code_raw": "    public String getResultKey() {\n        return resultKey;\n    }\n"
  },
  {
    "id": "Omegaphora_dalvik-66-Associations-FirstSentence",
    "old_comment_raw": "Returns an array containing one entry for each method in the stack.",
    "new_comment_raw": "Returns an array containing one entry for each method in the current execution stack.",
    "old_code_raw": "    @SuppressWarnings(\"unchecked\")\n    protected Class[] getClassContext() {\n        return Class.getStackClasses(-1, false);\n    }\n",
    "new_code_raw": "    @SuppressWarnings(\"unchecked\")\n    protected Class[] getClassContext() {\n        return VMStack.getClasses(-1, false);\n    }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-601-FirstSentence-0",
    "old_comment_raw": "Selects a suitable duration type for the given object.",
    "new_comment_raw": "Selects a suitable duration type for the given object.",
    "old_code_raw": "    public DurationType getDurationType(Object object) {\n        return DurationType.getAverageYearMonthType();\n    }\n",
    "new_code_raw": "    public DurationType getDurationType(Object object) {\n        return DurationType.getMillisType();\n    }\n"
  },
  {
    "id": "albfan_sqlworkbenchj-104-Associations-FirstSentence",
    "old_comment_raw": "Return the numeric mode value based on keywords.",
    "new_comment_raw": "Return the mode value based on keywords.",
    "old_code_raw": "\tpublic static int getModeValue(String mode)\n\t{\n\t\tif (mode == null) return -1;\n\t\tmode = mode.trim().toLowerCase();\n\t\tif (mode.indexOf(',') == -1)\n\t\t{\n\t\t\t// only one keyword supplied\n\t\t\tif (\"insert\".equals(mode))\n\t\t\t{\n\t\t\t\treturn MODE_INSERT;\n\t\t\t}\n\t\t\telse if (\"update\".equals(mode))\n\t\t\t{\n\t\t\t\treturn MODE_UPDATE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tList l = StringUtil.stringToList(mode, \",\");\n\t\t\tString first = (String)l.get(0);\n\t\t\tString second = (String)l.get(1);\n\t\t\tif (\"insert\".equals(first) && \"update\".equals(second))\n\t\t\t{\n\t\t\t\treturn MODE_INSERT_UPDATE;\n\t\t\t}\n\t\t\telse if (\"update\".equals(first) && \"insert\".equals(second))\n\t\t\t{\n\t\t\t\treturn MODE_UPDATE_INSERT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t}\n",
    "new_code_raw": "\tpublic static ImportMode getModeValue(String mode)\n\t{\n\t\tif (mode == null) return null;\n\n\t\tmode = mode.trim().toLowerCase();\n\t\tif (mode.indexOf(',') == -1)\n\t\t{\n\t\t\t// only one keyword supplied\n\t\t\tif (\"insert\".equals(mode))\n\t\t\t{\n        return ImportMode.insert;\n\t\t\t}\n\t\t\telse if (\"update\".equals(mode))\n\t\t\t{\n        return ImportMode.update;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tList l = StringUtil.stringToList(mode, \",\");\n\t\t\tString first = (String)l.get(0);\n\t\t\tString second = (String)l.get(1);\n\t\t\tif (\"insert\".equals(first) && \"update\".equals(second))\n\t\t\t{\n        return ImportMode.insertUpdate;\n\t\t\t}\n\t\t\telse if (\"update\".equals(first) && \"insert\".equals(second))\n\t\t\t{\n        return ImportMode.updateInsert;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t}\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-1929-FirstSentence-0",
    "old_comment_raw": "Get a  TregexMatcher for this pattern on this tree.",
    "new_comment_raw": "Get a  TregexMatcher for this pattern on this tree.",
    "old_code_raw": "  public TregexMatcher matcher(Tree t) {\n    return matcher(t, t, null, Generics.<String, Tree>newHashMap(), new VariableStrings());\n  }\n",
    "new_code_raw": "  public TregexMatcher matcher(Tree t) {\n    return matcher(t, t, null, new HashMap<String, Tree>(), new VariableStrings());\n  }\n"
  },
  {
    "id": "Omegaphora_dalvik-6-Associations-FirstSentence",
    "old_comment_raw": "Returns a Field object describing the field in the receiver named by the argument which must be visible from the current execution context.",
    "new_comment_raw": "Returns a  Field object which represents the public field with the specified name.",
    "old_code_raw": "    public Field getField(String name) throws NoSuchFieldException, SecurityException {\n        checkPublicMemberAccess();\n        return getMatchingField(getFullListOfFields(true), name);\n    }\n",
    "new_code_raw": "    public Field getField(String name) throws NoSuchFieldException, SecurityException {\n        checkPublicMemberAccess();\n\n        Field[] fields = getClassCache().getAllPublicFields();\n        Field field = findFieldByName(fields, name);\n\n        /*\n         * Make a copy of the private (to the package) object, so that\n         * setAccessible() won't alter the private instance.\n         */\n        return REFLECT.clone(field);\n    }\n\n"
  },
  {
    "id": "SeleniumHQ_selenium-610-FirstSentence-0",
    "old_comment_raw": "Verifies that the specified text pattern appears somewhere on the rendered page shown to the user.",
    "new_comment_raw": "Verifies that the specified text pattern appears somewhere on the rendered page shown to the user.",
    "old_code_raw": "  public boolean isTextPresent(String pattern) {\n    String text = driver.findElement(By.xpath(\"/html/body\")).getText();\n    text = text.trim();\n\n    String strategyName = \"implicit\";\n    String use = pattern;\n    Matcher matcher = TEXT_MATCHING_STRATEGY_AND_VALUE_PATTERN.matcher(pattern);\n    if (matcher.matches()) {\n      strategyName = matcher.group(1);\n      use = matcher.group(2);\n    }\n    TextMatchingStrategy strategy = textMatchingStrategies.get(strategyName);\n\n    return strategy.isAMatch(use, text);\n  }\n",
    "new_code_raw": "  public boolean isTextPresent(String pattern) {\n    return (Boolean) seleneseMethods.get(\"isTextPresent\").apply(driver, pattern);\n  }\n"
  },
  {
    "id": "SeleniumHQ_selenium-827-FirstSentence-0",
    "old_comment_raw": "Enhance the interfaces implemented by this instance of WebDriver iff that instance is a  org.openqa.selenium.remote.RemoteWebDriver.",
    "new_comment_raw": "Enhance the interfaces implemented by this instance of WebElement iff that instance is a  org.openqa.selenium.remote.RemoteWebElement.",
    "old_code_raw": "  public WebDriver augment(WebDriver driver) {\n    // TODO(simon): We should really add a \"SelfDescribing\" interface for this\n    if (!(driver instanceof RemoteWebDriver)) {\n      return driver;\n    }\n\n    Map<String, ?> capabilities = ((RemoteWebDriver) driver).getCapabilities().asMap();\n\n    CompoundHandler handler = new CompoundHandler((RemoteWebDriver) driver);\n\n    for (Map.Entry<String, ?> capablityName : capabilities.entrySet()) {\n      AugmenterProvider augmenter = augmentors.get(capablityName.getKey());\n      if (augmenter == null) {\n        continue;\n      }\n\n      Object value = capablityName.getValue();\n      if (value instanceof Boolean && !((Boolean) value).booleanValue()) {\n        continue;\n      }\n\n      handler.addCapabilityHander(augmenter.getDescribedInterface(),\n          augmenter.getImplementation(value));\n    }\n\n    if (handler.isNeedingApplication()) {\n      // Gather the existing interfaces\n      Set<Class<?>> interfaces = new HashSet<Class<?>>();\n      interfaces.addAll(handler.getInterfaces());\n      interfaces.addAll(getInterfacesFrom(driver.getClass()));\n\n      Enhancer enhancer = new Enhancer();\n      enhancer.setInterfaces(interfaces.toArray(new Class<?>[interfaces.size()]));\n      enhancer.setCallback(handler);\n      enhancer.setSuperclass(driver.getClass());\n\n      RemoteWebDriver remote = (RemoteWebDriver) enhancer.create();\n      remote.setCommandExecutor(((RemoteWebDriver) driver).getCommandExecutor());\n      remote.setElementConverter(((RemoteWebDriver) driver).getElementConverter());\n      return remote;\n    }\n\n    return driver;\n  }\n",
    "new_code_raw": "  public WebElement augment(RemoteWebElement element) {\n    // TODO(simon): We should really add a \"SelfDescribing\" interface for this\n    RemoteWebDriver parent = (RemoteWebDriver) element.getWrappedDriver();\n    if (parent == null) {\n      return element;\n    }\n    Map<String, AugmenterProvider> augmentors = elementAugmentors;\n\n    CompoundHandler handler = determineAugmentation(parent, augmentors);\n    RemoteWebElement remote = create(handler, element);\n\n    remote.setId(element.getId());\n    remote.setParent(parent);\n\n    return remote;\n  }\n"
  },
  {
    "id": "processing_processing-412-FirstSentence-0",
    "old_comment_raw": "Get the parameters for the specified renderer.",
    "new_comment_raw": "Get the parameters for the specified renderer.",
    "old_code_raw": "  public PParameters getParams(PGraphics renderer) {\n    if (paramMap == null) return null;\n    return paramMap.get(renderer);\n  }\n",
    "new_code_raw": "  public Object getParams(PGraphics renderer) {\n    if (paramMap == null) return null;\n    return paramMap.get(renderer);\n  }\n"
  },
  {
    "id": "apache_lenya-384-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Parse a URL",
    "old_code_raw": "    public java.util.List parsePage(String urlString) {\n        String status = \"ok\";\n\n        try {\n            URL currentURL = new java.net.URL(urlString);\n            String currentURLPath = urlString.substring(0, urlString.lastIndexOf(\"/\"));\n            HttpURLConnection httpCon = (HttpURLConnection) currentURL.openConnection();\n\n            httpCon.setRequestProperty(\"User-Agent\", \"Lenya Lucene Crawler\");\n\n            httpCon.connect();\n\n            long lastModified = httpCon.getLastModified();\n\n            if (httpCon.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                String contentType = httpCon.getContentType();\n\n                if (contentType.indexOf(\"text/html\") != -1) {\n                    return handleHTML(httpCon);\n                } else if (contentType.indexOf(\"application/pdf\") != -1) {\n                    handlePDF(httpCon);\n                } else {\n                    status = \"Not an excepted content type : \" + contentType;\n                }\n            } else {\n                status = \"bad\";\n            }\n\n            httpCon.disconnect();\n        } catch (java.net.MalformedURLException mue) {\n            status = mue.toString();\n        } catch (java.net.UnknownHostException uh) {\n            status = uh.toString(); // Mark as a bad URL\n        } catch (java.io.IOException ioe) {\n            status = ioe.toString(); // Mark as a bad URL\n        } catch (Exception e) {\n            status = e.toString(); // Mark as a bad URL\n        }\n\n        //return status;\n        return null;\n    }\n",
    "new_code_raw": "    public List parsePage(String urlString) {\n        String status = \"ok\";\n\n        try {\n            URL currentURL = new java.net.URL(urlString);\n            HttpURLConnection httpCon = (HttpURLConnection) currentURL.openConnection();\n\n            httpCon.setRequestProperty(\"User-Agent\", \"Lenya Lucene Crawler\");\n\n            httpCon.connect();\n\n            if (httpCon.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                String contentType = httpCon.getContentType();\n\n                if (contentType.indexOf(\"text/html\") != -1) {\n                    return handleHTML(httpCon);\n                } else if (contentType.indexOf(\"application/pdf\") != -1) {\n                    handlePDF(httpCon);\n                } else {\n                    status = \"Not an excepted content type : \" + contentType;\n                }\n            } else {\n                status = \"bad\";\n            }\n\n            httpCon.disconnect();\n        } catch (java.net.MalformedURLException mue) {\n            status = mue.toString();\n        } catch (java.net.UnknownHostException uh) {\n            status = uh.toString(); // Mark as a bad URL\n        } catch (java.io.IOException ioe) {\n            status = ioe.toString(); // Mark as a bad URL\n        } catch (Exception e) {\n            status = e.toString(); // Mark as a bad URL\n        }\n\n        //return status;\n        return null;\n    }\n\n"
  },
  {
    "id": "sarxos_webcam_capture-89-FirstSentence-0",
    "old_comment_raw": "Will discover and return first webcam available in the system.",
    "new_comment_raw": "Will discover and return first webcam available in the system.",
    "old_code_raw": "\tpublic static Webcam getDefault(long timeout) throws TimeoutException {\n\t\tList<Webcam> webcams = getWebcams(timeout);\n\t\tif (webcams.isEmpty()) {\n\t\t\tthrow new WebcamException(\"No webcam available in the system\");\n\t\t}\n\t\treturn webcams.get(0);\n\t}\n",
    "new_code_raw": "\tpublic static Webcam getDefault(long timeout) throws TimeoutException {\n\t\treturn getDefault(timeout, TimeUnit.MILLISECONDS);\n\t}\n"
  },
  {
    "id": "apache_lenya-93-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Encrypt plain text password",
    "old_code_raw": "    public static String encrypt(String plain) {\n        Md5 md5 = new Md5(plain);\n        byte[] b = md5.processString();\n\n        return md5.getStringDigest();\n    }\n",
    "new_code_raw": "    public static String encrypt(String plain) {\n        return getMD5(plain);\n/*\n        org.w3c.tools.crypt.Md5 md5 = new org.w3c.tools.crypt.Md5(plain);\n        byte[] b = md5.processString();\n\n        return md5.getStringDigest();\n*/\n    }\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-346-FirstSentence-0",
    "old_comment_raw": "Deprecated.",
    "new_comment_raw": "Deprecated.",
    "old_code_raw": "\tpublic int getOrdinalParameterSourceLocation(int position) {\n\t\treturn getOrdinalParameterDescriptor( position ).getSourceLocation();\n\t}\n",
    "new_code_raw": "\tpublic int getOrdinalParameterSourceLocation(int position) {\n\t\treturn getOrdinalParameterDescriptor( position ).getPosition();\n\t}\n"
  },
  {
    "id": "mccraigmccraig_prefuse-6-Associations-FirstSentence",
    "old_comment_raw": "Return the GraphItem representing the first (source) node in the edge.",
    "new_comment_raw": "Return the VisualItem representing the first (source) node in the edge.",
    "old_code_raw": "\tpublic NodeItem getFirstNode() {\n\t\treturn m_node1;\n\t} //\n",
    "new_code_raw": "\tpublic Node getFirstNode() {\n\t\treturn m_node1;\n\t} //\n\n"
  },
  {
    "id": "datastax_java_driver-23-FirstSentence-0",
    "old_comment_raw": "Creates a session rule builder for Core Graph workloads with the default Graph protocol.",
    "new_comment_raw": "Creates a session rule builder for Core Graph workloads with the default Graph protocol.",
    "old_code_raw": "  public static DseSessionRuleBuilder getCoreGraphSessionBuilder(CustomCcmRule ccmRule) {\n    return new DseSessionRuleBuilder(ccmRule)\n        .withCreateGraph()\n        .withCoreEngine()\n        .withGraphProtocol(GraphProtocol.GRAPH_BINARY_1_0.toInternalCode());\n  }\n",
    "new_code_raw": "  public static CqlSessionRuleBuilder getCoreGraphSessionBuilder(CustomCcmRule ccmRule) {\n    return new CqlSessionRuleBuilder(ccmRule)\n        .withCreateGraph()\n        .withCoreEngine()\n        .withGraphProtocol(GraphProtocol.GRAPH_BINARY_1_0.toInternalCode());\n  }\n"
  },
  {
    "id": "JetBrains_jdk8u_jaxp-51-Associations-FirstSentence",
    "old_comment_raw": "Get a Vector containing all compile warning messages",
    "new_comment_raw": "Get a list of all compile warning messages",
    "old_code_raw": "    public Vector getWarnings() {\n        return _parser.getWarnings();\n    }\n",
    "new_code_raw": "    public ArrayList<ErrorMsg> getWarnings() {\n        return _parser.getWarnings();\n    }\n\n"
  },
  {
    "id": "apache_drill-1136-FirstSentence-0",
    "old_comment_raw": "If schema is not indicated (only one element in the list) or schema is default temporary workspace, we need to check among session temporary tables in default temporary workspace first.",
    "new_comment_raw": "If schema is not indicated (only one element in the list) or schema is default temporary workspace, we need to check among session temporary tables in default temporary workspace first.",
    "old_code_raw": "    public RelOptTableImpl getTable(final List<String> names) {\n      RelOptTableImpl temporaryTable = null;\n\n      if (mightBeTemporaryTable(names, session.getDefaultSchemaPath(), drillConfig)) {\n        String temporaryTableName = session.resolveTemporaryTableName(names.get(names.size() - 1));\n        if (temporaryTableName != null) {\n          List<String> temporaryNames = Lists.newArrayList(temporarySchema, temporaryTableName);\n          temporaryTable = super.getTable(temporaryNames);\n        }\n      }\n      if (temporaryTable != null) {\n        if (allowTemporaryTables) {\n          return temporaryTable;\n        }\n        throw UserException\n            .validationError()\n            .message(\"Temporary tables usage is disallowed. Used temporary table name: %s.\", names)\n            .build(logger);\n      }\n      return super.getTable(names);\n    }\n",
    "new_code_raw": "    public RelOptTableImpl getTable(final List<String> names) {\n      RelOptTableImpl temporaryTable = null;\n\n      if (mightBeTemporaryTable(names, session.getDefaultSchemaPath(), drillConfig)) {\n        String temporaryTableName = session.resolveTemporaryTableName(names.get(names.size() - 1));\n        if (temporaryTableName != null) {\n          List<String> temporaryNames = Lists.newArrayList(temporarySchema, temporaryTableName);\n          temporaryTable = super.getTable(temporaryNames);\n        }\n      }\n      if (temporaryTable != null) {\n        if (allowTemporaryTables) {\n          return temporaryTable;\n        }\n        throw UserException\n            .validationError()\n            .message(\"Temporary tables usage is disallowed. Used temporary table name: %s.\", names)\n            .build(logger);\n      }\n\n      RelOptTableImpl table = super.getTable(names);\n\n      // Check the schema and throw a valid SchemaNotFound exception instead of TableNotFound exception.\n      if (table == null) {\n        isValidSchema(names);\n      }\n\n      return table;\n    }\n"
  },
  {
    "id": "apache_lenya-320-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Get a reader",
    "old_code_raw": "    public Reader getReader() throws IOException {\n        if (pipeIn == null) {\n            pipeIn = new PipedReader();\n            pipeOut = new PipedWriter(pipeIn);\n\n            Thread thread = new ParserThread(this);\n            thread.start(); // start parsing\n        }\n\n        return pipeIn;\n    }\n",
    "new_code_raw": "    public Reader getReader() throws IOException {\n        if (this.pipeIn == null) {\n            this.pipeIn = new PipedReader();\n            this.pipeOut = new PipedWriter(this.pipeIn);\n\n            Thread thread = new ParserThread(this);\n            thread.start(); // start parsing\n        }\n\n        return this.pipeIn;\n    }\n\n"
  },
  {
    "id": "cymcsg_UltimateRecyclerView-22-FirstSentence-0",
    "old_comment_raw": "to display the accumulator for the Ad position",
    "new_comment_raw": "to display the accumulator for the Ad position",
    "old_code_raw": "    public int atAdPos(final int pos) {\n        return (int) Math.floor(pos / adfrequency);\n    }\n",
    "new_code_raw": "    public int atAdPos(final int pos) {\n        final int take_int = (int) Math.floor((pos + 1) / adfrequency);\n        Log.d(\"atAdPosE2\", take_int + \"\");\n        return take_int;\n    }\n"
  },
  {
    "id": "apache_drill-1545-FirstSentence-0",
    "old_comment_raw": "Return  InputSplitWrappers for given  HiveReadEntry.",
    "new_comment_raw": "Return  LogicalInputSplits for given  HiveReadEntry.",
    "old_code_raw": "  public List<InputSplitWrapper> getInputSplits(final HiveReadEntry hiveReadEntry) {\n    final Stopwatch timeGetSplits = Stopwatch.createStarted();\n    try {\n      if (!isPartitionedTable) {\n        return getTableInputSplits();\n      }\n\n      final List<InputSplitWrapper> splits = Lists.newArrayList();\n      for (HivePartition p : hiveReadEntry.getPartitions()) {\n        splits.addAll(getPartitionInputSplits(p));\n      }\n      return splits;\n    } catch (final Exception e) {\n      logger.error(\"Failed to get InputSplits\", e);\n      throw new DrillRuntimeException(\"Failed to get InputSplits\", e);\n    } finally {\n      logger.debug(\"Took {} \u00c2\u00b5s to get InputSplits from {}.{}\", timeGetSplits.elapsed(TimeUnit.NANOSECONDS) / 1000,\n          hiveReadEntry.getTable().getDbName(), hiveReadEntry.getTable().getTableName());\n    }\n  }\n",
    "new_code_raw": "  public List<LogicalInputSplit> getInputSplits(final HiveReadEntry hiveReadEntry) {\n    final Stopwatch timeGetSplits = Stopwatch.createStarted();\n    try {\n      if (!isPartitionedTable) {\n        return getTableInputSplits();\n      }\n\n      final List<LogicalInputSplit> splits = Lists.newArrayList();\n      for (HivePartition p : hiveReadEntry.getPartitions()) {\n        splits.addAll(getPartitionInputSplits(p));\n      }\n      return splits;\n    } catch (final Exception e) {\n      logger.error(\"Failed to get InputSplits\", e);\n      throw new DrillRuntimeException(\"Failed to get InputSplits\", e);\n    } finally {\n      logger.debug(\"Took {} \u00c2\u00b5s to get InputSplits from {}.{}\", timeGetSplits.elapsed(TimeUnit.NANOSECONDS) / 1000,\n          hiveReadEntry.getTable().getDbName(), hiveReadEntry.getTable().getTableName());\n    }\n  }\n"
  },
  {
    "id": "Netflix_eureka-181-FirstSentence-0",
    "old_comment_raw": "Gets the task that is responsible for fetching the eureka service Urls.",
    "new_comment_raw": "Gets the task that is responsible for fetching the eureka service Urls.",
    "old_code_raw": "    private TimerTask getServiceUrlUpdateTask(final String zone) {\n        return new TimerTask() {\n            @Override\n            public void run() {\n                try {\n                    List<String> serviceUrlList = getDiscoveryServiceUrls(zone);\n                    if (serviceUrlList.isEmpty()) {\n                        logger.warn(\"The service url list is empty\");\n                        return;\n                    }\n                    if (!serviceUrlList.equals(eurekaServiceUrls.get())) {\n                        logger.info(\n                                \"Updating the serviceUrls as they seem to have changed from {} to {} \",\n                                Arrays.toString(eurekaServiceUrls.get()\n                                        .toArray()), Arrays\n                                        .toString(serviceUrlList.toArray()));\n\n                        eurekaServiceUrls.set(serviceUrlList);\n                    }\n                } catch (Throwable e) {\n                    logger.error(\"Cannot get the eureka service urls :\", e);\n                }\n\n            }\n        };\n    }\n",
    "new_code_raw": "    private TimerTask getServiceUrlUpdateTask(final String zone) {\n        return new TimerTask() {\n            @Override\n            public void run() {\n                try {\n                    List<String> serviceUrlList = timedGetDiscoveryServiceUrls(zone);\n                    if (serviceUrlList.isEmpty()) {\n                        logger.warn(\"The service url list is empty\");\n                        return;\n                    }\n                    if (!serviceUrlList.equals(eurekaServiceUrls.get())) {\n                        logger.info(\n                                \"Updating the serviceUrls as they seem to have changed from {} to {} \",\n                                Arrays.toString(eurekaServiceUrls.get()\n                                        .toArray()), Arrays\n                                        .toString(serviceUrlList.toArray()));\n\n                        eurekaServiceUrls.set(serviceUrlList);\n                    }\n                } catch (Throwable e) {\n                    logger.error(\"Cannot get the eureka service urls :\", e);\n                }\n\n            }\n        };\n    }\n"
  },
  {
    "id": "processing_processing-33-FirstSentence-0",
    "old_comment_raw": "Build all the code for this sketch.",
    "new_comment_raw": "Build all the code for this sketch.",
    "old_code_raw": "  public String preprocess(String buildPath) throws RunnerException {\n    return preprocess(buildPath, new PdePreprocessor());\n  }\n",
    "new_code_raw": "  public String preprocess(String buildPath) throws RunnerException {\n    try {\n      return preprocess(buildPath, new PdePreprocessor(buildPath, name));\n    } catch (IOException e) {\n      throw new RunnerException(\"Error while preprocessing\", true);\n    }\n  }\n"
  },
  {
    "id": "processing_processing-1224-FirstSentence-0",
    "old_comment_raw": "Make a JSON text of this JSONArray.",
    "new_comment_raw": "Make a JSON text of this JSONArray as a single line.",
    "old_code_raw": "  public String toString() {\n    try {\n      return this.toString(0);\n    } catch (Exception e) {\n      return null;\n    }\n  }\n",
    "new_code_raw": "  public String toString() {\n    try {\n      return toString(-1);\n    } catch (Exception e) {\n      return null;\n    }\n  }\n"
  },
  {
    "id": "RobotiumTech_robotium-1361-FirstSentence-0",
    "old_comment_raw": "Scrolls up the screen.",
    "new_comment_raw": "Scrolls up the screen.",
    "old_code_raw": "\tpublic boolean scrollUp(){\n\t\twaiter.waitForViews(ListView.class, ScrollView.class);\n\t\treturn scroller.scroll(Scroller.Direction.UP);\n\t}\n",
    "new_code_raw": "\tpublic boolean scrollUp(){\n\t\twaiter.waitForViews(ListView.class, ScrollView.class, false);\n\t\treturn scroller.scroll(Scroller.UP);\n\t}\n"
  },
  {
    "id": "orfjackal_ikayaki-23-Associations-FirstSentence",
    "old_comment_raw": "Gets current directory history from TODO.",
    "new_comment_raw": "Reads current directory history from Settings.",
    "old_code_raw": "    private String[] getDirectoryHistory() {\n        return new String[] { directory.getAbsolutePath(), \"resources\", \"mursukas\", \"heppa\", \"marsupapana\" };\n\n        // TODO:\n        //return Settings.instance().getDirectoryHistory();\n    }\n",
    "new_code_raw": "    private File[] getDirectoryHistory() {\n        File[] dirhist = Settings.instance().getDirectoryHistory();\n\n        if (dirhist == null || dirhist.length == 0) return new File[] { new File(\".\").getAbsoluteFile() };\n        else return dirhist;\n    }\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-1507-FirstSentence-0",
    "old_comment_raw": "Extract a component property value.",
    "new_comment_raw": "Extract a component property value.",
    "old_code_raw": "\tprotected Object getComponentValue(ComponentType type, Object component, String propertyPath) {\n\t\t\n\t\tint loc = propertyPath.indexOf('.');\n\t\tString basePropertyName = loc>0 ?\n\t\t\tpropertyPath.substring(0, loc) : propertyPath;\n\t\t\n\t\tString[] propertyNames = type.getPropertyNames();\n\t\tint index=0;\n\t\tfor ( ; index<propertyNames.length; index++ ) {\n\t\t\tif ( basePropertyName.equals( propertyNames[index] ) ) break;\n\t\t}\n\t\tif (index==propertyNames.length) {\n\t\t\tthrow new MappingException( \"component property not found: \" + basePropertyName );\n\t\t}\n\t\t\n\t\tObject baseValue = type.getPropertyValue( component, index, getEntityMode() );\n\t\t\n\t\tif ( loc>0 ) {\n\t\t\tComponentType subtype = (ComponentType) type.getSubtypes()[index];\n\t\t\treturn getComponentValue( subtype, baseValue, propertyPath.substring(loc+1) );\n\t\t}\n\t\telse {\n\t\t\treturn baseValue;\n\t\t}\n\t\t\n\t}\n",
    "new_code_raw": "\tprotected Object getComponentValue(ComponentType type, Object component, String propertyPath) {\n\t\tfinal int loc = propertyPath.indexOf( '.' );\n\t\tfinal String basePropertyName = loc > 0\n\t\t\t\t? propertyPath.substring( 0, loc )\n\t\t\t\t: propertyPath;\n\t\tfinal int index = findSubPropertyIndex( type, basePropertyName );\n\t\tfinal Object baseValue = type.getPropertyValue( component, index, getEntityMode() );\n\t\tif ( loc > 0 ) {\n\t\t\tif ( baseValue == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn getComponentValue(\n\t\t\t\t\t(ComponentType) type.getSubtypes()[index],\n\t\t\t\t\tbaseValue,\n\t\t\t\t\tpropertyPath.substring(loc+1)\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn baseValue;\n\t\t}\n\t\t\n\t}\n"
  },
  {
    "id": "RobotiumTech_robotium-65-Associations-FirstSentence",
    "old_comment_raw": "Returns an  ArrayList of the  View objects located in the current  Activity.",
    "new_comment_raw": "Returns an  ArrayList of all the  View objects located in the focused window e.g.",
    "old_code_raw": "\t\n\tpublic ArrayList<View> getViews() {\n\t\ttry {\n\t\t\treturn viewFetcher.getViews(null);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n",
    "new_code_raw": "\t\n\tpublic ArrayList<View> getViews() {\n\t\ttry {\n\t\t\treturn viewFetcher.getViews(null, false);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n\n"
  },
  {
    "id": "dropwizard_dropwizard-9-FirstSentence-0",
    "old_comment_raw": "Returns a  Log instance with the given name.",
    "new_comment_raw": "Returns a  Log instance with the given name.",
    "old_code_raw": "    public static Log named(String name) {\n        return forSlf4jLogger(LoggerFactory.getLogger(name));\n    }\n",
    "new_code_raw": "    public static Log named(String name) {\n        // a thread-safe SLF4J initialization routine is apparently hard, so I get to do dumb\n        // shit like this\n        while (true) {\n            final org.slf4j.Logger logger = LoggerFactory.getLogger(name);\n            if (logger instanceof Logger) {\n                return forSlf4jLogger(logger);\n            }\n        }\n    }\n"
  },
  {
    "id": "hazelcast_hazelcast-223-Associations-FirstSentence",
    "old_comment_raw": "Returns the next power of two that is larger than the specified int value.",
    "new_comment_raw": "Fast method of finding the next power of 2 greater than or equal to the supplied value.",
    "old_code_raw": "    public static int nextPowerOfTwo(int value) {\n        if (!isPowerOfTwo(value)) {\n            value--;\n            value |= value >> 1;\n            value |= value >> 2;\n            value |= value >> 4;\n            value |= value >> 8;\n            value |= value >> 16;\n            value++;\n        }\n        return value;\n    }\n",
    "new_code_raw": "    public static int nextPowerOfTwo(final int value) {\n        return 1 << (32 - Integer.numberOfLeadingZeros(value - 1));\n    }\n\n"
  },
  {
    "id": "apache_fineract-159-FirstSentence-0",
    "old_comment_raw": "Returns the response list by getting a proper  org.apache.fineract.batch.command.CommandStrategy.",
    "new_comment_raw": "Returns the response list by getting a proper  org.apache.fineract.batch.command.CommandStrategy.",
    "old_code_raw": "    private List<BatchResponse> handleBatchRequests(final List<BatchRequest> requestList, final UriInfo uriInfo) {\n\n        final List<BatchResponse> responseList = new ArrayList<>(requestList.size());\n\n        final List<BatchRequestNode> batchRequestNodes = this.resolutionHelper.getDependingRequests(requestList);\n        checkList.clear();\n\n        for (BatchRequestNode rootNode : batchRequestNodes) {\n            final BatchRequest rootRequest = rootNode.getRequest();\n            final CommandStrategy commandStrategy = this.strategyProvider.getCommandStrategy(CommandContext\n                    .resource(rootRequest.getRelativeUrl()).method(rootRequest.getMethod()).build());\n            final BatchResponse rootResponse = commandStrategy.execute(rootRequest, uriInfo);\n\n            responseList.add(rootResponse);\n            responseList.addAll(this.processChildRequests(rootNode, rootResponse, uriInfo));\n        }\n\n        Collections.sort(responseList, new Comparator<BatchResponse>() {\n\n            @Override\n            public int compare(BatchResponse source, BatchResponse testee) {\n                return source.getRequestId().compareTo(testee.getRequestId());\n            }\n        });\n\n        checkList = responseList;\n        return responseList;\n\n    }\n",
    "new_code_raw": "    private List<BatchResponse> handleBatchRequests(final List<BatchRequest> requestList, final UriInfo uriInfo) {\n\n        final List<BatchResponse> responseList = new ArrayList<>(requestList.size());\n\n        final List<BatchRequestNode> batchRequestNodes = this.resolutionHelper.getDependingRequests(requestList);\n        checkList.clear();\n        if(batchRequestNodes.isEmpty()) {\n        \t final BatchResponse response = new BatchResponse();\n        \t ErrorInfo ex = ErrorHandler.handler(new ClientDetailsNotFoundException());\n             response.setStatusCode(500);\n             response.setBody(ex.getMessage());\n             responseList.add(response) ;\n             return responseList ;\n        }\n        for (BatchRequestNode rootNode : batchRequestNodes) {\n            final BatchRequest rootRequest = rootNode.getRequest();\n            final CommandStrategy commandStrategy = this.strategyProvider.getCommandStrategy(CommandContext\n                    .resource(rootRequest.getRelativeUrl()).method(rootRequest.getMethod()).build());\n            final BatchResponse rootResponse = commandStrategy.execute(rootRequest, uriInfo);\n\n            responseList.add(rootResponse);\n            responseList.addAll(this.processChildRequests(rootNode, rootResponse, uriInfo));\n        }\n\n        Collections.sort(responseList, new Comparator<BatchResponse>() {\n\n            @Override\n            public int compare(BatchResponse source, BatchResponse testee) {\n                return source.getRequestId().compareTo(testee.getRequestId());\n            }\n        });\n\n        checkList = responseList;\n        return responseList;\n\n    }\n"
  },
  {
    "id": "RSB4760_apq8016_external_droiddriver-2-Associations-FirstSentence",
    "old_comment_raw": "Evaluates given @matchers in short-circuit fashion in the order they are passed.",
    "new_comment_raw": "Evaluates given @finders in short-circuit fashion in the order they are passed.",
    "old_code_raw": "  public static ElementMatcher anyOf(final ElementMatcher... matchers) {\n    return new ElementMatcher() {\n      @Override\n      public boolean matches(UiElement element) {\n        for (ElementMatcher matcher : matchers) {\n          if (matcher.matches(element)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      @Override\n      public String toString() {\n        return \"anyOf(\" + Joiner.on(\",\").join(matchers) + \")\";\n      }\n    };\n  }\n",
    "new_code_raw": "  public static MatchFinder anyOf(final MatchFinder... finders) {\n    return new MatchFinder() {\n      @Override\n      public boolean matches(UiElement element) {\n        for (MatchFinder finder : finders) {\n          if (finder.matches(element)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      @Override\n      public String toString() {\n        return \"anyOf(\" + Joiner.on(\",\").join(finders) + \")\";\n      }\n    };\n  }\n\n"
  },
  {
    "id": "gabrielemariotti_cardslib-23-FirstSentence-0",
    "old_comment_raw": "Returns the visible view for the cards",
    "new_comment_raw": "Returns the visible view for the cards",
    "old_code_raw": "    private List<CommonCardView> getVisibleViewsForCards(List<Card> cardsCopy) {\n        List<CommonCardView> originalViews = new ArrayList<CommonCardView>();\n        for (Card card:cardsCopy){\n            originalViews.add(card.getCardView());\n        }\n\n        /*List<CardView> views = new ArrayList<CardView>();\n        for (int i = 0; i < mCardListView.getChildCount(); i++) {\n            View child = mCardListView.getChildAt(i);\n            if (cardsCopy.contains(views)){\n                views.add((CardView) child);\n            }\n        }*/\n        return originalViews;\n    }\n",
    "new_code_raw": "    private List<CardViewWrapper> getVisibleViewsForCards(List<Card> cardsCopy) {\n        List<CardViewWrapper> originalViews = new ArrayList<CardViewWrapper>();\n        for (Card card:cardsCopy){\n            originalViews.add(card.getCardView());\n        }\n\n        /*List<CardView> views = new ArrayList<CardView>();\n        for (int i = 0; i < mCardListView.getChildCount(); i++) {\n            View child = mCardListView.getChildAt(i);\n            if (cardsCopy.contains(views)){\n                views.add((CardView) child);\n            }\n        }*/\n        return originalViews;\n    }\n"
  },
  {
    "id": "byterom_android_external_spongycastle-61-Associations-FirstSentence",
    "old_comment_raw": "Returns the other object type ID if an object digest info is used.",
    "new_comment_raw": "Returns algorithm identifier for the digest used if ObjectDigestInfo is present.",
    "old_code_raw": "    public String getDigestAlgorithm()\n    {\n        if (holder.getObjectDigestInfo() != null)\n        {\n            holder.getObjectDigestInfo().getDigestAlgorithm().getObjectId()\n                .getId();\n        }\n        return null;\n    }\n",
    "new_code_raw": "    public AlgorithmIdentifier getDigestAlgorithm()\n    {\n        if (holder.getObjectDigestInfo() != null)\n        {\n            return holder.getObjectDigestInfo().getDigestAlgorithm();\n        }\n        return null;\n    }\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2210-FirstSentence-0",
    "old_comment_raw": "Find the clauses in a sentence.",
    "new_comment_raw": "Find the clauses in a sentence.",
    "old_code_raw": "  public List<SentenceFragment> clausesInSentence(CoreMap sentence) {\n    return clausesInSentence(sentence.get(SemanticGraphCoreAnnotations.CollapsedCCProcessedDependenciesAnnotation.class), true);\n  }\n",
    "new_code_raw": "  public List<SentenceFragment> clausesInSentence(CoreMap sentence) {\n    return clausesInSentence(sentence.get(SemanticGraphCoreAnnotations.EnhancedPlusPlusDependenciesAnnotation.class), true);\n  }\n"
  },
  {
    "id": "jenkinsci_openshift-sync-plugin-3-Associations-FirstSentence",
    "old_comment_raw": "Creates the Jenkins Job name for the given buildConfigName",
    "new_comment_raw": "Creates the Jenkins Job name for the given buildConfigName in a namespace and the default namespace for jenkins",
    "old_code_raw": "  public static String jenkinsJobName(String namespace, String buildConfigName) {\n    return namespace + \"-\" + buildConfigName;\n  }\n",
    "new_code_raw": "  public static String jenkinsJobName(String namespace, String buildConfigName, String defaultNamespace) {\n    if (namespace == null || namespace.length() == 0 || namespace.equals(defaultNamespace)) {\n      return buildConfigName;\n    }\n    return namespace + \"-\" + buildConfigName;\n  }\n\n"
  },
  {
    "id": "debezium_debezium-18-FirstSentence-0",
    "old_comment_raw": "Get the ISO 8601 formatted representation of the given  java.util.Date or one of its JDBC subclasses, using the supplied timezone information.",
    "new_comment_raw": "Get the ISO 8601 formatted representation of the given  java.util.Date or one of its JDBC subclasses, using the supplied timezone information.",
    "old_code_raw": "    public static String toIsoString(java.util.Date timestamp, ZoneId zoneId) {\n        if (timestamp instanceof java.sql.Timestamp) {\n            return toIsoString((java.sql.Timestamp) timestamp, zoneId);\n        }\n        if (timestamp instanceof java.sql.Date) {\n            return toIsoString((java.sql.Date) timestamp, zoneId);\n        }\n        if (timestamp instanceof java.sql.Time) {\n            return toIsoString((java.sql.Time) timestamp, zoneId);\n        }\n        return timestamp.toInstant().atZone(zoneId).format(FORMATTER);\n    }\n",
    "new_code_raw": "    public static String toIsoString(java.util.Date timestamp, ZoneId zoneId, TemporalAdjuster adjuster) {\n        if (timestamp instanceof java.sql.Timestamp) {\n            return toIsoString((java.sql.Timestamp) timestamp, zoneId, adjuster);\n        }\n        if (timestamp instanceof java.sql.Date) {\n            return toIsoString((java.sql.Date) timestamp, zoneId, adjuster);\n        }\n        if (timestamp instanceof java.sql.Time) {\n            return toIsoString((java.sql.Time) timestamp, zoneId, adjuster);\n        }\n        return timestamp.toInstant().atZone(zoneId).format(FORMATTER);\n    }\n"
  },
  {
    "id": "yahoo_bullet-core-16-Associations-FirstSentence",
    "old_comment_raw": "Returns if this query should be buffered for a bit before getting results out.",
    "new_comment_raw": "Returns if this query should buffer before emitting results.",
    "old_code_raw": "    public boolean shouldBuffer() {\n        Window window = runningQuery.getQuery().getWindow();\n        // No window means duration drives the query -> time based. Otherwise, if the window is time based.\n        return window == null || window.isTimeBased();\n    }\n",
    "new_code_raw": "    public boolean shouldBuffer() {\n        Window window = runningQuery.getQuery().getWindow();\n        boolean noWindow = window == null;\n        // If it's a RAW query without a window, it should be buffered if and only if it timed out. This means that the\n        // query is not yet done. So this tells the driver to buffer the query to wait for more potential results.\n        if (noWindow && isRaw()) {\n            return runningQuery.isTimedOut();\n        }\n        // No window (and not raw) is a duration based query => do buffer. Otherwise, buffer if the window is time based.\n        return noWindow || window.isTimeBased();\n    }\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-713-FirstSentence-0",
    "old_comment_raw": "Build the bootstrap registry.",
    "new_comment_raw": "Build the bootstrap registry.",
    "old_code_raw": "\tpublic ServiceRegistry build() {\n\t\tfinal ClassLoaderServiceImpl classLoaderService = new ClassLoaderServiceImpl(\n\t\t\t\tapplicationClassLoader,\n\t\t\t\tresourcesClassLoader,\n\t\t\t\thibernateClassLoader,\n\t\t\t\tenvironmentClassLoader\n\t\t);\n\n\t\tfinal IntegratorServiceImpl integratorService = new IntegratorServiceImpl(\n\t\t\t\tprovidedIntegrators,\n\t\t\t\tclassLoaderService\n\t\t);\n\n\t\treturn new BootstrapServiceRegistryImpl( classLoaderService, integratorService );\n\t}\n",
    "new_code_raw": "\tpublic BootstrapServiceRegistry build() {\n\t\tfinal ClassLoaderServiceImpl classLoaderService = new ClassLoaderServiceImpl(\n\t\t\t\tapplicationClassLoader,\n\t\t\t\tresourcesClassLoader,\n\t\t\t\thibernateClassLoader,\n\t\t\t\tenvironmentClassLoader\n\t\t);\n\n\t\tfinal IntegratorServiceImpl integratorService = new IntegratorServiceImpl(\n\t\t\t\tprovidedIntegrators,\n\t\t\t\tclassLoaderService\n\t\t);\n\n\t\treturn new BootstrapServiceRegistryImpl( classLoaderService, integratorService );\n\t}\n"
  },
  {
    "id": "apache_calcite-978-FirstSentence-0",
    "old_comment_raw": "Executes a collection of updates in a single batch RPC.",
    "new_comment_raw": "Executes a collection of updates in a single batch RPC.",
    "old_code_raw": "  protected int[] executeBatchInternal() throws SQLException {\n    for (int i = 0; i < connection.maxRetriesPerExecute; i++) {\n      try {\n        Meta.ExecuteBatchResult result = connection.prepareAndUpdateBatch(this, batchedSql);\n        return result.updateCounts;\n      } catch (NoSuchStatementException e) {\n        resetStatement();\n      }\n    }\n\n    throw new RuntimeException(\"Failed to successfully execute batch update after \"\n        +  connection.maxRetriesPerExecute + \" attempts\");\n  }\n",
    "new_code_raw": "  protected long[] executeBatchInternal() throws SQLException {\n    for (int i = 0; i < connection.maxRetriesPerExecute; i++) {\n      try {\n        return connection.prepareAndUpdateBatch(this, batchedSql).updateCounts;\n      } catch (NoSuchStatementException e) {\n        resetStatement();\n      }\n    }\n\n    throw new RuntimeException(\"Failed to successfully execute batch update after \"\n        +  connection.maxRetriesPerExecute + \" attempts\");\n  }\n"
  },
  {
    "id": "apache_struts1-29-Associations-FirstSentence",
    "old_comment_raw": "Return the ApplicationConfig object is it exists, null otherwise.",
    "new_comment_raw": "Return the ModuleConfig object is it exists, null otherwise.",
    "old_code_raw": "    public static ApplicationConfig getModuleConfig(PageContext pageContext) {\n       ApplicationConfig appConfig = (ApplicationConfig)\n           pageContext.getRequest().getAttribute(Globals.MODULE_KEY);\n       if (appConfig == null) { // Backwards compatibility hack\n           appConfig = (ApplicationConfig)\n               pageContext.getServletContext().getAttribute(Globals.MODULE_KEY);\n       }\n       return appConfig;\n    }\n",
    "new_code_raw": "    public static ModuleConfig getModuleConfig(PageContext pageContext) {\n       ModuleConfig moduleConfig = (ModuleConfig)\n           pageContext.getRequest().getAttribute(Globals.MODULE_KEY);\n       if (moduleConfig == null) { // Backwards compatibility hack\n           moduleConfig = (ModuleConfig)\n               pageContext.getServletContext().getAttribute(Globals.MODULE_KEY);\n       }\n       return moduleConfig;\n    }\n\n"
  },
  {
    "id": "apache_drill-1555-FirstSentence-0",
    "old_comment_raw": "Check if two \"core\" types are the same, ignoring subtypes and children.",
    "new_comment_raw": "Check if two \"core\" types are the same, ignoring subtypes and children.",
    "old_code_raw": "  public static boolean isSameType(MajorType type1, MajorType type2) {\n    return type1.getMinorType() == type2.getMinorType() &&\n           type1.getMode() == type2.getMode() &&\n           type1.getScale() == type2.getScale() &&\n           type1.getPrecision() == type2.getPrecision();\n  }\n",
    "new_code_raw": "  public static boolean isSameType(MajorType type1, MajorType type2) {\n    return isSameTypeAndMode(type1, type2) &&\n           type1.getScale() == type2.getScale() &&\n           type1.getPrecision() == type2.getPrecision();\n  }\n"
  },
  {
    "id": "apache_geode-81-Associations-FirstSentence",
    "old_comment_raw": "Returns the int representing this operation code.",
    "new_comment_raw": "Returns the byte representing this operation code.",
    "old_code_raw": "    public int toOrdinal() {\n\t      return this.opCode;\n\t    }\n",
    "new_code_raw": "\t    public byte toOrdinal() {\n\t      return this.opCode;\n\t    }\n\n"
  },
  {
    "id": "iSoron_uhabits-18-FirstSentence-0",
    "old_comment_raw": "Gets the overall timeframe of the selected habits.",
    "new_comment_raw": "Gets the overall timeframe of the selected habits.",
    "old_code_raw": "    private long[] getTimeframe()\n    {\n        long oldest = Long.MAX_VALUE;\n        long newest = -1;\n        for (Habit h : selectedHabits)\n        {\n            if(h.getRepetitions().getOldest() == null || h.getRepetitions().getNewest() == null)\n                continue;\n            long currOld = h.getRepetitions().getOldest().getTimestamp();\n            long currNew = h.getRepetitions().getNewest().getTimestamp();\n            oldest = currOld > oldest ? oldest : currOld;\n            newest = currNew < newest ? newest : currNew;\n        }\n        return new long[]{oldest, newest};\n    }\n",
    "new_code_raw": "    private Timestamp[] getTimeframe()\n    {\n        Timestamp oldest = Timestamp.ZERO.plus(1000000);\n        Timestamp newest = Timestamp.ZERO;\n        for (Habit h : selectedHabits)\n        {\n            if(h.getRepetitions().getOldest() == null || h.getRepetitions().getNewest() == null)\n                continue;\n            Timestamp currOld = h.getRepetitions().getOldest().getTimestamp();\n            Timestamp currNew = h.getRepetitions().getNewest().getTimestamp();\n            oldest = currOld.isOlderThan(oldest) ? oldest : currOld;\n            newest = currNew.isNewerThan(newest) ? newest : currNew;\n        }\n        return new Timestamp[]{oldest, newest};\n    }\n"
  },
  {
    "id": "runelite_runelite-110-FirstSentence-0",
    "old_comment_raw": "Calculate skill levels required for increasing combat level, meant for all combat skills besides ranged and magic.",
    "new_comment_raw": "Calculate skill levels required for increasing combat level, meant for all combat skills besides prayer, ranged, and magic.",
    "old_code_raw": "\tstatic int calcLevels(double start, int end, double multiple)\n\t{\n\t\treturn (int) Math.ceil((end - start) / multiple);\n\t}\n",
    "new_code_raw": "\tstatic int calcLevels(double start, int end, double multiple)\n\t{\n\t\treturn (int) Math.ceil(calcMultipliedLevels(start, end, multiple));\n\t}\n"
  },
  {
    "id": "JodaOrg_joda_time-758-FirstSentence-0",
    "old_comment_raw": "Get the millis duration field for this chronology.",
    "new_comment_raw": "Get the millis duration field for this chronology.",
    "old_code_raw": "    public DurationField millis() {\n        return UnsupportedDurationField.getInstance(\"millis\");\n    }\n",
    "new_code_raw": "    public DurationField millis() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.millis());\n    }\n"
  },
  {
    "id": "dropwizard_dropwizard-69-Associations-FirstSentence",
    "old_comment_raw": "Creates an  AsyncAppenderBase of type  IAccessEvent.",
    "new_comment_raw": "Creates an  AsyncAppenderFactory of type  IAccessEvent that prepares events for deferred processing",
    "old_code_raw": "    @Override\n    public AsyncAppenderBase<IAccessEvent> build() {\n        return new AsyncAppenderBase<IAccessEvent>();\n    }\n",
    "new_code_raw": "    @Override\n    public AsyncAppenderBase<IAccessEvent> build() {\n        return new AsyncAppenderBase<IAccessEvent>() {\n            @Override\n            protected void preprocess(IAccessEvent event) {\n                event.prepareForDeferredProcessing();\n            }\n        };\n    }\n\n"
  },
  {
    "id": "RobotiumTech_robotium-1323-FirstSentence-0",
    "old_comment_raw": "Waits for a text to be shown.",
    "new_comment_raw": "Waits for a text to be shown.",
    "old_code_raw": "\tpublic boolean waitForText(String text, int matches, long timeout, boolean scroll)\n    {\n\t\tlong now = System.currentTimeMillis();\n        final long endTime = now + timeout;\n\n\t\twhile (!searcher.searchFor(TextView.class, text, matches, scroll) && !searcher.searchForEditText(text, scroll) && now < endTime) {\n        \tnow = System.currentTimeMillis();\t\n        }    \n        if (now > endTime)\n        \treturn false;\n        \n       return true;\n    }\n",
    "new_code_raw": "\tpublic boolean waitForText(String text, int matches, long timeout, boolean scroll)\n    {\n\t\tlong now = System.currentTimeMillis();\n        final long endTime = now + timeout;\n\n\t\twhile (!searcher.searchFor(TextView.class, text, matches, scroll) && !searcher.searchForEditText(text, scroll) && now < endTime) {\n        \tnow = System.currentTimeMillis();\t\n        }\n\n\t\tfinal boolean timedOut = now > endTime;\n\t\treturn !timedOut;\n\n    }\n"
  },
  {
    "id": "querydsl_querydsl-1438-FirstSentence-0",
    "old_comment_raw": "Expr : left.substring(beginIndex, endIndex)",
    "new_comment_raw": "Expr : left.substring(right)",
    "old_code_raw": "    public static EString substring(Expr<String> left, int beginIndex, int endIndex) {\n        return operationFactory.createString(Ops.SUBSTR2ARGS, left, exprFactory.createConstant(beginIndex), exprFactory.createConstant(endIndex));\n    }\n",
    "new_code_raw": "    public static EString substring(Expr<String> left, int right) {\n        return operationFactory.createString(Ops.SUBSTR1ARG, left, exprFactory\n                .createConstant(right));\n    }\n"
  },
  {
    "id": "zaproxy_zaproxy-2037-FirstSentence-0",
    "old_comment_raw": "Calculate the ratio of similarity between 2 strings using LCS",
    "new_comment_raw": "Calculate the ratio of similarity between 2 strings using LCS",
    "old_code_raw": "    public double getMatchRatio(String strA, String strB) {\n        if (strA == null && strB == null) {\n            return MAX_RATIO;\n            \n        } else if (strA == null || strB == null) {\n            return MIN_RATIO;\n        }\n        \n        if (strA.isEmpty() && strB.isEmpty()) {\n            return MAX_RATIO;\n            \n        } else if (strA.isEmpty() || strB.isEmpty()) {\n            return MIN_RATIO;\n        }\n                \n        //get the percentage match against the longer of the 2 strings\n        return (double)getLCS(strA, strB).length() / max(strA.length(), strB.length());\n    }    \n",
    "new_code_raw": "    public double getMatchRatio(String strA, String strB) {\n        if (strA == null && strB == null) {\n            return MAX_RATIO;\n            \n        } else if (strA == null || strB == null) {\n            return MIN_RATIO;\n        }\n        \n        if (strA.isEmpty() && strB.isEmpty()) {\n            return MAX_RATIO;\n            \n        } else if (strA.isEmpty() || strB.isEmpty()) {\n            return MIN_RATIO;\n        }\n                \n        //get the percentage match against the longer of the 2 strings\n        return (double)getLCS(strA, strB).length() / Math.max(strA.length(), strB.length());\n    }    \n"
  },
  {
    "id": "apache_clerezza-4-Associations-FirstSentence",
    "old_comment_raw": "Returns the wrapped LockableMGraph if the caller has all access rights, otherwise an AccessControlException is thrown.",
    "new_comment_raw": "Returns the wrapped LockableMGraph if the caller has all access rights.",
    "old_code_raw": "\tpublic LockableMGraph getUnsecuredMGraph() {\n\t\tcheckWrite();\n\t\treturn wrapped;\n\t}\n",
    "new_code_raw": "\tpublic LockableMGraph getUnsecuredMGraph() {\n\t\ttry {\n\t\t\tcheckWrite();\n\t\t\treturn wrapped;\n\t\t} catch (AccessControlException ex) {\n\t\t\tcheckRead();\n\t\t\treturn new WriteBlockedMGraph(wrapped);\n\t\t}\n\t\t\n\t}\n\n"
  },
  {
    "id": "SeleniumHQ_selenium-584-FirstSentence-0",
    "old_comment_raw": "Determines if the specified element is visible.",
    "new_comment_raw": "Determines if the specified element is visible.",
    "old_code_raw": "  public boolean isVisible(String locator) {\n    return ((RenderedWebElement) findElement(locator)).isDisplayed();\n  }\n",
    "new_code_raw": "  public boolean isVisible(String locator) {\n    return ((RenderedWebElement) elementFinder.findElement(driver, locator)).isDisplayed();\n  }\n"
  },
  {
    "id": "apache_giraph-154-Associations-FirstSentence",
    "old_comment_raw": "Convenient replacement of  #startProfilingCPU(long) with  ProfilingModes#CPU_TRACING for the mode.",
    "new_comment_raw": "Create a YourKit controller and do some or all of  Controller#enableExceptionTelemetry()  Controller#startCPUProfiling(long, String, String)  Controller#startAllocationRecording(boolean, int, boolean, int, boolean, boolean) based on boolean config options passed as method parameters",
    "old_code_raw": "  public static YourKitContext startProfile(GiraphConfiguration conf) {\n    Controller controller = null;\n    try {\n      controller = new Controller();\n      controller.enableStackTelemetry();\n      controller.startCPUProfiling(ProfilingModes.CPU_SAMPLING,\n          Controller.DEFAULT_FILTERS);\n      LOG.debug(\"Started YourKit profiling CPU\");\n      // CHECKSTYLE: stop IllegalCatch\n    } catch (Exception e) {\n      // CHECKSTYLE: resume IllegalCatch\n      LOG.debug(\"Failed to start YourKit CPU profiling\", e);\n    }\n    return new YourKitContext(controller);\n  }\n",
    "new_code_raw": "  public static YourKitContext startProfile(boolean enableStackTelemetry,\n                                            boolean enableCPUProfilling,\n                                            boolean enableAllocationRecording) {\n    Controller controller;\n    try {\n      controller = new Controller();\n      // CHECKSTYLE: stop IllegalCatch\n    } catch (Exception e) {\n      // CHECKSTYLE: resume IllegalCatch\n      LOG.info(\"Failed to set up YourKit controller\", e);\n      return null;\n    }\n\n    try {\n      if (enableStackTelemetry) {\n        controller.enableStackTelemetry();\n        LOG.info(\"Enabled Yourkit stack telemetry\");\n      }\n      // CHECKSTYLE: stop IllegalCatch\n    } catch (Exception e) {\n      // CHECKSTYLE: resume IllegalCatch\n      LOG.info(\"Failed to enable YourKit stack telemetry\", e);\n    }\n\n    try {\n      if (enableCPUProfilling) {\n        controller.startCPUProfiling(ProfilingModes.CPU_SAMPLING,\n          Controller.DEFAULT_FILTERS, Controller.DEFAULT_WALLTIME_SPEC);\n        LOG.info(\"Started YourKit CPU profiling\");\n      }\n      // CHECKSTYLE: stop IllegalCatch\n    } catch (Exception e) {\n      // CHECKSTYLE: resume IllegalCatch\n      LOG.info(\"Failed to start YourKit CPU profiling\", e);\n    }\n\n    try {\n      if (enableAllocationRecording) {\n        controller.startAllocationRecording(true, ALLOCATION_RECORDING_INTERVAL,\n            false, -1, true, false);\n        LOG.info(\"Started YourKit allocation recording\");\n      }\n      // CHECKSTYLE: stop IllegalCatch\n    } catch (Exception e) {\n      // CHECKSTYLE: resume IllegalCatch\n      LOG.info(\"Failed to start YourKit allocation recording\", e);\n    }\n\n    return new YourKitContext(controller);\n  }\n\n"
  },
  {
    "id": "graphql_java_graphql_java-367-FirstSentence-0",
    "old_comment_raw": "This allows you to morph a type into a more specialized form yet return the same parent and non-null ness, for example taking a  GraphQLInterfaceType and turning it into a specific  graphql.schema.GraphQLObjectType after type resolution has occurred",
    "new_comment_raw": "This allows you to morph a type into a more specialized form yet return the same parent and non-null ness, for example taking a  GraphQLInterfaceType and turning it into a specific  graphql.schema.GraphQLObjectType after type resolution has occurred",
    "old_code_raw": "    public ExecutionInfo treatAs(GraphQLType newType) {\n        return new ExecutionInfo(unwrapNonNull(newType), fieldDefinition, field, path, this.parentType, this.typeIsNonNull, arguments);\n    }\n",
    "new_code_raw": "    public ExecutionInfo treatAs(GraphQLType newType) {\n        return new ExecutionInfo(unwrapNonNull(newType), fieldDefinition, field, path, this.parentInfo, this.typeIsNonNull, arguments);\n    }\n"
  },
  {
    "id": "hazelcast_hazelcast-489-Associations-FirstSentence",
    "old_comment_raw": "Selects the best candidate to be evicted.",
    "new_comment_raw": "The evaluate method implements the  com.hazelcast.config.EvictionPolicy rule on the given input set of candidates.",
    "old_code_raw": "    public <C extends EvictionCandidate<A, E>> C evaluate(Iterable<C> evictionCandidates) {\n        C selectedEvictionCandidate = null;\n        long now = Clock.currentTimeMillis();\n        for (C currentEvictionCandidate : evictionCandidates) {\n            if (selectedEvictionCandidate == null) {\n                selectedEvictionCandidate = currentEvictionCandidate;\n            } else {\n                E evictable = currentEvictionCandidate.getEvictable();\n                if (isExpired(now, evictable)) {\n                    return currentEvictionCandidate;\n                }\n\n                int comparisonResult = evictionPolicyComparator.compare(selectedEvictionCandidate, currentEvictionCandidate);\n                if (comparisonResult == EvictionPolicyComparator.SECOND_ENTRY_HAS_HIGHER_PRIORITY_TO_BE_EVICTED) {\n                    selectedEvictionCandidate = currentEvictionCandidate;\n                }\n            }\n        }\n        return selectedEvictionCandidate;\n    }\n",
    "new_code_raw": "    public <C extends EvictionCandidate<A, E>> Iterable<C> evaluate(Iterable<C> evictionCandidates) {\n        C selectedEvictionCandidate = null;\n        long now = Clock.currentTimeMillis();\n        for (C currentEvictionCandidate : evictionCandidates) {\n            if (selectedEvictionCandidate == null) {\n                selectedEvictionCandidate = currentEvictionCandidate;\n            } else {\n                E evictable = currentEvictionCandidate.getEvictable();\n                if (isExpired(now, evictable)) {\n                    return returnEvictionCandidate(currentEvictionCandidate);\n                }\n\n                int comparisonResult = evictionPolicyComparator.compare(selectedEvictionCandidate, currentEvictionCandidate);\n                if (comparisonResult == EvictionPolicyComparator.SECOND_ENTRY_HAS_HIGHER_PRIORITY_TO_BE_EVICTED) {\n                    selectedEvictionCandidate = currentEvictionCandidate;\n                }\n            }\n        }\n        return returnEvictionCandidate(selectedEvictionCandidate);\n    }\n\n"
  },
  {
    "id": "apache_avro-39-FirstSentence-0",
    "old_comment_raw": "Gets the job output key schema.",
    "new_comment_raw": "Gets the job output key schema.",
    "old_code_raw": "  public static Schema getOutputKeySchema(Configuration conf) {\n    String schemaString = conf.get(CONF_OUTPUT_KEY_SCHEMA);\n    return schemaString != null ? Schema.parse(schemaString) : null;\n  }\n",
    "new_code_raw": "  public static Schema getOutputKeySchema(Configuration conf) {\n    String schemaString = conf.get(CONF_OUTPUT_KEY_SCHEMA);\n    return schemaString != null ? new Schema.Parser().parse(schemaString) : null;\n  }\n"
  },
  {
    "id": "hoecake_ephesoft-37-Associations-FirstSentence",
    "old_comment_raw": "An api to fetch count of the batch instance table for a given status list and batch priority and current user required",
    "new_comment_raw": "An api to fetch count of the batch instances for a given status list and batch priority and isCurrUsrNotReq is used for adding the batch instance access by the current user.",
    "old_code_raw": "\t@Transactional(readOnly = true)\n\t@Override\n\tpublic int getCount(final List<BatchInstanceStatus> batchInstStatusList, final List<BatchPriority> batchPriorities,\n\t\t\tfinal boolean isCurrUsrNotReq, final String currentUser, final Set<String> currentRole) {\n\t\treturn batchInstanceDao.getCount(batchInstStatusList, batchPriorities, isCurrUsrNotReq, currentRole, currentUser);\n\t}\n",
    "new_code_raw": "\t@Transactional(readOnly = true)\n\t@Override\n\tpublic int getCount(final List<BatchInstanceStatus> batchInstStatusList, final List<BatchPriority> batchPriorities,\n\t\t\tfinal boolean isCurrUsrNotReq, final String currentUser, final Set<String> userRoles, EphesoftUser ephesoftUser) {\n\t\treturn batchInstanceDao\n\t\t\t\t.getCount(batchInstStatusList, batchPriorities, isCurrUsrNotReq, userRoles, currentUser, ephesoftUser);\n\t}\n\n"
  },
  {
    "id": "jgilfelt_chuck-1-FirstSentence-0",
    "old_comment_raw": "Control the max length for request and response content that will be retained.",
    "new_comment_raw": "Control the max length for request and response content that will be retained.",
    "old_code_raw": "    public ChuckInterceptor maxContentLength(long max) {\n        this.maxContentLength = max;\n    }\n",
    "new_code_raw": "    public ChuckInterceptor maxContentLength(long max) {\n        this.maxContentLength = max;\n        return this;\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2400-FirstSentence-0",
    "old_comment_raw": "Just a pass through to the NDArray version, plus a FastMath.exp to ensure that to the outside world the TableFactor doesn't look like it's in log-space",
    "new_comment_raw": "Just a pass through to the NDArray version, plus a Math.exp to ensure that to the outside world the TableFactor doesn't look like it's in log-space",
    "old_code_raw": "    public double getAssignmentValue(int[] assignment) {\n        double d = super.getAssignmentValue(assignment);\n        // if (d == null) d = Double.NEGATIVE_INFINITY;\n        return FastMath.exp(d);\n    }\n",
    "new_code_raw": "    public double getAssignmentValue(int[] assignment) {\n        double d = super.getAssignmentValue(assignment);\n        // if (d == null) d = Double.NEGATIVE_INFINITY;\n        return Math.exp(d);\n    }\n"
  },
  {
    "id": "debezium_debezium-777-FirstSentence-0",
    "old_comment_raw": "Obtain a new  Builder instance that can be used to construct runnable  EmbeddedEngine instances.",
    "new_comment_raw": "Obtain a new  Builder instance that can be used to construct runnable  EmbeddedEngine instances.",
    "old_code_raw": "    public static Builder create() {\n        return new Builder() {\n            private Configuration config;\n            private Consumer<SourceRecord> consumer;\n            private ClassLoader classLoader;\n            private Clock clock;\n\n            @Override\n            public Builder using(Configuration config) {\n                this.config = config;\n                return this;\n            }\n\n            @Override\n            public Builder using(ClassLoader classLoader) {\n                this.classLoader = classLoader;\n                return this;\n            }\n\n            @Override\n            public Builder using(Clock clock) {\n                this.clock = clock;\n                return this;\n            }\n\n            @Override\n            public Builder notifying(Consumer<SourceRecord> consumer) {\n                this.consumer = consumer;\n                return this;\n            }\n\n            @Override\n            public EmbeddedEngine build() {\n                if (classLoader == null) classLoader = getClass().getClassLoader();\n                if (clock == null) clock = Clock.system();\n                Objects.requireNonNull(config, \"A connector configuration must be specified.\");\n                Objects.requireNonNull(consumer, \"A connector consumer must be specified.\");\n                return new EmbeddedEngine(config, classLoader, clock, consumer);\n            }\n\n        };\n    }\n",
    "new_code_raw": "    public static Builder create() {\n        return new Builder() {\n            private Configuration config;\n            private Consumer<SourceRecord> consumer;\n            private ClassLoader classLoader;\n            private Clock clock;\n            private CompletionCallback completionCallback;\n\n            @Override\n            public Builder using(Configuration config) {\n                this.config = config;\n                return this;\n            }\n\n            @Override\n            public Builder using(ClassLoader classLoader) {\n                this.classLoader = classLoader;\n                return this;\n            }\n\n            @Override\n            public Builder using(Clock clock) {\n                this.clock = clock;\n                return this;\n            }\n\n            @Override\n            public Builder using(CompletionCallback completionCallback) {\n                this.completionCallback = completionCallback;\n                return this;\n            }\n\n            @Override\n            public Builder notifying(Consumer<SourceRecord> consumer) {\n                this.consumer = consumer;\n                return this;\n            }\n\n            @Override\n            public EmbeddedEngine build() {\n                if (classLoader == null) classLoader = getClass().getClassLoader();\n                if (clock == null) clock = Clock.system();\n                Objects.requireNonNull(config, \"A connector configuration must be specified.\");\n                Objects.requireNonNull(consumer, \"A connector consumer must be specified.\");\n                return new EmbeddedEngine(config, classLoader, clock, consumer, completionCallback);\n            }\n\n        };\n    }\n"
  },
  {
    "id": "caillette_novelang-1-Associations-FirstSentence",
    "old_comment_raw": "Returns the sibling on the left of the end of given  Treepath.",
    "new_comment_raw": "Returns the sibling on the left of the bottom of given  Treepath.",
    "old_code_raw": "  public static Treepath getPreviousSibling( Treepath treepath ) {\n    if( treepath.getHeight() < 2 ) {\n      throw new IllegalArgumentException( \"Treepath must have minimum height of 2\" ) ;\n    }\n    final Tree treeToMove = treepath.getBottom() ;\n    final Tree parent = treepath.getTreeAtHeight( 1 ) ;\n    for( int i = parent.getChildCount() - 1 ; i > 0 ; i-- ) {\n      final Tree child = parent.getChildAt( i ) ;\n      if( child == treeToMove ) {\n        return Treepath.create( treepath.getParent(), parent.getChildAt( i - 1 ) ) ;\n      }\n    }\n    return null ;\n  }\n",
    "new_code_raw": "  public static Treepath getPreviousSibling( Treepath treepath ) throws IllegalArgumentException {\n    if( treepath.getHeight() < 2 ) {\n      throw new IllegalArgumentException( \"Treepath must have minimum height of 2\" ) ;\n    }\n    final Tree treeToMove = treepath.getBottom() ;\n    final Tree parent = treepath.getTreeAtHeight( 1 ) ;\n    for( int i = parent.getChildCount() - 1 ; i > 0 ; i-- ) {\n      final Tree child = parent.getChildAt( i ) ;\n      if( child == treeToMove ) {\n        return Treepath.create( treepath.getParent(), parent.getChildAt( i - 1 ) ) ;\n      }\n    }\n    throw new IllegalArgumentException( \"No previous sibling\" ) ;\n  }\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-1954-FirstSentence-0",
    "old_comment_raw": "Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.",
    "new_comment_raw": "Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.",
    "old_code_raw": "  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          int zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 38: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '/');\n                  }\n                  if (normalizeSpace) {\n                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 55: break;\n        case 43: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 9;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 10;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { // try to work around an apparent jflex bug where it\n                          // gets a space at the token end by getting\n                          // wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n\t\t\t  return getNext();\n          }\n        case 56: break;\n        case 11: \n          { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 57: break;\n        case 19: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 58: break;\n        case 8: \n          { return handleQuotes(yytext(), false);\n          }\n        case 59: break;\n        case 35: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), false);\n          }\n        case 60: break;\n        case 27: \n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 61: break;\n        case 33: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 62: break;\n        case 48: \n          { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 63: break;\n        case 49: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNormalizedAmpNext();\n          }\n        case 64: break;\n        case 36: \n          { return getNormalizedAmpNext();\n          }\n        case 65: break;\n        case 23: \n          { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n          }\n        case 66: break;\n        case 37: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '/');\n                  }\n                  if (normalizeSpace) {\n                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 67: break;\n        case 53: \n          // lookahead expression with fixed lookahead length\n          yypushback(4);\n          { return getNext();\n          }\n        case 68: break;\n        case 46: \n          // lookahead expression with fixed lookahead length\n          yypushback(2);\n          { return getNext();\n          }\n        case 69: break;\n        case 42: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 15;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 70: break;\n        case 41: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 16;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 17;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 71: break;\n        case 40: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 13;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 72: break;\n        case 3: \n          { return getNext();\n          }\n        case 73: break;\n        case 24: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext();\n          }\n        case 74: break;\n        case 51: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 75: break;\n        case 26: \n          { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n          }\n        case 76: break;\n        case 6: \n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 77: break;\n        case 29: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 3;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 4;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 78: break;\n        case 16: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 79: break;\n        case 2: \n          { return getNext(\"<\", yytext());\n          }\n        case 80: break;\n        case 30: \n          { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 81: break;\n        case 18: \n          { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 82: break;\n        case 54: \n          { String txt = yytext();\n                          if (normalizeSpace) {\n                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 83: break;\n        case 25: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), true);\n          }\n        case 84: break;\n        case 39: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 5;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 6;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n          }\n        case 85: break;\n        case 21: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 86: break;\n        case 50: \n          { if (splitAssimilations) {\n                            yypushback(3) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 87: break;\n        case 17: \n          { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 88: break;\n        case 13: \n          { return handleEllipsis(yytext());\n          }\n        case 89: break;\n        case 34: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 1;\n          { /* invert quote - often but not always right */\n                  return handleQuotes(yytext(), true);\n          }\n        case 90: break;\n        case 14: \n          { return normalizeFractions(yytext());\n          }\n        case 91: break;\n        case 15: \n          { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 92: break;\n        case 47: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 11;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 12;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 93: break;\n        case 7: \n          { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n          }\n        case 94: break;\n        case 9: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 95: break;\n        case 45: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                               yytext());\n          }\n        case 96: break;\n        case 4: \n          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n          }\n        case 97: break;\n        case 28: \n          { return getNext(removeSoftHyphens(yytext()), yytext());\n          }\n        case 98: break;\n        case 20: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 99: break;\n        case 12: \n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 100: break;\n        case 31: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 101: break;\n        case 10: \n          { return getNext(\">\", yytext());\n          }\n        case 102: break;\n        case 32: \n          { // this one should only match if we're basically at the end of file\n                          // since the last one matches two things, even newlines\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 103: break;\n        case 22: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 104: break;\n        case 52: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 7;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 8;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { // try to work around an apparent jflex bug where it\n                          // gets a space at the token end by getting\n                          // wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 105: break;\n        case 1: \n          { String str = yytext();\n          int first = str.charAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n          }\n        case 106: break;\n        case 44: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 107: break;\n        case 5: \n          { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n          }\n        case 108: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                if (invertible) {\n            prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n",
    "new_code_raw": "  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          int zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 38: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '/');\n                  }\n                  if (normalizeSpace) {\n                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 55: break;\n        case 43: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 9;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 10;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { // try to work around an apparent jflex bug where it\n                          // gets a space at the token end by getting\n                          // wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n\t\t\t  return getNext();\n          }\n        case 56: break;\n        case 11: \n          { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 57: break;\n        case 19: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 58: break;\n        case 8: \n          { return handleQuotes(yytext(), false);\n          }\n        case 59: break;\n        case 35: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), false);\n          }\n        case 60: break;\n        case 27: \n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 61: break;\n        case 33: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 62: break;\n        case 49: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNormalizedAmpNext();\n          }\n        case 63: break;\n        case 36: \n          { return getNormalizedAmpNext();\n          }\n        case 64: break;\n        case 23: \n          { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n          }\n        case 65: break;\n        case 37: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '/');\n                  }\n                  if (normalizeSpace) {\n                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 66: break;\n        case 53: \n          // lookahead expression with fixed lookahead length\n          yypushback(4);\n          { return getNext();\n          }\n        case 67: break;\n        case 46: \n          // lookahead expression with fixed lookahead length\n          yypushback(2);\n          { return getNext();\n          }\n        case 68: break;\n        case 42: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 15;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 69: break;\n        case 41: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 16;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 17;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 70: break;\n        case 40: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 13;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 71: break;\n        case 3: \n          { return getNext();\n          }\n        case 72: break;\n        case 24: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext();\n          }\n        case 73: break;\n        case 51: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 74: break;\n        case 26: \n          { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n          }\n        case 75: break;\n        case 6: \n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 76: break;\n        case 29: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 3;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 4;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 77: break;\n        case 16: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 78: break;\n        case 2: \n          { return getNext(\"<\", yytext());\n          }\n        case 79: break;\n        case 30: \n          { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 80: break;\n        case 18: \n          { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 81: break;\n        case 54: \n          { String txt = yytext();\n                          if (normalizeSpace) {\n                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 82: break;\n        case 50: \n          { yypushback(3) ; return getNext();\n          }\n        case 83: break;\n        case 25: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), true);\n          }\n        case 84: break;\n        case 39: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 5;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 6;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n          }\n        case 85: break;\n        case 21: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 86: break;\n        case 17: \n          { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 87: break;\n        case 13: \n          { return handleEllipsis(yytext());\n          }\n        case 88: break;\n        case 34: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 1;\n          { /* invert quote - often but not always right */\n                  return handleQuotes(yytext(), true);\n          }\n        case 89: break;\n        case 14: \n          { return normalizeFractions(yytext());\n          }\n        case 90: break;\n        case 15: \n          { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 91: break;\n        case 47: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 11;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 12;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 92: break;\n        case 7: \n          { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n          }\n        case 93: break;\n        case 9: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 94: break;\n        case 45: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                               yytext());\n          }\n        case 95: break;\n        case 4: \n          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n          }\n        case 96: break;\n        case 28: \n          { return getNext(removeSoftHyphens(yytext()), yytext());\n          }\n        case 97: break;\n        case 48: \n          { if (keepAssimilations) {\n                            yypushback(2) ; return getNext(); \n                          } else {\n                            return getNext();\n                          }\n          }\n        case 98: break;\n        case 20: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 99: break;\n        case 12: \n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 100: break;\n        case 31: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 101: break;\n        case 10: \n          { return getNext(\">\", yytext());\n          }\n        case 102: break;\n        case 32: \n          { // this one should only match if we're basically at the end of file\n                          // since the last one matches two things, even newlines\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 103: break;\n        case 22: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 104: break;\n        case 52: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 7;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 8;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { // try to work around an apparent jflex bug where it\n                          // gets a space at the token end by getting\n                          // wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 105: break;\n        case 1: \n          { String str = yytext();\n          int first = str.charAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n          }\n        case 106: break;\n        case 44: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 107: break;\n        case 5: \n          { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n          }\n        case 108: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                if (invertible) {\n            prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n"
  },
  {
    "id": "apache_tuscany-sca-1.x-34-Associations-FirstSentence",
    "old_comment_raw": "Visits the given implementation type and calls back to  org.apache.tuscany.core.extension.config.ImplementationProcessors registered with this introspector to build up a  ComponentInfo",
    "new_comment_raw": "Visits the given implementation type and calls back to  org.apache.tuscany.core.extension.config.ImplementationProcessors registered with this introspector to build up a  ComponentType",
    "old_code_raw": "    public ComponentInfo introspect(Class<?> implClass) throws ConfigurationLoadException {\n        ComponentInfo compType = factory.createComponentInfo();\n        return introspect(implClass, compType);\n    }\n",
    "new_code_raw": "    public ComponentType introspect(Class<?> implClass) throws ConfigurationLoadException {\n        ComponentType compType = factory.createComponentType();\n        return introspect(implClass, compType);\n    }\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2246-FirstSentence-0",
    "old_comment_raw": "Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.",
    "new_comment_raw": "Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.",
    "old_code_raw": "  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n              {\n                if (invertible) {\n            // prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            // System.err.println(\"At end of text making after: |\" + str + \"|\");\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n            // System.err.println(\"prevWord is |\" + prevWord.get(CoreAnnotations.TextAnnotation.class) + \"|, its after is |\" +\n            //         prevWord.get(CoreAnnotations.AfterAnnotation.class) + \"|\");\n            prevWordAfter.setLength(0);\n          }\n          return null;\n              }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { String str = yytext();\n          int first = str.codePointAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n            }\n          case 67: break;\n          case 2: \n            { return getNext(\"<\", yytext());\n            }\n          case 68: break;\n          case 3: \n            { return getNext();\n            }\n          case 69: break;\n          case 4: \n            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n            }\n          case 70: break;\n          case 5: \n            { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns\n                  } else if (invertible) {\n                    // System.err.println(\"Appending newline: |\" + yytext() + \"|\");\n                    prevWordAfter.append(yytext());\n                  }\n            }\n          case 71: break;\n          case 6: \n            { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n            }\n          case 72: break;\n          case 7: \n            { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n            }\n          case 73: break;\n          case 8: \n            { return handleQuotes(yytext(), false);\n            }\n          case 74: break;\n          case 9: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 75: break;\n          case 10: \n            { return getNext(\">\", yytext());\n            }\n          case 76: break;\n          case 11: \n            { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n            }\n          case 77: break;\n          case 12: \n            { handleHyphenatedNumber(yytext());\n                          return getNext(removeFromNumber(yytext()), yytext());\n            }\n          case 78: break;\n          case 13: \n            { return handleEllipsis(yytext());\n            }\n          case 79: break;\n          case 14: \n            { return normalizeFractions(yytext());\n            }\n          case 80: break;\n          case 15: \n            { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext());\n                        } else {\n                            return getNext(minimallyNormalizeCurrency(yytext()), yytext());\n                          }\n            }\n          case 81: break;\n          case 16: \n            { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 82: break;\n          case 17: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 83: break;\n          case 18: \n            { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 84: break;\n          case 19: \n            { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 85: break;\n          case 20: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 86: break;\n          case 21: \n            { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 87: break;\n          case 22: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 88: break;\n          case 23: \n            { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n            }\n          case 89: break;\n          case 24: \n            { return getNext(\"\\u2022\", yytext());\n            }\n          case 90: break;\n          case 25: \n            { return getNext(\"\\u2122\", yytext());\n            }\n          case 91: break;\n          case 26: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 15;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 92: break;\n          case 27: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext();\n            }\n          case 93: break;\n          case 28: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return handleQuotes(yytext(), true);\n            }\n          case 94: break;\n          case 29: \n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 95: break;\n          case 30: \n            { breakByHyphens(yytext());\n                    return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 96: break;\n          case 31: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 3;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 4;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n            }\n          case 97: break;\n          case 32: \n            { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 98: break;\n          case 33: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 99: break;\n          case 34: \n            { // this one should only match if we're basically at the end of file\n                          // since the last one matches two things, even newlines (if not tokenize per line)\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n            }\n          case 100: break;\n          case 35: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 101: break;\n          case 36: \n            // lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 1);\n            { /* invert quote - often but not always right */\n                  return handleQuotes(yytext(), true);\n            }\n          case 102: break;\n          case 37: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return handleQuotes(yytext(), false);\n            }\n          case 103: break;\n          case 38: \n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 104: break;\n          case 39: \n            { String txt = yytext();\n                  // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...\n                  if (strictTreebank3) {\n                    int spaceIndex = indexOfSpace(txt);\n                    if (spaceIndex >= 0) {\n                      yypushback(txt.length() - spaceIndex);\n                      return getNext();\n                    }\n                  }\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '/');\n                  }\n                  if (normalizeSpace) {\n                    txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n            }\n          case 105: break;\n          case 40: \n            { return getNormalizedAmpNext();\n            }\n          case 106: break;\n          case 41: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 107: break;\n          case 42: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 108: break;\n          case 43: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 5;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 6;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n            }\n          case 109: break;\n          case 44: \n            { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 110: break;\n          case 45: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 17;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 111: break;\n          case 46: \n            // lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 112: break;\n          case 47: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 113: break;\n          case 48: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 22;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 114: break;\n          case 49: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 18;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 19;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 115: break;\n          case 50: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 116: break;\n          case 51: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 21;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 117: break;\n          case 52: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 118: break;\n          case 53: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { breakByHyphens(yytext());\n                    return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 119: break;\n          case 54: \n            { if (splitAssimilations) {\n                            yypushback(3) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 120: break;\n          case 55: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNormalizedAmpNext();\n            }\n          case 121: break;\n          case 56: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 9;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 122: break;\n          case 57: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { return getNext();\n            }\n          case 123: break;\n          case 58: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 14;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 124: break;\n          case 59: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 8;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 125: break;\n          case 60: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 13;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 126: break;\n          case 61: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 127: break;\n          case 62: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);\n            { return getNext();\n            }\n          case 128: break;\n          case 63: \n            // lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { return getNext();\n            }\n          case 129: break;\n          case 64: \n            { String txt = yytext();\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 130: break;\n          case 65: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 25;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 131: break;\n          case 66: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 24;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 132: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n",
    "new_code_raw": "  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n              {\n                if (invertible) {\n            prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { String str = yytext();\n          int first = str.codePointAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n            }\n          case 67: break;\n          case 2: \n            { return getNext(\"<\", yytext());\n            }\n          case 68: break;\n          case 3: \n            { return getNext();\n            }\n          case 69: break;\n          case 4: \n            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n            }\n          case 70: break;\n          case 5: \n            { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n            }\n          case 71: break;\n          case 6: \n            { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n            }\n          case 72: break;\n          case 7: \n            { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n            }\n          case 73: break;\n          case 8: \n            { return handleQuotes(yytext(), false);\n            }\n          case 74: break;\n          case 9: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 75: break;\n          case 10: \n            { return getNext(\">\", yytext());\n            }\n          case 76: break;\n          case 11: \n            { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n            }\n          case 77: break;\n          case 12: \n            { return getNext(removeFromNumber(yytext()), yytext());\n            }\n          case 78: break;\n          case 13: \n            { return handleEllipsis(yytext());\n            }\n          case 79: break;\n          case 14: \n            { return normalizeFractions(yytext());\n            }\n          case 80: break;\n          case 15: \n            { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext());\n                        } else {\n                            return getNext(minimallyNormalizeCurrency(yytext()), yytext());\n                          }\n            }\n          case 81: break;\n          case 16: \n            { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 82: break;\n          case 17: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 83: break;\n          case 18: \n            { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 84: break;\n          case 19: \n            { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 85: break;\n          case 20: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 86: break;\n          case 21: \n            { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 87: break;\n          case 22: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 88: break;\n          case 23: \n            { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n            }\n          case 89: break;\n          case 24: \n            { return getNext(\"\\u2022\", yytext());\n            }\n          case 90: break;\n          case 25: \n            { return getNext(\"\\u2122\", yytext());\n            }\n          case 91: break;\n          case 26: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 15;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 92: break;\n          case 27: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext();\n            }\n          case 93: break;\n          case 28: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return handleQuotes(yytext(), true);\n            }\n          case 94: break;\n          case 29: \n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 95: break;\n          case 30: \n            { breakByHyphens(yytext());\n                    return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 96: break;\n          case 31: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 3;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 4;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n            }\n          case 97: break;\n          case 32: \n            { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 98: break;\n          case 33: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 99: break;\n          case 34: \n            { // this one should only match if we're basically at the end of file\n                          // since the last one matches two things, even newlines (if not tokenize per line)\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n            }\n          case 100: break;\n          case 35: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 101: break;\n          case 36: \n            // lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 1);\n            { /* invert quote - often but not always right */\n                  return handleQuotes(yytext(), true);\n            }\n          case 102: break;\n          case 37: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return handleQuotes(yytext(), false);\n            }\n          case 103: break;\n          case 38: \n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 104: break;\n          case 39: \n            { String txt = yytext();\n                  // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...\n                  if (strictTreebank3) {\n                    int spaceIndex = indexOfSpace(txt);\n                    if (spaceIndex >= 0) {\n                      yypushback(txt.length() - spaceIndex);\n                      String newText = yytext();\n                      return getNext(newText, newText);\n                    }\n                  }\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '/');\n                  }\n                  if (normalizeSpace) {\n                    txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                  }\n                  return getNext(txt, txt);\n            }\n          case 105: break;\n          case 40: \n            { return getNormalizedAmpNext();\n            }\n          case 106: break;\n          case 41: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 107: break;\n          case 42: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 108: break;\n          case 43: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 5;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 6;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n            }\n          case 109: break;\n          case 44: \n            { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 110: break;\n          case 45: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 17;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 111: break;\n          case 46: \n            // lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 112: break;\n          case 47: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 113: break;\n          case 48: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 22;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 114: break;\n          case 49: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 18;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 19;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 115: break;\n          case 50: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 116: break;\n          case 51: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 21;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 117: break;\n          case 52: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 118: break;\n          case 53: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { breakByHyphens(yytext());\n                    return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 119: break;\n          case 54: \n            { if (splitAssimilations) {\n                            yypushback(3) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 120: break;\n          case 55: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNormalizedAmpNext();\n            }\n          case 121: break;\n          case 56: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 9;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 122: break;\n          case 57: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { return getNext();\n            }\n          case 123: break;\n          case 58: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 14;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 124: break;\n          case 59: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 8;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 125: break;\n          case 60: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 13;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 126: break;\n          case 61: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 127: break;\n          case 62: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);\n            { return getNext();\n            }\n          case 128: break;\n          case 63: \n            // lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { return getNext();\n            }\n          case 129: break;\n          case 64: \n            { String txt = yytext();\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 130: break;\n          case 65: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 25;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 131: break;\n          case 66: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 24;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 132: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n"
  },
  {
    "id": "eseawind_opening-trunk-9-Associations-FirstSentence",
    "old_comment_raw": "Returns the entity as an input stream.",
    "new_comment_raw": "Returns the entity.",
    "old_code_raw": "    public final BranchingInputStream getEntity() {\n        return entity;\n    }\n",
    "new_code_raw": "    public final Entity getEntity() {\n        return entity;\n    }\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-599-FirstSentence-0",
    "old_comment_raw": "Tags the Words in each Sentence in the given List with their grammatical part-of-speech.",
    "new_comment_raw": "Tags the Words in each Sentence in the given List with their grammatical part-of-speech.",
    "old_code_raw": "  public List<ArrayList<TaggedWord>> process(List<? extends List<? extends HasWord>> sentences) {\n    List<ArrayList<TaggedWord>> taggedSentences = new ArrayList<ArrayList<TaggedWord>>();\n\n    TestSentence testSentence = new TestSentence(this);\n    for (List<? extends HasWord> sentence : sentences) {\n      taggedSentences.add(testSentence.tagSentence(sentence, false));\n    }\n    return taggedSentences;\n  }\n",
    "new_code_raw": "  public List<List<TaggedWord>> process(List<? extends List<? extends HasWord>> sentences) {\n    List<List<TaggedWord>> taggedSentences = Generics.newArrayList();\n\n    TestSentence testSentence = new TestSentence(this);\n    for (List<? extends HasWord> sentence : sentences) {\n      taggedSentences.add(testSentence.tagSentence(sentence, false));\n    }\n    return taggedSentences;\n  }\n"
  },
  {
    "id": "yahoo_bullet-core-17-Associations-FirstSentence",
    "old_comment_raw": "Returns true if the query window is closed and you should emit the result at this time.",
    "new_comment_raw": "Depending on the  Mode#ALL mode this is operating in, returns true if and only if the query window is closed and you should emit the result at this time.",
    "old_code_raw": "    @Override\n    public boolean isClosed() {\n        return window.isClosed();\n    }\n",
    "new_code_raw": "    @Override\n    public boolean isClosed() {\n        return mode == Mode.PARTITION ? window.isClosedForPartition() : window.isClosed();\n    }\n\n"
  },
  {
    "id": "SeleniumHQ_selenium-794-FirstSentence-0",
    "old_comment_raw": "Configures and returns a new  OperaDriverService using the default configuration.",
    "new_comment_raw": "Configures and returns a new  OperaDriverService using the default configuration.",
    "old_code_raw": "  public static OperaDriverService createDefaultService() {\n    return new Builder().usingAnyFreePort().build();\n  }\n",
    "new_code_raw": "  public static OperaDriverService createDefaultService() {\n    return new Builder().build();\n  }\n"
  },
  {
    "id": "sudosurootdev_frameworks_opt_telephony-50-Associations-FirstSentence",
    "old_comment_raw": "Returns the  android.telecomm.Connection.VideoProvider for the connection.",
    "new_comment_raw": "Returns the  android.telecom.Connection.VideoProvider for the connection.",
    "old_code_raw": "    public android.telecomm.Connection.VideoProvider getVideoProvider() {\n        return mVideoProvider;\n    }\n",
    "new_code_raw": "    public android.telecom.Connection.VideoProvider getVideoProvider() {\n        return mVideoProvider;\n    }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-778-FirstSentence-0",
    "old_comment_raw": "Get the hour of day (offset to 1-24) field type.",
    "new_comment_raw": "Get the hour of day (offset to 1-24) field type.",
    "old_code_raw": "    public static DateTimeFieldType clockhourOfDay() {\n        return CLOCKHOUR_OF_DAY;\n    }\n",
    "new_code_raw": "    public static DateTimeFieldType clockhourOfDay() {\n        return CLOCKHOUR_OF_DAY_TYPE;\n    }\n"
  },
  {
    "id": "apache_lenya-281-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Returns the live path",
    "old_code_raw": "    public String getLivePath() {\n        return livePath;\n    }\n",
    "new_code_raw": "    public String getLivePath() {\n        return this.livePath;\n    }\n\n"
  },
  {
    "id": "apache_activemq-1041-FirstSentence-0",
    "old_comment_raw": "Creates a publisher for the specified topic.",
    "new_comment_raw": "Creates a publisher for the specified topic.",
    "old_code_raw": "    public TopicPublisher createPublisher(Topic topic) throws JMSException {\n        checkClosed();\n\n        if (topic instanceof CustomDestination) {\n            CustomDestination customDestination = (CustomDestination)topic;\n            return customDestination.createPublisher(this);\n        }\n        return new ActiveMQTopicPublisher(this, ActiveMQMessageTransformation.transformDestination(topic));\n    }\n",
    "new_code_raw": "    public TopicPublisher createPublisher(Topic topic) throws JMSException {\n        checkClosed();\n\n        if (topic instanceof CustomDestination) {\n            CustomDestination customDestination = (CustomDestination)topic;\n            return customDestination.createPublisher(this);\n        }\n        int timeSendOut = connection.getSendTimeout();\n        return new ActiveMQTopicPublisher(this, ActiveMQMessageTransformation.transformDestination(topic),timeSendOut);\n    }\n"
  },
  {
    "id": "debezium_debezium-26-FirstSentence-0",
    "old_comment_raw": "Obtain an editor for the identified table or, if there is no such table, create an editor with the specified ID.",
    "new_comment_raw": "Obtain an editor for the table with the given ID.",
    "old_code_raw": "    public TableEditor editOrCreateTable(String catalogName, String schemaName, String tableName) {\n        return editOrCreateTable(new TableId(catalogName, schemaName, tableName));\n    }\n",
    "new_code_raw": "    public TableEditor editOrCreateTable(TableId tableId) {\n        Table table = forTable(tableId);\n        return table == null ? Table.editor().tableId(tableId) : table.edit();\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-1238-FirstSentence-0",
    "old_comment_raw": "Searches for a text string in the edit texts located in the current activity.",
    "new_comment_raw": "Searches for a text string in the edit texts located in the current activity.",
    "old_code_raw": "\tpublic boolean searchEditText(String search) {\n\t\tPattern p = Pattern.compile(search);\n\t\tMatcher matcher;\n\t\tArrayList<EditText> editTextList = getCurrentEditTexts();\n\t\tIterator<EditText> iterator = editTextList.iterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tEditText editText = (EditText) iterator.next();\n\t\t\tmatcher = p.matcher(editText.getText().toString());\n\t\t\tif (matcher.matches()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (scrollDownList())\n\t\t\treturn searchEditText(search);\n\t\telse\n\t\t\treturn false;\n\t}\n",
    "new_code_raw": "\tpublic boolean searchEditText(String search) {\n\t\tboolean found = soloSearch.searchEditText(search);\n\t\treturn found;\n\t}\n"
  },
  {
    "id": "hibernate_hibernate_orm-297-FirstSentence-0",
    "old_comment_raw": "Deserializes an Object from the specified stream. The stream will be closed once the object is written.",
    "new_comment_raw": "Deserializes an object from the specified stream using the Thread Context",
    "old_code_raw": "    public static Object deserialize(InputStream inputStream) throws SerializationException {\n        if (inputStream == null) {\n            throw new IllegalArgumentException(\"The InputStream must not be null\");\n        }\n\n\t\tlog.trace(\"Starting deserialization of object\");\n\n        CustomObjectInputStream in = null;\n        try {\n            // stream closed in the finally\n            in = new CustomObjectInputStream(inputStream);\n            return in.readObject();\n\n        }\n        catch (ClassNotFoundException ex) {\n            throw new SerializationException(\"could not deserialize\", ex);\n        }\n        catch (IOException ex) {\n            throw new SerializationException(\"could not deserialize\", ex);\n        }\n        finally {\n            try {\n                if (in != null) in.close();\n            }\n            catch (IOException ex) {}\n        }\n    }\n",
    "new_code_raw": "    public static Object deserialize(InputStream inputStream) throws SerializationException {\n\t\treturn deserialize( inputStream, Thread.currentThread().getContextClassLoader() );\n    }\n"
  },
  {
    "id": "socketio_socket.io_client_java-47-FirstSentence-0",
    "old_comment_raw": "Initializes a  Socket from an existing  Manager for multiplexing.",
    "new_comment_raw": "Initializes a  Socket from an existing  Manager for multiplexing.",
    "old_code_raw": "    public static Socket socket(URI uri, Options opts) {\n        if (opts == null) {\n            opts = new Options();\n        }\n\n        URL parsed = Url.parse(uri);\n        URI source;\n        try {\n            source = parsed.toURI();\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n        String id = Url.extractId(parsed);\n        String path = parsed.getPath();\n        boolean sameNamespace = managers.containsKey(id)\n                && managers.get(id).nsps.containsKey(path);\n        boolean newConnection = opts.forceNew || !opts.multiplex || sameNamespace;\n        Manager io;\n\n        if (newConnection) {\n            logger.fine(String.format(\"ignoring socket cache for %s\", source));\n            io = new Manager(source, opts);\n        } else {\n            if (!managers.containsKey(id)) {\n                logger.fine(String.format(\"new io instance for %s\", source));\n                managers.putIfAbsent(id, new Manager(source, opts));\n            }\n            io = managers.get(id);\n        }\n\n        return io.socket(parsed.getPath());\n    }\n",
    "new_code_raw": "    public static Socket socket(URI uri, Options opts) {\n        if (opts == null) {\n            opts = new Options();\n        }\n\n        URL parsed = Url.parse(uri);\n        URI source;\n        try {\n            source = parsed.toURI();\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n        String id = Url.extractId(parsed);\n        String path = parsed.getPath();\n        boolean sameNamespace = managers.containsKey(id)\n                && managers.get(id).nsps.containsKey(path);\n        boolean newConnection = opts.forceNew || !opts.multiplex || sameNamespace;\n        Manager io;\n\n        if (newConnection) {\n            logger.fine(String.format(\"ignoring socket cache for %s\", source));\n            io = new Manager(source, opts);\n        } else {\n            if (!managers.containsKey(id)) {\n                logger.fine(String.format(\"new io instance for %s\", source));\n                managers.putIfAbsent(id, new Manager(source, opts));\n            }\n            io = managers.get(id);\n        }\n\n        String query = parsed.getQuery();\n        if (query != null && (opts.query == null || opts.query.isEmpty())) {\n            opts.query = query;\n        }\n\n        return io.socket(parsed.getPath(), opts);\n    }\n"
  },
  {
    "id": "twitter_commons-30-Associations-FirstSentence",
    "old_comment_raw": "Deserializes the previously serialized TokenStream using the provided AttributeSerializer(s).",
    "new_comment_raw": "Deserializes the previously serialized TwitterTokenStream using the provided AttributeSerializer(s).",
    "old_code_raw": "  public final TokenStream deserialize(final byte[] data,\n                                       final CharSequence charSequence) throws IOException {\n    return deserialize(data, 0, data.length, charSequence);\n  }\n",
    "new_code_raw": "  public final TwitterTokenStream deserialize(final byte[] data,\n                                       final CharSequence charSequence) throws IOException {\n    return deserialize(data, 0, data.length, charSequence);\n  }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2047-FirstSentence-0",
    "old_comment_raw": "Get user by user name",
    "new_comment_raw": "Get user by user name",
    "old_code_raw": "    public User getUserByName(String username) throws ApiException {\n        ApiResponse<User> resp = getUserByNameWithHttpInfo(username);\n        return resp.getData();\n    }\n",
    "new_code_raw": "    public User getUserByName(String username) throws ApiException {\n        ApiResponse<User> localVarResp = getUserByNameWithHttpInfo(username);\n        return localVarResp.getData();\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1971-FirstSentence-0",
    "old_comment_raw": "Reads class byte array info from the given input stream.",
    "new_comment_raw": "Read class definition a zip (jar) file entry.",
    "old_code_raw": "\tpublic static byte[] readByteCode(InputStream inputStream) throws IOException {\n\t\tif ( inputStream == null ) {\n\t\t\tthrow new IOException( \"null input stream\" );\n\t\t}\n\n\t\tbyte[] buffer = new byte[409600];\n\t\tbyte[] classBytes = new byte[0];\n\t\tint r = 0;\n\n\t\ttry {\n\t\t\tr = inputStream.read( buffer );\n\t\t\twhile ( r >= buffer.length ) {\n\t\t\t\tbyte[] temp = new byte[ classBytes.length + buffer.length ];\n\t\t\t\tSystem.arraycopy( classBytes, 0, temp, 0, classBytes.length );\n\t\t\t\tSystem.arraycopy( buffer, 0, temp, classBytes.length, buffer.length );\n\t\t\t\tclassBytes = temp;\n\t\t\t}\n\t\t\tif ( r != -1 ) {\n\t\t\t\tbyte[] temp = new byte[ classBytes.length + r ];\n\t\t\t\tSystem.arraycopy( classBytes, 0, temp, 0, classBytes.length );\n\t\t\t\tSystem.arraycopy( buffer, 0, temp, classBytes.length, r );\n\t\t\t\tclassBytes = temp;\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tinputStream.close();\n\t\t\t}\n\t\t\tcatch (IOException ignore) {\n\t\t\t\t// intentionally empty\n\t\t\t}\n\t\t}\n\n\t\treturn classBytes;\n\t}\n",
    "new_code_raw": "\tpublic static byte[] readByteCode(ZipInputStream zip) throws IOException {\n        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n        InputStream in = new BufferedInputStream( zip );\n        int b;\n        while ( ( b = in.read() ) != -1 ) {\n            bout.write( b );\n        }\n        return bout.toByteArray();\n    }\n"
  },
  {
    "id": "apache_calcite-698-FirstSentence-0",
    "old_comment_raw": "Returns whether two types are comparable.",
    "new_comment_raw": "Returns whether two types are comparable.",
    "old_code_raw": "  public static boolean isComparable(RelDataType type1, RelDataType type2) {\n    if (type1.isStruct() != type2.isStruct()) {\n      return false;\n    }\n\n    if (type1.isStruct()) {\n      int n = type1.getFieldCount();\n      if (n != type2.getFieldCount()) {\n        return false;\n      }\n      for (Pair<RelDataTypeField, RelDataTypeField> pair\n          : Pair.zip(type1.getFieldList(), type2.getFieldList())) {\n        if (!isComparable(pair.left.getType(), pair.right.getType())) {\n          return false;\n        }\n      }\n      return true;\n    }\n    RelDataTypeFamily family1 = null;\n    RelDataTypeFamily family2 = null;\n\n    // REVIEW jvs 2-June-2005:  This is needed to keep\n    // the Saffron type system happy.\n    if (type1.getSqlTypeName() != null) {\n      family1 = type1.getSqlTypeName().getFamily();\n    }\n    if (type2.getSqlTypeName() != null) {\n      family2 = type2.getSqlTypeName().getFamily();\n    }\n    if (family1 == null) {\n      family1 = type1.getFamily();\n    }\n    if (family2 == null) {\n      family2 = type2.getFamily();\n    }\n    if (family1 == family2) {\n      return true;\n    }\n\n    // If one of the operators is of type 'ANY', return true.\n    if (family1 == SqlTypeFamily.ANY\n        || family2 == SqlTypeFamily.ANY) {\n      return true;\n    }\n\n    return false;\n  }\n",
    "new_code_raw": "  public static boolean isComparable(RelDataType type1, RelDataType type2) {\n    if (type1.isStruct() != type2.isStruct()) {\n      return false;\n    }\n\n    if (type1.isStruct()) {\n      int n = type1.getFieldCount();\n      if (n != type2.getFieldCount()) {\n        return false;\n      }\n      for (Pair<RelDataTypeField, RelDataTypeField> pair\n          : Pair.zip(type1.getFieldList(), type2.getFieldList())) {\n        if (!isComparable(pair.left.getType(), pair.right.getType())) {\n          return false;\n        }\n      }\n      return true;\n    }\n    RelDataTypeFamily family1 = null;\n    RelDataTypeFamily family2 = null;\n\n    // REVIEW jvs 2-June-2005:  This is needed to keep\n    // the Saffron type system happy.\n    if (type1.getSqlTypeName() != null) {\n      family1 = type1.getSqlTypeName().getFamily();\n    }\n    if (type2.getSqlTypeName() != null) {\n      family2 = type2.getSqlTypeName().getFamily();\n    }\n    if (family1 == null) {\n      family1 = type1.getFamily();\n    }\n    if (family2 == null) {\n      family2 = type2.getFamily();\n    }\n    if (family1 == family2) {\n      return true;\n    }\n\n    // If one of the operators is of type 'ANY', return true.\n    if (family1 == SqlTypeFamily.ANY\n        || family2 == SqlTypeFamily.ANY) {\n      return true;\n    }\n\n    // We can implicitly convert from character to date\n    if (family1 == SqlTypeFamily.CHARACTER\n        && canConvertStringInCompare(family2)\n        || family2 == SqlTypeFamily.CHARACTER\n        && canConvertStringInCompare(family1)) {\n      return true;\n    }\n\n    return false;\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-490-FirstSentence-0",
    "old_comment_raw": "Does this time interval contain the specified millisecond instant.",
    "new_comment_raw": "Does this time interval contain or equal the specified millisecond instant.",
    "old_code_raw": "    public boolean contains(long millisInstant) {\n        long thisStart = getStartMillis();\n        long thisEnd = getEndMillis();\n        return (millisInstant >= thisStart && millisInstant < thisEnd);\n    }\n",
    "new_code_raw": "    public boolean contains(long millisInstant) {\n        long thisStart = getStartMillis();\n        long thisEnd = getEndMillis();\n        return (millisInstant >= thisStart && millisInstant < thisEnd) ||\n            (thisStart == millisInstant && thisEnd == millisInstant);\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2299-FirstSentence-0",
    "old_comment_raw": "Get an array of rare word feature Extractor identified by a name.",
    "new_comment_raw": "Get an array of rare word feature Extractor identified by a name.",
    "old_code_raw": "  protected static Extractor[] getExtractorFramesRare(String identifier, TTags ttags) {\n    ArrayList<Extractor> extrs = new ArrayList<>();\n    List<String> args = StringUtils.valueSplit(identifier, \"[a-zA-Z0-9]*(?:\\\\([^)]*\\\\))?\", \"\\\\s*,\\\\s*\");\n\n    for (String arg : args) {\n      if (\"naacl2003unknowns\".equalsIgnoreCase(arg)) {\n        extrs.addAll(Arrays.asList(eFrames_motley_naacl2003));\n        getNaaclExtractors(extrs);\n      } else if ((\"lnaacl2003unknowns\").equalsIgnoreCase(arg)) {\n        extrs.addAll(Arrays.asList(eFrames_motley_naacl2003_left));\n        getNaaclExtractors(extrs);\n      } else if (\"caselessnaacl2003unknowns\".equalsIgnoreCase(arg)) {\n        extrs.addAll(Arrays.asList(eFrames_motley_caseless_naacl2003));\n        getCaselessNaaclExtractors(extrs);\n        // TODO: test this next one\n      } else if (\"naacl2003conjunctions\".equalsIgnoreCase(arg)) {\n        extrs.addAll(Arrays.asList(naacl2003Conjunctions()));\n      } else if (\"frenchunknowns\".equalsIgnoreCase(arg)) {\n        extrs.addAll(Arrays.asList(french_unknown_extractors));\n      } else if (arg.startsWith(\"wordshapes(\")) {\n        int lWindow = Extractor.getParenthesizedNum(arg, 1);\n        int rWindow = Extractor.getParenthesizedNum(arg, 2);\n        String wsc = Extractor.getParenthesizedArg(arg, 3);\n        if (wsc == null) {\n          wsc = \"chris2\";\n        }\n        for (int i = lWindow; i <= rWindow; i++) {\n          extrs.add(new ExtractorWordShapeClassifier(i, wsc));\n        }\n      } else if (arg.startsWith(\"wordshapeconjunction(\")) {\n        int lWindow = Extractor.getParenthesizedNum(arg, 1);\n        int rWindow = Extractor.getParenthesizedNum(arg, 2);\n        String wsc = Extractor.getParenthesizedArg(arg, 3);\n        if (wsc == null) {\n          wsc = \"chris2\";\n        }\n        for (int i = lWindow; i <= rWindow; i++) {\n          extrs.add(new ExtractorWordShapeConjunction(lWindow, rWindow, wsc));\n        }\n      } else if (arg.startsWith(\"unicodeshapes(\")) {\n        int lWindow = Extractor.getParenthesizedNum(arg, 1);\n        int rWindow = Extractor.getParenthesizedNum(arg, 2);\n        for (int i = lWindow; i <= rWindow; i++) {\n          extrs.add(new ExtractorWordShapeClassifier(i, \"chris4\"));\n        }\n      } else if (arg.startsWith(\"unicodeshapeconjunction(\")) {\n        int lWindow = Extractor.getParenthesizedNum(arg, 1);\n        int rWindow = Extractor.getParenthesizedNum(arg, 2);\n        extrs.add(new ExtractorWordShapeConjunction(lWindow, rWindow, \"chris4\"));\n      } else if (arg.startsWith(\"chinesedictionaryfeatures(\")) {\n        throw new RuntimeException(\"These features are no longer supported.\" +\n                                   \"  The paths and data files associated \" +\n                                   \"with this material are out of date, and \" +\n                                   \"the classes used are not thread-safe.  \" +\n                                   \"Those problems would need to be fixed \" +\n                                   \"to use this feature.\");\n        //String path = Extractor.getParenthesizedArg(arg, 1);\n        //// Default nlp location for these features is: /u/nlp/data/pos-tagger/dictionary\n        //int lWindow = Extractor.getParenthesizedNum(arg, 2);\n        //int rWindow = Extractor.getParenthesizedNum(arg, 3);\n        //// First set up the dictionary prefix for the Chinese dictionaries\n        //ASBCDict.setPathPrefix(path);\n        //for (int i = lWindow; i <= rWindow; i++) {\n        //  extrs.addAll(Arrays.asList(ctbPreFeatures(i)));\n        //  extrs.addAll(Arrays.asList(ctbSufFeatures(i)));\n        //  extrs.addAll(Arrays.asList(ctbUnkDictFeatures(i)));\n        //  extrs.addAll(Arrays.asList(asbcUnkFeatures(i)));\n        //}\n      // No longer add prefix suffix features, now that you can more flexibly add them separately.\n      // } else if (\"generic\".equalsIgnoreCase(arg)) {\n      //   // does prefix and suffix up to 6 grams\n      //   for (int i = 1; i <= 6; i++) {\n      //     extrs.add(new ExtractorCWordSuff(i));\n      //     extrs.add(new ExtractorCWordPref(i));\n      //   }\n      } else if (arg.equalsIgnoreCase(\"motleyUnknown\")) {  // This is naacl2003unknown minus prefix and suffix features.\n        extrs.addAll(Arrays.asList(eFrames_motley_naacl2003));\n      } else if (arg.startsWith(\"suffix(\")) {\n        int max = Extractor.getParenthesizedNum(arg, 1);\n        // will conveniently be 0 if not specified\n        int position = Extractor.getParenthesizedNum(arg, 2);\n        for (int i = 1; i <= max; i++) {\n          extrs.add(new ExtractorWordSuff(i, position));\n        }\n      } else if (arg.startsWith(\"prefix(\")) {\n        int max = Extractor.getParenthesizedNum(arg, 1);\n        // will conveniently be 0 if not specified\n        int position = Extractor.getParenthesizedNum(arg, 2);\n        for (int i = 1; i <= max; i++) {\n          extrs.add(new ExtractorWordPref(i, position));\n        }\n      } else if (arg.startsWith(\"prefixsuffix(\")) {\n        int max = Extractor.getParenthesizedNum(arg, 1);\n        for (int i = 1; i <= max; i++) {\n          extrs.add(new ExtractorsConjunction(new ExtractorWordPref(i, 0),\n                                              new ExtractorWordSuff(i, 0)));\n        }\n      } else if (arg.startsWith(\"capitalizationsuffix(\")) {\n        int max = Extractor.getParenthesizedNum(arg, 1);\n        for (int i = 1; i <= max; i++) {\n          extrs.add(new ExtractorsConjunction(cWordUppCase, new ExtractorWordSuff(i,0)));\n        }\n      } else if (arg.startsWith(\"distsim(\")) {\n        String path = Extractor.getParenthesizedArg(arg, 1);\n        // traditional nlp filesystem location is: /u/nlp/data/pos_tags_are_useless/egw.bnc.200.pruned\n        int lWindow = Extractor.getParenthesizedNum(arg, 2);\n        int rWindow = Extractor.getParenthesizedNum(arg, 3);\n        for (int i = lWindow; i <= rWindow; i++) {\n          extrs.add(new ExtractorDistsim(path, i));\n        }\n      } else if (arg.startsWith(\"distsimconjunction(\")) {\n        String path = Extractor.getParenthesizedArg(arg, 1);\n        int lWindow = Extractor.getParenthesizedNum(arg, 2);\n        int rWindow = Extractor.getParenthesizedNum(arg, 3);\n        extrs.add(new ExtractorDistsimConjunction(path, lWindow, rWindow));\n      } else if (arg.equalsIgnoreCase(\"lctagfeatures\")) {\n        extrs.addAll(Arrays.asList(lcTagFeatures(ttags)));\n      }\n    }\n\n    return extrs.toArray(new Extractor[extrs.size()]);\n  }\n",
    "new_code_raw": "  protected static Extractor[] getExtractorFramesRare(String identifier, TTags ttags) {\n    ArrayList<Extractor> extrs = new ArrayList<>();\n    List<String> args = StringUtils.valueSplit(identifier, \"[a-zA-Z0-9]*(?:\\\\([^)]*\\\\))?\", \"\\\\s*,\\\\s*\");\n\n    for (String arg : args) {\n      if (\"naacl2003unknowns\".equalsIgnoreCase(arg)) {\n        extrs.addAll(Arrays.asList(eFrames_motley_naacl2003));\n        getNaaclExtractors(extrs);\n      } else if ((\"lnaacl2003unknowns\").equalsIgnoreCase(arg)) {\n        extrs.addAll(Arrays.asList(eFrames_motley_naacl2003_left));\n        getNaaclExtractors(extrs);\n      } else if (\"caselessnaacl2003unknowns\".equalsIgnoreCase(arg)) {\n        extrs.addAll(Arrays.asList(eFrames_motley_caseless_naacl2003));\n        getCaselessNaaclExtractors(extrs);\n        // TODO: test this next one\n      } else if (\"naacl2003conjunctions\".equalsIgnoreCase(arg)) {\n        extrs.addAll(Arrays.asList(naacl2003Conjunctions()));\n      } else if (\"frenchunknowns\".equalsIgnoreCase(arg)) {\n        extrs.addAll(Arrays.asList(french_unknown_extractors));\n      } else if (arg.startsWith(\"wordshapes(\")) {\n        int lWindow = Extractor.getParenthesizedNum(arg, 1);\n        int rWindow = Extractor.getParenthesizedNum(arg, 2);\n        String wsc = Extractor.getParenthesizedArg(arg, 3);\n        if (wsc == null) {\n          wsc = \"chris2\";\n        }\n        for (int i = lWindow; i <= rWindow; i++) {\n          extrs.add(new ExtractorWordShapeClassifier(i, wsc));\n        }\n      } else if (arg.startsWith(\"wordshapeconjunction(\")) {\n        int lWindow = Extractor.getParenthesizedNum(arg, 1);\n        int rWindow = Extractor.getParenthesizedNum(arg, 2);\n        String wsc = Extractor.getParenthesizedArg(arg, 3);\n        if (wsc == null) {\n          wsc = \"chris2\";\n        }\n        for (int i = lWindow; i <= rWindow; i++) {\n          extrs.add(new ExtractorWordShapeConjunction(lWindow, rWindow, wsc));\n        }\n      } else if (arg.startsWith(\"unicodeshapes(\")) {\n        int lWindow = Extractor.getParenthesizedNum(arg, 1);\n        int rWindow = Extractor.getParenthesizedNum(arg, 2);\n        for (int i = lWindow; i <= rWindow; i++) {\n          extrs.add(new ExtractorWordShapeClassifier(i, \"chris4\"));\n        }\n      } else if (arg.startsWith(\"unicodeshapeconjunction(\")) {\n        int lWindow = Extractor.getParenthesizedNum(arg, 1);\n        int rWindow = Extractor.getParenthesizedNum(arg, 2);\n        extrs.add(new ExtractorWordShapeConjunction(lWindow, rWindow, \"chris4\"));\n      } else if (arg.startsWith(\"chinesedictionaryfeatures(\")) {\n        throw new RuntimeException(\"These features are no longer supported.\" +\n                                   \"  The paths and data files associated \" +\n                                   \"with this material are out of date, and \" +\n                                   \"the classes used are not thread-safe.  \" +\n                                   \"Those problems would need to be fixed \" +\n                                   \"to use this feature.\");\n        //String path = Extractor.getParenthesizedArg(arg, 1);\n        //// Default nlp location for these features is: /u/nlp/data/pos-tagger/dictionary\n        //int lWindow = Extractor.getParenthesizedNum(arg, 2);\n        //int rWindow = Extractor.getParenthesizedNum(arg, 3);\n        //// First set up the dictionary prefix for the Chinese dictionaries\n        //ASBCDict.setPathPrefix(path);\n        //for (int i = lWindow; i <= rWindow; i++) {\n        //  extrs.addAll(Arrays.asList(ctbPreFeatures(i)));\n        //  extrs.addAll(Arrays.asList(ctbSufFeatures(i)));\n        //  extrs.addAll(Arrays.asList(ctbUnkDictFeatures(i)));\n        //  extrs.addAll(Arrays.asList(asbcUnkFeatures(i)));\n        //}\n      // No longer add prefix suffix features, now that you can more flexibly add them separately.\n      // } else if (\"generic\".equalsIgnoreCase(arg)) {\n      //   // does prefix and suffix up to 6 grams\n      //   for (int i = 1; i <= 6; i++) {\n      //     extrs.add(new ExtractorCWordSuff(i));\n      //     extrs.add(new ExtractorCWordPref(i));\n      //   }\n      } else if (arg.equalsIgnoreCase(\"motleyUnknown\")) {  // This is naacl2003unknown minus prefix and suffix features.\n        extrs.addAll(Arrays.asList(eFrames_motley_naacl2003));\n      } else if (arg.startsWith(\"suffix(\")) {\n        int max = Extractor.getParenthesizedNum(arg, 1);\n        // will conveniently be 0 if not specified\n        int position = Extractor.getParenthesizedNum(arg, 2);\n        for (int i = 1; i <= max; i++) {\n          extrs.add(new ExtractorWordSuff(i, position));\n        }\n      } else if (arg.startsWith(\"prefix(\")) {\n        int max = Extractor.getParenthesizedNum(arg, 1);\n        // will conveniently be 0 if not specified\n        int position = Extractor.getParenthesizedNum(arg, 2);\n        for (int i = 1; i <= max; i++) {\n          extrs.add(new ExtractorWordPref(i, position));\n        }\n      } else if (arg.startsWith(\"prefixsuffix(\")) {\n        int max = Extractor.getParenthesizedNum(arg, 1);\n        for (int i = 1; i <= max; i++) {\n          extrs.add(new ExtractorsConjunction(new ExtractorWordPref(i, 0),\n                                              new ExtractorWordSuff(i, 0)));\n        }\n      } else if (arg.startsWith(\"capitalizationsuffix(\")) {\n        int max = Extractor.getParenthesizedNum(arg, 1);\n        for (int i = 1; i <= max; i++) {\n          extrs.add(new ExtractorsConjunction(cWordUppCase, new ExtractorWordSuff(i,0)));\n        }\n      } else if (arg.startsWith(\"distsim(\")) {\n        String path = Extractor.getParenthesizedArg(arg, 1);\n        // traditional nlp filesystem location is: /u/nlp/data/pos_tags_are_useless/egw.bnc.200.pruned\n        int lWindow = Extractor.getParenthesizedNum(arg, 2);\n        int rWindow = Extractor.getParenthesizedNum(arg, 3);\n        for (int i = lWindow; i <= rWindow; i++) {\n          extrs.add(new ExtractorDistsim(path, i));\n        }\n      } else if (arg.startsWith(\"distsimconjunction(\")) {\n        String path = Extractor.getParenthesizedArg(arg, 1);\n        int lWindow = Extractor.getParenthesizedNum(arg, 2);\n        int rWindow = Extractor.getParenthesizedNum(arg, 3);\n        extrs.add(new ExtractorDistsimConjunction(path, lWindow, rWindow));\n      } else if (arg.equalsIgnoreCase(\"lctagfeatures\")) {\n        extrs.addAll(Arrays.asList(lcTagFeatures(ttags)));\n      }\n    }\n\n    return extrs.toArray(Extractor.EMPTY_EXTRACTOR_ARRAY);\n  }\n"
  },
  {
    "id": "apache_lenya-388-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Get Anchor Hrefs",
    "old_code_raw": "    public List getAnchorHRefs(boolean duplicate) {\n        if (duplicate) {\n            return htmlHandler.getAllAHRefs();\n        } else {\n            return htmlHandler.getAHRefs();\n        }\n    }\n",
    "new_code_raw": "    public List getAnchorHRefs(boolean duplicate) {\n        if (duplicate) {\n            return this.htmlHandler.getAllAHRefs();\n        }\n        return this.htmlHandler.getAHRefs();\n    }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-1052-FirstSentence-0",
    "old_comment_raw": "Returns a formatter that combines a full date, two digit hour of day, and two digit minute of hour.",
    "new_comment_raw": "Returns a formatter that combines a full date, two digit hour of day, and two digit minute of hour.",
    "old_code_raw": "    public static DateTimeFormatter dateHourMinute() {\n        if (dhm == null) {\n            dhm = new DateTimeFormatterBuilder()\n                .append(date())\n                .append(literalTElement())\n                .append(hourMinute())\n                .toFormatter();\n        }\n        return dhm;\n    }\n",
    "new_code_raw": "    public static DateTimeFormatter dateHourMinute() {\n        return Constants.dhm;\n    }\n"
  },
  {
    "id": "apache_kylin-507-FirstSentence-0",
    "old_comment_raw": "at first stage the only table in II is fact table, TODO: to extend to all tables",
    "new_comment_raw": "at first stage the only table in II is fact table, tables",
    "old_code_raw": "    public List<TableDesc> listTables() {\n        return Lists.newArrayList(this.tableDesc);\n    }\n",
    "new_code_raw": "    public List<TableDesc> listTables() {\n        return allTables;\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-2251-FirstSentence-0",
    "old_comment_raw": "Gets an array of the fields that this partial supports.",
    "new_comment_raw": "Gets an array of the fields that this partial supports.",
    "old_code_raw": "    public DateTimeField[] getFields() {\n        return (DateTimeField[]) iFields.clone();\n    }\n",
    "new_code_raw": "    public DateTimeField[] getFields() {\n        DateTimeField[] result = new DateTimeField[getFieldSize()];\n        for (int i = 0; i < result.length; i++) {\n            result[i] = getField(i);\n        }\n        return result;\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-334-Associations-FirstSentence",
    "old_comment_raw": "Get the  edu.stanford.nlp.international.Language object corresponding to the given language string.",
    "new_comment_raw": "Get the  edu.stanford.nlp.international.Languages.Language object corresponding to the given language string.",
    "old_code_raw": "  private Language getLanguage(String languageStr) {\n    for (Language l : Language.values()) {\n      if (l.name().equalsIgnoreCase(languageStr))\n        return l;\n    }\n    return null;\n  }\n",
    "new_code_raw": "  private Languages.Language getLanguage(String languageStr) {\n    for (Languages.Language l : Languages.Language.values()) {\n      if (l.name().equalsIgnoreCase(languageStr))\n        return l;\n    }\n    return null;\n  }\n\n"
  },
  {
    "id": "graphql_java_graphql_java-364-FirstSentence-0",
    "old_comment_raw": "Adds a definition to the registry",
    "new_comment_raw": "Adds a definition to the registry",
    "old_code_raw": "    public Optional<GraphQLError> add(Definition definition) {\n        // extensions\n        if (definition instanceof ObjectTypeExtensionDefinition) {\n            ObjectTypeExtensionDefinition newEntry = (ObjectTypeExtensionDefinition) definition;\n            return defineExt(objectTypeExtensions, newEntry, ObjectTypeExtensionDefinition::getName);\n        } else if (definition instanceof InterfaceTypeExtensionDefinition) {\n            InterfaceTypeExtensionDefinition newEntry = (InterfaceTypeExtensionDefinition) definition;\n            return defineExt(interfaceTypeExtensions, newEntry, InterfaceTypeExtensionDefinition::getName);\n        } else if (definition instanceof UnionTypeExtensionDefinition) {\n            UnionTypeExtensionDefinition newEntry = (UnionTypeExtensionDefinition) definition;\n            return defineExt(unionTypeExtensions, newEntry, UnionTypeExtensionDefinition::getName);\n        } else if (definition instanceof EnumTypeExtensionDefinition) {\n            EnumTypeExtensionDefinition newEntry = (EnumTypeExtensionDefinition) definition;\n            return defineExt(enumTypeExtensions, newEntry, EnumTypeExtensionDefinition::getName);\n        } else if (definition instanceof ScalarTypeExtensionDefinition) {\n            ScalarTypeExtensionDefinition newEntry = (ScalarTypeExtensionDefinition) definition;\n            return defineExt(scalarTypeExtensions, newEntry, ScalarTypeExtensionDefinition::getName);\n        } else if (definition instanceof InputObjectTypeExtensionDefinition) {\n            InputObjectTypeExtensionDefinition newEntry = (InputObjectTypeExtensionDefinition) definition;\n            return defineExt(inputObjectTypeExtensions, newEntry, InputObjectTypeExtensionDefinition::getName);\n            //\n            // normal\n        } else if (definition instanceof ScalarTypeDefinition) {\n            ScalarTypeDefinition newEntry = (ScalarTypeDefinition) definition;\n            return define(scalarTypes, scalarTypes, newEntry);\n        } else if (definition instanceof TypeDefinition) {\n            TypeDefinition newEntry = (TypeDefinition) definition;\n            return define(types, types, newEntry);\n        } else if (definition instanceof DirectiveDefinition) {\n            DirectiveDefinition newEntry = (DirectiveDefinition) definition;\n            return define(directiveDefinitions, directiveDefinitions, newEntry);\n        } else if (definition instanceof SchemaDefinition) {\n            SchemaDefinition newSchema = (SchemaDefinition) definition;\n            if (schema != null) {\n                return Optional.of(new SchemaRedefinitionError(this.schema, newSchema));\n            } else {\n                schema = newSchema;\n            }\n        }\n        return Optional.empty();\n    }\n",
    "new_code_raw": "    public Optional<GraphQLError> add(SDLDefinition definition) {\n        // extensions\n        if (definition instanceof ObjectTypeExtensionDefinition) {\n            ObjectTypeExtensionDefinition newEntry = (ObjectTypeExtensionDefinition) definition;\n            return defineExt(objectTypeExtensions, newEntry, ObjectTypeExtensionDefinition::getName);\n        } else if (definition instanceof InterfaceTypeExtensionDefinition) {\n            InterfaceTypeExtensionDefinition newEntry = (InterfaceTypeExtensionDefinition) definition;\n            return defineExt(interfaceTypeExtensions, newEntry, InterfaceTypeExtensionDefinition::getName);\n        } else if (definition instanceof UnionTypeExtensionDefinition) {\n            UnionTypeExtensionDefinition newEntry = (UnionTypeExtensionDefinition) definition;\n            return defineExt(unionTypeExtensions, newEntry, UnionTypeExtensionDefinition::getName);\n        } else if (definition instanceof EnumTypeExtensionDefinition) {\n            EnumTypeExtensionDefinition newEntry = (EnumTypeExtensionDefinition) definition;\n            return defineExt(enumTypeExtensions, newEntry, EnumTypeExtensionDefinition::getName);\n        } else if (definition instanceof ScalarTypeExtensionDefinition) {\n            ScalarTypeExtensionDefinition newEntry = (ScalarTypeExtensionDefinition) definition;\n            return defineExt(scalarTypeExtensions, newEntry, ScalarTypeExtensionDefinition::getName);\n        } else if (definition instanceof InputObjectTypeExtensionDefinition) {\n            InputObjectTypeExtensionDefinition newEntry = (InputObjectTypeExtensionDefinition) definition;\n            return defineExt(inputObjectTypeExtensions, newEntry, InputObjectTypeExtensionDefinition::getName);\n            //\n            // normal\n        } else if (definition instanceof ScalarTypeDefinition) {\n            ScalarTypeDefinition newEntry = (ScalarTypeDefinition) definition;\n            return define(scalarTypes, scalarTypes, newEntry);\n        } else if (definition instanceof TypeDefinition) {\n            TypeDefinition newEntry = (TypeDefinition) definition;\n            return define(types, types, newEntry);\n        } else if (definition instanceof DirectiveDefinition) {\n            DirectiveDefinition newEntry = (DirectiveDefinition) definition;\n            return define(directiveDefinitions, directiveDefinitions, newEntry);\n        } else if (definition instanceof SchemaDefinition) {\n            SchemaDefinition newSchema = (SchemaDefinition) definition;\n            if (schema != null) {\n                return Optional.of(new SchemaRedefinitionError(this.schema, newSchema));\n            } else {\n                schema = newSchema;\n            }\n        } else {\n            return Assert.assertShouldNeverHappen();\n        }\n        return Optional.empty();\n    }\n"
  },
  {
    "id": "apache_lenya-389-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Get Link hrefs",
    "old_code_raw": "    public List getLinkHRefs(boolean duplicate) {\n        if (duplicate) {\n            return htmlHandler.getAllLinkHRefs();\n        } else {\n            return htmlHandler.getLinkHRefs();\n        }\n    }\n",
    "new_code_raw": "    public List getLinkHRefs(boolean duplicate) {\n        if (duplicate) {\n            return this.htmlHandler.getAllLinkHRefs();\n        }\n        return this.htmlHandler.getLinkHRefs();\n    }\n\n"
  },
  {
    "id": "apache_calcite-691-FirstSentence-0",
    "old_comment_raw": "Returns the \"extra\" field in a row type whose presence signals that fields will come into existence just by asking for them.",
    "new_comment_raw": "Returns the \"extra\" field in a row type whose presence signals that fields will come into existence just by asking for them.",
    "old_code_raw": "  public static RelDataTypeField extra(RelDataType rowType) {\n    // Even in a case-insensitive connection, the name must be precisely\n    // \"_extra\".\n    return rowType.getField(\"_extra\", true);\n  }\n",
    "new_code_raw": "  public static RelDataTypeField extra(RelDataType rowType) {\n    // Even in a case-insensitive connection, the name must be precisely\n    // \"_extra\".\n    return rowType.getField(\"_extra\", true, false);\n  }\n"
  },
  {
    "id": "tms005_datanucleus-appengine-35-Associations-FirstSentence",
    "old_comment_raw": "Applies all the relation events that have been built up.",
    "new_comment_raw": "Method to process all relations that have been identified by earlier call(s) of op.provideField(...).",
    "old_code_raw": "  boolean storeRelations(KeyRegistry keyRegistry) {\n    NucleusLogger.GENERAL.debug(\">> StoreFM.storeRelations \" + getObjectProvider() + \" numRelations=\" + relationStoreInfos.size());\n    if (relationStoreInfos.isEmpty()) {\n      // No relations waiting to be persisted\n      return false;\n    }\n\n    ObjectProvider op = getObjectProvider();\n    ExecutionContext ec = op.getExecutionContext();\n    DatastoreTable table = getDatastoreTable();\n    if (datastoreEntity.getKey() != null) {\n      // Register parent key for all owned related objects\n      Key key = datastoreEntity.getKey();\n      AbstractClassMetaData acmd = op.getClassMetaData();\n      int[] relationFieldNums = acmd.getRelationMemberPositions(ec.getClassLoaderResolver(), ec.getMetaDataManager());\n      if (relationFieldNums != null) {\n        for (int i=0;i<relationFieldNums.length;i++) {\n          AbstractMemberMetaData mmd = acmd.getMetaDataForManagedMemberAtAbsolutePosition(relationFieldNums[i]);\n          boolean owned = MetaDataUtils.isOwnedRelation(mmd);\n          if (owned) {\n            Object childValue = op.provideField(mmd.getAbsoluteFieldNumber());\n            if (childValue != null) {\n              if (childValue instanceof Object[]) {\n                childValue = Arrays.asList((Object[]) childValue);\n              }\n\n              String expectedType = getExpectedChildType(mmd);\n              if (childValue instanceof Iterable) {\n                // TODO(maxr): Make sure we're not pulling back unnecessary data when we iterate over the values.\n                for (Object element : (Iterable) childValue) {\n                  addToParentKeyMap(keyRegistry, element, key, op.getExecutionContext(), expectedType, true);\n                }\n              } else {\n                addToParentKeyMap(keyRegistry, childValue, key, op.getExecutionContext(), expectedType, \n                    !table.isParentKeyProvider(mmd));\n              }\n            }\n          }\n        }\n      }\n    }\n\n    boolean modifiedEntity = false;\n\n    // Stage 1 : process FKs\n    for (RelationStoreInformation relInfo : relationStoreInfos) {\n      AbstractMemberMetaData mmd = relInfo.mmd;\n      try {\n        JavaTypeMapping mapping = table.getMemberMappingInDatastoreClass(relInfo.mmd);\n        if (mapping instanceof EmbeddedPCMapping ||\n            mapping instanceof SerialisedPCMapping ||\n            mapping instanceof SerialisedReferenceMapping ||\n            mapping instanceof PersistableMapping ||\n            mapping instanceof InterfaceMapping) {\n          if (!table.isParentKeyProvider(mmd)) {\n            EntityUtils.checkParentage(relInfo.value, op);\n            mapping.setObject(getExecutionContext(), datastoreEntity, IS_FK_VALUE_ARR, relInfo.value, op, mmd.getAbsoluteFieldNumber());\n          }\n        }\n      } catch (NotYetFlushedException e) {\n        // Ignore this. We always have the object in the datastore, at least partially to get the key\n      }\n    }\n\n    // Stage 2 : postInsert/postUpdate\n    for (RelationStoreInformation relInfo : relationStoreInfos) {\n      try {\n        JavaTypeMapping mapping = table.getMemberMappingInDatastoreClass(relInfo.mmd);\n        if (mapping instanceof MappingCallbacks) {\n          if (operation == StoreFieldManager.Operation.INSERT) {\n            ((MappingCallbacks)mapping).postInsert(op);\n          } else {\n            ((MappingCallbacks)mapping).postUpdate(op);\n          }\n        }\n      } catch (NotYetFlushedException e) {\n        // Ignore this. We always have the object in the datastore, at least partially to get the key\n      }\n    }\n\n    // Stage 3 : set child keys in parent\n    for (RelationStoreInformation relInfo : relationStoreInfos) {\n      AbstractMemberMetaData mmd = relInfo.mmd;\n      int relationType = mmd.getRelationType(ec.getClassLoaderResolver());\n      NucleusLogger.GENERAL.debug(\">> StoreFM.storeRelations \" + getObjectProvider() + \" field=\" + mmd.getFullFieldName());\n\n      boolean owned = MetaDataUtils.isOwnedRelation(mmd);\n      if (owned) {\n        // Owned relations only store child keys if storageVersion high enough, and at \"owner\" side.\n        if (!getStoreManager().storageVersionAtLeast(StorageVersion.WRITE_OWNED_CHILD_KEYS_TO_PARENTS)) {\n          // don't write child keys to the parent if the storage version isn't high enough\n          continue;\n        }\n        if (relationType == Relation.MANY_TO_ONE_BI) {\n          // We don't store any \"FK\" of the parent at the child side (use parent key instead)\n          continue;\n        } else if (relationType == Relation.ONE_TO_ONE_BI && mmd.getMappedBy() != null) {\n          // We don't store any \"FK\" at the non-owner side (use parent key instead)\n          continue;\n        }\n      }\n\n      Object value = relInfo.value;\n      if (value == null) {\n        // Nothing to extract\n        checkSettingToNullValue(mmd, value);\n      } else if (Relation.isRelationSingleValued(relationType)) {\n        if (ec.getApiAdapter().isDeleted(value)) {\n          value = null;\n        } else {\n          Key key = EntityUtils.extractChildKey(value, ec, datastoreEntity);\n          if (key == null) {\n            Object childPC = processPersistable(mmd, value);\n            if (childPC != value) {\n              // Child object has been persisted/attached, so update it in the owner\n              op.replaceField(mmd.getAbsoluteFieldNumber(), childPC);\n            }\n            key = EntityUtils.extractChildKey(childPC, ec, datastoreEntity);\n          }\n          value = key;\n        }\n      } else if (Relation.isRelationMultiValued(relationType)) {\n        if (mmd.hasCollection()) {\n          Collection coll = (Collection) value;\n          List<Key> keys = Utils.newArrayList();\n          for (Object obj : coll) {\n            // TODO Should process SCO before we get here so we have no deleted objects\n            if (!ec.getApiAdapter().isDeleted(obj)) {\n              Key key = EntityUtils.extractChildKey(obj, ec, datastoreEntity);\n              if (key != null) {\n                keys.add(key);\n              } else {\n                Object childPC = processPersistable(mmd, obj);\n                key = EntityUtils.extractChildKey(childPC, ec, datastoreEntity);\n                keys.add(key);\n              }\n            }\n          }\n          value = keys;\n        }\n        // TODO Cater for PC array, maps\n\n        if (value instanceof SCO) {\n          // Use the unwrapped value so the datastore doesn't fail on unknown types\n          value = ((SCO)value).getValue();\n        }\n      }\n\n      modifiedEntity = true;\n      EntityUtils.setEntityProperty(datastoreEntity, mmd, \n          EntityUtils.getPropertyName(getStoreManager().getIdentifierFactory(), mmd), value);\n    }\n\n    relationStoreInfos.clear();\n\n    NucleusLogger.GENERAL.debug(\">> StoreFM.storeRelations \" + getObjectProvider() + \" entityModified=\" + modifiedEntity);\n    // TODO Return if we have modified the entity in this call\n\n    try {\n      return keyRegistry.parentNeedsUpdate(datastoreEntity.getKey());\n    } finally {\n      keyRegistry.clearModifiedParent(datastoreEntity.getKey());\n    }\n  }\n",
    "new_code_raw": "  boolean storeRelations(KeyRegistry keyRegistry) {\n    if (relationStoreInfos.isEmpty()) {\n      // No relations waiting to be persisted\n      return false;\n    }\n\n    ObjectProvider op = getObjectProvider();\n    ExecutionContext ec = op.getExecutionContext();\n    DatastoreTable table = getDatastoreTable();\n    if (datastoreEntity.getKey() != null) {\n      // Register parent key for all owned related objects\n      Key key = datastoreEntity.getKey();\n      AbstractClassMetaData acmd = op.getClassMetaData();\n      int[] relationFieldNums = acmd.getRelationMemberPositions(ec.getClassLoaderResolver(), ec.getMetaDataManager());\n      if (relationFieldNums != null) {\n        for (int i=0;i<relationFieldNums.length;i++) {\n          AbstractMemberMetaData mmd = acmd.getMetaDataForManagedMemberAtAbsolutePosition(relationFieldNums[i]);\n          boolean owned = MetaDataUtils.isOwnedRelation(mmd);\n          if (owned) {\n            Object childValue = op.provideField(mmd.getAbsoluteFieldNumber());\n            if (childValue != null) {\n              if (childValue instanceof Object[]) {\n                childValue = Arrays.asList((Object[]) childValue);\n              }\n\n              String expectedType = getExpectedChildType(mmd);\n              if (childValue instanceof Iterable) {\n                // TODO(maxr): Make sure we're not pulling back unnecessary data when we iterate over the values.\n                for (Object element : (Iterable) childValue) {\n                  addToParentKeyMap(keyRegistry, element, key, op.getExecutionContext(), expectedType, true);\n                }\n              } else {\n                addToParentKeyMap(keyRegistry, childValue, key, op.getExecutionContext(), expectedType, \n                    !table.isParentKeyProvider(mmd));\n              }\n            }\n          }\n        }\n      }\n    }\n\n    boolean modifiedEntity = false;\n\n    // Stage 1 : process FKs\n    for (RelationStoreInformation relInfo : relationStoreInfos) {\n      AbstractMemberMetaData mmd = relInfo.mmd;\n      try {\n        JavaTypeMapping mapping = table.getMemberMappingInDatastoreClass(relInfo.mmd);\n        if (mapping instanceof EmbeddedPCMapping ||\n            mapping instanceof SerialisedPCMapping ||\n            mapping instanceof SerialisedReferenceMapping ||\n            mapping instanceof PersistableMapping ||\n            mapping instanceof InterfaceMapping) {\n          if (!table.isParentKeyProvider(mmd)) {\n            EntityUtils.checkParentage(relInfo.value, op);\n            mapping.setObject(getExecutionContext(), datastoreEntity, IS_FK_VALUE_ARR, relInfo.value, op, mmd.getAbsoluteFieldNumber());\n          }\n        }\n      } catch (NotYetFlushedException e) {\n        // Ignore this. We always have the object in the datastore, at least partially to get the key\n      }\n    }\n\n    // Stage 2 : postInsert/postUpdate\n    for (RelationStoreInformation relInfo : relationStoreInfos) {\n      try {\n        JavaTypeMapping mapping = table.getMemberMappingInDatastoreClass(relInfo.mmd);\n        if (mapping instanceof MappingCallbacks) {\n          if (operation == StoreFieldManager.Operation.INSERT) {\n            ((MappingCallbacks)mapping).postInsert(op);\n          } else {\n            ((MappingCallbacks)mapping).postUpdate(op);\n          }\n        }\n      } catch (NotYetFlushedException e) {\n        // Ignore this. We always have the object in the datastore, at least partially to get the key\n      }\n    }\n\n    // Stage 3 : set child keys in parent\n    for (RelationStoreInformation relInfo : relationStoreInfos) {\n      AbstractMemberMetaData mmd = relInfo.mmd;\n      int relationType = mmd.getRelationType(ec.getClassLoaderResolver());\n\n      boolean owned = MetaDataUtils.isOwnedRelation(mmd);\n      if (owned) {\n        // Owned relations only store child keys if storageVersion high enough, and at \"owner\" side.\n        if (!getStoreManager().storageVersionAtLeast(StorageVersion.WRITE_OWNED_CHILD_KEYS_TO_PARENTS)) {\n          // don't write child keys to the parent if the storage version isn't high enough\n          continue;\n        }\n        if (relationType == Relation.MANY_TO_ONE_BI) {\n          // We don't store any \"FK\" of the parent at the child side (use parent key instead)\n          continue;\n        } else if (relationType == Relation.ONE_TO_ONE_BI && mmd.getMappedBy() != null) {\n          // We don't store any \"FK\" at the non-owner side (use parent key instead)\n          continue;\n        }\n      }\n\n      Object value = relInfo.value;\n      String propName = EntityUtils.getPropertyName(getStoreManager().getIdentifierFactory(), mmd);\n      if (value == null) {\n        // Nothing to extract\n        checkSettingToNullValue(mmd, value);\n        if (!datastoreEntity.hasProperty(propName)) {\n          modifiedEntity = true;\n          EntityUtils.setEntityProperty(datastoreEntity, mmd, propName, value);\n        }\n      } else if (Relation.isRelationSingleValued(relationType)) {\n        if (ec.getApiAdapter().isDeleted(value)) {\n          value = null;\n        } else {\n          Key key = EntityUtils.extractChildKey(value, ec, datastoreEntity);\n          if (key == null) {\n            Object childPC = processPersistable(mmd, value);\n            if (childPC != value) {\n              // Child object has been persisted/attached, so update it in the owner\n              op.replaceField(mmd.getAbsoluteFieldNumber(), childPC);\n            }\n            key = EntityUtils.extractChildKey(childPC, ec, datastoreEntity);\n          }\n          value = key;\n          if (!datastoreEntity.hasProperty(propName) || !value.equals(datastoreEntity.getProperty(propName))) {\n            modifiedEntity = true;\n            EntityUtils.setEntityProperty(datastoreEntity, mmd, propName, value);\n          }\n        }\n      } else if (Relation.isRelationMultiValued(relationType)) {\n        if (mmd.hasCollection()) {\n          Collection coll = (Collection) value;\n          List<Key> keys = Utils.newArrayList();\n          for (Object obj : coll) {\n            // TODO Should process SCO before we get here so we have no deleted objects\n            if (!ec.getApiAdapter().isDeleted(obj)) {\n              Key key = EntityUtils.extractChildKey(obj, ec, datastoreEntity);\n              if (key != null) {\n                keys.add(key);\n              } else {\n                Object childPC = processPersistable(mmd, obj);\n                key = EntityUtils.extractChildKey(childPC, ec, datastoreEntity);\n                keys.add(key);\n              }\n            }\n          }\n          value = keys;\n          if (!datastoreEntity.hasProperty(propName) || !value.equals(datastoreEntity.getProperty(propName))) {\n            modifiedEntity = true;\n            EntityUtils.setEntityProperty(datastoreEntity, mmd, propName, value);\n          }\n        }\n        // TODO Cater for PC array, maps\n      }\n    }\n\n    relationStoreInfos.clear();\n\n    return modifiedEntity;\n  }\n\n"
  },
  {
    "id": "lingochamp_FileDownloader-44-FirstSentence-0",
    "old_comment_raw": "start download",
    "new_comment_raw": "start download",
    "old_code_raw": "    public int start() {\n        FileDownloadLog.d(this, \"begin call start url[%s], savePath[%s], listener[%s], isNeedNotification[%B], notificationTitle[%s], notificationDesc[%s],\" +\n                \" tag[%s]\", url, savePath, listener, isNeedNotification, notificationTitle, notificationDesc, tag);\n\n        if (savePath == null) {\n            savePath = FileDownloadUtils.getDefaultSaveFilePath(url);\n            FileDownloadLog.e(this, \"save path is null to %s\", savePath);\n        }\n\n\n        addEventListener();\n\n        if (isNeedNotification) {\n            // TODO \u00e6\u009b\u00bf\u00e6\u008d\u00a2app name\n            notificationTitle = notificationTitle == null ? \"app name\" : notificationTitle;\n        }\n\n\n        this.downloadId = 0;\n\n        try {\n            checkFile(savePath);\n\n            // \u00e6\u009c\u008d\u00e5\u008a\u00a1\u00e6\u0098\u00af\u00e5\u0090\u00a6\u00e5\u0090\u00af\u00e5\u008a\u00a8\n            if (!checkCanStart()) {\n                // \u00e6\u00b2\u00a1\u00e6\u009c\u0089\u00e5\u0087\u0086\u00e5\u00a4\u0087\u00e5\u00a5\u00bd\n                return 0;\n            }\n\n            FileDownloadList.getImpl().add(this);\n\n            // \u00e6\u0098\u00af\u00e5\u0090\u00a6\u00e6\u00ad\u00a3\u00e5\u009c\u00a8\u00e4\u00b8\u008b\u00e8\u00bd\u00bd\n            if (checkDownloading(getUrl(), getSavePath())) {\n                // \u00e6\u00ad\u00a3\u00e5\u009c\u00a8\u00e4\u00b8\u008b\u00e8\u00bd\u00bd\n                // \u00e8\u00bf\u0099\u00e9\u0087\u008c\u00e5\u00b0\u00b1\u00e7\u009b\u00b4\u00e6\u008e\u00a5\u00e7\u00bb\u0093\u00e6\u009d\u009f\u00e4\u00ba\u0086\n                FileDownloadLog.d(this, \"Current is downloading %d\", getDownloadId());\n\n                setStatus(FileDownloadStatus.warn);\n                FileDownloadList.getImpl().removeByWarn(this);\n\n                return 0;\n            }\n\n            if (checkCanReuse()) {\n                FileDownloadLog.d(this, \"reuse downloaded file %s\", getUrl());\n                this.isReusedOldFile = true;\n\n\n                setStatus(FileDownloadStatus.completed);\n                FileDownloadList.getImpl().removeByCompleted(this);\n\n            } else {\n                FileDownloadLog.d(this, \"start downloaded by ui process %s\", getUrl());\n                this.isReusedOldFile = false;\n\n                downloadId = startExecute();\n                if (downloadId == 0) {\n                    setEx(new RuntimeException(\"not run download, not got download id\"));\n                    FileDownloadList.getImpl().removeByError(this);\n                }\n            }\n\n        } catch (Throwable e) {\n            e.printStackTrace();\n\n            setEx(e);\n            FileDownloadList.getImpl().removeByError(this);\n        }\n\n        FileDownloadLog.d(this, \"end call start url[%s], savePath[%s], listener[%s], isNeedNotification[%B], notificationTitle[%s], notificationDesc[%s],\" +\n                        \"tag[%s]\", url, savePath, listener, isNeedNotification, notificationTitle, notificationDesc,\n                tag);\n\n        return downloadId;\n\n    }\n",
    "new_code_raw": "    public int start() {\n        FileDownloadLog.d(this, \"begin call start url[%s], savePath[%s], listener[%s], isNeedNotification[%B], notificationTitle[%s], notificationDesc[%s],\" +\n                \" tag[%s]\", url, savePath, listener, isNeedNotification, notificationTitle, notificationDesc, tag);\n\n        if (savePath == null) {\n            savePath = FileDownloadUtils.getDefaultSaveFilePath(url);\n            FileDownloadLog.e(this, \"save path is null to %s\", savePath);\n        }\n\n\n        addEventListener();\n\n        if (isNeedNotification) {\n            // TODO \u00e6\u009b\u00bf\u00e6\u008d\u00a2app name\n            notificationTitle = notificationTitle == null ? \"app name\" : notificationTitle;\n        }\n\n\n        try {\n            checkFile(savePath);\n\n            // \u00e6\u009c\u008d\u00e5\u008a\u00a1\u00e6\u0098\u00af\u00e5\u0090\u00a6\u00e5\u0090\u00af\u00e5\u008a\u00a8\n            if (!checkCanStart()) {\n                // \u00e6\u00b2\u00a1\u00e6\u009c\u0089\u00e5\u0087\u0086\u00e5\u00a4\u0087\u00e5\u00a5\u00bd\n                return getDownloadId();\n            }\n\n            FileDownloadList.getImpl().add(this);\n\n            // \u00e6\u0098\u00af\u00e5\u0090\u00a6\u00e6\u00ad\u00a3\u00e5\u009c\u00a8\u00e4\u00b8\u008b\u00e8\u00bd\u00bd\n            if (checkDownloading(getUrl(), getSavePath())) {\n                // \u00e6\u00ad\u00a3\u00e5\u009c\u00a8\u00e4\u00b8\u008b\u00e8\u00bd\u00bd\n                // \u00e8\u00bf\u0099\u00e9\u0087\u008c\u00e5\u00b0\u00b1\u00e7\u009b\u00b4\u00e6\u008e\u00a5\u00e7\u00bb\u0093\u00e6\u009d\u009f\u00e4\u00ba\u0086\n                FileDownloadLog.d(this, \"Current is downloading %d\", getDownloadId());\n\n                setStatus(FileDownloadStatus.warn);\n                FileDownloadList.getImpl().removeByWarn(this);\n\n                return getDownloadId();\n            }\n\n            if (checkCanReuse()) {\n                FileDownloadLog.d(this, \"reuse downloaded file %s\", getUrl());\n                this.isReusedOldFile = true;\n\n\n                setStatus(FileDownloadStatus.completed);\n                FileDownloadList.getImpl().removeByCompleted(this);\n\n            } else {\n                FileDownloadLog.d(this, \"start downloaded by ui process %s\", getUrl());\n                this.isReusedOldFile = false;\n\n                if (startExecute() == 0) {\n                    setEx(new RuntimeException(\"not run download, not got download id\"));\n                    FileDownloadList.getImpl().removeByError(this);\n                }\n            }\n\n        } catch (Throwable e) {\n            e.printStackTrace();\n\n            setEx(e);\n            FileDownloadList.getImpl().removeByError(this);\n        }\n\n        FileDownloadLog.d(this, \"end call start url[%s], savePath[%s], listener[%s], isNeedNotification[%B], notificationTitle[%s], notificationDesc[%s],\" +\n                        \"tag[%s]\", url, savePath, listener, isNeedNotification, notificationTitle, notificationDesc,\n                tag);\n\n        return getDownloadId();\n\n    }\n"
  },
  {
    "id": "apache_drill-143-Associations-FirstSentence",
    "old_comment_raw": "Checks that column chunk's statistics has at least one null",
    "new_comment_raw": "Checks that column chunk's statistics does not have nulls",
    "old_code_raw": "  static boolean hasNoNulls(Statistics stat) {\n    return !stat.isNumNullsSet() || stat.getNumNulls() == 0;\n  }\n",
    "new_code_raw": "  static boolean hasNoNulls(Statistics stat) {\n    return stat.getNumNulls() <= 0;\n  }\n\n"
  },
  {
    "id": "facebook_fresco-69-FirstSentence-0",
    "old_comment_raw": "Checks if byteArray interpreted as sequence of bytes starts with pattern starting at position equal to offset.",
    "new_comment_raw": "Checks if byteArray interpreted as sequence of bytes starts with pattern starting at position equal to offset.",
    "old_code_raw": "  public static boolean startsWithPattern(final byte[] byteArray, final byte[] pattern) {\n    Preconditions.checkNotNull(byteArray);\n    Preconditions.checkNotNull(pattern);\n    if (pattern.length > byteArray.length) {\n      return false;\n    }\n\n    for (int i = 0; i < pattern.length; ++i) {\n      if (byteArray[i] != pattern[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n",
    "new_code_raw": "  public static boolean startsWithPattern(final byte[] byteArray, final byte[] pattern) {\n    return hasPatternAt(byteArray, pattern, 0);\n  }\n"
  },
  {
    "id": "apache_calcite-615-FirstSentence-0",
    "old_comment_raw": "Returns whether two types are comparable.",
    "new_comment_raw": "Returns whether two types are comparable.",
    "old_code_raw": "    public static boolean isComparable(RelDataType type1, RelDataType type2)\n    {\n        if (type1.isStruct() != type2.isStruct()) {\n            return false;\n        }\n\n        if (type1.isStruct()) {\n            int n = type1.getFieldCount();\n            if (n != type2.getFieldCount()) {\n                return false;\n            }\n            for (int i = 0; i < n; ++i) {\n                RelDataTypeField field1 =\n                    (RelDataTypeField) type1.getFieldList().get(i);\n                RelDataTypeField field2 =\n                    (RelDataTypeField) type2.getFieldList().get(i);\n                if (!isComparable(\n                        field1.getType(),\n                        field2.getType()))\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n        RelDataTypeFamily family1 = null;\n        RelDataTypeFamily family2 = null;\n\n        // REVIEW jvs 2-June-2005:  This is needed to keep\n        // the Saffron type system happy.\n        if (type1.getSqlTypeName() != null) {\n            family1 = type1.getSqlTypeName().getFamily();\n        }\n        if (type2.getSqlTypeName() != null) {\n            family2 = type2.getSqlTypeName().getFamily();\n        }\n        if (family1 == null) {\n            family1 = type1.getFamily();\n        }\n        if (family2 == null) {\n            family2 = type2.getFamily();\n        }\n        if (family1 == family2) {\n            return true;\n        }\n        return false;\n    }\n",
    "new_code_raw": "    public static boolean isComparable(RelDataType type1, RelDataType type2)\n    {\n        if (type1.isStruct() != type2.isStruct()) {\n            return false;\n        }\n\n        if (type1.isStruct()) {\n            int n = type1.getFieldCount();\n            if (n != type2.getFieldCount()) {\n                return false;\n            }\n            for (int i = 0; i < n; ++i) {\n                RelDataTypeField field1 =\n                    (RelDataTypeField) type1.getFieldList().get(i);\n                RelDataTypeField field2 =\n                    (RelDataTypeField) type2.getFieldList().get(i);\n                if (!isComparable(\n                        field1.getType(),\n                        field2.getType()))\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n        RelDataTypeFamily family1 = null;\n        RelDataTypeFamily family2 = null;\n\n        // REVIEW jvs 2-June-2005:  This is needed to keep\n        // the Saffron type system happy.\n        if (type1.getSqlTypeName() != null) {\n            family1 = type1.getSqlTypeName().getFamily();\n        }\n        if (type2.getSqlTypeName() != null) {\n            family2 = type2.getSqlTypeName().getFamily();\n        }\n        if (family1 == null) {\n            family1 = type1.getFamily();\n        }\n        if (family2 == null) {\n            family2 = type2.getFamily();\n        }\n        if (family1 == family2) {\n            return true;\n        }\n\n        /* If one of the operators is of type 'ANY', return true */\n        if (family1 == SqlTypeFamily.ANY ||\n            family2 == SqlTypeFamily.ANY)\n            return true;\n\n        return false;\n    }\n"
  },
  {
    "id": "facebook_fresco-46-FirstSentence-0",
    "old_comment_raw": "If file cache size is not calculated or if it was calculated a long time ago (FILECACHE_SIZE_UPDATE_PERIOD_MS) recalculated from file listing.",
    "new_comment_raw": "If file cache size is not calculated or if it was calculated a long time ago (FILECACHE_SIZE_UPDATE_PERIOD_MS) recalculated from file listing.",
    "old_code_raw": "  private boolean maybeUpdateFileCacheSize() {\n    boolean result = false;\n    long now = mClock.now();\n    if ((!mCacheStats.isInitialized()) ||\n        mCacheSizeLastUpdateTime == UNINITIALIZED ||\n        (now - mCacheSizeLastUpdateTime) > FILECACHE_SIZE_UPDATE_PERIOD_MS) {\n      maybeUpdateFileCacheSizeAndIndex();\n      mCacheSizeLastUpdateTime = now;\n      result = true;\n    }\n    return result;\n  }\n",
    "new_code_raw": "  private boolean maybeUpdateFileCacheSize() {\n    long now = mClock.now();\n    if ((!mCacheStats.isInitialized()) ||\n        mCacheSizeLastUpdateTime == UNINITIALIZED ||\n        (now - mCacheSizeLastUpdateTime) > FILECACHE_SIZE_UPDATE_PERIOD_MS) {\n      return maybeUpdateFileCacheSizeAndIndex();\n    }\n    return false;\n  }\n"
  },
  {
    "id": "apache_axis1-java-22-Associations-FirstSentence",
    "old_comment_raw": "Generates a WSDL Document for a given Class and a space seperated list of methods at design time",
    "new_comment_raw": "Generates a WSDL Definition for a given Class and a space seperated list of methods at design time",
    "old_code_raw": "    public Document emit(Class cls, String allowedMethods) throws Exception {\n        this.cls = cls;\n        this.allowedMethods = allowedMethods;\n\n        /** @todo ravi: getting the serviceName from cls name or explicitly ask the user? */\n        String name = cls.getName();\n        name = name.substring(name.lastIndexOf('.') + 1);\n        setServiceName(name);\n        return emit();\n    }\n",
    "new_code_raw": "    public Definition emit(Class cls, String allowedMethods) throws Exception {\n        this.cls = cls;\n        this.allowedMethods = allowedMethods;\n\n        /** @todo ravi: getting the serviceName from cls name or explicitly ask the user? */\n        String name = cls.getName();\n        name = name.substring(name.lastIndexOf('.') + 1);\n        setServiceName(name);\n        return emit();\n    }\n\n"
  },
  {
    "id": "apache_calcite-571-FirstSentence-0",
    "old_comment_raw": "Apply this  HintStrategyTable to the given relational expression for the  hints.",
    "new_comment_raw": "Apply this  HintStrategyTable to the given relational expression for the  hints.",
    "old_code_raw": "  public List<RelHint> apply(List<RelHint> hints, RelNode rel) {\n    return hints.stream()\n        .filter(relHint -> supportsRel(relHint, rel))\n        .collect(Collectors.toList());\n  }\n",
    "new_code_raw": "  public List<RelHint> apply(List<RelHint> hints, RelNode rel) {\n    return hints.stream()\n        .filter(relHint -> canApply(relHint, rel))\n        .collect(Collectors.toList());\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2531-FirstSentence-0",
    "old_comment_raw": "Output the Getter name for boolean property, e.g.",
    "new_comment_raw": "Output the partial Getter name for boolean property, e.g.",
    "old_code_raw": "    public String toBooleanGetter(String name) {\n        return \"is\" + getterAndSetterCapitalize(name);\n    }\n",
    "new_code_raw": "    public String toBooleanGetter(String name) {\n        return getterAndSetterCapitalize(name);\n    }\n"
  },
  {
    "id": "apache_calcite-762-FirstSentence-0",
    "old_comment_raw": "Creates an equivalent version of a node where common factors among ORs are pulled up.",
    "new_comment_raw": "Creates an equivalent version of a node where common factors among ORs are pulled up.",
    "old_code_raw": "  public static RexNode pullFactors(RexBuilder rexBuilder, RexNode node) {\n    return new CnfHelper(rexBuilder).pull(node);\n  }\n",
    "new_code_raw": "  public static RexNode pullFactors(RexBuilder rexBuilder, RexNode node) {\n    return new CnfHelper(rexBuilder, -1).pull(node);\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-560-FirstSentence-0",
    "old_comment_raw": "Rounds to the nearest whole unit of this field on a copy of this DateOnly, favoring the floor if halfway.",
    "new_comment_raw": "Rounds to the nearest whole unit of this field on a copy of this DateOnly, favoring the floor if halfway.",
    "old_code_raw": "    public DateOnly roundHalfFloorCopy() {\n        DateOnly instant = iInstant;\n        return (DateOnly)instant.toCopy(iField.roundHalfFloor(instant.getMillis()));\n    }\n",
    "new_code_raw": "    public DateOnly roundHalfFloorCopy() {\n        DateOnly instant = iInstant;\n        return (DateOnly)instant.withMillis(iField.roundHalfFloor(instant.getMillis()));\n    }\n"
  },
  {
    "id": "debezium_debezium-1300-FirstSentence-0",
    "old_comment_raw": "Get the number of nanoseconds past midnight of the given  java.time.LocalDateTime,  java.time.LocalDate,  java.time.LocalTime,  java.util.Date,  java.sql.Date,  java.sql.Time, or  java.sql.Timestamp, ignoring any date portions of the supplied value.",
    "new_comment_raw": "Get the number of nanoseconds past midnight of the given  Duration.",
    "old_code_raw": "    public static long toNanoOfDay(Object value, TemporalAdjuster adjuster) {\n        LocalTime time = Conversions.toLocalTime(value);\n        if (adjuster !=null) {\n            time = time.with(adjuster);\n        }\n        return time.toNanoOfDay();\n    }\n",
    "new_code_raw": "    public static long toNanoOfDay(Object value, boolean acceptLargeValues) {\n        if (value instanceof Duration) {\n            Duration duration = (Duration) value;\n            if (!acceptLargeValues && (duration.isNegative() || duration.compareTo(ONE_DAY) > 0)) {\n                throw new IllegalArgumentException(\"Time values must be between 00:00:00 and 24:00:00 (inclusive): \" + duration);\n            }\n\n            return ((Duration) value).toNanos();\n        }\n\n        // TODO only needed for SQL Server/Oracle, where we don't produce Duration right away;\n        // this should go eventually, as the conversion to LocalTime is superfluous\n        LocalTime time = Conversions.toLocalTime(value);\n        return time.toNanoOfDay();\n    }\n"
  },
  {
    "id": "apache_calcite-781-FirstSentence-0",
    "old_comment_raw": "Creates the time format extraction function for the given granularity.",
    "new_comment_raw": "Creates the time format extraction function for the given granularity.",
    "old_code_raw": "  public static TimeExtractionFunction createFromGranularity(Granularity granularity) {\n    switch (granularity) {\n    case DAY:\n      return new TimeExtractionFunction(\"dd\", null, \"UTC\", null);\n    case MONTH:\n      return new TimeExtractionFunction(\"MM\", null, \"UTC\", null);\n    case YEAR:\n      return new TimeExtractionFunction(\"yyyy\", null, \"UTC\", null);\n    case HOUR:\n      return new TimeExtractionFunction(\"hh\", null, \"UTC\", null);\n    default:\n      throw new AssertionError(\"Extraction \" + granularity.value + \" is not valid\");\n    }\n  }\n",
    "new_code_raw": "  public static TimeExtractionFunction createFromGranularity(Granularity granularity) {\n    switch (granularity) {\n    case DAY:\n      return new TimeExtractionFunction(\"d\", null, \"UTC\", Locale.getDefault().toLanguageTag());\n    case MONTH:\n      return new TimeExtractionFunction(\"M\", null, \"UTC\", Locale.getDefault().toLanguageTag());\n    case YEAR:\n      return new TimeExtractionFunction(\"yyyy\", null, \"UTC\", Locale.getDefault().toLanguageTag());\n    default:\n      throw new AssertionError(\"Extraction \" + granularity.value + \" is not valid\");\n    }\n  }\n"
  },
  {
    "id": "pwittchen_ReactiveNetwork-0-Associations-FirstSentence",
    "old_comment_raw": "Observes ConnectivityStatus, which can be WIFI_CONNECTED, MOBILE_CONNECTED or OFFLINE",
    "new_comment_raw": "Observes network connectivity.",
    "old_code_raw": "  public Observable<ConnectivityStatus> observeNetworkConnectivity(final Context context) {\n    final IntentFilter filter = new IntentFilter();\n    filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);\n\n    return Observable.create(new Observable.OnSubscribe<ConnectivityStatus>() {\n      @Override public void call(final Subscriber<? super ConnectivityStatus> subscriber) {\n        final BroadcastReceiver receiver = new BroadcastReceiver() {\n          @Override public void onReceive(Context context, Intent intent) {\n            final ConnectivityStatus newStatus = getConnectivityStatus(context);\n\n            // we need to perform check below,\n            // because after going off-line, onReceive() is called twice\n            if (newStatus != status) {\n              status = newStatus;\n              subscriber.onNext(newStatus);\n            }\n          }\n        };\n\n        context.registerReceiver(receiver, filter);\n\n        subscriber.add(unsubscribeInUiThread(new Action0() {\n          @Override public void call() {\n            context.unregisterReceiver(receiver);\n          }\n        }));\n      }\n    }).defaultIfEmpty(ConnectivityStatus.OFFLINE);\n  }\n",
    "new_code_raw": "  public Observable<Connectivity> observeNetworkConnectivity(final Context context) {\n    final IntentFilter filter = new IntentFilter();\n    filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);\n\n    return Observable.create(new Observable.OnSubscribe<Connectivity>() {\n      @Override public void call(final Subscriber<? super Connectivity> subscriber) {\n        final BroadcastReceiver receiver = new BroadcastReceiver() {\n          @Override public void onReceive(Context context, Intent intent) {\n            subscriber.onNext(Connectivity.create(context));\n          }\n        };\n\n        context.registerReceiver(receiver, filter);\n\n        subscriber.add(unsubscribeInUiThread(new Action0() {\n          @Override public void call() {\n            context.unregisterReceiver(receiver);\n          }\n        }));\n      }\n    }).defaultIfEmpty(Connectivity.create());\n  }\n\n"
  },
  {
    "id": "mcxiaoke_android_volley-5-FirstSentence-0",
    "old_comment_raw": "Checks if the item is available in the cache.",
    "new_comment_raw": "Checks if the item is available in the cache.",
    "old_code_raw": "    public boolean isCached(String requestUrl, int maxWidth, int maxHeight) {\n        throwIfNotOnMainThread();\n\n        String cacheKey = getCacheKey(requestUrl, maxWidth, maxHeight);\n        return mCache.getBitmap(cacheKey) != null;\n    }\n",
    "new_code_raw": "    public boolean isCached(String requestUrl, int maxWidth, int maxHeight) {\n        return isCached(requestUrl, maxWidth, maxHeight, ScaleType.CENTER_INSIDE);\n    }\n"
  },
  {
    "id": "nelsonsilva_vaadin-157-Associations-FirstSentence",
    "old_comment_raw": "Gets the 'top' CSS-attributes value in specified units.",
    "new_comment_raw": "Gets the 'top' attributes value in current units.",
    "old_code_raw": "        public float getTopValue() {\n            return topValue == null ? 0 : topValue.floatValue();\n        }\n",
    "new_code_raw": "        public Float getTopValue() {\n            return topValue;\n        }\n\n"
  },
  {
    "id": "apache_calcite-976-FirstSentence-0",
    "old_comment_raw": "Returns whether an input can be merged into a given relational expression without changing semantics.",
    "new_comment_raw": "Returns whether an input can be merged into a given relational expression without changing semantics.",
    "old_code_raw": "  private boolean canCombine(RelNode input, boolean nullGenerating) {\n    return input instanceof MultiJoinRel\n        && !((MultiJoinRel) input).isFullOuterJoin()\n        && !((MultiJoinRel) input).containsOuter()\n        && !nullGenerating;\n  }\n",
    "new_code_raw": "  private boolean canCombine(RelNode input, boolean nullGenerating) {\n    return input instanceof MultiJoin\n        && !((MultiJoin) input).isFullOuterJoin()\n        && !((MultiJoin) input).containsOuter()\n        && !nullGenerating;\n  }\n"
  },
  {
    "id": "kaendfinger_pircbotx-109-Associations-FirstSentence",
    "old_comment_raw": "Attempts to establish a DCC CHAT session with a client.",
    "new_comment_raw": "Utility method to send a chat request to a user.",
    "old_code_raw": "\tpublic DccChat dccSendChatRequest(User sender, int timeout) throws IOException, SocketTimeoutException {\r\n\t\tif (sender == null)\r\n\t\t\tthrow new IllegalArgumentException(\"Can't send chat request to null user\");\r\n\t\tServerSocket ss = null;//dccManager.createServerSocket();\r\n\t\tss.setSoTimeout(timeout);\r\n\t\tint serverPort = ss.getLocalPort();\r\n\r\n\t\tInetAddress ourAddress = getDccInetAddress();\r\n\t\tif (ourAddress == null)\r\n\t\t\tourAddress = getInetAddress();\r\n\t\tString ipNum = DccManager.addressToInteger(ourAddress);\r\n\r\n\t\tsendCTCPCommand(sender, \"DCC CHAT chat \" + ipNum + \" \" + serverPort);\r\n\r\n\t\t// The client may now connect to us to chat.\r\n\t\tSocket userSocket = ss.accept();\r\n\r\n\t\t// Close the server socket now that we've finished with it.\r\n\t\tss.close();\r\n\r\n\t\treturn new DccChat(this, sender, userSocket);\r\n\t}\r\n",
    "new_code_raw": "\tpublic Chat dccSendChatRequest(User sender, int timeout) throws IOException, SocketTimeoutException {\r\n\t\treturn dccHandler.sendChatRequest(sender);\r\n\t}\r\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-742-FirstSentence-0",
    "old_comment_raw": "Get shipDate",
    "new_comment_raw": "Get shipDate",
    "old_code_raw": "    public Date getShipDate() {\n        return shipDate;\n    }\n",
    "new_code_raw": "    public DateTime getShipDate() {\n        return shipDate;\n    }\n"
  },
  {
    "id": "Atmosphere_atmosphere-859-FirstSentence-0",
    "old_comment_raw": "Jetty 7.2 & 8.0.0-M1/M2and up WebSocket support.",
    "new_comment_raw": "Jetty 7 and up WebSocket support.",
    "old_code_raw": "    public WebSocket doWebSocketConnect(final HttpServletRequest request, final String protocol) {\n        logger.info(\"WebSocket upgrade requested\");\n\n        return new JettyWebSocketHandler(request,this, webSocketProcessorClassName);\n    }\n",
    "new_code_raw": "    protected WebSocket doWebSocketConnect(final HttpServletRequest request, final String protocol) {\n        logger.info(\"WebSocket upgrade requested\");\n\n        return new WebSocket() {\n            private WebSocketProcessor webSocketProcessor;\n\n            @Override\n            public void onConnect(WebSocket.Outbound outbound) {\n                webSocketProcessor = new WebSocketProcessor(AtmosphereServlet.this, new JettyWebSocketSupport(outbound));\n                try {\n                    webSocketProcessor.connect(new JettyRequestFix(request));\n                } catch (IOException e) {\n                    logger.warn(\"failed to connect to web socket\", e);\n                }\n            }\n\n            @Override\n            public void onMessage(byte frame, String data) {\n                webSocketProcessor.broadcast(frame, data);\n            }\n\n            @Override\n            public void onMessage(byte frame, byte[] data, int offset, int length) {\n                webSocketProcessor.broadcast(frame, new String(data, offset, length));\n            }\n\n            @Override\n            public void onFragment(boolean more, byte opcode, byte[] data, int offset, int length) {\n                webSocketProcessor.broadcast(opcode, new String(data, offset, length));\n            }\n\n            @Override\n            public void onDisconnect() {\n                webSocketProcessor.close();\n            }\n        };\n    }\n"
  },
  {
    "id": "apache_avro-170-FirstSentence-0",
    "old_comment_raw": "Constructs a Schema object from JSON schema file file.",
    "new_comment_raw": "Constructs a Schema object from JSON schema file file.",
    "old_code_raw": "  public static Schema parse(File file) throws IOException {\n    JsonParser parser = FACTORY.createJsonParser(file);\n    try {\n      return Schema.parse(MAPPER.readTree(parser), new Names());\n    } catch (JsonParseException e) {\n      throw new SchemaParseException(e);\n    }\n  }\n",
    "new_code_raw": "  public static Schema parse(File file) throws IOException {\n    return new Parser().parse(file);\n  }\n"
  },
  {
    "id": "justinedelson_felix-194-Associations-FirstSentence",
    "old_comment_raw": "The cause of this exception can only be set when constructed.",
    "new_comment_raw": "Initializes the cause of this exception to the specified value.",
    "old_code_raw": "\tpublic Throwable initCause(Throwable cause) {\n\t\tthrow new IllegalStateException();\n\t}\n",
    "new_code_raw": "\tpublic Throwable initCause(Throwable cause) {\n\t\treturn super.initCause(cause);\n\t}\n\n"
  },
  {
    "id": "avast_android_butterknife_zelezny-8-FirstSentence-0",
    "old_comment_raw": "Load field name prefix from code style",
    "new_comment_raw": "Load field name prefix from code style",
    "old_code_raw": "\tpublic static String getPrefix() {\n        String prefix = PropertiesComponent.getInstance().getValue(Settings.PREFIX);\n        if (prefix == null || prefix.length() == 0) {\n            CodeStyleSettingsManager manager = CodeStyleSettingsManager.getInstance();\n            CodeStyleSettings settings = manager.getCurrentSettings();\n            prefix = settings.FIELD_NAME_PREFIX;\n        }\n\t\tif (prefix == null || prefix.length() == 0) {\n\t\t\tprefix = \"m\"; // field name\n\t\t}\n\t\treturn prefix;\n\t}\n",
    "new_code_raw": "\tpublic static String getPrefix() {\n\t\tif (PropertiesComponent.getInstance().isValueSet(Settings.PREFIX)) {\n\t\t\treturn PropertiesComponent.getInstance().getValue(Settings.PREFIX);\n\t\t} else {\n\t\t\tCodeStyleSettingsManager manager = CodeStyleSettingsManager.getInstance();\n\t\t\tCodeStyleSettings settings = manager.getCurrentSettings();\n\t\t\treturn settings.FIELD_NAME_PREFIX;\n\t\t}\n\t}\n"
  },
  {
    "id": "apache_activemq-artemis-27-Associations-FirstSentence",
    "old_comment_raw": "Create a HornetQConnectionFactory which creates session factories from a set of live servers, no HA backup information is propagated to the client",
    "new_comment_raw": "Create a ActiveMQConnectionFactory which creates session factories from a set of live servers, no HA backup information is propagated to the client",
    "old_code_raw": "   public static HornetQConnectionFactory createConnectionFactoryWithoutHA(final DiscoveryGroupConfiguration groupConfiguration, JMSFactoryType jmsFactoryType)\n   {\n      HornetQConnectionFactory factory = null;\n      if (jmsFactoryType.equals(JMSFactoryType.CF))\n      {\n         factory = new HornetQJMSConnectionFactory(false, groupConfiguration);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_CF))\n      {\n         factory = new HornetQQueueConnectionFactory(false, groupConfiguration);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_CF))\n      {\n         factory = new HornetQTopicConnectionFactory(false, groupConfiguration);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.XA_CF))\n      {\n         factory = new HornetQXAConnectionFactory(false, groupConfiguration);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_XA_CF))\n      {\n         factory = new HornetQXAQueueConnectionFactory(false, groupConfiguration);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_XA_CF))\n      {\n         factory = new HornetQXATopicConnectionFactory(false, groupConfiguration);\n      }\n\n      return factory;\n   }\n",
    "new_code_raw": "   public static ActiveMQConnectionFactory createConnectionFactoryWithoutHA(final DiscoveryGroupConfiguration groupConfiguration, JMSFactoryType jmsFactoryType)\n   {\n      ActiveMQConnectionFactory factory = null;\n      if (jmsFactoryType.equals(JMSFactoryType.CF))\n      {\n         factory = new ActiveMQJMSConnectionFactory(false, groupConfiguration);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_CF))\n      {\n         factory = new ActiveMQQueueConnectionFactory(false, groupConfiguration);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_CF))\n      {\n         factory = new ActiveMQTopicConnectionFactory(false, groupConfiguration);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.XA_CF))\n      {\n         factory = new ActiveMQXAConnectionFactory(false, groupConfiguration);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_XA_CF))\n      {\n         factory = new ActiveMQXAQueueConnectionFactory(false, groupConfiguration);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_XA_CF))\n      {\n         factory = new ActiveMQXATopicConnectionFactory(false, groupConfiguration);\n      }\n\n      return factory;\n   }\n\n"
  },
  {
    "id": "processing_processing-128-FirstSentence-0",
    "old_comment_raw": "Converts a Windows buffer to a Java String.",
    "new_comment_raw": "Converts a Windows buffer to a Java String.",
    "old_code_raw": "  private static String convertBufferToString(byte[] buf) throws UnsupportedEncodingException {\n    return(new String(buf, 0, buf.length - 2, \"UTF-16LE\"));\n  }\n",
    "new_code_raw": "  private static String convertBufferToString(byte[] buf) throws UnsupportedEncodingException {\n    return new String(buf, 0, buf.length - 2, \"UTF-16LE\");\n  }\n"
  },
  {
    "id": "frohoff_jdk6-44-Associations-FirstSentence",
    "old_comment_raw": "Returns JTreePath instances representing the path between index0 and index1 (including index1).",
    "new_comment_raw": "Returns the paths (inclusive) between the specified rows.",
    "old_code_raw": "    protected TreePath[] getPathBetweenRows(int index0, int index1) {\n        int              newMinIndex, newMaxIndex;\n        TreeUI           tree = getUI();\n\n        newMinIndex = Math.min(index0, index1);\n        newMaxIndex = Math.max(index0, index1);\n\n        if(tree != null) {\n            TreePath[] selection = new TreePath[newMaxIndex - newMinIndex + 1];\n            for(int counter = newMinIndex; counter <= newMaxIndex; counter++) {\n                selection[counter - newMinIndex] = tree.getPathForRow(this, counter);\n            }\n            return selection;\n        }\n        return null;\n    }\n",
    "new_code_raw": "    protected TreePath[] getPathBetweenRows(int index0, int index1) {\n        TreeUI           tree = getUI();\n        if (tree != null) {\n            int rowCount = getRowCount();\n            if (rowCount > 0 && !((index0 < 0 && index1 < 0) ||\n                                  (index0 >= rowCount && index1 >= rowCount))){\n                index0 = Math.min(rowCount - 1, Math.max(index0, 0));\n                index1 = Math.min(rowCount - 1, Math.max(index1, 0));\n                int minIndex = Math.min(index0, index1);\n                int maxIndex = Math.max(index0, index1);\n                TreePath[] selection = new TreePath[\n                        maxIndex - minIndex + 1];\n                for(int counter = minIndex; counter <= maxIndex; counter++) {\n                    selection[counter - minIndex] =\n                            tree.getPathForRow(this, counter);\n                }\n                return selection;\n            }\n        }\n        return new TreePath[0];\n    }\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-1959-FirstSentence-0",
    "old_comment_raw": "True if this observation is constrained, and false otherwise.",
    "new_comment_raw": "True if this observation is constrained, and false otherwise.",
    "old_code_raw": "  public boolean isConstrained(String observation) {\n    return labelDictionary.containsKey(observation);\n  }\n",
    "new_code_raw": "  public boolean isConstrained(String observation) {\n    return observationIndex.indexOf(observation) >= 0;\n  }\n"
  },
  {
    "id": "apache_oodt-18-Associations-FirstSentence",
    "old_comment_raw": "Gets a  Hashtable representation of a  WorkflowInstancePage that is serializable over the XML-RPC wire.",
    "new_comment_raw": "Gets a  HashMap representation of a  WorkflowInstancePage that is serializable over the XML-RPC wire.",
    "old_code_raw": "  public static Hashtable getXmlRpcWorkflowInstancePage(\n      WorkflowInstancePage page) {\n    Hashtable pageHash = new Hashtable();\n    pageHash.put(\"totalPages\", String.valueOf(page.getTotalPages()));\n    pageHash.put(\"pageNum\", String.valueOf(page.getPageNum()));\n    pageHash.put(\"pageSize\", String.valueOf(page.getPageSize()));\n    pageHash.put(\"pageWorkflows\",\n        getXmlRpcWorkflowInstances(page.getPageWorkflows()));\n\n    return pageHash;\n\n  }\n",
    "new_code_raw": "  public static HashMap getXmlRpcWorkflowInstancePage(\n      WorkflowInstancePage page) {\n    HashMap pageHash = new HashMap();\n    pageHash.put(\"totalPages\", String.valueOf(page.getTotalPages()));\n    pageHash.put(\"pageNum\", String.valueOf(page.getPageNum()));\n    pageHash.put(\"pageSize\", String.valueOf(page.getPageSize()));\n    pageHash.put(\"pageWorkflows\",\n        getXmlRpcWorkflowInstances(page.getPageWorkflows()));\n\n    return pageHash;\n\n  }\n\n"
  },
  {
    "id": "graphql_java_graphql_java-438-FirstSentence-0",
    "old_comment_raw": "This flag controls whether schema printer will use the  graphql.schema.GraphQLType's original Ast  graphql.language.TypeDefinitions when printing the type.",
    "new_comment_raw": "This flag controls whether schema printer will use the  graphql.schema.GraphQLType's original Ast  graphql.language.TypeDefinitions when printing the type.",
    "old_code_raw": "        public Options useAstDefinitions(boolean flag) {\n            return new Options(this.includeIntrospectionTypes, this.includeScalars, this.includeExtendedScalars, this.includeSchemaDefinition, flag, this.descriptionsAsHashComments, this.includeDirective, this.comparatorRegistry);\n        }\n",
    "new_code_raw": "        public Options useAstDefinitions(boolean flag) {\n            return new Options(this.includeIntrospectionTypes, this.includeScalars, this.includeSchemaDefinition, flag, this.descriptionsAsHashComments, this.includeDirective, this.comparatorRegistry);\n        }\n"
  },
  {
    "id": "ncdc_Qpid-1-10-Associations-FirstSentence",
    "old_comment_raw": "Sends the specified ping message and then waits for a correlating reply.",
    "new_comment_raw": "Sends the specified number of ping message and then waits for all correlating replies.",
    "old_code_raw": "    public Message pingAndWaitForReply(Message message, long timeout) throws JMSException, InterruptedException\r\n    {\r\n        _producer.send(message);\r\n\r\n        // Keep the messageId to correlate with the reply.\r\n        String messageId = message.getJMSMessageID();\r\n\r\n        // Commit the transaction if running in transactional mode. This must happen now, rather than at the end of\r\n        // this method, as the message will not be sent until the transaction is committed.\r\n        commitTx();\r\n\r\n        // Block the current thread until a reply to the message is received, or it times out.\r\n        BooleanLatch trafficLight = new BooleanLatch();\r\n        trafficLights.put(messageId, trafficLight);\r\n\r\n        // Note that this call expects a timeout in nanoseconds, millisecond timeout is multiplied up.\r\n        trafficLight.await(timeout * 1000);\r\n\r\n        // Check the replies to see if one was generated, if not then the reply timed out.\r\n        Message result = replies.get(messageId);\r\n\r\n        return result;\r\n    }\r\n",
    "new_code_raw": "    public int pingAndWaitForReply(Message message, int numPings, long timeout) throws JMSException, InterruptedException\r\n    {\r\n        // Put a unique correlation id on the message before sending it.\r\n        String messageCorrelationId = Long.toString(idGenerator.incrementAndGet());\r\n        message.setJMSCorrelationID(messageCorrelationId);\r\n\r\n        for (int i = 0; i < numPings; i++)\r\n        {\r\n            // Re-timestamp the message.\r\n            message.setLongProperty(\"timestamp\", System.currentTimeMillis());\r\n\r\n            _producer.send(message);\r\n        }\r\n\r\n        // Commit the transaction if running in transactional mode. This must happen now, rather than at the end of\r\n        // this method, as the message will not be sent until the transaction is committed.\r\n        commitTx(getProducerSession());\r\n\r\n        // Keep the messageId to correlate with the reply.\r\n        //String messageId = message.getJMSMessageID();\r\n\r\n        if (_verbose)\r\n        {\r\n            _logger.info(timestampFormatter.format(new Date()) + \": Pinged at with correlation id, \" + messageCorrelationId);\r\n        }\r\n\r\n        // Block the current thread until a reply to the message is received, or it times out.\r\n        CountDownLatch trafficLight = new CountDownLatch(numPings);\r\n        trafficLights.put(messageCorrelationId, trafficLight);\r\n\r\n        // Note that this call expects a timeout in nanoseconds, millisecond timeout is multiplied up.\r\n        trafficLight.await(timeout, TimeUnit.MILLISECONDS);\r\n\r\n        // Work out how many replies were receieved.\r\n        int numReplies = numPings - (int) trafficLight.getCount();\r\n\r\n        if ((numReplies < numPings) && _verbose)\r\n        {\r\n            _logger.info(\"Timed out before all replies received on id, \" + messageCorrelationId);\r\n        }\r\n        else if (_verbose)\r\n        {\r\n            _logger.info(\"Got all replies on id, \" + messageCorrelationId);\r\n        }\r\n\r\n        return numReplies;\r\n    }\r\n\n"
  },
  {
    "id": "apache_activemq-969-FirstSentence-0",
    "old_comment_raw": "Creates a nondurable subscriber to the specified topic, using a message selector or specifying whether messages published by its own connection should be delivered to it.",
    "new_comment_raw": "Creates a nondurable subscriber to the specified topic, using a message selector or specifying whether messages published by its own connection should be delivered to it.",
    "old_code_raw": "    public TopicSubscriber createSubscriber(Topic topic, String messageSelector, boolean noLocal) throws JMSException {\n        checkClosed();\n        ActiveMQPrefetchPolicy prefetchPolicy = this.connection.getPrefetchPolicy();\n        return new ActiveMQTopicSubscriber(this, getNextConsumerId(), ActiveMQMessageTransformation\n                .transformDestination(topic), null, messageSelector, prefetchPolicy.getTopicPrefetch(), \n                prefetchPolicy.getMaximumPendingMessageLimit(), noLocal, false, asyncDispatch);\n    }\n",
    "new_code_raw": "    public TopicSubscriber createSubscriber(Topic topic, String messageSelector, boolean noLocal) throws JMSException {\n        checkClosed();\n\n        if (topic instanceof CustomDestination)  {\n            CustomDestination customDestination = (CustomDestination) topic;\n            return customDestination.createSubscriber(this, messageSelector, noLocal);\n        }\n\n        ActiveMQPrefetchPolicy prefetchPolicy = this.connection.getPrefetchPolicy();\n        return new ActiveMQTopicSubscriber(this, getNextConsumerId(), ActiveMQMessageTransformation\n                .transformDestination(topic), null, messageSelector, prefetchPolicy.getTopicPrefetch(), \n                prefetchPolicy.getMaximumPendingMessageLimit(), noLocal, false, asyncDispatch);\n    }\n"
  },
  {
    "id": "svn2github_fleXive-9-Associations-FirstSentence",
    "old_comment_raw": "Hashes a password, making it almost impossible to read it.",
    "new_comment_raw": "Compute the hash of the given flexive password.",
    "old_code_raw": "    public synchronized static final String hashPassword(String password) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"CMS will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        //Now, compute hash.\n        digest.update(getBytes(password));\n        String result = FxFormatUtils.encodeHex(digest.digest());\n        // Avoid SQL problems\n        return result.replaceAll(\"'\", \"_\");\n    }\n",
    "new_code_raw": "    public synchronized static String hashPassword(long accountId, String password) {\n        try {\n            return sha1Hash(getBytes(\"FX-SALT\" + accountId + password));\n        } catch (NoSuchAlgorithmException e) {\n            throw new FxCreateException(\"Failed to load the SHA1 algorithm.\").asRuntimeException();\n        }\n    }\n\n"
  },
  {
    "id": "SeleniumHQ_selenium-1038-FirstSentence-0",
    "old_comment_raw": "Switches to a given frame according to name or numeric ID.",
    "new_comment_raw": "Switches to a given frame according to name or numeric ID.",
    "old_code_raw": "    public WebDriver frame(final String name) {\n      WebWindow window = currentWindow.getTopWindow();\n\n      // Walk over all parts of the frame identifier, each time looking for a frame\n      // with a name or ID matching this part of the identifier (separated by '.').\n      String[] frames = name.split(\"\\\\.\");\n      for (int i = 0; i < frames.length; ++i) {\n        final String currentFrameId = frames[i];\n        final HtmlPage page = (HtmlPage) window.getEnclosedPage();\n        \n        if (isNumericFrameIdValid(currentFrameId, page)) {\n          window = getWindowByNumericFrameId(currentFrameId, page);\n        } else {\n          // Numeric frame ID is not valid - could be either because the identifier\n          // was numeric and not valid OR the number that was given is actually a frame\n          // name, not an index.\n          \n          boolean nextFrameFound = false;\n          for (final FrameWindow frameWindow : page.getFrames()) {\n            final String frameName = frameWindow.getName();\n            final String frameId = frameWindow.getFrameElement().getId();\n            final String remainingFrameId = joinFrom(frames, i, '.');\n            if (frameName.equals(remainingFrameId) || frameId.equals(remainingFrameId)) {\n              currentWindow = frameWindow;\n              return HtmlUnitDriver.this;\n            }\n            if (frameName.equals(currentFrameId) || frameId.equals(currentFrameId)) {\n              window = frameWindow;\n              nextFrameFound = true;\n            }\n          } // End for.\n          \n          if (!nextFrameFound) {\n            throw new NoSuchFrameException(\"Cannot find frame: \" + name);\n          }\n        } // End else\n\n      } // End for\n      \n      currentWindow = window;\n      return HtmlUnitDriver.this;\n    }\n",
    "new_code_raw": "    public WebDriver frame(final String nameOrIdOrIndex) {\n      try {\n        // 1.) try to find frame in current window ...\n        currentWindow = findFrame(currentWindow, nameOrIdOrIndex);\n      } catch (NoSuchFrameException ignored) {\n        // 2.) try to find frame in top window ...\n        final WebWindow topWindow = currentWindow.getTopWindow();\n        currentWindow = findFrame(topWindow, nameOrIdOrIndex);\n      }\n      return HtmlUnitDriver.this;\n    }\n"
  },
  {
    "id": "processing_processing-180-FirstSentence-0",
    "old_comment_raw": "Access variable inspector window.",
    "new_comment_raw": "Access variable inspector window.",
    "old_code_raw": "  public VariableInspector variableInspector() {\n    return tray;\n  }\n",
    "new_code_raw": "  public VariableInspector variableInspector() {\n    return inspector;\n  }\n"
  },
  {
    "id": "android_platform_packages_providers_contactsprovider-74-Associations-FirstSentence",
    "old_comment_raw": "Inserts a new entry into the (contact) data table.",
    "new_comment_raw": "Inserts an item in the data table",
    "old_code_raw": "    private long insertData(ContentValues inputValues, boolean callerIsSyncAdapter) {\n        final Long rawContactId = inputValues.getAsLong(Data.RAW_CONTACT_ID);\n        if (rawContactId == null) {\n            throw new IllegalArgumentException(Data.RAW_CONTACT_ID + \" is required\");\n        }\n\n        final String mimeType = inputValues.getAsString(Data.MIMETYPE);\n        if (TextUtils.isEmpty(mimeType)) {\n            throw new IllegalArgumentException(Data.MIMETYPE + \" is required\");\n        }\n\n        // The input seem valid, create a shallow copy.\n        final ContentValues values = new ContentValues(inputValues);\n\n        // Populate the relevant values before inserting the new entry into the database.\n        replacePackageNameByPackageId(values);\n\n        // Replace the mimetype by the corresponding mimetype ID.\n        values.put(DataColumns.MIMETYPE_ID, mDbHelper.get().getMimeTypeId(mimeType));\n        values.remove(Data.MIMETYPE);\n\n        // Insert the new entry.\n        final SQLiteDatabase db = mDbHelper.get().getWritableDatabase();\n        final TransactionContext context = mTransactionContext.get();\n        final long dataId = getDataRowHandler(mimeType).insert(db, context, rawContactId, values);\n        context.markRawContactDirtyAndChanged(rawContactId, callerIsSyncAdapter);\n        context.rawContactUpdated(rawContactId);\n\n        return dataId;\n    }\n",
    "new_code_raw": "    private long insertData(ContentValues values, boolean callerIsSyncAdapter) {\n        long id = 0;\n        mValues.clear();\n        mValues.putAll(values);\n\n        Long rawContactId = mValues.getAsLong(Data.RAW_CONTACT_ID);\n        if (rawContactId == null) {\n            throw new IllegalArgumentException(Data.RAW_CONTACT_ID + \" is required\");\n        }\n\n        // Replace package with internal mapping\n        final String packageName = mValues.getAsString(Data.RES_PACKAGE);\n        if (packageName != null) {\n            mValues.put(DataColumns.PACKAGE_ID, mDbHelper.get().getPackageId(packageName));\n        }\n        mValues.remove(Data.RES_PACKAGE);\n\n        // Replace mimetype with internal mapping\n        final String mimeType = mValues.getAsString(Data.MIMETYPE);\n        if (TextUtils.isEmpty(mimeType)) {\n            throw new IllegalArgumentException(Data.MIMETYPE + \" is required\");\n        }\n\n        mValues.put(DataColumns.MIMETYPE_ID, mDbHelper.get().getMimeTypeId(mimeType));\n        mValues.remove(Data.MIMETYPE);\n\n        DataRowHandler rowHandler = getDataRowHandler(mimeType);\n        final SQLiteDatabase db = mDbHelper.get().getWritableDatabase();\n        id = rowHandler.insert(db, mTransactionContext.get(), rawContactId, mValues);\n        mTransactionContext.get().markRawContactDirtyAndChanged(rawContactId, callerIsSyncAdapter);\n        mTransactionContext.get().rawContactUpdated(rawContactId);\n        return id;\n    }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-733-FirstSentence-0",
    "old_comment_raw": "Get the minute of hour field for this chronology.",
    "new_comment_raw": "Get the minute of hour field for this chronology.",
    "old_code_raw": "    public DateTimeField minuteOfHour() {\n        return UnsupportedDateTimeField.getInstance(\"minuteOfHour\", minutes());\n    }\n",
    "new_code_raw": "    public DateTimeField minuteOfHour() {\n        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.minuteOfHour(), minutes());\n    }\n"
  },
  {
    "id": "JetBrains_jdk8u_jaxp-44-Associations-FirstSentence",
    "old_comment_raw": "get all built-in DVs, which are stored in a Map keyed by the name",
    "new_comment_raw": "get all built-in DVs, which are stored in a hashtable keyed by the name",
    "old_code_raw": "    @Override\n    public Map<String, DatatypeValidator> getBuiltInTypes() {\n        return new HashMap<>(fBuiltInTypes);\n    }\n",
    "new_code_raw": "    public Hashtable getBuiltInTypes() {\n        return (Hashtable)fBuiltInTypes.clone();\n    }\n\n"
  },
  {
    "id": "yanzhenjie_NoHttp-105-FirstSentence-0",
    "old_comment_raw": "Get version name of NoHttp.",
    "new_comment_raw": "Get version name of NoHttp.",
    "old_code_raw": "    public static String versionName() {\n        return \"1.0.2\";\n    }\n",
    "new_code_raw": "    public static String versionName() {\n        return \"1.0.3\";\n    }\n"
  },
  {
    "id": "apache_lenya-395-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Get a list of links",
    "old_code_raw": "    public ArrayList getLinkHRefs() {\n        return link_href;\n    }\n",
    "new_code_raw": "    public ArrayList getLinkHRefs() {\n        return this.link_href;\n    }\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-299-FirstSentence-0",
    "old_comment_raw": "Determine the name of the column used to store the generator value in the db.",
    "new_comment_raw": "Determine the name of the column used to store the generator value in the db.",
    "old_code_raw": "\tprotected String determineValueColumnName(Properties params) {\n\t\treturn PropertiesHelper.getString( VALUE_COLUMN_PARAM, params, DEF_VALUE_COLUMN );\n\t}\n",
    "new_code_raw": "\tprotected String determineValueColumnName(Properties params, Dialect dialect) {\n\t\tObjectNameNormalizer normalizer = ( ObjectNameNormalizer ) params.get( IDENTIFIER_NORMALIZER );\n\t\tString name = PropertiesHelper.getString( VALUE_COLUMN_PARAM, params, DEF_VALUE_COLUMN );\n\t\treturn dialect.quote( normalizer.normalizeIdentifierQuoting( name ) );\n\t}\n"
  },
  {
    "id": "apache_empire-db-15-Associations-FirstSentence",
    "old_comment_raw": "Clones this object.",
    "new_comment_raw": "Clones this table and assigns a new table alias.",
    "old_code_raw": "    @Override\n    public Object clone()\n    {\n        try\n        {\n            DBTable clone = (DBTable) super.clone();\n            // clone all columns\n            Class<?> colClass = columns.get(0).getClass();\n            Class<?> colBase = colClass.getSuperclass();\n            clone.columns = new ArrayList<DBColumn>();\n            Field[] fields = getClass().getDeclaredFields();\n            for (int i = 0; i < columns.size(); i++)\n            {\n                DBTableColumn srcCol = (DBTableColumn) columns.get(i);\n                DBTableColumn newCol = new DBTableColumn(clone, srcCol);\n                // Replace all references for oldCol to newCol\n                for (int j = 0; j < fields.length; j++)\n                { // Find a class of Type DBColumn or DBTableColumn\n                    Class<?> type = fields[j].getType();\n                    if (type == colClass || type == colBase)\n                    {\n                        try\n                        {\n                            // Check if the field points to the old Value\n                            if (fields[j].get(clone) == srcCol)\n                                fields[j].set(clone, newCol);\n                        } catch (Exception e)\n                        {\n                            // IllegalAccessException or IllegalArgumentException\n                            log.error(\"clone: Cannot clone table-member: \" + fields[j].getName() + \"-->\" + e.getMessage());\n                        }\n                    }\n                }\n            }\n            // set new alias\n            clone.alias = \"t\" + String.valueOf(tableCount.incrementAndGet());\n            // done\n            log.info(\"clone: Table \" + name + \" cloned! Alias old=\" + alias + \" new=\" + clone.alias);\n            return clone;\n        } catch (CloneNotSupportedException e)\n        {\n            return null;\n        }\n    }\n",
    "new_code_raw": "    @Override\n    public Object clone()\n    {\n        try {\n            DBTable clone = (DBTable) super.clone();\n            // clone all columns\n            Class<?> colClass = columns.get(0).getClass();\n            Class<?> colBase = colClass.getSuperclass();\n            clone.columns = new ArrayList<DBColumn>();\n            Field[] fields = getClass().getFields();\n            for (int i = 0; i < columns.size(); i++)\n            {\n                DBTableColumn srcCol = (DBTableColumn) columns.get(i);\n                DBTableColumn newCol = new DBTableColumn(clone, srcCol);\n                // Replace all references for oldCol to newCol\n                for (int j = 0; j < fields.length; j++)\n                { // Find a class of Type DBColumn or DBTableColumn\n                    Class<?> type = fields[j].getType();\n                    if (type == colClass || type == colBase)\n                    {\n                        try\n                        {   // Check if the field points to the old Value\n                            if (fields[j].get(clone) == srcCol)\n                              fields[j].set(clone, newCol);\n                        } catch (Exception e)  {\n                            // IllegalAccessException or IllegalArgumentException\n                            String fieldName = fields[j].getName();\n                            log.error(\"Cannot adjust declared table field: \" + fieldName + \". Reason is: \" + e.getMessage());\n                            // throw CloneNotSupportedException\n                            CloneNotSupportedException cnse = new CloneNotSupportedException(\"Unable to replace field reference for field \" + fieldName);\n                            cnse.initCause(e);\n                            throw cnse;\n                        }\n                    }\n                }\n            }\n            // set new alias\n            clone.alias = \"t\" + String.valueOf(tableCount.incrementAndGet());\n            // done\n            log.info(\"clone: Table \" + name + \" cloned! Alias old=\" + alias + \" new=\" + clone.alias);\n            return clone;\n\n        } catch (CloneNotSupportedException e) {\n            // unable to clone table\n            log.error(\"Unable to clone table \" + getName());\n            throw new RuntimeException(e);\n        }\n    }\n\n"
  },
  {
    "id": "SeleniumHQ_selenium-751-FirstSentence-0",
    "old_comment_raw": "Moves the mouse to the middle of the element.",
    "new_comment_raw": "Moves the mouse to the middle of the element.",
    "old_code_raw": "  public Actions moveToElement(WebElement target) {\n    if (isBuildingActions()) {\n      action.addAction(new MoveMouseAction(jsonMouse, (Locatable) target));\n      return this;\n    }\n    return moveToElement(target, 0, 0);\n  }\n",
    "new_code_raw": "  public Actions moveToElement(WebElement target) {\n    if (isBuildingActions()) {\n      action.addAction(new MoveMouseAction(jsonMouse, (Locatable) target));\n    }\n\n    return moveInTicks(target, 0, 0);\n  }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2421-FirstSentence-0",
    "old_comment_raw": "Create a CoreLabel from its serialized counterpart.",
    "new_comment_raw": "Create a CoreMap representing a sentence from this protocol buffer.",
    "old_code_raw": "  protected CoreLabel fromProto(CoreNLPProtos.Token proto) {\n    CoreLabel word = new CoreLabel();\n    // Required fields\n    word.setWord(proto.getWord());\n    // Optional fields\n    if (proto.hasPos()) { word.setTag(proto.getPos()); }\n    if (proto.hasValue()) { word.setValue(proto.getValue()); }\n    if (proto.hasCategory()) { word.setCategory(proto.getCategory()); }\n    if (proto.hasBefore()) { word.setBefore(proto.getBefore()); }\n    if (proto.hasAfter()) { word.setAfter(proto.getAfter()); }\n    if (proto.hasOriginalText()) { word.setOriginalText(proto.getOriginalText()); }\n    if (proto.hasNer()) { word.setNER(proto.getNer()); }\n    if (proto.hasLemma()) { word.setLemma(proto.getLemma()); }\n    if (proto.hasBeginChar()) { word.setBeginPosition(proto.getBeginChar()); }\n    if (proto.hasEndChar()) { word.setEndPosition(proto.getEndChar()); }\n    if (proto.hasSpeaker()) { word.set(SpeakerAnnotation.class, proto.getSpeaker()); }\n    if (proto.hasUtterance()) { word.set(UtteranceAnnotation.class, proto.getUtterance()); }\n    if (proto.hasBeginIndex()) { word.set(BeginIndexAnnotation.class, proto.getBeginIndex()); }\n    if (proto.hasEndIndex()) { word.set(EndIndexAnnotation.class, proto.getEndIndex()); }\n    if (proto.hasTokenBeginIndex()) { word.set(TokenBeginAnnotation.class, proto.getTokenBeginIndex()); }\n    if (proto.hasTokenEndIndex()) { word.set(TokenEndAnnotation.class, proto.getTokenEndIndex()); }\n    if (proto.hasNormalizedNER()) { word.set(NormalizedNamedEntityTagAnnotation.class, proto.getNormalizedNER()); }\n    if (proto.hasTimexValue()) { word.set(TimexAnnotation.class, fromProto(proto.getTimexValue())); }\n    if (proto.hasHasXmlContext() && proto.getHasXmlContext()) { word.set(XmlContextAnnotation.class, proto.getXmlContextList()); }\n    if (proto.hasCorefClusterID()) { word.set(CorefClusterIdAnnotation.class, proto.getCorefClusterID()); }\n    if (proto.hasAnswer()) { word.set(AnswerAnnotation.class, proto.getAnswer()); }\n    // Non-default annotators\n    if (proto.hasGender()) { word.set(GenderAnnotation.class, proto.getGender()); }\n    if (proto.hasTrueCase()) { word.set(TrueCaseAnnotation.class, proto.getTrueCase()); }\n    if (proto.hasTrueCaseText()) { word.set(TrueCaseTextAnnotation.class, proto.getTrueCaseText()); }\n    // Return\n    return word;\n  }\n",
    "new_code_raw": "  private static CoreMap fromProto(CoreNLPProtos.Sentence proto) {\n    CoreMap sentence = new ArrayCoreMap();\n    // Required fields\n    sentence.set(TokenBeginAnnotation.class, proto.getTokenOffsetBegin());\n    sentence.set(TokenEndAnnotation.class, proto.getTokenOffsetEnd());\n    // Optional fields\n    if (proto.hasSentenceIndex()) { sentence.set(SentenceIndexAnnotation.class, proto.getSentenceIndex()); }\n    if (proto.hasCharacterOffsetBegin()) { sentence.set(CharacterOffsetBeginAnnotation.class, proto.getCharacterOffsetBegin()); }\n    if (proto.hasCharacterOffsetEnd()) { sentence.set(CharacterOffsetEndAnnotation.class, proto.getCharacterOffsetEnd()); }\n    if (proto.hasParseTree()) { sentence.set(TreeAnnotation.class, fromProto(proto.getParseTree())); }\n    // Non-default fields\n    if (proto.hasHasRelationAnnotations() && proto.getHasRelationAnnotations()) {\n      // set entities\n      List<EntityMention> entities = new ArrayList<EntityMention>();\n      for (CoreNLPProtos.Entity entity : proto.getEntityList()) { entities.add(fromProto(entity, sentence)); }\n      sentence.set(EntityMentionsAnnotation.class, entities);\n      // set relations\n      List<RelationMention> relations = new ArrayList<RelationMention>();\n      for (CoreNLPProtos.Relation relation : proto.getRelationList()) { relations.add(fromProto(relation, sentence)); }\n      sentence.set(RelationMentionsAnnotation.class, relations);\n    }\n    // Return\n    return sentence;\n  }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2074-FirstSentence-0",
    "old_comment_raw": "Accepts a String that is a sentence end punctuation tag, and rejects everything else.",
    "new_comment_raw": "Accepts a String that is a sentence end punctuation tag, and rejects everything else.",
    "old_code_raw": "  public boolean isSentenceFinalPunctuationTag(String str) {\n    return sFPunctTagStringAcceptFilter.accept(str);\n  }\n",
    "new_code_raw": "  public boolean isSentenceFinalPunctuationTag(String str) {\n    return sFPunctTagStringAcceptFilter.test(str);\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1735-FirstSentence-0",
    "old_comment_raw": "The corresponding SQL operator",
    "new_comment_raw": "The corresponding SQL operator",
    "old_code_raw": "\t\tpublic String getOperator() {\n\t\t\treturn name().toLowerCase();\n\t\t}\n",
    "new_code_raw": "\t\tpublic String getOperator() {\n\t\t\treturn name().toLowerCase(Locale.ROOT);\n\t\t}\n"
  },
  {
    "id": "RobotiumTech_robotium-1450-FirstSentence-0",
    "old_comment_raw": "Executes JavaScript determined by the given By object",
    "new_comment_raw": "Executes JavaScript determined by the given By object",
    "old_code_raw": "\tprivate boolean executeJavaScript(final By by){\n\t\tif(by instanceof By.Id){\n\t\t\treturn executeJavaScriptFunction(\"id(\\\"\"+by.getValue()+\"\\\");\");\n\t\t}\n\t\telse if(by instanceof By.Xpath){\n\t\t\treturn executeJavaScriptFunction(\"xpath(\\\"\"+by.getValue()+\"\\\");\");\n\t\t}\n\t\telse if(by instanceof By.CssSelector){\n\t\t\treturn executeJavaScriptFunction(\"cssSelector(\\\"\"+by.getValue()+\"\\\");\");\n\t\t}\n\t\telse if(by instanceof By.Name){\n\t\t\treturn executeJavaScriptFunction(\"name(\\\"\"+by.getValue()+\"\\\");\");\n\t\t}\n\t\telse if(by instanceof By.ClassName){\n\t\t\treturn executeJavaScriptFunction(\"className(\\\"\"+by.getValue()+\"\\\");\");\n\t\t}\n\t\telse if(by instanceof By.Text){\n\t\t\treturn executeJavaScriptFunction(\"textContent(\\\"\"+by.getValue()+\"\\\");\");\n\t\t}\n\t\telse if(by instanceof By.TagName){\n\t\t\treturn executeJavaScriptFunction(\"tagName(\\\"\"+by.getValue()+\"\\\");\");\n\t\t}\n\t\treturn false;\n\t}\n",
    "new_code_raw": "\tpublic boolean executeJavaScript(final By by, boolean click){\n\t\tif(by instanceof By.Id){\n\t\t\treturn executeJavaScriptFunction(\"id(\\\"\"+by.getValue()+\"\\\", \\\"\" + String.valueOf(click) + \"\\\");\");\n\t\t}\n\t\telse if(by instanceof By.Xpath){\n\t\t\treturn executeJavaScriptFunction(\"xpath(\\\"\"+by.getValue()+\"\\\", \\\"\" + String.valueOf(click) + \"\\\");\");\n\t\t}\n\t\telse if(by instanceof By.CssSelector){\n\t\t\treturn executeJavaScriptFunction(\"cssSelector(\\\"\"+by.getValue()+\"\\\", \\\"\" + String.valueOf(click) + \"\\\");\");\n\t\t}\n\t\telse if(by instanceof By.Name){\n\t\t\treturn executeJavaScriptFunction(\"name(\\\"\"+by.getValue()+\"\\\", \\\"\" + String.valueOf(click) + \"\\\");\");\n\t\t}\n\t\telse if(by instanceof By.ClassName){\n\t\t\treturn executeJavaScriptFunction(\"className(\\\"\"+by.getValue()+\"\\\", \\\"\" + String.valueOf(click) + \"\\\");\");\n\t\t}\n\t\telse if(by instanceof By.Text){\n\t\t\treturn executeJavaScriptFunction(\"textContent(\\\"\"+by.getValue()+\"\\\", \\\"\" + String.valueOf(click) + \"\\\");\");\n\t\t}\n\t\telse if(by instanceof By.TagName){\n\t\t\treturn executeJavaScriptFunction(\"tagName(\\\"\"+by.getValue()+\"\\\", \\\"\" + String.valueOf(click) + \"\\\");\");\n\t\t}\n\t\treturn false;\n\t}\n"
  },
  {
    "id": "morristech_gwt-5-Associations-FirstSentence",
    "old_comment_raw": "Finds a source file (or other resource) in this module's source path.",
    "new_comment_raw": "Finds a source file (or other resource) that's either in this module's source path, or is a generated file.",
    "old_code_raw": "  InputStream openSourceFile(String resourceName) throws IOException {\n    URL resource = recompiler.getResourceLoader().getResource(resourceName);\n    return resource == null ? null : resource.openStream();\n  }\n",
    "new_code_raw": "  InputStream openSourceFile(String path) throws IOException {\n\n    if (path.startsWith(\"gen/\")) {\n      // generated file?\n      String rest = path.substring(\"gen/\".length());\n      File fileInGenDir = new File(getGenDir(), rest);\n      if (!fileInGenDir.isFile()) {\n        return null;\n      }\n      return new BufferedInputStream(new FileInputStream(fileInGenDir));\n    } else {\n      // regular source file?\n      URL resource = recompiler.getResourceLoader().getResource(path);\n      if (resource == null) {\n        return null;\n      }\n      return resource.openStream();\n    }\n  }\n\n"
  },
  {
    "id": "SeleniumHQ_selenium-847-FirstSentence-0",
    "old_comment_raw": "uses the hub API to get some of its configuration.",
    "new_comment_raw": "uses the hub API to get some of its configuration.",
    "old_code_raw": "  private GridHubConfiguration getHubConfiguration() throws Exception {\n    String hubApi =\n      \"http://\" + registrationRequest.getConfiguration().getHubHost() + \":\"\n      + registrationRequest.getConfiguration().getHubPort() + \"/grid/api/hub\";\n\n    URL api = new URL(hubApi);\n    HttpClient client = httpClientFactory.createClient(api);\n    String url = api.toExternalForm();\n    HttpRequest request = new HttpRequest(GET, url);\n\n    HttpResponse response = client.execute(request);\n    return GridHubConfiguration.loadFromJSON(extractObject(response));\n  }\n",
    "new_code_raw": "  private GridHubConfiguration getHubConfiguration() throws Exception {\n    String hubApi =\n      \"http://\" + registrationRequest.getConfiguration().getHubHost() + \":\"\n      + registrationRequest.getConfiguration().getHubPort() + \"/grid/api/hub\";\n\n    URL api = new URL(hubApi);\n    HttpClient client = httpClientFactory.createClient(api);\n    String url = api.toExternalForm();\n    HttpRequest request = new HttpRequest(GET, url);\n\n    HttpResponse response = client.execute(request);\n    try (Reader reader = new StringReader(response.getContentString());\n        JsonInput jsonInput = new Json().newInput(reader)) {\n      return StandaloneConfiguration.loadFromJson(jsonInput, GridHubConfiguration.class);\n    }\n  }\n"
  },
  {
    "id": "codehaus_cake-2-Associations-FirstSentence",
    "old_comment_raw": "Analogous to  #get(WithAttributes) except returning a primitive byte.",
    "new_comment_raw": "Extracts the attribute map from the specified  WithAttributes and returns the value of this attribute from the map.",
    "old_code_raw": "    public byte get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n",
    "new_code_raw": "    public byte get(WithAttributes withAttributes) {\r\n        return withAttributes.getAttributes().get(this);\r\n    }\r\n\n"
  },
  {
    "id": "JodaOrg_joda_time-949-FirstSentence-0",
    "old_comment_raw": "Gets the chronology, which is the GJChronology if a GregorianCalendar is used,",
    "new_comment_raw": "Gets the chronology, which is the GJChronology if a GregorianCalendar is used,",
    "old_code_raw": "    public Chronology getChronology(Object object, DateTimeZone zone) {\n        if (object.getClass().getName().endsWith(\".BuddhistCalendar\")) {\n            return BuddhistChronology.getInstance(zone);\n        } else if (object instanceof GregorianCalendar) {\n            GregorianCalendar gc = (GregorianCalendar) object;\n            long cutover = gc.getGregorianChange().getTime();\n            if (cutover == Long.MIN_VALUE) {\n                return GregorianChronology.getInstance(zone);\n            } else if (cutover == Long.MAX_VALUE) {\n                return JulianChronology.getInstance(zone);\n            } else {\n                return GJChronology.getInstance(zone, cutover, 4);\n            }\n        } else {\n            return ChronologyType.iso().getChronology(zone);\n        }\n    }\n",
    "new_code_raw": "    public Chronology getChronology(Object object, DateTimeZone zone) {\n        if (object.getClass().getName().endsWith(\".BuddhistCalendar\")) {\n            return BuddhistChronology.getInstance(zone);\n        } else if (object instanceof GregorianCalendar) {\n            GregorianCalendar gc = (GregorianCalendar) object;\n            long cutover = gc.getGregorianChange().getTime();\n            if (cutover == Long.MIN_VALUE) {\n                return GregorianChronology.getInstance(zone);\n            } else if (cutover == Long.MAX_VALUE) {\n                return JulianChronology.getInstance(zone);\n            } else {\n                return GJChronology.getInstance(zone, cutover, 4);\n            }\n        } else {\n            return ISOChronology.getInstance(zone);\n        }\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2092-FirstSentence-0",
    "old_comment_raw": "Parses an operation string into a  TsurgeonPattern.",
    "new_comment_raw": "Parses an operation string into a  TsurgeonPattern.",
    "old_code_raw": "  public static TsurgeonPattern parseOperation(String operationString) {\n    try {\n      TsurgeonParser parser =\n        new TsurgeonParser(new StringReader(operationString + '\\n'));\n      return parser.Root();\n    } catch (ParseException | TokenMgrError e) {\n      throw new TsurgeonParseException(\"Error parsing Tsurgeon expression: \" +\n                                       operationString, e);\n    }\n  }\n",
    "new_code_raw": "  public static TsurgeonPattern parseOperation(String operationString) {\n    try {\n      TsurgeonParser parser =\n        new TsurgeonParser(new StringReader(operationString + \"\\n\"));\n      return new TsurgeonPatternRoot(new TsurgeonPattern[] {parser.Root()} );\n    } catch(ParseException e) {\n      throw new TsurgeonParseException(\"Error parsing Tsurgeon expression: \" +\n                                       operationString, e);\n    } catch(TokenMgrError e) {\n      throw new TsurgeonParseException(\"Error parsing Tsurgeon expression: \" +\n                                       operationString, e);\n    }\n  }\n"
  },
  {
    "id": "TommyLemon_APIJSON-6-Associations-FirstSentence",
    "old_comment_raw": "encode = true",
    "new_comment_raw": "encode = false",
    "old_code_raw": "\t@Override\n\tpublic Object put(Object value) {\n\t\treturn put(null, value);\n\t}\n",
    "new_code_raw": "\t@Override\n\tpublic Object put(Object value) {\n\t\treturn put(value, false);\n\t}\n\n"
  },
  {
    "id": "dropwizard_dropwizard-41-FirstSentence-0",
    "old_comment_raw": "Builds the  HttpClient.",
    "new_comment_raw": "Builds the  HttpClient.",
    "old_code_raw": "    public CloseableHttpClient build(String name) {\n        return buildWithDefaultRequestConfiguration(name).getClient();\n    }\n",
    "new_code_raw": "    public CloseableHttpClient build(String name) {\n        final CloseableHttpClient client = buildWithDefaultRequestConfiguration(name).getClient();\n        // If the environment is present, we tie the client with the server lifecycle\n        if (environment != null) {\n            environment.lifecycle().manage(new Managed() {\n                @Override\n                public void start() throws Exception {\n                }\n\n                @Override\n                public void stop() throws Exception {\n                    client.close();\n                }\n            });\n        }\n        return client;\n    }\n"
  },
  {
    "id": "querydsl_querydsl-232-FirstSentence-0",
    "old_comment_raw": "Expr : left || right",
    "new_comment_raw": "Expr : left || right",
    "old_code_raw": "    public static EString concat(Expr<String> left, String right) {\n        return createString(Ops.CONCAT, left, createConstant(right));\n    }\n",
    "new_code_raw": "    public static EString concat(Expr<String> left, String right) {\n        return factory.createString(Ops.CONCAT, left, factory.createConstant(right));\n    }\n"
  },
  {
    "id": "debezium_debezium-0-FirstSentence-0",
    "old_comment_raw": "Obtain a configuration instance by copying the supplied Properties object.",
    "new_comment_raw": "Obtain a configuration instance by copying the supplied map of string keys and string values.",
    "old_code_raw": "    public static Configuration from(Properties properties) {\n        Properties props = new Properties();\n        if (properties != null) props.putAll(properties);\n        return new Configuration() {\n            @Override\n            public String getString(String key) {\n                return properties.getProperty(key);\n            }\n\n            @Override\n            public Set<String> keys() {\n                return properties.stringPropertyNames();\n            }\n            \n            @Override\n            public String toString() {\n                return props.toString();\n            }\n        };\n    }\n",
    "new_code_raw": "    public static Configuration from(Map<String, String> properties) {\n        Map<String, String> props = new HashMap<>();\n        if (properties != null) props.putAll(properties);\n        return new Configuration() {\n            @Override\n            public String getString(String key) {\n                return properties.get(key);\n            }\n\n            @Override\n            public Set<String> keys() {\n                return properties.keySet();\n            }\n\n            @Override\n            public String toString() {\n                return props.toString();\n            }\n        };\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1797-FirstSentence-0",
    "old_comment_raw": "Some dialects have trouble applying pessimistic locking depending upon what other query options are specified (paging, ordering, etc).",
    "new_comment_raw": "Some dialects have trouble applying pessimistic locking depending upon what other query options are specified (paging, ordering, etc).",
    "old_code_raw": "\tpublic boolean useFollowOnLocking() {\n\t\treturn false;\n\t}\n",
    "new_code_raw": "\tpublic boolean useFollowOnLocking() {\n\t\treturn useFollowOnLocking( null );\n\t}\n"
  },
  {
    "id": "albfan_sqlworkbenchj-61-Associations-FirstSentence",
    "old_comment_raw": "Return the status object for the given row.",
    "new_comment_raw": "Return the status value for the given row.",
    "old_code_raw": "\tpublic Integer getRowStatus(int aRow)\n\t\tthrows IndexOutOfBoundsException\n\t{\n\t\tRowData row = this.getRow(aRow);\n\t\tif (row.isOriginal())\n\t\t{\n\t\t\treturn ROW_ORIGINAL;\n\t\t}\n\t\telse if (row.isNew())\n\t\t{\n\t\t\treturn ROW_NEW;\n\t\t}\n\t\telse if (row.isModified())\n\t\t{\n\t\t\treturn ROW_MODIFIED;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn ROW_ORIGINAL;\n\t\t}\n\t}\n",
    "new_code_raw": "\tpublic int getRowStatus(int aRow)\n\t\tthrows IndexOutOfBoundsException\n\t{\n\t\tRowData row = this.getRow(aRow);\n\t\tif (row.isNew())\n\t\t{\n\t\t\treturn RowData.NEW;\n\t\t}\n\t\telse if (row.isModified())\n\t\t{\n\t\t\treturn RowData.MODIFIED;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn RowData.NOT_MODIFIED;\n\t\t}\n\t}\n\n"
  },
  {
    "id": "querydsl_querydsl-281-FirstSentence-0",
    "old_comment_raw": "Expr : left like right",
    "new_comment_raw": "Expr : left like right",
    "old_code_raw": "    public static EBoolean like(Expr<String> left, String right) {                \n        return factory.createBoolean(Ops.LIKE, left, factory.createConstant(right));\n    }\n",
    "new_code_raw": "    public static EBoolean like(Expr<String> left, String right) {                \n        return operationFactory.createBoolean(Ops.LIKE, left, exprFactory.createConstant(right));\n    }\n"
  },
  {
    "id": "Omegaphora_dalvik-396-Associations-FirstSentence",
    "old_comment_raw": "Inserts the specified element into this priority queue.",
    "new_comment_raw": "Adds the specified element to this queue.",
    "old_code_raw": "    public boolean add(E e) {\n        return offer(e);\n    }\n",
    "new_code_raw": "    public boolean add(E o) {\n        return super.add(o);\n    }\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-1863-FirstSentence-0",
    "old_comment_raw": "Needed because while iterating the observers list and executing the before/update callbacks, some observers might get removed from the list.",
    "new_comment_raw": "Needed because while iterating the observers list and executing the before/update callbacks, some observers might get removed from the list.",
    "old_code_raw": "\tprivate Iterable<TransactionObserver> observers() {\n\t\treturn new ArrayList<>( observers );\n\t}\n",
    "new_code_raw": "\tprivate Iterable<TransactionObserver> observers() {\n\t\tif ( observers == null || observers.isEmpty() ) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\telse {\n\t\t\treturn new ArrayList<>( observers );\n\t\t}\n\t}\n"
  },
  {
    "id": "bmc_curn-4-Associations-FirstSentence",
    "old_comment_raw": "Get an InputStream that can be used to read the output data produced by the handler, if applicable.",
    "new_comment_raw": "Get the File that represents the output produced by the handler, if applicable.",
    "old_code_raw": "    public InputStream getGeneratedOutput()\n        throws CurnException\n    {\n        return null;\n    }\n",
    "new_code_raw": "    public File getGeneratedOutput()\n        throws CurnException\n    {\n        return null;\n    }\n\n"
  },
  {
    "id": "apache_kylin-441-FirstSentence-0",
    "old_comment_raw": "Calculate size of each region for given table and other info of the table.",
    "new_comment_raw": "Calculate size of each region for given table and other info of the table.",
    "old_code_raw": "    public HBaseResponse getHTableInfo(String tableName) throws IOException {\n        if (htableInfoCache.containsKey(tableName)) {\n            return htableInfoCache.get(tableName);\n        }\n\n        // Get HBase storage conf.\n        String hbaseUrl = KylinConfig.getInstanceFromEnv().getStorageUrl();\n        Configuration hconf = HBaseConnection.newHBaseConfiguration(hbaseUrl);\n\n        HTable table = null;\n        HBaseResponse hr = null;\n        long tableSize = 0;\n        int regionCount = 0;\n\n        try {\n            table = new HTable(hconf, tableName);\n\n            HBaseRegionSizeCalculator cal = new HBaseRegionSizeCalculator(table);\n            Map<byte[], Long> sizeMap = cal.getRegionSizeMap();\n\n            for (long s : sizeMap.values()) {\n                tableSize += s;\n            }\n\n            regionCount = sizeMap.size();\n\n            // Set response.\n            hr = new HBaseResponse();\n            hr.setTableSize(tableSize);\n            hr.setRegionCount(regionCount);\n        } finally {\n            if (null != table) {\n                table.close();\n            }\n        }\n\n        htableInfoCache.put(tableName, hr);\n\n        return hr;\n    }\n",
    "new_code_raw": "    public HBaseResponse getHTableInfo(String tableName) throws IOException {\n        Configuration hconf = HadoopUtil.getCurrentHBaseConfiguration();\n        HTable table = null;\n        HBaseResponse hr = null;\n        long tableSize = 0;\n        int regionCount = 0;\n\n        try {\n            table = new HTable(hconf, tableName);\n\n            HBaseRegionSizeCalculator cal = new HBaseRegionSizeCalculator(table);\n            Map<byte[], Long> sizeMap = cal.getRegionSizeMap();\n\n            for (long s : sizeMap.values()) {\n                tableSize += s;\n            }\n\n            regionCount = sizeMap.size();\n\n            // Set response.\n            hr = new HBaseResponse();\n            hr.setTableSize(tableSize);\n            hr.setRegionCount(regionCount);\n        } finally {\n            if (null != table) {\n                table.close();\n            }\n        }\n\n        return hr;\n    }\n"
  },
  {
    "id": "egonw_pathvisio-89-Associations-FirstSentence",
    "old_comment_raw": "Get the first  Data instance of the cached data for this gene-product.",
    "new_comment_raw": "Get the first  ReporterData instance of the cached data for this gene-product.",
    "old_code_raw": "\tpublic Data getSingleData(Xref idc) {\n\t\tList<Data> dlist = data.get(idc);\n\t\tif(dlist != null && dlist.size() > 0) return dlist.get(0);\n\t\treturn null;\n\t}\n",
    "new_code_raw": "\tpublic ReporterData getSingleData(Xref idc) {\n\t\tList<ReporterData> dlist = data.get(idc);\n\t\tif(dlist != null && dlist.size() > 0) return dlist.get(0);\n\t\treturn null;\n\t}\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-1944-FirstSentence-0",
    "old_comment_raw": "Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.",
    "new_comment_raw": "Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.",
    "old_code_raw": "  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          int zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 23: \n          { final String origTxt = yytext();\n\t\t\t  String txt = origTxt;\n       \t\t\t  if (normalizeSpace) {\n\t\t\t    txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n\t\t\t  }\n                          return getNext(txt, origTxt);\n          }\n        case 45: break;\n        case 31: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 1;\n          { /* invert quote - often but not always right */\n\t\t  return handleQuotes(yytext(), true);\n          }\n        case 46: break;\n        case 8: \n          { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 47: break;\n        case 19: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 48: break;\n        case 38: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 9;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 10;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n\t                  return getNext(s, yytext());\n          }\n        case 49: break;\n        case 15: \n          { return handleQuotes(yytext(), false);\n          }\n        case 50: break;\n        case 30: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), false);\n          }\n        case 51: break;\n        case 12: \n          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n\t            return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n\t\t  }\n          }\n        case 52: break;\n        case 40: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNormalizedAmpNext();\n          }\n        case 53: break;\n        case 29: \n          { return getNormalizedAmpNext();\n          }\n        case 54: break;\n        case 37: \n          // lookahead expression with fixed lookahead length\n          yypushback(2);\n          { return getNext();\n          }\n        case 55: break;\n        case 4: \n          { return getNext();\n          }\n        case 56: break;\n        case 21: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext();\n          }\n        case 57: break;\n        case 34: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 11;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 12;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 58: break;\n        case 35: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 13;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 12;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 59: break;\n        case 42: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 60: break;\n        case 6: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 61: break;\n        case 27: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 3;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 4;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 62: break;\n        case 16: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 63: break;\n        case 32: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '/');\n                  }\n                  if (normalizeSpace) {\n                    txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 64: break;\n        case 24: \n          { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 65: break;\n        case 44: \n          { String txt = yytext();\n\t\t\t  if (normalizeSpace) {\n\t\t\t    txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n\t\t\t  }\n\t\t\t  if (normalizeParentheses) {\n\t\t\t    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n\t\t\t    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n\t\t\t  }\n\t\t\t  return getNext(txt, yytext());\n          }\n        case 66: break;\n        case 18: \n          { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 67: break;\n        case 41: \n          { yypushback(3) ; return getNext();\n          }\n        case 68: break;\n        case 22: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), true);\n          }\n        case 69: break;\n        case 2: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 70: break;\n        case 33: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 5;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 6;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n          }\n        case 71: break;\n        case 20: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 72: break;\n        case 25: \n          { // this one should only match if we're basically at the end of file\n\t\t\t  // since the last one matches two things, even newlines\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n\t                  return getNext(s, yytext());\n          }\n        case 73: break;\n        case 43: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 7;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 8;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { String s;\n                          // try to work around an apparent jflex bug where it\n                          // gets a space at the token end by getting\n                          // wrong the length of the trailing context.\n                          while (yylength() > 0) {\n\t\t\t    char last = yycharat(yylength()-1);\n\t\t\t    if (last == ' ' || last == '\\t') {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 74: break;\n        case 17: \n          { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 75: break;\n        case 11: \n          { return handleEllipsis(yytext());\n          }\n        case 76: break;\n        case 13: \n          { return normalizeFractions(yytext());\n          }\n        case 77: break;\n        case 14: \n          { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 78: break;\n        case 10: \n          { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n          }\n        case 79: break;\n        case 3: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 80: break;\n        case 39: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                               yytext());\n          }\n        case 81: break;\n        case 26: \n          { return getNext(removeSoftHyphens(yytext()), yytext());\n          }\n        case 82: break;\n        case 7: \n          { final String origTxt = yytext();\n\t\t\t  String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 83: break;\n        case 9: \n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 84: break;\n        case 28: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 85: break;\n        case 1: \n          { String str = yytext();\n          int first = str.charAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n          }\n        case 86: break;\n        case 36: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 87: break;\n        case 5: \n          { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n          }\n        case 88: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                if (invertible) { \n            prevWordAfter.append(yytext()); \n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(AfterAnnotation.class, str);\n          }\n          return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n",
    "new_code_raw": "  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          int zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 8: \n          { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 48: break;\n        case 19: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 49: break;\n        case 45: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 7;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 8;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { String s;\n                          // try to work around an apparent jflex bug where it\n                          // gets a space at the token end by getting\n                          // wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 50: break;\n        case 15: \n          { return handleQuotes(yytext(), false);\n          }\n        case 51: break;\n        case 30: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), false);\n          }\n        case 52: break;\n        case 42: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNormalizedAmpNext();\n          }\n        case 53: break;\n        case 29: \n          { return getNormalizedAmpNext();\n          }\n        case 54: break;\n        case 46: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 4;\n          { return getNext();\n          }\n        case 55: break;\n        case 40: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 3;\n          { return getNext();\n          }\n        case 56: break;\n        case 37: \n          // lookahead expression with fixed lookahead length\n          yypushback(2);\n          { return getNext();\n          }\n        case 57: break;\n        case 4: \n          { return getNext();\n          }\n        case 58: break;\n        case 21: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext();\n          }\n        case 59: break;\n        case 34: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 11;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 12;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 60: break;\n        case 35: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 13;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 12;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 61: break;\n        case 44: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 62: break;\n        case 47: \n          { String txt = yytext();\n                          if (normalizeSpace) {\n                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 63: break;\n        case 6: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 64: break;\n        case 7: \n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 65: break;\n        case 27: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 3;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 4;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 66: break;\n        case 16: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 67: break;\n        case 41: \n          { yypushback(2) ; return getNext();\n          }\n        case 68: break;\n        case 32: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '/');\n                  }\n                  if (normalizeSpace) {\n                    txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 69: break;\n        case 24: \n          { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 70: break;\n        case 18: \n          { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 71: break;\n        case 43: \n          { yypushback(3) ; return getNext();\n          }\n        case 72: break;\n        case 22: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), true);\n          }\n        case 73: break;\n        case 2: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 74: break;\n        case 23: \n          { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n          }\n        case 75: break;\n        case 33: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 5;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 6;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n          }\n        case 76: break;\n        case 20: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 77: break;\n        case 17: \n          { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 78: break;\n        case 11: \n          { return handleEllipsis(yytext());\n          }\n        case 79: break;\n        case 31: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 1;\n          { /* invert quote - often but not always right */\n                  return handleQuotes(yytext(), true);\n          }\n        case 80: break;\n        case 13: \n          { return normalizeFractions(yytext());\n          }\n        case 81: break;\n        case 14: \n          { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 82: break;\n        case 38: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 9;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 10;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 83: break;\n        case 10: \n          { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n          }\n        case 84: break;\n        case 3: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 85: break;\n        case 39: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                               yytext());\n          }\n        case 86: break;\n        case 12: \n          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n          }\n        case 87: break;\n        case 26: \n          { return getNext(removeSoftHyphens(yytext()), yytext());\n          }\n        case 88: break;\n        case 9: \n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 89: break;\n        case 28: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 90: break;\n        case 25: \n          { // this one should only match if we're basically at the end of file\n                          // since the last one matches two things, even newlines\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 91: break;\n        case 1: \n          { String str = yytext();\n          int first = str.charAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n          }\n        case 92: break;\n        case 36: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 93: break;\n        case 5: \n          { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n          }\n        case 94: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                if (invertible) {\n            prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(AfterAnnotation.class, str);\n          }\n          return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n"
  },
  {
    "id": "jackyglony_objectiveclipse-373-Associations-FirstSentence",
    "old_comment_raw": "Returns a Set of property names (Strings) stored in this object",
    "new_comment_raw": "Returns the Set of property names stored in this object",
    "old_code_raw": "\tpublic Set getKeySet() throws CoreException {\n\t\treturn DBProperty.getKeySet(db, index);\n\t}\n",
    "new_code_raw": "\tpublic Set<String> getKeySet() throws CoreException {\n\t\treturn DBProperty.getKeySet(db, index);\n\t}\n\n"
  },
  {
    "id": "apache_drill-1241-FirstSentence-0",
    "old_comment_raw": "Checks if current number of processed records does not exceed max batch size.",
    "new_comment_raw": "Checks if current number of processed records does not exceed max batch size.",
    "old_code_raw": "  public boolean isBatchFull() {\n    return processedRecordCount >= HiveAbstractReader.TARGET_RECORD_COUNT;\n  }\n",
    "new_code_raw": "  public boolean isBatchFull() {\n    return processedRecordCount >= HiveDefaultRecordReader.TARGET_RECORD_COUNT;\n  }\n"
  },
  {
    "id": "apache_drill-137-Associations-FirstSentence",
    "old_comment_raw": "Compares selection root and actual file path to determine partition columns values.",
    "new_comment_raw": "Creates map with implicit columns where key is column name, value is columns actual value.",
    "old_code_raw": "  public Map<String, String> populateImplicitColumns(FileWork work, String selectionRoot) {\n    return populateImplicitColumns(work.getPath(), selectionRoot);\n  }\n",
    "new_code_raw": "  public Map<String, String> populateImplicitColumns(String filePath,\n                                                     List<String> partitionValues,\n                                                     boolean includeFileImplicitColumns) {\n    Map<String, String> implicitValues = new LinkedHashMap<>();\n\n    for (int i = 0; i < partitionValues.size(); i++) {\n      if (isStarQuery || selectedPartitionColumns.contains(i)) {\n        implicitValues.put(partitionDesignator + i, partitionValues.get(i));\n      }\n    }\n\n    if (includeFileImplicitColumns) {\n      Path path = Path.getPathWithoutSchemeAndAuthority(new Path(filePath));\n      for (Map.Entry<String, ImplicitFileColumns> entry : selectedImplicitColumns.entrySet()) {\n        implicitValues.put(entry.getKey(), entry.getValue().getValue(path));\n      }\n    }\n\n    return implicitValues;\n  }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-1013-FirstSentence-0",
    "old_comment_raw": "Get the date time as a java.util.Date.",
    "new_comment_raw": "Get the date time as a java.util.Date.",
    "old_code_raw": "    public Date toDate() {\n        int dom = getDayOfMonth();\n        Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom,\n                        getHourOfDay(), getMinuteOfHour(), getSecondOfMinute());\n        date.setTime(date.getTime() + getMillisOfSecond());\n        LocalDateTime check = LocalDateTime.fromDateFields(date);\n        if (check.isBefore(this)) {\n            // DST gap\n            // move forward in units of one minute until equal/after\n            while (check.isBefore(this)) {\n                date.setTime(date.getTime() + 60000);\n                check = LocalDateTime.fromDateFields(date);\n            }\n            // move back in units of one second until date wrong\n            while (check.isBefore(this) == false) {\n                date.setTime(date.getTime() - 1000);\n                check = LocalDateTime.fromDateFields(date);\n            }\n            date.setTime(date.getTime() + 1000);\n        } else if (check.equals(this)) {\n            // check for DST overlap\n            Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings());\n            check = LocalDateTime.fromDateFields(earlier);\n            if (check.equals(this)) {\n                date = earlier;\n            }\n        }\n        return date;\n    }\n",
    "new_code_raw": "    public Date toDate() {\n        int dom = getDayOfMonth();\n        Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom,\n                        getHourOfDay(), getMinuteOfHour(), getSecondOfMinute());\n        date.setTime(date.getTime() + getMillisOfSecond());\n\n        return correctDstTransition(date, TimeZone.getDefault());\n    }\n"
  },
  {
    "id": "wso2-extensions_siddhi-execution-extrema-1-Associations-FirstSentence",
    "old_comment_raw": "Method to find whether a value d% less than or equal to max exists within l length window, by looping through older events.",
    "new_comment_raw": "Method to find whether a value preBoundChange% less than or equal to max exists within maxPreBound length window, by looping through older events.",
    "old_code_raw": "    private StreamEvent findIfActualMax(attributeDetails latestEvent) {\n        int indexCurrentMax = valueStack.indexOf(currentMax);\n        int actual_L = valueStack.indexOf(latestEvent) - indexCurrentMax;\n        // If latest event is at a distance greater than L from max, max is not eligible to be sent as output\n        if (actual_L > L) {\n            currentMax.notEligibleForRealMax();\n            return null;\n        }\n        int actual_l = 1;\n        double dThreshold = currentMax.getValue() - currentMax.getValue() * d / 100;\n        while (actual_l <= l && indexCurrentMax - actual_l >= 0) {\n            if (valueStack.get(indexCurrentMax - actual_l).getValue() <= dThreshold) {\n                StreamEvent outputEvent = eventStack.get(indexCurrentMax);\n                complexEventPopulater.populateComplexEvent(outputEvent, new Object[] { \"max\", actual_l, actual_L });\n                currentMax.sentOutputAsRealMax();\n                return outputEvent;\n            }\n            ++actual_l;\n        }\n        // Completed iterating through l older events. No events which satisfy d condition found.\n        // Therefore max is not eligible to be sent as output.\n        currentMax.notEligibleForRealMax();\n        return null;\n    }\n",
    "new_code_raw": "    private StreamEvent findIfActualMax(AttributeDetails latestEvent) {\n        int indexCurrentMax = valueStack.indexOf(currentMax);\n        int postBound = valueStack.indexOf(latestEvent) - indexCurrentMax;\n        // If latest event is at a distance greater than maxPostBound from max, max is not eligible to be sent as output\n        if (postBound > maxPostBound) {\n            currentMax.notEligibleForRealMax();\n            return null;\n        }\n        // If maxPreBound is 0, no need to check preBoundChange. Send output with postBound value\n        if (maxPreBound == 0) {\n            StreamEvent outputEvent = eventStack.get(indexCurrentMax);\n            complexEventPopulater.populateComplexEvent(outputEvent, new Object[] { \"max\", 0, postBound });\n            currentMax.sentOutputAsRealMax();\n            return outputEvent;\n        }\n        int preBound = 1;\n        double dThreshold = currentMax.getValue() - currentMax.getValue() * preBoundChange / 100;\n        while (preBound <= maxPreBound && indexCurrentMax - preBound >= 0) {\n            if (valueStack.get(indexCurrentMax - preBound).getValue() <= dThreshold) {\n                StreamEvent outputEvent = eventStack.get(indexCurrentMax);\n                complexEventPopulater.populateComplexEvent(outputEvent, new Object[] { \"max\", preBound, postBound });\n                currentMax.sentOutputAsRealMax();\n                return outputEvent;\n            }\n            ++preBound;\n        }\n        // Completed iterating through maxPreBound older events. No events which satisfy preBoundChange condition found.\n        // Therefore max is not eligible to be sent as output.\n        currentMax.notEligibleForRealMax();\n        return null;\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2560-FirstSentence-0",
    "old_comment_raw": "Escapes a reserved word as defined in the `reservedWords` array.",
    "new_comment_raw": "Escapes a reserved word as defined in the `reservedWords` array.",
    "old_code_raw": "    public String escapeReservedWord(String name) {\n        return \"_\" + name;  // add an underscore to the name\n    }\n",
    "new_code_raw": "    public String escapeReservedWord(String name) {           \n        if(this.reservedWordsMappings().containsKey(name)) {\n            return this.reservedWordsMappings().get(name);\n        }\n        return \"_\" + name;\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2597-FirstSentence-0",
    "old_comment_raw": "If a RequestBody contains a reference to an other RequestBody with '$ref', returns the referenced RequestBody or the actual RequestBody in the other cases.",
    "new_comment_raw": "If a RequestBody contains a reference to an other RequestBody with '$ref', returns the referenced RequestBody if it is found or the actual RequestBody in the other cases.",
    "old_code_raw": "    public static RequestBody getReferencedRequestBody(OpenAPI openAPI, RequestBody requestBody) {\n        if (requestBody != null && StringUtils.isNotEmpty(requestBody.get$ref())) {\n            String name = getSimpleRef(requestBody.get$ref());\n            return getRequestBody(openAPI, name);\n        }\n        return requestBody;\n    }\n",
    "new_code_raw": "    public static RequestBody getReferencedRequestBody(OpenAPI openAPI, RequestBody requestBody) {\n        if (requestBody != null && StringUtils.isNotEmpty(requestBody.get$ref())) {\n            String name = getSimpleRef(requestBody.get$ref());\n            RequestBody referencedRequestBody = getRequestBody(openAPI, name);\n            if(referencedRequestBody != null) {\n                return referencedRequestBody;\n            }\n        }\n        return requestBody;\n    }\n"
  },
  {
    "id": "notnoop_java_apns-61-FirstSentence-0",
    "old_comment_raw": "Shrinks the alert message body so that the resulting payload message fits within the passed expected payload length.",
    "new_comment_raw": "Shrinks the alert message body so that the resulting payload message fits within the passed expected payload length.",
    "old_code_raw": "    public PayloadBuilder resizeAlertBody(int payloadLength) {\n        int currLength = length();\n        if (currLength < payloadLength)\n            return this;\n\n        int d = currLength - payloadLength;\n        String body = (String)aps.get(\"alert\");\n\n        if (body.length() < d)\n            aps.remove(\"alert\");\n        else\n            aps.put(\"alert\", body.subSequence(0, body.length() - d));\n\n        return this;\n    }\n",
    "new_code_raw": "    public PayloadBuilder resizeAlertBody(int payloadLength) {\n        return resizeAlertBody(payloadLength, \"\");\n    }\n"
  },
  {
    "id": "zaproxy_zaproxy-2114-FirstSentence-0",
    "old_comment_raw": "This method initializes jTextField",
    "new_comment_raw": "This method initializes ZapTextField",
    "old_code_raw": "\tprivate JTextField getTxtReverseProxyHttpsPort() {\n\t\tif (txtReverseProxyHttpsPort == null) {\n\t\t\ttxtReverseProxyHttpsPort = new JTextField();\n\t\t}\n\t\treturn txtReverseProxyHttpsPort;\n\t}\n",
    "new_code_raw": "\tprivate ZapTextField getTxtReverseProxyHttpsPort() {\n\t\tif (txtReverseProxyHttpsPort == null) {\n\t\t\ttxtReverseProxyHttpsPort = new ZapTextField();\n\t\t}\n\t\treturn txtReverseProxyHttpsPort;\n\t}\n"
  },
  {
    "id": "apache_drill-1045-FirstSentence-0",
    "old_comment_raw": "Generate a new BatchSchema object based on the current state of the builder.",
    "new_comment_raw": "Generate a new BatchSchema object based on the current state of the builder.",
    "old_code_raw": "  public BatchSchema build() throws SchemaChangeException {\n    // check if any fields are unaccounted for.\n\n    List<MaterializedField> fieldList = Lists.newArrayList();\n    for (ObjectCursor<MaterializedField> f : fields.values()) {\n      if (f != null) fieldList.add(f.value);\n    }\n    Collections.sort(fieldList);\n    return new BatchSchema(this.hasSelectionVector, fieldList);\n  }\n",
    "new_code_raw": "  public BatchSchema build(){\n    List<MaterializedField> fieldList = Lists.newArrayList(fields);\n    return new BatchSchema(this.selectionVectorMode, fieldList);\n  }\n"
  },
  {
    "id": "apache_lenya-397-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Get a list of a href=",
    "old_code_raw": "    public ArrayList getAHRefs() {\n        return a_href;\n    }\n",
    "new_code_raw": "    public ArrayList getAHRefs() {\n        return this.a_href;\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1697-FirstSentence-0",
    "old_comment_raw": "uploads an image (required)",
    "new_comment_raw": "uploads an image (required)",
    "old_code_raw": "    public Single<ModelApiResponse> rxUploadFileWithRequiredFile(Long petId, AsyncFile file, String additionalMetadata) {\n        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {\n            delegate.uploadFileWithRequiredFile(petId, file, additionalMetadata, fut);\n        }));\n    }\n",
    "new_code_raw": "    public Single<ModelApiResponse> rxUploadFileWithRequiredFile(Long petId, AsyncFile requiredFile, String additionalMetadata) {\n        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {\n            delegate.uploadFileWithRequiredFile(petId, requiredFile, additionalMetadata, fut);\n        }));\n    }\n"
  },
  {
    "id": "eclipse_mylyn.reviews-1-Associations-FirstSentence",
    "old_comment_raw": "Returns the meta object for the reference ' org.eclipse.mylyn.reviews.core.model.ITopic#getItem Item'.",
    "new_comment_raw": "Returns the meta object for the container reference ' org.eclipse.mylyn.reviews.core.model.ITopic#getItem Item'.",
    "old_code_raw": "\tpublic EReference getTopic_Item() {\n\t\treturn (EReference) topicEClass.getEStructuralFeatures().get(5);\n\t}\n",
    "new_code_raw": "\tpublic EReference getTopic_Item() {\n\t\treturn (EReference) topicEClass.getEStructuralFeatures().get(4);\n\t}\n\n"
  },
  {
    "id": "JodaOrg_joda_time-994-FirstSentence-0",
    "old_comment_raw": "Adds to the value of this field in a copy of this YearMonth wrapping within this field if the maximum value is reached.",
    "new_comment_raw": "Adds to the value of this field in a copy of this YearMonth wrapping within this field if the maximum value is reached.",
    "old_code_raw": "        public YearMonth addWrapFieldToCopy(int valueToAdd) {\n            int[] newValues = iYearMonth.getValues();\n            newValues = getField().addWrapField(iYearMonth, iFieldIndex, newValues, valueToAdd);\n            return new YearMonth(iYearMonth, newValues);\n        }\n",
    "new_code_raw": "        public YearMonth addWrapFieldToCopy(int valueToAdd) {\n            int[] newValues = iBase.getValues();\n            newValues = getField().addWrapField(iBase, iFieldIndex, newValues, valueToAdd);\n            return new YearMonth(iBase, newValues);\n        }\n"
  },
  {
    "id": "mccraigmccraig_prefuse-57-Associations-FirstSentence",
    "old_comment_raw": "Interpolates a value between a given minimum and maximum value using a specified scale.",
    "new_comment_raw": "Interpolates a value within a range using a specified scale, returning the fractional position of the value within that scale.",
    "old_code_raw": "    public static double interp(int scale, double val, double min, double max) {\n        switch ( scale ) {\n        case Constants.LINEAR_SCALE:\n            return linearInterp(val, min, max);\n        case Constants.LOG_SCALE:\n            return logInterp(val, min, max);\n        case Constants.SQRT_SCALE:\n            return sqrtInterp(val, min, max);\n        }\n        throw new IllegalArgumentException(\"Unrecognized scale value: \"+scale);\n    }\n",
    "new_code_raw": "    public static double interp(int scale, double val, double dist[]) {\n        switch ( scale ) {\n        case Constants.LINEAR_SCALE:\n            return linearInterp(val, dist[0], dist[dist.length-1]);\n        case Constants.LOG_SCALE:\n            return logInterp(val, dist[0], dist[dist.length-1]);\n        case Constants.SQRT_SCALE:\n            return sqrtInterp(val, dist[0], dist[dist.length-1]);\n        case Constants.QUANTILE_SCALE:\n            return quantile(val, dist);\n        }\n        throw new IllegalArgumentException(\"Unrecognized scale value: \"+scale);\n    }\n\n"
  },
  {
    "id": "android_location_samples-0-FirstSentence-0",
    "old_comment_raw": "Gets a PendingIntent to send with the request to add or remove Geofences.",
    "new_comment_raw": "Gets a PendingIntent to send with the request to add or remove Geofences.",
    "old_code_raw": "    private PendingIntent getGeofencePendingIntent() {\n        // Reuse the PendingIntent if we already have it.\n        if (mGeofencePendingIntent != null) {\n            return mGeofencePendingIntent;\n        }\n        Intent intent = new Intent(this, GeofenceTransitionsIntentService.class);\n        // We use FLAG_UPDATE_CURRENT so that we get the same pending intent back when calling\n        // addGeofences() and removeGeofences().\n        return PendingIntent.getService(this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);\n    }\n",
    "new_code_raw": "    private PendingIntent getGeofencePendingIntent() {\n        // Reuse the PendingIntent if we already have it.\n        if (mGeofencePendingIntent != null) {\n            return mGeofencePendingIntent;\n        }\n        Intent intent = new Intent(this, GeofenceBroadcastReceiver.class);\n        // We use FLAG_UPDATE_CURRENT so that we get the same pending intent back when calling\n        // addGeofences() and removeGeofences().\n        mGeofencePendingIntent = PendingIntent.getBroadcast(this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);\n        return mGeofencePendingIntent;\n    }\n"
  },
  {
    "id": "hazelcast_hazelcast-202-Associations-FirstSentence",
    "old_comment_raw": "The  ClientProtocolBuffer that encapsulates the internal buffer.",
    "new_comment_raw": "The  MutableDirectBuffer that encapsulates the internal buffer.",
    "old_code_raw": "    public ClientProtocolBuffer buffer() {\n        return protocolBuffer;\n    }\n",
    "new_code_raw": "    public MutableDirectBuffer buffer() {\n        return mutableDirectBuffer;\n    }\n\n"
  },
  {
    "id": "RobotiumTech_robotium-1387-FirstSentence-0",
    "old_comment_raw": "Returns an EditText which shows a given text.",
    "new_comment_raw": "Returns an EditText which shows a given text.",
    "old_code_raw": "\tpublic EditText getEditText(String text)\n\t{\n\t\treturn viewFetcher.getView(EditText.class, text, false);\n\t}\n",
    "new_code_raw": "\tpublic EditText getEditText(String text)\n\t{\n\t\treturn getter.getView(EditText.class, text, false);\n\t}\n"
  },
  {
    "id": "eclipse_emf.refactor.refactoring-2-Associations-FirstSentence",
    "old_comment_raw": "Gets the EmfRefactoring supported by the controller.",
    "new_comment_raw": "Gets the Refactoring supported by the controller.",
    "old_code_raw": "\t@Override\n\tpublic EmfRefactoring getParent() {\n\t\treturn this.parent;\n\t}\n",
    "new_code_raw": "\t@Override\n\tpublic Refactoring getParent() {\n\t\treturn this.parent;\n\t}\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2380-FirstSentence-0",
    "old_comment_raw": "Returns a String representation of the result of this set of typed dependencies in a user-specified format.",
    "new_comment_raw": "Returns a String representation of the result of this set of typed dependencies in a user-specified format.",
    "old_code_raw": "  public String toString(String format) {\n    if (format != null && format.equals(\"xml\")) {\n      return toXMLString();\n    } else if (format != null && format.equals(\"readable\")) {\n      return toReadableString();\n    } else {\n      return toList();\n    }\n  }\n",
    "new_code_raw": "  public String toString(OutputFormat format) {\n    switch(format) {\n    case XML:\n      return toXMLString();\n    case READABLE:\n      return toReadableString();\n    case LIST:\n      return toList();\n    case RECURSIVE:\n      return toString();\n    default:\n      throw new IllegalArgumentException(\"Unsupported format \" + format);\n    }\n  }\n"
  },
  {
    "id": "apache_clerezza-18-Associations-FirstSentence",
    "old_comment_raw": "Parses a serialized Graph from an InputStream.",
    "new_comment_raw": "Parses a serialized ImmutableGraph from an InputStream.",
    "old_code_raw": "    public Graph parse(InputStream serializedGraph,\n            String formatIdentifier) throws UnsupportedFormatException {\n        return parse(serializedGraph, formatIdentifier, null);\n    }\n",
    "new_code_raw": "    public ImmutableGraph parse(InputStream serializedGraph,\n            String formatIdentifier) throws UnsupportedFormatException {\n        return parse(serializedGraph, formatIdentifier, null);\n    }\n\n"
  },
  {
    "id": "yanzhenjie_NoHttp-96-FirstSentence-0",
    "old_comment_raw": "Randomly generated boundary mark",
    "new_comment_raw": "Randomly generated boundary mark",
    "old_code_raw": "\tpublic boolean needCache() {\n\t\treturn !TextUtils.isEmpty(getCacheKey());\n\t}\n",
    "new_code_raw": "\tpublic boolean needCache() {\n\t\treturn RequestMethod.GET == getRequestMethod();\n\t}\n"
  },
  {
    "id": "JodaOrg_joda_time-453-FirstSentence-0",
    "old_comment_raw": "Removes a converter from the set of converters, by index.",
    "new_comment_raw": "Removes a converter from the set of converters.",
    "old_code_raw": "    public IntervalConverter removeIntervalConverter(int index) throws SecurityException {\n        checkAlterIntervalConverters();\n        IntervalConverter[] removed = new IntervalConverter[1];\n        iIntervalConverters = iIntervalConverters.remove(index, removed);\n        return removed[0];\n    }\n",
    "new_code_raw": "    public IntervalConverter removeIntervalConverter(IntervalConverter converter)\n            throws SecurityException {\n        \n        checkAlterIntervalConverters();\n        if (converter == null) {\n            return null;\n        }\n        IntervalConverter[] removed = new IntervalConverter[1];\n        iIntervalConverters = iIntervalConverters.remove(converter, removed);\n        return removed[0];\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2001-FirstSentence-0",
    "old_comment_raw": "Get read timeout (in milliseconds).",
    "new_comment_raw": "Get read timeout (in milliseconds).",
    "old_code_raw": "    public int getReadTimeout() {\n        return httpClient.getReadTimeout();\n    }\n",
    "new_code_raw": "    public int getReadTimeout() {\n        return httpClient.readTimeoutMillis();\n    }\n"
  },
  {
    "id": "ushahidi_Crowdmap-Java-11-Associations-FirstSentence",
    "old_comment_raw": "Get list of maps.",
    "new_comment_raw": "Get list of maps as anonymous user",
    "old_code_raw": "    public Maps getMaps() {\n        //Crowdmap requires a new api signature every 2 minutes\n        // so before a request is made, generate a new key\n        //generate the api key\n        setApiKey(METHOD_GET, SEGMENT_MAPS);\n        String response = client.get(SEGMENT_MAPS);\n        Maps mapsJson = fromString(response, Maps.class);\n        return mapsJson;\n    }\n",
    "new_code_raw": "    public Maps getMaps() {\n        //Crowdmap requires a new api signature every 2 minutes\n        // so before a request is made, generate a new key\n        setApiKey(METHOD_GET, SEGMENT_MAPS);\n        return fromString(client.get(SEGMENT_MAPS), Maps.class);\n    }\n\n"
  },
  {
    "id": "RobotiumTech_robotium-1312-FirstSentence-0",
    "old_comment_raw": "Returns a  List of the  Views located in the current  Activity.",
    "new_comment_raw": "Returns a  List of the  Views located in the current  Activity.",
    "old_code_raw": "\tpublic ArrayList<View> getViews() {\n\t\treturn ensureArrayListOrNull(viewFetcher.getViews());\n\t}\n",
    "new_code_raw": "\tpublic ArrayList<View> getViews() {\n\t\ttry {\n\t\t\treturn ensureArrayListOrNull(viewFetcher.getViews());\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n"
  },
  {
    "id": "hazelcast_hazelcast-121-Associations-FirstSentence",
    "old_comment_raw": "Gets the  CacheEvictionConfig instance for eviction configuration of the cache config.",
    "new_comment_raw": "Gets the  EvictionConfig instance for eviction configuration of the cache config.",
    "old_code_raw": "    public CacheEvictionConfig getEvictionConfig() {\n        return evictionConfig;\n    }\n",
    "new_code_raw": "    public EvictionConfig getEvictionConfig() {\n        return evictionConfig;\n    }\n\n"
  },
  {
    "id": "debezium_debezium-757-FirstSentence-0",
    "old_comment_raw": "Remove the definition of the identified table.",
    "new_comment_raw": "Remove the definition of the identified table.",
    "old_code_raw": "    public Table removeTable(TableId tableId) {\n        return lock.write(() -> tablesByTableId.remove(tableId));\n    }\n",
    "new_code_raw": "    public Table removeTable(TableId tableId) {\n        return lock.write(() -> {\n            changes.add(tableId);\n            return tablesByTableId.remove(tableId);\n        });\n    }\n"
  },
  {
    "id": "RSB4760_apq8016_external_droiddriver-1-Associations-FirstSentence",
    "old_comment_raw": "Evaluates given @matchers in short-circuit fashion in the order they are passed.",
    "new_comment_raw": "Evaluates given @finders in short-circuit fashion in the order they are passed.",
    "old_code_raw": "  public static ElementMatcher allOf(final ElementMatcher... matchers) {\n    return new ElementMatcher() {\n      @Override\n      public boolean matches(UiElement element) {\n        for (ElementMatcher matcher : matchers) {\n          if (!matcher.matches(element)) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      @Override\n      public String toString() {\n        return \"allOf(\" + Joiner.on(\",\").join(matchers) + \")\";\n      }\n    };\n  }\n",
    "new_code_raw": "  public static MatchFinder allOf(final MatchFinder... finders) {\n    return new MatchFinder() {\n      @Override\n      public boolean matches(UiElement element) {\n        for (MatchFinder finder : finders) {\n          if (!finder.matches(element)) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      @Override\n      public String toString() {\n        return \"allOf(\" + Joiner.on(\",\").join(finders) + \")\";\n      }\n    };\n  }\n\n"
  },
  {
    "id": "SeleniumHQ_selenium-706-FirstSentence-0",
    "old_comment_raw": "Sets which port the driver server should be started on.",
    "new_comment_raw": "Sets which port the driver server should be started on.",
    "old_code_raw": "    public Builder<DS> usingPort(int port) {\n      checkArgument(port >= 0, \"Invalid port number: %d\", port);\n      this.port = port;\n      return this;\n    }\n",
    "new_code_raw": "    public B usingPort(int port) {\n      checkArgument(port >= 0, \"Invalid port number: %d\", port);\n      this.port = port;\n      return (B) this;\n    }\n"
  },
  {
    "id": "ncdc_Qpid-1-81-Associations-FirstSentence",
    "old_comment_raw": "Retrive the ObjectName for the given Exchange on the test Virtualhost.",
    "new_comment_raw": "Retrive the ObjectName for the given Queue on a Virtualhost.",
    "old_code_raw": "    public ObjectName getQueueObjectName(String virtualHostName, String queue)\n    {\n        // Get the name of the test manager\n        AllObjects allObject = new AllObjects(_mbsc);\n        allObject.querystring = \"org.apache.qpid:type=VirtualHost.Queue,VirtualHost=\" + virtualHostName + \",name=\" + queue + \",*\";\n\n        Set<ObjectName> objectNames = allObject.returnObjects();\n\n        _test.assertNotNull(\"Null ObjectName Set returned\", objectNames);\n        _test.assertEquals(\"Incorrect number of queues with name '\" + allObject.querystring +\n                           \"' returned\", 1, objectNames.size());\n\n        // We have verified we have only one value in objectNames so return it\n        return objectNames.iterator().next();\n    }\n",
    "new_code_raw": "    @SuppressWarnings(\"static-access\")\n    public ObjectName getQueueObjectName(String virtualHostName, String queue)\n    {\n        // Get the name of the test manager\n        AllObjects allObject = new AllObjects(_mbsc);\n        allObject.querystring = \"org.apache.qpid:type=VirtualHost.Queue,VirtualHost=\" + virtualHostName + \",name=\" + queue + \",*\";\n\n        Set<ObjectName> objectNames = allObject.returnObjects();\n\n        _test.assertNotNull(\"Null ObjectName Set returned\", objectNames);\n        _test.assertEquals(\"Incorrect number of queues with name '\" + allObject.querystring +\n                           \"' returned\", 1, objectNames.size());\n\n        // We have verified we have only one value in objectNames so return it\n        ObjectName objectName = objectNames.iterator().next();\n\t\t_test.getLogger().info(\"Loading: \" + objectName);\n        return objectName;\n    }\n\n"
  },
  {
    "id": "apache_calcite-583-FirstSentence-0",
    "old_comment_raw": "Converts a call to an operator into a  RexCall to the same operator.",
    "new_comment_raw": "Converts a call to an operator into a  RexCall to the same operator.",
    "old_code_raw": "    private void ensureSameType(SqlRexContext cx, RexNode[] exprs) {\n        // TODO: make leastRestrictive take a list\n        List<RelDataType> types = new ArrayList<RelDataType>();\n        for (RexNode expr : exprs) {\n            types.add(expr.getType());\n        }\n        RelDataType type =\n            cx.getTypeFactory().leastRestrictive(\n                types.toArray(new RelDataType[types.size()]));\n        for (int i = 0; i < exprs.length; i++) {\n            exprs[i] = cx.getRexBuilder().ensureType(type, exprs[i], false);\n        }\n    }\n",
    "new_code_raw": "    private void ensureSameType(SqlRexContext cx, final RexNode[] exprs) {\n        RelDataType type =\n            cx.getTypeFactory().leastRestrictive(\n                new AbstractList<RelDataType>() {\n                    public RelDataType get(int index) {\n                        return exprs[index].getType();\n                    }\n                    public int size() {\n                        return exprs.length;\n                    }\n                });\n        for (int i = 0; i < exprs.length; i++) {\n            exprs[i] = cx.getRexBuilder().ensureType(type, exprs[i], false);\n        }\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2572-FirstSentence-0",
    "old_comment_raw": "Convert map of Swagger SecuritySchemeDefinition objects to a list of Codegen Security objects",
    "new_comment_raw": "Convert map of OAS SecurityScheme objects to a list of Codegen Security objects",
    "old_code_raw": "    public List<CodegenSecurity> fromSecurity(Map<String, SecuritySchemeDefinition> schemes) {\n        if (schemes == null) {\n            return Collections.emptyList();\n        }\n\n        List<CodegenSecurity> secs = new ArrayList<CodegenSecurity>(schemes.size());\n        for (Iterator<Map.Entry<String, SecuritySchemeDefinition>> it = schemes.entrySet().iterator(); it.hasNext(); ) {\n            final Map.Entry<String, SecuritySchemeDefinition> entry = it.next();\n            final SecuritySchemeDefinition schemeDefinition = entry.getValue();\n\n            CodegenSecurity sec = CodegenModelFactory.newInstance(CodegenModelType.SECURITY);\n            sec.name = entry.getKey();\n            sec.type = schemeDefinition.getType();\n            sec.isCode = sec.isPassword = sec.isApplication = sec.isImplicit = false;\n            sec.vendorExtensions = schemeDefinition.getVendorExtensions();\n\n            if (schemeDefinition instanceof ApiKeyAuthDefinition) {\n                final ApiKeyAuthDefinition apiKeyDefinition = (ApiKeyAuthDefinition) schemeDefinition;\n                sec.isBasic = sec.isOAuth = false;\n                sec.isApiKey = true;\n                sec.keyParamName = apiKeyDefinition.getName();\n                sec.isKeyInHeader = apiKeyDefinition.getIn() == In.HEADER;\n                sec.isKeyInQuery = !sec.isKeyInHeader;\n            } else if(schemeDefinition instanceof BasicAuthDefinition) {\n                sec.isKeyInHeader = sec.isKeyInQuery = sec.isApiKey = sec.isOAuth = false;\n                sec.isBasic = true;\n            } else {\n                final OAuth2Definition oauth2Definition = (OAuth2Definition) schemeDefinition;\n                sec.isKeyInHeader = sec.isKeyInQuery = sec.isApiKey = sec.isBasic = false;\n                sec.isOAuth = true;\n                sec.flow = oauth2Definition.getFlow();\n                if (sec.flow == null) {\n                    throw new RuntimeException(\"missing oauth flow in \" + sec.name);\n                }\n                switch(sec.flow) {\n                    case \"accessCode\":\n                        sec.isCode = true;\n                        break;\n                    case \"password\":\n                        sec.isPassword = true;\n                        break;\n                    case \"application\":\n                        sec.isApplication = true;\n                        break;\n                    case \"implicit\":\n                        sec.isImplicit = true;\n                        break;\n                    default:\n                        throw new RuntimeException(\"unknown oauth flow: \" + sec.flow);\n                }\n                sec.authorizationUrl = oauth2Definition.getAuthorizationUrl();\n                sec.tokenUrl = oauth2Definition.getTokenUrl();\n                if (oauth2Definition.getScopes() != null) {\n                    List<Map<String, Object>> scopes = new ArrayList<Map<String, Object>>();\n                    int count = 0, numScopes = oauth2Definition.getScopes().size();\n                    for(Map.Entry<String, String> scopeEntry : oauth2Definition.getScopes().entrySet()) {\n                        Map<String, Object> scope = new HashMap<String, Object>();\n                        scope.put(\"scope\", scopeEntry.getKey());\n                        scope.put(\"description\", escapeText(scopeEntry.getValue()));\n\n                        count += 1;\n                        if (count < numScopes) {\n                            scope.put(\"hasMore\", \"true\");\n                        } else {\n                            scope.put(\"hasMore\", null);\n                        }\n\n                        scopes.add(scope);\n                    }\n                    sec.scopes = scopes;\n                }\n            }\n\n            secs.add(sec);\n        }\n\n        // sort auth methods to maintain the same order\n        Collections.sort(secs, new Comparator<CodegenSecurity>() {\n            @Override\n            public int compare(CodegenSecurity one, CodegenSecurity another) {\n                return ObjectUtils.compare(one.name, another.name);\n            }\n        });\n        // set 'hasMore'\n        Iterator<CodegenSecurity> it = secs.iterator();\n        while (it.hasNext()) {\n            final CodegenSecurity security = it.next();\n            security.hasMore = it.hasNext();\n        }\n\n        return secs;\n    }\n",
    "new_code_raw": "    public List<CodegenSecurity> fromSecurity(Map<String, SecurityScheme> securitySchemeMap) {\n        if (securitySchemeMap == null) {\n            return Collections.emptyList();\n        }\n\n        List<CodegenSecurity> codegenSecurities = new ArrayList<CodegenSecurity>(securitySchemeMap.size());\n        for (String key : securitySchemeMap.keySet()) {\n            final SecurityScheme securityScheme = securitySchemeMap.get(key);\n\n            CodegenSecurity cs = CodegenModelFactory.newInstance(CodegenModelType.SECURITY);\n            cs.name = key;\n            cs.type = securityScheme.getType().toString();\n            cs.isCode = cs.isPassword = cs.isApplication = cs.isImplicit = false;\n\n            if (SecurityScheme.Type.APIKEY.equals(securityScheme.getType())) {\n                cs.isBasic = cs.isOAuth = false;\n                cs.isApiKey = true;\n                cs.keyParamName = securityScheme.getName();\n                cs.isKeyInHeader = securityScheme.getIn() == SecurityScheme.In.HEADER;\n                cs.isKeyInQuery = !cs.isKeyInHeader;\n            } else if (SecurityScheme.Type.HTTP.equals(securityScheme.getType())) {\n                cs.isKeyInHeader = cs.isKeyInQuery = cs.isApiKey = cs.isOAuth = false;\n                cs.isBasic = true;\n            } else if (SecurityScheme.Type.OAUTH2.equals(securityScheme.getType())) {\n                cs.isKeyInHeader = cs.isKeyInQuery = cs.isApiKey = cs.isBasic = false;\n                cs.isOAuth = true;\n                final OAuthFlows flows = securityScheme.getFlows();\n                if (securityScheme.getFlows() == null) {\n                    throw new RuntimeException(\"missing oauth flow in \" + cs.name);\n                }\n                if (flows.getPassword() != null) {\n                    setOauth2Info(cs, flows.getPassword());\n                    cs.isPassword = true;\n                    cs.flow = \"password\";\n                } else if (flows.getImplicit() != null) {\n                    setOauth2Info(cs, flows.getImplicit());\n                    cs.isImplicit = true;\n                    cs.flow = \"implicit\";\n                } else if (flows.getClientCredentials() != null) {\n                    setOauth2Info(cs, flows.getClientCredentials());\n                    cs.isApplication = true;\n                    cs.flow = \"application\";\n                } else if (flows.getAuthorizationCode() != null) {\n                    setOauth2Info(cs, flows.getAuthorizationCode());\n                    cs.isCode = true;\n                    cs.flow = \"accessCode\";\n                } else {\n                    throw new RuntimeException(\"Could not identify any oauth2 flow in \" + cs.name);\n                }\n            }\n\n            codegenSecurities.add(cs);\n        }\n\n        // sort auth methods to maintain the same order\n        Collections.sort(codegenSecurities, new Comparator<CodegenSecurity>() {\n            @Override\n            public int compare(CodegenSecurity one, CodegenSecurity another) {\n                return ObjectUtils.compare(one.name, another.name);\n            }\n        });\n        // set 'hasMore'\n        Iterator<CodegenSecurity> it = codegenSecurities.iterator();\n        while (it.hasNext()) {\n            final CodegenSecurity security = it.next();\n            security.hasMore = it.hasNext();\n        }\n\n        return codegenSecurities;\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-1274-FirstSentence-0",
    "old_comment_raw": "Returns a  List of the  EditTexts contained in the current  Activity.",
    "new_comment_raw": "Returns a  List of the  EditTexts contained in the current  Activity.",
    "old_code_raw": "\tpublic ArrayList<EditText> getCurrentEditTexts() {\n\t\tArrayList<EditText>editTextList = new ArrayList<EditText>();\n\t\tArrayList<View> viewList = getViews();\n\t\tfor(View view : viewList){\n\t\t\tif (view instanceof android.widget.EditText)\n\t\t\t\teditTextList.add((EditText) view);\n\t\t}\n\t\treturn editTextList;\t\n\t}\n",
    "new_code_raw": "\tpublic ArrayList<EditText> getCurrentEditTexts() {\n\t\treturn getCurrentViews(EditText.class);\n\t}\n"
  },
  {
    "id": "eclipse_rt.equinox.bundles-61-Associations-FirstSentence",
    "old_comment_raw": "Obtains a ISTextExpert instance for processing structured text with the specified type handler.",
    "new_comment_raw": "Obtains a IStructuredTextExpert instance for processing structured text with the specified type handler.",
    "old_code_raw": "\tstatic public ISTextExpert getStatefulExpert(String type) {\n\t\treturn getStatefulExpert(type, STextEnvironment.DEFAULT);\n\t}\n",
    "new_code_raw": "\tstatic public IStructuredTextExpert getStatefulExpert(String type) {\n\t\treturn getStatefulExpert(type, StructuredTextEnvironment.DEFAULT);\n\t}\n\n"
  },
  {
    "id": "graphql_java_graphql_java-232-FirstSentence-0",
    "old_comment_raw": "This allows you to build a schema from an existing schema.",
    "new_comment_raw": "This allows you to build a schema from an existing schema.",
    "old_code_raw": "    public static Builder newSchema(GraphQLSchema existingSchema) {\n        return new Builder()\n                .query(existingSchema.getQueryType())\n                .mutation(existingSchema.getMutationType())\n                .subscription(existingSchema.getSubscriptionType())\n                .fieldVisibility(existingSchema.getFieldVisibility())\n                .clearAdditionalTypes()\n                .clearDirectives()\n                .additionalDirectives(existingSchema.directives)\n                .additionalTypes(existingSchema.additionalTypes);\n    }\n",
    "new_code_raw": "    public static Builder newSchema(GraphQLSchema existingSchema) {\n        return new Builder()\n                .query(existingSchema.getQueryType())\n                .mutation(existingSchema.getMutationType())\n                .subscription(existingSchema.getSubscriptionType())\n                .codeRegistry(existingSchema.getCodeRegistry())\n                .clearAdditionalTypes()\n                .clearDirectives()\n                .additionalDirectives(existingSchema.directives)\n                .additionalTypes(existingSchema.additionalTypes);\n    }\n"
  },
  {
    "id": "codehaus_cake-8-Associations-FirstSentence",
    "old_comment_raw": "Analogous to  #get(WithAttributes) except returning a primitive float.",
    "new_comment_raw": "Extracts the attribute map from the specified  WithAttributes and returns the value of this attribute from the map.",
    "old_code_raw": "    public float get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n",
    "new_code_raw": "    public float get(WithAttributes withAttributes) {\r\n        return withAttributes.getAttributes().get(this);\r\n    }\r\n\n"
  },
  {
    "id": "debezium_debezium-970-FirstSentence-0",
    "old_comment_raw": "Builds the filter selector that returns the field filter for a given collection identifier, using the comma-separated list of fully-qualified field names (for details, see  MongoDbConnectorConfig#FIELD_BLACKLIST) defining which fields (if any) should be excluded, and using the comma-separated list of fully-qualified field replacements (for details, see  MongoDbConnectorConfig#FIELD_RENAMES) defining which fields (if any) should be renamed.",
    "new_comment_raw": "Builds the filter selector that returns the field filter for a given collection identifier, using the comma-separated list of fully-qualified field names (for details, see  MongoDbConnectorConfig#FIELD_BLACKLIST) defining which fields (if any) should be excluded, and using the comma-separated list of fully-qualified field replacements (for details, see  MongoDbConnectorConfig#FIELD_RENAMES) defining which fields (if any) should be renamed.",
    "old_code_raw": "        public FieldSelector build() {\n            List<Path> result = new ArrayList<>();\n            parse(fullyQualifiedFieldNames, name -> {\n                String[] fieldNodes = parseIntoParts(name, name, length -> length < 3, \"\\\\.\");\n                return new RemovePath(fieldNodes);\n            }, result);\n            parse(fullyQualifiedFieldReplacements, name -> {\n                String[] renameMapping = parseIntoParts(name, name, length -> length != 2, \"=\");\n                String[] fieldNodes = parseIntoParts(name, renameMapping[0], length -> length < 3, \"\\\\.\");\n                return new RenamePath(fieldNodes, renameMapping[1]);\n            }, result);\n            return new FieldSelector(result);\n        }\n",
    "new_code_raw": "        public FieldSelector build() {\n            List<Path> result = new ArrayList<>();\n            parse(fullyQualifiedFieldNames, name -> {\n                String[] nameNodes = parseIntoParts(name, name, length -> length < 3, DOT);\n                return new RemovePath(selectNamespacePartAsPattern(nameNodes), selectFieldPartAsNodes(nameNodes));\n            }, result);\n            parse(fullyQualifiedFieldReplacements, name -> {\n                String[] replacement = parseIntoParts(name, name, length -> length != 2, COLON);\n                String[] nameNodes = parseIntoParts(name, replacement[0], length -> length < 3, DOT);\n                return new RenamePath(selectNamespacePartAsPattern(nameNodes), selectFieldPartAsNodes(nameNodes), replacement[1]);\n            }, result);\n            return new FieldSelector(result);\n        }\n"
  },
  {
    "id": "JetBrains_adt-tools-base-398-Associations-FirstSentence",
    "old_comment_raw": "Given an input stream, reads the stream until the end and returns a  ResourceFile representing the contents of the stream.",
    "new_comment_raw": "Given an input stream, reads the stream until the end and returns a  BinaryResourceFile representing the contents of the stream.",
    "old_code_raw": "  public static ResourceFile fromInputStream(InputStream is) throws IOException {\n    byte[] buf = ByteStreams.toByteArray(is);\n    return new ResourceFile(buf);\n  }\n",
    "new_code_raw": "  public static BinaryResourceFile fromInputStream(InputStream is) throws IOException {\n    byte[] buf = ByteStreams.toByteArray(is);\n    return new BinaryResourceFile(buf);\n  }\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2040-FirstSentence-0",
    "old_comment_raw": "Transforms t if it contains an UCP, it will change the UCP tag into the phrasal tag of the first word of the UCP (UCP (JJ electronic) (, ,) (NN computer) (CC and) (NN building)) will become (ADJP (JJ electronic) (, ,) (NN computer) (CC and) (NN building))",
    "new_comment_raw": "Transforms t if it contains an UCP, it will change the UCP tag into the phrasal tag of the first word of the UCP (UCP (JJ electronic) (, ,) (NN computer) (CC and) (NN building)) will become (ADJP (JJ electronic) (, ,) (NN computer) (CC and) (NN building))",
    "old_code_raw": "  public static Tree UCPtransform(Tree t) {\n    if (t == null) {\n      return null;\n    }\n    return Tsurgeon.processPattern(ucpRenameTregex, ucpRenameTsurgeon, t);\n  }\n",
    "new_code_raw": "  public static Tree UCPtransform(Tree t) {\n    if (t == null) {\n      return null;\n    }\n    Tree firstChild = t.firstChild();\n    if (firstChild != null) {\n      List<Pair<TregexPattern,TsurgeonPattern>> ops = Generics.newArrayList();\n\n      for (int i = 0; i < operations.length; i++) {\n        for (TregexPattern pattern : matchPatterns[i]) {\n          ops.add(Generics.newPair(pattern, operations[i]));\n        }\n      }\n\n      return Tsurgeon.processPatternsOnTree(ops, t);\n    } else {\n      return t;\n    }\n  }\n"
  },
  {
    "id": "codehaus_dna-1-Associations-FirstSentence",
    "old_comment_raw": "Retrieve an array of Classes for all the services that a Component offers.",
    "new_comment_raw": "Retrieve an array of Classes for all the value that a Component offers.",
    "old_code_raw": "    Class[] getServiceClasses( final Class type, final List issues )\n    {\n        final List services = new ArrayList();\n        final ClassLoader classLoader = type.getClassLoader();\n        final Attribute[] attributes =\n            Attributes.getAttributes( type, \"dna.service\" );\n        for( int i = 0; i < attributes.length; i++ )\n        {\n            final String classname = attributes[ i ].getParameter( \"type\" );\n            try\n            {\n                final Class clazz = classLoader.loadClass( classname );\n                services.add( clazz );\n            }\n            catch( final Throwable t )\n            {\n                final Object[] args = new Object[]{classname, t};\n                final String message = getMessage( \"CV014\", args );\n                final VerifyIssue issue =\n                    new VerifyIssue( VerifyIssue.ERROR, message );\n                issues.add( issue );\n            }\n        }\n\n        return (Class[])services.toArray( new Class[ services.size() ] );\n    }\n",
    "new_code_raw": "    Class[] getServiceClasses( final Class type, final List issues )\n    {\n        final ServiceDescriptorSet set =\n            (ServiceDescriptorSet)type.getAnnotation( ServiceDescriptorSet.class );\n        if( null != set )\n        {\n            final ServiceDescriptor[] descriptors = set.value();\n            final Class[] services = new Class[descriptors.length];\n            for( int i = 0; i < descriptors.length; i++ )\n            {\n                ServiceDescriptor descriptor = descriptors[i];\n                services[i] = descriptor.type();\n            }\n            return services;\n        }\n        else\n        {\n            return new Class[0];\n        }\n    }\n\n"
  },
  {
    "id": "zaproxy_zaproxy-2036-FirstSentence-0",
    "old_comment_raw": "Gets the extensions' state (as saved in the configuration file).",
    "new_comment_raw": "Gets the extensions' state (as saved in the configuration file).",
    "old_code_raw": "    List<ExtensionState> getExtensions() {\n        return Collections.unmodifiableList(extensions);\n    }\n",
    "new_code_raw": "    List<ExtensionState> getExtensions() {\n        return extensions;\n    }\n"
  },
  {
    "id": "justinedelson_felix-9-Associations-FirstSentence",
    "old_comment_raw": "Returns the property descriptors",
    "new_comment_raw": "Returns the properties.",
    "old_code_raw": "    public Properties getProperties() {\r\n        return m_properties;\r\n    }\r\n",
    "new_code_raw": "    public Dictionary getProperties() {\r\n        return m_properties;\r\n    }\r\n\n"
  },
  {
    "id": "katzer_cordova_plugin_background_mode-17-FirstSentence-0",
    "old_comment_raw": "Retrieves the resource ID of the app icon.",
    "new_comment_raw": "Retrieves the resource ID of the app icon.",
    "old_code_raw": "    private int getIconResId() {\n        JSONObject settings = BackgroundMode.getSettings();\n        Context context = getApplicationContext();\n        Resources res   = context.getResources();\n        String pkgName  = context.getPackageName();\n        String icon     = settings.optString(\"icon\", \"icon\");\n\n        return res.getIdentifier(icon, \"drawable\", pkgName);\n    }\n",
    "new_code_raw": "    private int getIconResId() {\n        JSONObject settings = BackgroundMode.getSettings();\n        Context context = getApplicationContext();\n        Resources res   = context.getResources();\n        String pkgName  = context.getPackageName();\n        String icon     = settings.optString(\"icon\", \"icon\");\n\n        int resId = res.getIdentifier(icon, \"drawable\", pkgName);\n\n        if (resId == 0) {\n            resId = res.getIdentifier(\"icon\", \"drawable\", pkgName);\n        }\n\n        return resId;\n    }\n"
  },
  {
    "id": "apache_lenya-280-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Returns the authoring path",
    "old_code_raw": "    public String getAuthoringPath() {\n        return authoringPath;\n    }\n",
    "new_code_raw": "    public String getAuthoringPath() {\n        return this.authoringPath;\n    }\n\n"
  },
  {
    "id": "debezium_debezium-996-FirstSentence-0",
    "old_comment_raw": "Converts a value object for an expected type of  java.time.Duration to  Long values that represents the time in microseconds.",
    "new_comment_raw": "Converts a value object for an expected type of  java.time.Duration to  Long values that represents the time in microseconds.",
    "old_code_raw": "    protected Object convertDurationToMicroseconds(Column column, Field fieldDefn, Object data) {\n        if (data == null && !fieldDefn.schema().isOptional()) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0L;\n        }\n        try {\n            if (data instanceof Duration) return ((Duration) data).toNanos() / 1_000;\n        } catch (IllegalArgumentException e) {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n",
    "new_code_raw": "    protected Object convertDurationToMicroseconds(Column column, Field fieldDefn, Object data) {\n        return convertValue(column, fieldDefn, data, 0L, (r) -> {\n            try {\n                if (data instanceof Duration) {\n                    r.deliver(((Duration)data).toNanos() / 1_000);\n                }\n            } catch (IllegalArgumentException e) {\n            }\n        });\n    }\n"
  },
  {
    "id": "SeleniumHQ_selenium-1040-FirstSentence-0",
    "old_comment_raw": "Extracts platforms based on system properties in Java and a heuristic to determine the most likely operating system.",
    "new_comment_raw": "Extracts platforms based on system properties in Java and uses a heuristic to determine the most likely operating system.",
    "old_code_raw": "  public static Platform extractFromSysProperty(String osName) {\n    osName = osName.toLowerCase();\n    // os.name for android is linux\n    if (\"dalvik\".equalsIgnoreCase(System.getProperty(\"java.vm.name\"))) {\n      return Platform.ANDROID;\n    }\n    Platform mostLikely = UNIX;\n    String previousMatch = null;\n    for (Platform os : Platform.values()) {\n      for (String matcher : os.partOfOsName) {\n        if (\"\".equals(matcher)) {\n          continue;\n        }\n        matcher = matcher.toLowerCase();\n        if (os.isExactMatch(osName, matcher)) {\n          return os;\n        }\n        if (os.isCurrentPlatform(osName, matcher) && isBetterMatch(previousMatch, matcher)) {\n          previousMatch = matcher;\n          mostLikely = os;\n        }\n      }\n    }\n\n    // Default to assuming we're on a UNIX variant (including LINUX)\n    return mostLikely;\n  }\n",
    "new_code_raw": "  public static Platform extractFromSysProperty(String osName, String osVersion) {\n    osName = osName.toLowerCase();\n    // os.name for android is linux\n    if (\"dalvik\".equalsIgnoreCase(System.getProperty(\"java.vm.name\"))) {\n      return Platform.ANDROID;\n    }\n    // Windows 8 can't be detected by osName alone\n    if (osVersion.equals(\"6.2\") && osName.startsWith(\"windows nt\")) {\n        return WIN8;\n    }\n    Platform mostLikely = UNIX;\n    String previousMatch = null;\n    for (Platform os : Platform.values()) {\n      for (String matcher : os.partOfOsName) {\n        if (\"\".equals(matcher)) {\n          continue;\n        }\n        matcher = matcher.toLowerCase();\n        if (os.isExactMatch(osName, matcher)) {\n          return os;\n        }\n        if (os.isCurrentPlatform(osName, matcher) && isBetterMatch(previousMatch, matcher)) {\n          previousMatch = matcher;\n          mostLikely = os;\n        }\n      }\n    }\n\n    // Default to assuming we're on a UNIX variant (including LINUX)\n    return mostLikely;\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1885-FirstSentence-0",
    "old_comment_raw": "Place an order for a pet",
    "new_comment_raw": "Place an order for a pet",
    "old_code_raw": "  public Order placeOrder(Order body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling placeOrder\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/store/order\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/xml\", \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Order> localVarReturnType = new GenericType<Order>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public Order placeOrder(Order body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling placeOrder\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/store/order\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/xml\", \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Order> localVarReturnType = new GenericType<Order>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "biddyweb_android-rcs-ims-stack-147-Associations-FirstSentence",
    "old_comment_raw": "Build sdp proposal for addVideo",
    "new_comment_raw": "Build SDP proposal to add video stream in the session",
    "old_code_raw": "\tprivate String buildAddVideoSdpProposal() {\n\t\tif (logger.isActivated()) {\n\t\t\tlogger.info(\"buildAddVideoSdpProposal()\");\n\t\t}\n\n\t\tString sdp = \"\";\n\t\ttry {\n\t\t\tif ((getVideoPlayer() == null)\n\t\t\t\t\t|| (getVideoPlayer().getMediaCodec() == null)) {\n\t\t\t\thandleError(new IPCallError(IPCallError.UNSUPPORTED_VIDEO_TYPE,\n\t\t\t\t\t\t\"Video codec not selected\"));\n\t\t\t} \n\t\t\telse if ((getVideoRenderer() == null)\n\t\t\t\t\t|| (getVideoRenderer().getMediaCodec() == null)) {\n\t\t\t\thandleError(new IPCallError(IPCallError.UNSUPPORTED_VIDEO_TYPE,\n\t\t\t\t\t\t\"Video codec not selected\"));\n\t\t\t} \n\t\t\telse {\n\t\t\t\t// Build SDP part\n\t\t\t\tString ntpTime = SipUtils.constructNTPtime(System\n\t\t\t\t\t\t.currentTimeMillis());\n\t\t\t\tString ipAddress = getDialogPath().getSipStack()\n\t\t\t\t\t\t.getLocalIpAddress();\n\t\t\t\n\t\t\t\tlogger.warn(\"Build audio sdp\");\n\t\t\t\tgetAudioPlayer().getLocalRtpPort();\n\t\t\t\tString audioSdp = AudioSdpBuilder.buildSdp(getAudioPlayer().getSupportedAudioCodecs(), getAudioPlayer().getLocalRtpPort());\n\t\t\t\t\n\t\t\t\tlogger.warn(\"Build video sdp\");\n\t\t\t\tString videoSdp;\n\t\t\t\tvideoSdp = VideoSdpBuilder.buildSdpWithOrientationExtension(\n\t\t\t\t\t\tgetVideoPlayer().getSupportedMediaCodecs(),\n\t\t\t\t\t\tgetVideoPlayer().getLocalRtpPort());\n\t\t\t\t\n\t\t\t\tsdp = \"v=0\" + SipUtils.CRLF + \"o=- \" + ntpTime + \" \" + ntpTime\n\t\t\t\t\t\t+ \" \" + SdpUtils.formatAddressType(ipAddress)\n\t\t\t\t\t\t+ SipUtils.CRLF + \"s=-\" + SipUtils.CRLF + \"c=\"\n\t\t\t\t\t\t+ SdpUtils.formatAddressType(ipAddress) + SipUtils.CRLF\n\t\t\t\t\t\t+ \"t=0 0\" + SipUtils.CRLF + audioSdp + \"a=sendrcv\"\n\t\t\t\t\t\t+ SipUtils.CRLF + videoSdp + \"a=sendrcv\"\n\t\t\t\t\t\t+ SipUtils.CRLF;\n\n\t\t\t}\n\t\t} catch (RemoteException e) {\n\t\t\tif (logger.isActivated()) {\n\t\t\t\tlogger.error(\"Add Video has failed\", e);\n\t\t\t}\n\n\t\t\t// Unexpected error\n\t\t\thandleError(new IPCallError(IPCallError.UNEXPECTED_EXCEPTION,\n\t\t\t\t\te.getMessage()));\n\t\t}\n\n\t\treturn sdp;\n\t}\n",
    "new_code_raw": "\tprivate String buildAddVideoSdpProposal() {\n\t\tif (logger.isActivated()) {\n\t\t\tlogger.debug(\"Build SDP proposal to add video stream in the session\");\n\t\t}\n\n\t\ttry {\n\t\t\t// Build SDP part\n\t\t\tString ntpTime = SipUtils.constructNTPtime(System.currentTimeMillis());\n\t\t\tString ipAddress = getDialogPath().getSipStack().getLocalIpAddress();\n\t\t\n\t\t\tgetAudioPlayer().getLocalRtpPort();\n\t\t\tString audioSdp = AudioSdpBuilder.buildSdpOffer(getAudioPlayer().getSupportedAudioCodecs(), getAudioPlayer().getLocalRtpPort());\n\t\t\t\n\t\t\tString videoSdp;\n\t\t\tvideoSdp = VideoSdpBuilder.buildSdpOfferWithOrientation(\n\t\t\t\t\tgetVideoPlayer().getSupportedVideoCodecs(),\n\t\t\t\t\tgetVideoPlayer().getLocalRtpPort());\n\t\t\t\n\t\t\treturn \"v=0\" + SipUtils.CRLF +\n\t\t\t\t\t\"o=- \" + ntpTime + \" \" + ntpTime + \" \" + SdpUtils.formatAddressType(ipAddress) + SipUtils.CRLF +\n\t\t\t\t\t\"s=-\" + SipUtils.CRLF +\n\t\t\t\t\t\"c=\" + SdpUtils.formatAddressType(ipAddress) + SipUtils.CRLF +\n\t\t\t\t\t\"t=0 0\" + SipUtils.CRLF + audioSdp +\n\t\t\t\t\t\"a=sendrcv\"\t+ SipUtils.CRLF + videoSdp +\n\t\t\t\t\t\"a=sendrcv\"\t+ SipUtils.CRLF;\n\t\t} catch (RemoteException e) {\n\t\t\tif (logger.isActivated()) {\n\t\t\t\tlogger.error(\"Add video has failed\", e);\n\t\t\t}\n\n\t\t\t// Unexpected error\n\t\t\thandleError(new IPCallError(IPCallError.UNEXPECTED_EXCEPTION, e.getMessage()));\n\t\t\treturn null;\n\t\t}\n\t}\n\n"
  },
  {
    "id": "JodaOrg_joda_time-797-FirstSentence-0",
    "old_comment_raw": "Get the hours field type.",
    "new_comment_raw": "Get the hours field type.",
    "old_code_raw": "    public static DurationFieldType hours() {\n        return HOURS;\n    }\n",
    "new_code_raw": "    public static DurationFieldType hours() {\n        return HOURS_TYPE;\n    }\n"
  },
  {
    "id": "apache_activemq-1300-FirstSentence-0",
    "old_comment_raw": "Copies the messages matching the given selector up to the maximum number of matched messages",
    "new_comment_raw": "Copies the messages matching the given selector",
    "old_code_raw": "    public int copyMatchingMessagesTo(ConnectionContext context, String selector, ActiveMQDestination dest, int maximumMessages) throws Exception {\n        return copyMatchingMessages(context, createSelectorFilter(selector), dest, maximumMessages);\n    }\n",
    "new_code_raw": "    public int copyMatchingMessagesTo(ConnectionContext context, String selector, ActiveMQDestination dest)\n            throws Exception {\n        return copyMatchingMessagesTo(context, selector, dest, -1);\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-816-FirstSentence-0",
    "old_comment_raw": "Compares this ReadablePartial with another returning true if the chronology, field types and values are equal.",
    "new_comment_raw": "Compares this ReadablePartial with another returning true if the chronology, field types and values are equal.",
    "old_code_raw": "    public boolean equals(Object partial) {\n        if (partial instanceof ReadablePartial == false) {\n            return false;\n        }\n        ReadablePartial other = (ReadablePartial) partial;\n        if (size() != other.size()) {\n            return false;\n        }\n        for (int i = 0, isize = size(); i < isize; i++) {\n            if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {\n                return false;\n            }\n        }\n        return (getChronology() == other.getChronology());\n    }\n",
    "new_code_raw": "    public boolean equals(Object partial) {\n        if (this == partial) {\n            return true;\n        }\n        if (partial instanceof ReadablePartial == false) {\n            return false;\n        }\n        ReadablePartial other = (ReadablePartial) partial;\n        if (size() != other.size()) {\n            return false;\n        }\n        for (int i = 0, isize = size(); i < isize; i++) {\n            if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {\n                return false;\n            }\n        }\n        return (getChronology() == other.getChronology());\n    }\n"
  },
  {
    "id": "debezium_debezium-24-FirstSentence-0",
    "old_comment_raw": "Converts a MySQL  TIME value without fractional seconds to a  LocalTime.",
    "new_comment_raw": "Converts a MySQL  TIME value without fractional seconds to a  java.time.Duration.",
    "old_code_raw": "    protected static Serializable deserializeTime(ByteArrayInputStream inputStream) throws IOException {\n        // Times are stored as an integer as `HHMMSS`, so we need to split out the digits ...\n        int value = inputStream.readInteger(3);\n        int[] split = split(value, 100, 3);\n        int hours = split[2];\n        int minutes = split[1];\n        int seconds = split[0];\n        int nanoOfSecond = 0; // This version does not support fractional seconds\n        return LocalTime.of(hours, minutes, seconds, nanoOfSecond);\n    }\n",
    "new_code_raw": "    protected static Serializable deserializeTime(ByteArrayInputStream inputStream) throws IOException {\n        // Times are stored as an integer as `HHMMSS`, so we need to split out the digits ...\n        int value = inputStream.readInteger(3);\n        int[] split = split(value, 100, 3);\n        int hours = split[2];\n        int minutes = split[1];\n        int seconds = split[0];\n        return Duration.ofHours(hours).plusMinutes(minutes).plusSeconds(seconds);\n    }\n"
  },
  {
    "id": "apache_calcite-725-FirstSentence-0",
    "old_comment_raw": "Returns the  BuiltInMetadata.NonCumulativeCost#getNonCumulativeCost() statistic.",
    "new_comment_raw": "Returns the  BuiltInMetadata.NonCumulativeCost#getNonCumulativeCost() statistic.",
    "old_code_raw": "  public RelOptCost getNonCumulativeCost(RelNode rel) {\n    final BuiltInMetadata.NonCumulativeCost metadata =\n        rel.metadata(BuiltInMetadata.NonCumulativeCost.class, this);\n    return metadata.getNonCumulativeCost();\n  }\n",
    "new_code_raw": "  public RelOptCost getNonCumulativeCost(RelNode rel) {\n    for (;;) {\n      try {\n        return nonCumulativeCostHandler.getNonCumulativeCost(rel, this);\n      } catch (JaninoRelMetadataProvider.NoHandler e) {\n        nonCumulativeCostHandler = metadataProvider.revise(e.relClass,\n            BuiltInMetadata.NonCumulativeCost.DEF);\n      }\n    }\n  }\n"
  },
  {
    "id": "zjpjohn_idempiere-74-Associations-FirstSentence",
    "old_comment_raw": "get the sum Current Cost Price Level Low for this Cost Element Type",
    "new_comment_raw": "get the sum Current Cost Price Level Low for this Cost Element",
    "old_code_raw": "\tprivate BigDecimal getCurrentCostPriceLL(MPPProductBOM bom, MCostElement element ,int Yield)\n\t{\n\t\tlog.info(\"ElementType: \"+ element.getCostElementType());\n\t\tBigDecimal costPriceLL = Env.ZERO;\n\n\t\tfor (MPPProductBOMLine bomline : bom.getLines())\n\t\t{\n\t\t\tMProduct component = MProduct.get(getCtx(), bomline.getM_Product_ID());\n\t\t\t\n\t\t\t// get the rate for this resource     \n\t\t\tfor (MCost cost : getCosts(component, element.getCostElementType()))\n\t\t\t{                 \n\t\t\t\t// check if current cost element type is specified cost element type\n\t\t\t\tif (element.getCostElementType().equals(element.getCostElementType()))\n\t\t\t\t{\n\t\t\t\t\tBigDecimal qtyPercentage = bomline.getQtyBatch().divide(Env.ONEHUNDRED, 8, BigDecimal.ROUND_UP);\n\t\t\t\t\tBigDecimal qtyBOM = bomline.getQtyBOM(); \n\t\t\t\t\tBigDecimal scrapDec = bomline.getScrap().divide(Env.ONEHUNDRED, 4, BigDecimal.ROUND_UP);\n\t\t\t\t\tBigDecimal qtyTotal = Env.ZERO;\n\t\t\t\t\tif (bomline.isQtyPercentage())\n\t\t\t\t\t{\n\t\t\t\t\t\tqtyTotal =  qtyPercentage.divide(Env.ONE.subtract(scrapDec), 4, BigDecimal.ROUND_HALF_UP);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tqtyTotal =  qtyBOM.divide(Env.ONE.subtract(scrapDec), 4, BigDecimal.ROUND_HALF_UP);\n\t\t\t\t\t}\n\n\t\t\t\t\tBigDecimal costPrice = cost.getCurrentCostPrice().add(cost.getCurrentCostPriceLL());\n\t\t\t\t\tcostPriceLL = costPriceLL.add(costPrice.multiply(qtyTotal));\n\t\t\t\t\tlog.info(\"Cost Element:\"+element.getName()\n\t\t\t\t\t\t\t\t+ \", Total Cost Element: \" +   costPriceLL\n\t\t\t\t\t\t\t\t+ \", QtyPercentage: \" + qtyPercentage\n\t\t\t\t\t\t\t\t+ \", QtyBOM: \" + qtyBOM);\n\t\t\t\t}\n\t\t\t} // for each cost\n\t\t} // for each BOM line  \n\n\t\tif(Yield != 0)\n\t\t{\n\t\t\tBigDecimal decimalYield = new BigDecimal(Yield / 100);\n\t\t\tcostPriceLL = costPriceLL.divide(decimalYield, 4 ,BigDecimal.ROUND_HALF_UP);\n\t\t}\n       \n\t\treturn costPriceLL;     \n\t}\n",
    "new_code_raw": "\tprivate BigDecimal getCurrentCostPriceLL(MPPProductBOM bom, MCostElement element)\n\t{\n\t\tlog.info(\"ElementType: \"+ element.getCostElementType());\n\t\tBigDecimal costPriceLL = Env.ZERO;\n\t\tif(bom == null)\n\t\t\treturn costPriceLL;\n\n\t\tfor (MPPProductBOMLine bomline : bom.getLines())\n\t\t{\n\t\t\tMProduct component = MProduct.get(getCtx(), bomline.getM_Product_ID());\t\t\t\n\t\t\t// get the rate for this resource     \n\t\t\tfor (MCost cost : getCosts(component, element.getCostElementType()))\n\t\t\t{                 \n\t\t\t\t\tBigDecimal qtyPercentage = bomline.getQtyBatch().divide(Env.ONEHUNDRED, 8, BigDecimal.ROUND_UP);\n\t\t\t\t\tBigDecimal qtyBOM = bomline.getQtyBOM(); \n\t\t\t\t\tBigDecimal scrapDec = bomline.getScrap().divide(Env.ONEHUNDRED, 4, BigDecimal.ROUND_UP);\n\t\t\t\t\tBigDecimal qtyTotal = Env.ZERO;\n\t\t\t\t\tif (bomline.isQtyPercentage())\n\t\t\t\t\t{\n\t\t\t\t\t\tqtyTotal =  qtyPercentage.divide(Env.ONE.subtract(scrapDec), 4, BigDecimal.ROUND_HALF_UP);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tqtyTotal =  qtyBOM.divide(Env.ONE.subtract(scrapDec), 4, BigDecimal.ROUND_HALF_UP);\n\t\t\t\t\t}\n\n\t\t\t\t\tBigDecimal costPrice = cost.getCurrentCostPrice().add(cost.getCurrentCostPriceLL());\n\t\t\t\t\tcostPriceLL = costPriceLL.add(costPrice.multiply(qtyTotal));\n\t\t\t\t\tlog.info(\"Cost Element:\"+element.getName()\n\t\t\t\t\t\t\t\t+ \", Total Cost Element: \" +   costPriceLL\n\t\t\t\t\t\t\t\t+ \", QtyPercentage: \" + qtyPercentage\n\t\t\t\t\t\t\t\t+ \", QtyBOM: \" + qtyBOM);\n\t\t\t} // for each cost\n\t\t} // for each BOM line         \n\t\treturn costPriceLL;     \n\t}\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2081-FirstSentence-0",
    "old_comment_raw": "Grammatical relations are equal with other grammatical relations if they have the same shortName and specific (if present).",
    "new_comment_raw": "Grammatical relations are equal with other grammatical relations if they have the same shortName and specific (if present).",
    "old_code_raw": "  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o instanceof String) {\n      // TODO: Remove this. It's broken but was meant to cover legacy code. It would be correct to just return false.\n      new Throwable(\"Warning: comparing GrammaticalRelation to String\").printStackTrace();\n      return this.toString().equals(o);\n    }\n    if (!(o instanceof GrammaticalRelation)) return false;\n\n    final GrammaticalRelation gr = (GrammaticalRelation) o;\n    // == okay for language as enum!\n    return this.language == gr.language &&\n             this.shortName.equals(gr.shortName) &&\n             (this.specific == gr.specific ||\n              (this.specific != null && this.specific.equals(gr.specific)));\n  }\n",
    "new_code_raw": "  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o instanceof String) {\n      // TODO: Remove this. It's broken but was meant to cover legacy code. It would be correct to just return false.\n      new Throwable(\"Warning: comparing GrammaticalRelation to String\").printStackTrace();\n      return this.toString().equals(o);\n    }\n    if (!(o instanceof GrammaticalRelation)) return false;\n\n    final GrammaticalRelation gr = (GrammaticalRelation) o;\n    // == okay for language as enum!\n    // TODO(gabor) perhaps Language.Any shouldn't be equal to any language? This is a bit of a hack around some dependencies caring about language and others not.\n    return (this.language == Language.Any || gr.language == Language.Any || this.language == gr.language) &&\n             this.shortName.equals(gr.shortName) &&\n             (this.specific == gr.specific ||\n              (this.specific != null && this.specific.equals(gr.specific)));\n  }\n"
  },
  {
    "id": "zaproxy_zaproxy-2012-FirstSentence-0",
    "old_comment_raw": "Returns the text representation of the given  target.",
    "new_comment_raw": "Returns the text representation of the given  target.",
    "old_code_raw": "\tprotected static String getTargetText(Target target) {\n\t\tif (target != null) {\n\t\t\tif (target.getStartNode() != null && target.getStartNode().getHistoryReference() != null) {\n\t\t\t\treturn target.getStartNode().getHistoryReference().getURI().toString();\n\t\t\t} else if (target.getContext() != null) {\n\t\t\t\treturn Constant.messages.getString(\"context.prefixName\", target.getContext().getName());\n\t\t\t} else if (target.isInScopeOnly()) {\n\t\t\t\treturn Constant.messages.getString(\"context.allInScope\");\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "new_code_raw": "\tprotected static String getTargetText(Target target) {\n\t\tif (target != null) {\n\t\t\tif (target.getStartNode() != null) {\n\t\t\t\treturn getNodeText(target.getStartNode());\n\t\t\t} else if (target.getContext() != null) {\n\t\t\t\treturn Constant.messages.getString(\"context.prefixName\", target.getContext().getName());\n\t\t\t} else if (target.isInScopeOnly()) {\n\t\t\t\treturn Constant.messages.getString(\"context.allInScope\");\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n"
  },
  {
    "id": "mccraigmccraig_prefuse-3-Associations-FirstSentence",
    "old_comment_raw": "Returns the GraphItem located at the given point.",
    "new_comment_raw": "Returns the VisualItem located at the given point.",
    "old_code_raw": "\tpublic GraphItem findItem(Point p) {\n        Point2D p2 = (m_itransform==null ? p : \n                        m_itransform.transform(p, m_tmpPoint));\n\t\tsynchronized (m_registry) {\n\t\t\tIterator items = m_registry.getItemsReversed();\n\t\t\twhile (items.hasNext()) {\n\t\t\t\tGraphItem gi = (GraphItem) items.next();\n\t\t\t\tRenderer r = gi.getRenderer();\n\t\t\t\tif (r != null && r.locatePoint(p2, gi)) {\n\t\t\t\t\treturn gi;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t} //\n",
    "new_code_raw": "\tpublic VisualItem findItem(Point p) {\n        Point2D p2 = (m_itransform==null ? p : \n                        m_itransform.transform(p, m_tmpPoint));\n\t\tsynchronized (m_registry) {\n\t\t\tIterator items = m_registry.getItemsReversed();\n\t\t\twhile (items.hasNext()) {\n\t\t\t\tVisualItem vi = (VisualItem) items.next();\n\t\t\t\tRenderer r = vi.getRenderer();\n\t\t\t\tif (r != null && r.locatePoint(p2, vi)) {\n\t\t\t\t\treturn vi;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t} //\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2041-FirstSentence-0",
    "old_comment_raw": "Place an order for a pet",
    "new_comment_raw": "Place an order for a pet",
    "old_code_raw": "    public Order placeOrder(Order body) throws ApiException {\n        ApiResponse<Order> resp = placeOrderWithHttpInfo(body);\n        return resp.getData();\n    }\n",
    "new_code_raw": "    public Order placeOrder(Order body) throws ApiException {\n        ApiResponse<Order> localVarResp = placeOrderWithHttpInfo(body);\n        return localVarResp.getData();\n    }\n"
  },
  {
    "id": "hazelcast_hazelcast-226-Associations-FirstSentence",
    "old_comment_raw": "Fast method of finding the next power of 2 greater than or equal to the supplied value.",
    "new_comment_raw": "Returns the next power of two that is larger than the specified long value.",
    "old_code_raw": "    public static long nextPowerOfTwo(final long value) {\n        return 1L << (64 - Long.numberOfLeadingZeros(value - 1));\n    }\n",
    "new_code_raw": "    public static long nextPowerOfTwo(long value) {\n        if (!isPowerOfTwo(value)) {\n            value--;\n            value |= value >> 1;\n            value |= value >> 2;\n            value |= value >> 4;\n            value |= value >> 8;\n            value |= value >> 16;\n            value |= value >> 32;\n            value++;\n        }\n        return value;\n    }\n\n"
  },
  {
    "id": "apache_calcite-694-FirstSentence-0",
    "old_comment_raw": "Returns the rel nodes in this rel subset.",
    "new_comment_raw": "Returns the rel nodes in this rel subset.",
    "old_code_raw": "  public Iterable<RelNode> getRels() {\n    return new Iterable<RelNode>() {\n      public Iterator<RelNode> iterator() {\n        return Linq4j.asEnumerable(set.rels)\n            .where(\n                new Predicate1<RelNode>() {\n                  public boolean apply(RelNode v1) {\n                    return v1.getTraitSet().subsumes(traitSet);\n                  }\n                })\n            .iterator();\n      }\n    };\n  }\n",
    "new_code_raw": "  public Iterable<RelNode> getRels() {\n    return new Iterable<RelNode>() {\n      public Iterator<RelNode> iterator() {\n        return Linq4j.asEnumerable(set.rels)\n            .where(\n                new Predicate1<RelNode>() {\n                  public boolean apply(RelNode v1) {\n                    return v1.getTraitSet().satisfies(traitSet);\n                  }\n                })\n            .iterator();\n      }\n    };\n  }\n"
  },
  {
    "id": "stephenh_jxls-2-Associations-FirstSentence",
    "old_comment_raw": "Creates HSSFWorkbook instance based on .xls template from a given InputStream and a number of beans",
    "new_comment_raw": "Creates Workbook instance based on .xls template from a given InputStream and a number of beans",
    "old_code_raw": "    public HSSFWorkbook transformXLS(InputStream is, Map beanParams) throws ParsePropertyException {\n        HSSFWorkbook hssfWorkbook = null;\n        try {\n            POIFSFileSystem fs = new POIFSFileSystem(is);\n            hssfWorkbook = new HSSFWorkbook(fs);\n            transformWorkbook(hssfWorkbook, beanParams);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return hssfWorkbook;\n    }\n",
    "new_code_raw": "    public org.apache.poi.ss.usermodel.Workbook transformXLS(InputStream is, Map beanParams) throws ParsePropertyException, InvalidFormatException {\n        org.apache.poi.ss.usermodel.Workbook hssfWorkbook = null;\n        try {\n            hssfWorkbook = WorkbookFactory.create(is);\n            transformWorkbook(hssfWorkbook, beanParams);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return hssfWorkbook;\n    }\n\n"
  },
  {
    "id": "querydsl_querydsl-502-FirstSentence-0",
    "old_comment_raw": "Create a new PathMetadata for a variable",
    "new_comment_raw": "Create a new PathMetadata for a variable",
    "old_code_raw": "    public static PathMetadata<String> forVariable(String variable) {\n        return new PathMetadata<String>(null, ConstantImpl.create(Assert.hasLength(variable,\"variable\"), true), PathType.VARIABLE);\n    }\n",
    "new_code_raw": "    public static PathMetadata<String> forVariable(String variable) {\n        return new PathMetadata<String>(null, Assert.hasLength(variable,\"variable\"), PathType.VARIABLE);\n    }\n"
  },
  {
    "id": "codehaus_cake-14-Associations-FirstSentence",
    "old_comment_raw": "Analogous to  #get(WithAttributes) except returning a primitive short.",
    "new_comment_raw": "Extracts the attribute map from the specified  WithAttributes and returns the value of this attribute from the map.",
    "old_code_raw": "    public short get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n",
    "new_code_raw": "    public short get(WithAttributes withAttributes) {\r\n        return withAttributes.getAttributes().get(this);\r\n    }\r\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-311-FirstSentence-0",
    "old_comment_raw": "Return a well formed property path.",
    "new_comment_raw": "Return a well formed property path.",
    "old_code_raw": "\tprivate static String buildPropertyPath(String parent, String child) {\n\t\treturn new StringBuffer( parent.length() + child.length() + 1 )\n\t\t\t.append(parent).append('.').append(child).toString();\n\t}\n",
    "new_code_raw": "\tprivate static String buildPropertyPath(String parent, String child) {\n\t\treturn new StringBuilder( parent.length() + child.length() + 1 )\n\t\t\t.append(parent).append('.').append(child).toString();\n\t}\n"
  },
  {
    "id": "zaproxy_zaproxy-2201-FirstSentence-0",
    "old_comment_raw": "Returns true if the WebSocket connection that followed the given",
    "new_comment_raw": "Returns true if given channel id is connected.",
    "old_code_raw": "\tpublic boolean isConnected(HttpMessage handshakeMessage) {\n\t\tint historyId = handshakeMessage.getHistoryRef().getHistoryId();\n\t\tfor (Entry<Integer, WebSocketProxy> entry : wsProxies.entrySet()) {\n\t\t\tWebSocketProxy proxy = entry.getValue();\n\t\t\tif (historyId == proxy.getHandshakeReference().getHistoryId()) {\n\t\t\t\treturn proxy.isConnected();\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "new_code_raw": "\tpublic boolean isConnected(Integer channelId) {\n\t\tsynchronized (wsProxies) {\n\t\t\tif (wsProxies.containsKey(channelId)) {\n\t\t\t\treturn wsProxies.get(channelId).isConnected();\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n"
  },
  {
    "id": "JodaOrg_joda_time-820-FirstSentence-0",
    "old_comment_raw": "Gets the days field part of the period.",
    "new_comment_raw": "Gets the days field part of the period.",
    "old_code_raw": "    public int getDays() {\n        return getPeriodType().getDays(this);\n    }\n",
    "new_code_raw": "    public int getDays() {\n        return getPeriodType().getIndexedField(this, PeriodType.DAY_INDEX);\n    }\n"
  },
  {
    "id": "vbehar_jenkins-rundeck-plugin-3-Associations-FirstSentence",
    "old_comment_raw": "prepare the  HttpClient's queryString containing the group/job and the options.",
    "new_comment_raw": "prepares an url-encoded HTTP queryString containing the group/job and the options.",
    "old_code_raw": "    private NameValuePair[] prepareQueryString(String groupPath, String jobName, Properties options) {\n        List<NameValuePair> queryString = new ArrayList<NameValuePair>();\n\n        queryString.add(new NameValuePair(\"groupPath\", groupPath));\n        queryString.add(new NameValuePair(\"jobName\", jobName));\n\n        if (options != null) {\n            StringBuilder argString = new StringBuilder();\n            for (Entry<Object, Object> option : options.entrySet()) {\n                String key = String.valueOf(option.getKey());\n                String value = String.valueOf(option.getValue());\n                if (StringUtils.isNotBlank(key) && StringUtils.isNotBlank(value)) {\n                    // for rundeck 1.1, we need 1 argument per option\n                    queryString.add(new NameValuePair(\"extra.command.option.\" + key, value));\n\n                    // for rundeck 1.2, we need a single argument (extra.argString) with all options\n                    // format is : \"-key1 value1 -key2 'this is value 2 with spaces'\"\n                    if (argString.length() > 0) {\n                        argString.append(\" \");\n                    }\n                    argString.append(\"-\").append(key);\n                    argString.append(\" \");\n                    if (value.indexOf(\" \") >= 0\n                        && !(0 == value.indexOf(\"'\") && (value.length() - 1) == value.lastIndexOf(\"'\"))) {\n                        argString.append(\"'\").append(value).append(\"'\");\n                    } else {\n                        argString.append(value);\n                    }\n                }\n            }\n            queryString.add(new NameValuePair(\"extra.argString\", argString.toString()));\n        }\n\n        return queryString.toArray(new NameValuePair[queryString.size()]);\n    }\n",
    "new_code_raw": "    private String prepareQueryString(String groupPath, String jobName, Properties options) {\n        List<NameValuePair> parameters = new ArrayList<NameValuePair>();\n\n        parameters.add(new BasicNameValuePair(\"groupPath\", groupPath));\n        parameters.add(new BasicNameValuePair(\"jobName\", jobName));\n\n        if (options != null) {\n            for (Entry<Object, Object> option : options.entrySet()) {\n                parameters.add(new BasicNameValuePair(\"extra.command.option.\" + option.getKey(),\n                                                      String.valueOf(option.getValue())));\n            }\n        }\n\n        return URLEncodedUtils.format(parameters, HTTP.UTF_8);\n    }\n\n"
  },
  {
    "id": "graphql_java_graphql_java-350-FirstSentence-0",
    "old_comment_raw": "Converts an object that is known to should be an Iterable into one",
    "new_comment_raw": "Converts an object that is known to should be an Iterable into one",
    "old_code_raw": "    protected Iterable<Object> toIterable(Object result) {\n        if (result.getClass().isArray()) {\n            return IntStream.range(0, Array.getLength(result))\n                    .mapToObj(i -> Array.get(result, i))\n                    .collect(toList());\n        }\n        return (Iterable<Object>) result;\n    }\n",
    "new_code_raw": "    protected Iterable<Object> toIterable(Object result) {\n        return FpKit.toCollection(result);\n    }\n"
  },
  {
    "id": "apache_tuscany-sca-1.x-68-Associations-FirstSentence",
    "old_comment_raw": "Returns the physical class used by the runtime.",
    "new_comment_raw": "Returns the physical type used by the runtime.",
    "old_code_raw": "    public Class<P> getPhysical() {\n        return physical;\n    }\n",
    "new_code_raw": "    public Type getPhysical() {\n        return physical;\n    }\n\n"
  },
  {
    "id": "querydsl_querydsl-525-FirstSentence-0",
    "old_comment_raw": "Return true if this starts with str",
    "new_comment_raw": "Return true if this starts with str",
    "old_code_raw": "    public BooleanExpression startsWith(Expression<String> str) {\n        return BooleanOperation.create(Ops.STARTS_WITH, this, str);\n    }\n",
    "new_code_raw": "    public BooleanExpression startsWith(Expression<String> str) {\n        return BooleanOperation.create(Ops.STARTS_WITH, mixin, str);\n    }\n"
  },
  {
    "id": "frohoff_jdk6-73-Associations-FirstSentence",
    "old_comment_raw": "This default implementation returns a new  Insets object that is initialized by the  #getBorderInsets(Component,Insets) method.",
    "new_comment_raw": "This default implementation returns a new Insets instance where the top, left, bottom, and right fields are set to 0.",
    "old_code_raw": "    public Insets getBorderInsets(Component c)       {\n        return getBorderInsets(c, new Insets(0, 0, 0, 0));\n    }\n",
    "new_code_raw": "    public Insets getBorderInsets(Component c)       { \n        return new Insets(0, 0, 0, 0);\n    }\n\n"
  },
  {
    "id": "SeleniumHQ_selenium-683-FirstSentence-0",
    "old_comment_raw": "Creates a new binary to manage the chromedriver server.",
    "new_comment_raw": "Creates a new binary to manage the chromedriver server.",
    "old_code_raw": "    public ChromeDriverService build() {\n      if (port == 0) {\n        port = PortProber.findFreePort();\n      }\n\n      checkState(exe != null, \"Path to the chromedriver executable not specified\");\n\n      try {\n        return new ChromeDriverService(exe, port, environment, logFile);\n      } catch (IOException e) {\n        throw new WebDriverException(e);\n      }\n    }\n",
    "new_code_raw": "    public ChromeDriverService build() {\n      return (ChromeDriverService) super.build();\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-1462-FirstSentence-0",
    "old_comment_raw": "Scrolls up and down.",
    "new_comment_raw": "Scrolls up and down.",
    "old_code_raw": "\tpublic boolean scroll(int direction, boolean allTheWay) {\n\t\tfinal ArrayList<View> viewList = RobotiumUtils.\n\t\t\t\tremoveInvisibleViews(viewFetcher.getAllViews(true));\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tArrayList<View> views = RobotiumUtils.filterViewsToSet(new Class[] { ListView.class,\n\t\t\t\tScrollView.class, GridView.class, WebView.class}, viewList);\n\t\tView view = viewFetcher.getFreshestView(views);\n\t\t\n\t\tif (view == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif (view instanceof AbsListView) {\n\t\t\treturn scrollList((AbsListView)view, direction, allTheWay);\n\t\t}\n\n\t\tif (view instanceof ScrollView) {\n\t\t\tif (allTheWay) {\n\t\t\t\tscrollScrollViewAllTheWay((ScrollView) view, direction);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn scrollScrollView((ScrollView)view, direction);\n\t\t\t}\n\t\t}\n\t\tif(view instanceof WebView){\n\t\t\treturn scrollWebView((WebView)view, direction, allTheWay);\n\t\t}\n\t\treturn false;\n\t}\n",
    "new_code_raw": "\tpublic boolean scroll(int direction, boolean allTheWay) {\n\t\tfinal ArrayList<View> viewList = RobotiumUtils.\n\t\t\t\tremoveInvisibleViews(viewFetcher.getAllViews(true));\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tArrayList<View> views = RobotiumUtils.filterViewsToSet(new Class[] { ListView.class,\n\t\t\t\tScrollView.class, GridView.class, WebView.class}, viewList);\n\n\t\tView view = viewFetcher.getFreshestView(views);\n\n\t\tif (view == null) {\n\t\t\tview = getRecyclerView(viewList);\n\n\t\t\tif(view == null){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (view instanceof AbsListView) {\n\t\t\treturn scrollList((AbsListView)view, direction, allTheWay);\n\t\t}\n\n\t\tif(view instanceof WebView){\n\t\t\treturn scrollWebView((WebView)view, direction, allTheWay);\n\t\t}\n\n\t\tif (allTheWay) {\n\t\t\tscrollViewAllTheWay(view, direction);\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn scrollView(view, direction);\n\t\t}\n\t}\n"
  },
  {
    "id": "apache_calcite-avatica-80-Associations-FirstSentence",
    "old_comment_raw": "Determines whether a relational expression should be visible in EXPLAIN",
    "new_comment_raw": "Returns the  BuiltInMetadata.ExplainVisibility#isVisibleInExplain(SqlExplainLevel) statistic.",
    "old_code_raw": "  public static boolean isVisibleInExplain(\n      RelNode rel,\n      SqlExplainLevel explainLevel) {\n    Boolean b =\n        (Boolean) rel.getCluster().getMetadataProvider().getRelMetadata(\n            rel,\n            \"isVisibleInExplain\",\n            new Object[]{explainLevel});\n    if (b == null) {\n      return true;\n    } else {\n      return b;\n    }\n  }\n",
    "new_code_raw": "  public static boolean isVisibleInExplain(RelNode rel,\n      SqlExplainLevel explainLevel) {\n    final BuiltInMetadata.ExplainVisibility metadata =\n        rel.metadata(BuiltInMetadata.ExplainVisibility.class);\n    Boolean b = metadata.isVisibleInExplain(explainLevel);\n    return b == null || b;\n  }\n\n"
  },
  {
    "id": "processing_processing-34-FirstSentence-0",
    "old_comment_raw": "Build all the code for this sketch.",
    "new_comment_raw": "Build all the code for this sketch.",
    "old_code_raw": "  public String preprocess(String buildPath) throws RunnerException {\n    try {\n      return preprocess(buildPath, new PdePreprocessor(buildPath, name));\n    } catch (IOException e) {\n      throw new RunnerException(\"Error while preprocessing\", true);\n    }\n  }\n",
    "new_code_raw": "  public String preprocess(String buildPath) throws RunnerException {\n    try {\n      return preprocess(buildPath, new PdePreprocessor(name));\n    } catch (IOException e) {\n      throw new RunnerException(\"Error while preprocessing\", true);\n    }\n  }\n"
  },
  {
    "id": "LawnchairLauncher_Lawnchair-420-FirstSentence-0",
    "old_comment_raw": "This method can be called only once! Calling #findVacantCellsFromOccupied will restore the ability to call this method.",
    "new_comment_raw": "Finds the upper-left coordinate of the first rectangle in the grid that can hold a cell of the specified dimensions.",
    "old_code_raw": "        boolean findCellForSpan(int[] cellXY, int spanX, int spanY) {\n            return findCellForSpan(cellXY, spanX, spanY, true);\n        }\n",
    "new_code_raw": "        boolean findCellForSpan(int[] cellXY, int spanX, int spanY) {\n            // return the span represented by the CellInfo only there is no view there\n            //   (this.cell == null) and there is enough space\n\n            if (this.cell == null && this.spanX >= spanX && this.spanY >= spanY) {\n                if (cellXY != null) {\n                    cellXY[0] = cellX;\n                    cellXY[1] = cellY;\n                }\n                return true;\n            }\n\n            int startX = 0;\n            if (intersectX >= 0) {\n                startX = Math.max(startX, intersectX - (spanX - 1));\n            }\n            int endX = mCountX - (spanX - 1);\n            if (intersectX >= 0) {\n                endX = Math.min(endX, intersectX + (spanX - 1));\n            }\n            int startY = 0;\n            if (intersectY >= 0) {\n                startY = Math.max(startY, intersectY - (spanY - 1));\n            }\n            int endY = mCountY - (spanY - 1);\n            if (intersectY >= 0) {\n                endY = Math.min(endY, intersectY + (spanY - 1));\n            }\n\n            for (int x = startX; x < endX + 1; x++) {\n                inner:\n                for (int y = startY; y < endY; y++) {\n                    for (int i = 0; i < spanX; i++) {\n                        for (int j = 0; j < spanY; j++) {\n                            if (mOccupied[x + i][y + j]) {\n                                // small optimization: we can skip to below the row we just found\n                                // an occupied cell\n                                y += j;\n                                continue inner;\n                            }\n                        }\n                    }\n                    if (cellXY != null) {\n                        cellXY[0] = x;\n                        cellXY[1] = y;\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n"
  },
  {
    "id": "querydsl_querydsl-483-FirstSentence-0",
    "old_comment_raw": "Populate the INSERT clause with the properties of the given bean.",
    "new_comment_raw": "Populate the INSERT clause with the properties of the given bean.",
    "old_code_raw": "    public SQLInsertClause populate(Object bean) {\n        try {\n            Class<?> beanClass = bean.getClass();\n            Map<String, Field> fields = getPathFields(entity.getClass());\n            for (Field beanField : beanClass.getDeclaredFields()) {\n                if (!Modifier.isStatic(beanField.getModifiers())) {\n                    Field field = fields.get(beanField.getName());                    \n                    Path path = (Path<?>) field.get(entity);\n                    beanField.setAccessible(true);\n                    Object propertyValue = beanField.get(bean);\n                    if (propertyValue != null) {\n                        set(path, propertyValue);\n                    }     \n                }\n            }\n//            BeanMap map = new BeanMap(bean);\n//            for (Map.Entry entry : map.entrySet()) {\n//                String property = entry.getKey().toString();\n//                if (!property.equals(\"class\")) {\n//                    Field field = entity.getClass().getDeclaredField(property);\n//                    field.setAccessible(true);\n//                    Path path = (Path<?>) field.get(entity);\n//                    if (entry.getValue() != null) {\n//                        set(path, entry.getValue());    \n//                    }                    \n//                }\n//            }\n            return this;\n        } catch (SecurityException e) {\n            throw new QueryException(e);\n        } catch (IllegalAccessException e) {\n            throw new QueryException(e);\n        }\n    }\n",
    "new_code_raw": "    public SQLInsertClause populate(Object bean) {\n        return populate(bean, DefaultMapper.DEFAULT);\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-691-FirstSentence-0",
    "old_comment_raw": "Selects a suitable duration type for the given object.",
    "new_comment_raw": "Selects a suitable duration type for the given object.",
    "old_code_raw": "    public DurationType getDurationType(Object object, boolean precise) {\n        return DurationType.getPreciseAllType();\n    }\n",
    "new_code_raw": "    public DurationType getDurationType(Object object, boolean precise) {\n        ReadableTimePeriod period = (ReadableTimePeriod) object;\n        if (precise) {\n            if (period.getDurationType().isPrecise()) {\n                return period.getDurationType();\n            } else {\n                return DurationType.getPreciseAllType();\n            }\n        }\n        return period.getDurationType();\n    }\n"
  },
  {
    "id": "bmc_curn-3-Associations-FirstSentence",
    "old_comment_raw": "Get an InputStream that can be used to read the output data produced by the handler, if applicable.",
    "new_comment_raw": "Get the File that represents the output produced by the handler, if applicable.",
    "old_code_raw": "    public final InputStream getGeneratedOutput()\n        throws CurnException\n    {\n        InputStream result = null;\n\n        if (hasGeneratedOutput())\n        {\n            try\n            {\n                result = new FileInputStream (outputFile);\n            }\n\n            catch (FileNotFoundException ex)\n            {\n                throw new CurnException (Curn.BUNDLE_NAME,\n                                         \"FileOutputHandler.cantReopenFile\",\n                                         \"Cannot reopen file \\\"{0}\\\".\",\n                                         new Object[] {outputFile},\n                                         ex);\n            }\n        }\n\n        return result;\n    }\n",
    "new_code_raw": "    public final File getGeneratedOutput()\n        throws CurnException\n    {\n        return hasGeneratedOutput() ? outputFile : null;\n    }\n\n"
  },
  {
    "id": "processing_processing-37-FirstSentence-0",
    "old_comment_raw": "Returns true if the texture has been initialized.",
    "new_comment_raw": "Returns true if the texture has been initialized.",
    "old_code_raw": "  public boolean available()  {\n    return 0 < glTextureID[0];\n  }\n",
    "new_code_raw": "  public boolean available()  {\n    return 0 < glTextureID;\n  }\n"
  },
  {
    "id": "apache_geode-387-Associations-FirstSentence",
    "old_comment_raw": "Get the current number of bucket hosts and update the redundancy statistics for the region",
    "new_comment_raw": "Determine if there has been a change in redundancy and alter the lowRedundancyBucketCount stat as needed.",
    "old_code_raw": "  private int updateRedundancy() {\n    int numBucketHosts = getNumInitializedBuckets();\n    if (!isClosed()) {\n      redundancyTracker.updateStatistics(numBucketHosts);\n    }\n    return numBucketHosts;\n  }\n",
    "new_code_raw": "  private int updateRedundancy() {\n    int desiredRedundancy = this.pRegion.getRedundantCopies();\n    int numBucketHosts = getNumInitializedBuckets();\n    if (isClosed()) {\n      return numBucketHosts;\n    }\n    int actualRedundancy = numBucketHosts - 1;\n    this.redundancy = actualRedundancy;\n    if (this.redundancySatisfied && numBucketHosts > 0 && actualRedundancy < desiredRedundancy) {\n      incLowRedundancyBucketCount(1);\n      this.redundancySatisfied = false;\n    } else if (!this.redundancySatisfied && numBucketHosts > 0\n        && actualRedundancy >= desiredRedundancy) {\n      incLowRedundancyBucketCount(-1);\n      this.redundancySatisfied = true;\n      this.redundancyEverSatisfied = true;\n    }\n    return numBucketHosts;\n  }\n\n"
  },
  {
    "id": "debezium_debezium-318-FirstSentence-0",
    "old_comment_raw": "Determine if the supplied value is one of the predefined options.",
    "new_comment_raw": "Determine if the supplied value is one of the predefined options.",
    "old_code_raw": "        public static TopicSelectionStrategy parse(String value) {\n            if (value == null) return null;\n            value = value.trim();\n            for (TopicSelectionStrategy option : TopicSelectionStrategy.values()) {\n                if (option.getValue().equalsIgnoreCase(value)) return option;\n            }\n            return null;\n        }\n",
    "new_code_raw": "        public static SchemaRefreshMode parse(String value) {\n            if (value == null) return null;\n            value = value.trim();\n            for (SchemaRefreshMode option : SchemaRefreshMode.values()) {\n                if (option.getValue().equalsIgnoreCase(value)) return option;\n            }\n            return null;\n        }\n"
  },
  {
    "id": "apache_lenya-308-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Return all task ids",
    "old_code_raw": "    public String[] getTaskIds() {\n        return (String[]) tasks.keySet().toArray(new String[tasks.size()]);\n    }\n",
    "new_code_raw": "    public String[] getTaskIds() {\n        return (String[]) this.tasks.keySet().toArray(new String[this.tasks.size()]);\n    }\n\n"
  },
  {
    "id": "facebook_fresco-20-FirstSentence-0",
    "old_comment_raw": "Creates a bitmap of the specified width and height.",
    "new_comment_raw": "Creates a bitmap of the specified width and height.",
    "old_code_raw": "  CloseableReference<Bitmap> createBitmap(short width, short height) {\n    CloseableReference<PooledByteBuffer> jpgRef = mJpegGenerator.generate(width, height);\n    try {\n      return decodeJPEGFromPooledByteBuffer(jpgRef, jpgRef.get().size());\n    } finally {\n      jpgRef.close();\n    }\n  }\n",
    "new_code_raw": "  CloseableReference<Bitmap> createBitmap(short width, short height) {\n    CloseableReference<PooledByteBuffer> jpgRef = mJpegGenerator.generate(width, height);\n    try {\n      CloseableReference<Bitmap> bitmapRef =\n          decodeJPEGFromPooledByteBuffer(jpgRef, jpgRef.get().size());\n      Bitmap underlying = bitmapRef.get();\n      for (int x = 0; x < underlying.getWidth(); x++) {\n        for (int y = 0; y < underlying.getHeight(); y++) {\n          underlying.setPixel(x, y, Color.TRANSPARENT);\n        }\n      }\n      return bitmapRef;\n    } finally {\n      jpgRef.close();\n    }\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-325-FirstSentence-0",
    "old_comment_raw": "Checks whether the  Element hosts an annotation of the specified class.",
    "new_comment_raw": "Checks whether the  Element hosts the annotation with the given fully qualified class name.",
    "old_code_raw": "\tpublic static AnnotationMirror getAnnotationMirror(Element element, Class<? extends Annotation> clazz) {\n\t\tassert clazz != null;\n\t\treturn getAnnotationMirror( element, clazz.getName() );\n\t}\n",
    "new_code_raw": "\tpublic static AnnotationMirror getAnnotationMirror(Element element, String fqcn) {\n\t\tassert element != null;\n\t\tassert fqcn != null;\n\n\t\tAnnotationMirror mirror = null;\n\t\tfor ( AnnotationMirror am : element.getAnnotationMirrors() ) {\n\t\t\tif ( isAnnotationMirrorOfType( am, fqcn ) ) {\n\t\t\t\tmirror = am;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn mirror;\n\t}\n"
  },
  {
    "id": "apache_calcite-853-FirstSentence-0",
    "old_comment_raw": "Convert the value of a literal to a string.",
    "new_comment_raw": "Convert the value of a literal to a string.",
    "old_code_raw": "    private static String literalValue(RexLiteral literal) {\n      Object value = literal.getValue2();\n      StringBuilder buf = new StringBuilder();\n      buf.append(value);\n      return buf.toString();\n    }\n",
    "new_code_raw": "    private static String literalValue(RexLiteral literal) {\n      Object value = literal.getValue2();\n      return String.valueOf(value);\n    }\n"
  },
  {
    "id": "apache_rave-0-Associations-FirstSentence",
    "old_comment_raw": "Gets the  Person that owns the page",
    "new_comment_raw": "Gets the  User that owns the page",
    "old_code_raw": "    public Person getOwner() {\n        return owner;\n    }\n",
    "new_code_raw": "    public User getOwner() {\n        return owner;\n    }\n\n"
  },
  {
    "id": "apache_calcite-624-FirstSentence-0",
    "old_comment_raw": "Translates an expression that is not in the cache.",
    "new_comment_raw": "Translates an expression that is not in the cache.",
    "old_code_raw": "  private Expression translate0(RexNode expr, RexImpTable.NullAs nullAs) {\n    if (nullAs == RexImpTable.NullAs.NULL && !expr.getType().isNullable()) {\n      nullAs = RexImpTable.NullAs.NOT_POSSIBLE;\n    }\n    switch (expr.getKind()) {\n    case INPUT_REF:\n      final int index = ((RexInputRef) expr).getIndex();\n      Expression x = inputGetter.field(list, index);\n      return list.append(\n          \"v\",\n          nullAs.handle(\n              list.append(\"v\", x)));\n    case LOCAL_REF:\n      return translate(\n          program.getExprList().get(((RexLocalRef) expr).getIndex()),\n          nullAs);\n    case LITERAL:\n      return translateLiteral(\n          expr,\n          nullifyType(\n              expr.getType(),\n              isNullable(expr)\n                  && nullAs != RexImpTable.NullAs.NOT_POSSIBLE),\n          typeFactory,\n          nullAs);\n    case DYNAMIC_PARAM:\n      return translateParameter((RexDynamicParam) expr, nullAs);\n    default:\n      if (expr instanceof RexCall) {\n        final RexCall call = (RexCall) expr;\n        final SqlOperator operator = call.getOperator();\n        RexImpTable.CallImplementor implementor =\n            RexImpTable.INSTANCE.get(operator);\n        if (implementor != null) {\n          return implementor.implement(this, call, nullAs);\n        }\n      }\n      throw new RuntimeException(\n          \"cannot translate expression \" + expr);\n    }\n  }\n",
    "new_code_raw": "  private Expression translate0(RexNode expr, RexImpTable.NullAs nullAs) {\n    if (nullAs == RexImpTable.NullAs.NULL && !expr.getType().isNullable()) {\n      nullAs = RexImpTable.NullAs.NOT_POSSIBLE;\n    }\n    switch (expr.getKind()) {\n    case INPUT_REF:\n      final int index = ((RexInputRef) expr).getIndex();\n      Expression x = inputGetter.field(list, index);\n      return list.append(\n          \"v\",\n          nullAs.handle(\n              list.append(\"v\", x)));\n    case LOCAL_REF:\n      return translate(\n          program.getExprList().get(((RexLocalRef) expr).getIndex()),\n          nullAs);\n    case LITERAL:\n      return translateLiteral(\n          expr,\n          nullifyType(\n              expr.getType(),\n              isNullable(expr)\n                  && nullAs != RexImpTable.NullAs.NOT_POSSIBLE),\n          typeFactory,\n          nullAs);\n    case DYNAMIC_PARAM:\n      return translateParameter((RexDynamicParam) expr, nullAs);\n    default:\n      if (expr instanceof RexCall) {\n        return translateCall((RexCall) expr, nullAs);\n      }\n      throw new RuntimeException(\n          \"cannot translate expression \" + expr);\n    }\n  }\n"
  },
  {
    "id": "apache_derby-123-Associations-FirstSentence",
    "old_comment_raw": "Evaluate this object's compiled XML query expression against the received xmlContext and return whether or not at least one item in the xmlContext is returned.",
    "new_comment_raw": "Evaluate this object's compiled XML query expression against the received xmlContext.",
    "old_code_raw": "    protected boolean evalXQExpression(XMLDataValue xmlContext)\n        throws Exception\n    {\n        // Make sure we have a compiled query.\n        if (SanityManager.DEBUG) {\n            SanityManager.ASSERT(\n                (query != null) && (query.getExpression() != null),\n                \"Failed to locate compiled XML query expression.\");\n        }\n\n        // Create a DOM node from the xmlContext, since that's how\n        // we feed the context to Xalan.\n        Document docNode = null;\n        docNode = dBuilder.parse(\n            new InputSource(\n                new StringReader(xmlContext.getString())));\n\n        // Evaluate the expresion using Xalan.\n        getXPathContext();\n        xpContext.reset();\n        XObject xOb = query.execute(xpContext, docNode, null);\n\n        // We don't want to return the actual results, we just\n        // want to know if there was at least one item in the\n        // result sequence.\n        if ((xOb instanceof XNodeSet) &&\n            (((XNodeSet)xOb).nodelist().getLength() > 0))\n        { // If we have a sequence (XNodeSet) of length greater\n          // than zero, then we know that at least one item\n          // \"exists\" in the result.\n            return true;\n        }\n        else if (!(xOb instanceof XNodeSet))\n        // we have a single atomic value, which means the result is\n        // non-empty.\n            return true;\n\n        // Else the result was an empty sequence.\n        return false;\n    }\n",
    "new_code_raw": "    protected ArrayList evalXQExpression(XMLDataValue xmlContext,\n        boolean returnResults, int [] resultXType) throws Exception\n    {\n        // Make sure we have a compiled query.\n        if (SanityManager.DEBUG) {\n            SanityManager.ASSERT(\n                (query != null) && (query.getExpression() != null),\n                \"Failed to locate compiled XML query expression.\");\n        }\n\n        /* Create a DOM node from the xmlContext, since that's how\n         * we feed the context to Xalan.  We do this by creating\n         * a Document node using DocumentBuilder, which means that\n         * the serialized form of the context node must be a string\n         * value that is parse-able by DocumentBuilder--i.e. it must\n         * constitute a valid XML document.  If that's true then\n         * the context item's qualified type will be DOC_ANY.\n         */\n        if (xmlContext.getXType() != XML.XML_DOC_ANY)\n        {\n            throw StandardException.newException(\n                SQLState.LANG_INVALID_XML_CONTEXT_ITEM,\n                (returnResults ? \"XMLQUERY\" : \"XMLEXISTS\"));\n        } \n\n        Document docNode = null;\n        docNode = dBuilder.parse(\n            new InputSource(\n                new StringReader(xmlContext.getString())));\n\n        // Evaluate the expresion using Xalan.\n        getXPathContext();\n        xpContext.reset();\n        XObject xOb = query.execute(xpContext, docNode, null);\n\n        if (!returnResults)\n        {\n            // We don't want to return the actual results, we just\n            // want to know if there was at least one item in the\n            // result sequence.\n            if ((xOb instanceof XNodeSet) &&\n                (((XNodeSet)xOb).nodelist().getLength() > 0))\n            { // If we have a sequence (XNodeSet) of length greater\n              // than zero, then we know that at least one item\n              // \"exists\" in the result so return a non-null list.\n                return new ArrayList(0);\n            }\n            else if (!(xOb instanceof XNodeSet))\n            // we have a single atomic value, which means the result is\n            // non-empty.  So return a non-null list.\n                return new ArrayList(0);\n            else {\n            // return null; caller will take this to mean we have an\n            // an empty sequence.\n                return null;\n            }\n        }\n\n        // Else process the results.\n        NodeList nodeList = null;\n        int numItems = 0;\n        if (!(xOb instanceof XNodeSet))\n        // then we only have a single (probably atomic) item.\n            numItems = 1;\n        else {\n            nodeList = xOb.nodelist();\n            numItems = nodeList.getLength();\n        }\n\n        // Return a list of the items contained in the query results.\n        ArrayList itemRefs = new ArrayList();\n        if (nodeList == null)\n        // result is a single, non-node value (ex. it's an atomic number);\n        // in this case, just take the string value.\n            itemRefs.add(xOb.str());\n        else {\n            for (int i = 0; i < numItems; i++)\n                itemRefs.add(nodeList.item(i));\n        }\n\n        nodeList = null;\n\n        // Indicate what kind of XML result value we have.  If\n        // we have a sequence of exactly one Element or Document\n        // then it is XMLPARSE-able and so we consider it to be\n        // of type XML_DOC_ANY (which means we can store it in\n        // a Derby XML column).\n        if ((numItems == 1) && ((itemRefs.get(0) instanceof Document)\n            || (itemRefs.get(0) instanceof Element)))\n        {\n            resultXType[0] = XML.XML_DOC_ANY;\n        }\n        else\n            resultXType[0] = XML.XML_SEQUENCE;\n\n        return itemRefs;\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2050-FirstSentence-0",
    "old_comment_raw": "Logs user into the system",
    "new_comment_raw": "Logs user into the system",
    "old_code_raw": "    public ApiResponse<String> loginUserWithHttpInfo(String username, String password) throws ApiException {\n        okhttp3.Call call = loginUserValidateBeforeCall(username, password, null, null);\n        Type localVarReturnType = new TypeToken<String>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n",
    "new_code_raw": "    public ApiResponse<String> loginUserWithHttpInfo(String username, String password) throws ApiException {\n        okhttp3.Call localVarCall = loginUserValidateBeforeCall(username, password, null, null);\n        Type localVarReturnType = new TypeToken<String>(){}.getType();\n        return localVarApiClient.execute(localVarCall, localVarReturnType);\n    }\n"
  },
  {
    "id": "Vexatos_Resonant-Induction-1-5-Associations-FirstSentence",
    "old_comment_raw": "Is this conveyor belt slanted towards a direction?",
    "new_comment_raw": "Checks the front and the back position to find any conveyor blocks either higher or lower than this block to determine if it this conveyor block needs to slant.",
    "old_code_raw": "\tpublic ForgeDirection getSlant(World world, Vector3 position)\n\t{\n\t\tTileEntity t = position.getTileEntity(world);\n\n\t\tif (t != null)\n\t\t{\n\t\t\tif (t instanceof TileEntityConveyorBelt)\n\t\t\t{\n\t\t\t\tTileEntityConveyorBelt tileEntity = (TileEntityConveyorBelt) t;\n\t\t\t\tVector3 highCheck = position.clone();\n\t\t\t\thighCheck.modifyPositionFromSide(tileEntity.getDirection());\n\t\t\t}\n\t\t}\n\n\t\treturn ForgeDirection.UNKNOWN;\n\t}\n",
    "new_code_raw": "\tpublic static SlantType getSlant(World world, Vector3 position)\n\t{\n\t\tTileEntity t = position.getTileEntity(world);\n\n\t\tif (t != null)\n\t\t{\n\t\t\tif (t instanceof TileEntityConveyorBelt)\n\t\t\t{\n\t\t\t\tTileEntityConveyorBelt tileEntity = (TileEntityConveyorBelt) t;\n\t\t\t\tVector3 frontCheck = position.clone();\n\t\t\t\tfrontCheck.modifyPositionFromSide(tileEntity.getDirection());\n\t\t\t\tVector3 backCheck = position.clone();\n\t\t\t\tbackCheck.modifyPositionFromSide(tileEntity.getDirection().getOpposite());\n\n\t\t\t\tif (Vector3.add(frontCheck, new Vector3(0, 1, 0)).getBlockID(world) == AssemblyLine.blockConveyorBelt.blockID && Vector3.add(backCheck, new Vector3(0, -1, 0)).getBlockID(world) == AssemblyLine.blockConveyorBelt.blockID)\n\t\t\t\t{\n\t\t\t\t\treturn SlantType.UP;\n\t\t\t\t}\n\t\t\t\telse if (Vector3.add(frontCheck, new Vector3(0, -1, 0)).getBlockID(world) == AssemblyLine.blockConveyorBelt.blockID && Vector3.add(backCheck, new Vector3(0, 1, 0)).getBlockID(world) == AssemblyLine.blockConveyorBelt.blockID) { return SlantType.DOWN; }\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n"
  },
  {
    "id": "rstudio_rstudio-135-FirstSentence-0",
    "old_comment_raw": "Map an ANSI escape sequence to the appropriate css styles; only handles colors and visual appearance covered by SGR codes; other sequences such as cursor movement are ignored.",
    "new_comment_raw": "Map an ANSI escape sequence to the appropriate css styles; only handles colors and visual appearance covered by SGR codes; other sequences such as cursor movement are ignored.",
    "old_code_raw": "   public String processCode(String code)\n   {\n      if (code == null || code.length() < 2)\n         return null;\n      if (code.charAt(0) != '\\033' && code.charAt(code.length() - 1) != 'm')\n         return null;\n      if (code.length() == 2)\n      {\n         clazzes_.clear(); // CSIm is equivalent to CSI0m, which is 'reset'\n         return null;\n      }\n      \n      int extendedColor = 0;\n      boolean extendedMarkerSeen = false;\n      boolean extendedRGBMarkerSeen = false;\n      int extendedRGBColorsSeen = 0;\n      \n      String[] tokens = code.substring(2, code.length() - 1).split(\";\");\n      for (String token : tokens)\n      {\n         int codeVal = StringUtil.parseInt(token,  -1);\n         if (codeVal == -1)\n            continue;\n\n         if (extendedColor > 0)\n         {\n            if (!extendedMarkerSeen && !extendedRGBMarkerSeen)\n            {\n               if (codeVal == EXT_BY_INDEX)\n               {\n                  extendedMarkerSeen = true;\n                  continue;\n               }\n               else if (codeVal == EXT_BY_RGB)\n               {\n                  extendedRGBMarkerSeen = true;\n                  extendedRGBColorsSeen = 0;\n               }\n               else\n               {\n                  // unknown extended color format; hard to recover so\n                  // just reset back to defaults and return\n                  clazzes_.clear();\n                  return null;\n               }\n            }\n            else\n            {\n               // We don't support colors specified via RGB, but parse the\n               // sequence then ignore it in case there are supported \n               // sequences after it\n               if (extendedRGBMarkerSeen)\n               {\n                  extendedRGBColorsSeen++;\n                  if (extendedRGBColorsSeen == 3 /*red, green, blue*/)\n                  {\n                     extendedColor = 0;\n                     extendedRGBMarkerSeen = false;\n                     extendedRGBColorsSeen = 0;\n                  }\n               }\n               else \n               {\n                  if (extendedColor == FOREGROUND_EXT)\n                  {\n                     if (codeVal >= 0 && codeVal <= 255)\n                     {\n                        currentColor_.setExtended(codeVal);\n                        resetForeground();\n                        clazzes_.add(Color.clazzForColorIndex(codeVal, \n                              false /*background*/));\n                     }\n                  }\n                  else\n                  {\n                     if (codeVal >= 0 && codeVal <= 255)\n                     {\n                        currentBgColor_.setExtended(codeVal);\n                        resetBackground();\n                        clazzes_.add(Color.clazzForColorIndex(codeVal, \n                              true /*background*/));\n                     }\n                  }\n                  extendedColor = 0;\n                  extendedMarkerSeen = false;\n               }\n            }\n         }\n         else if (codeVal == RESET)\n         {\n            inverted_ = false;\n            currentColor_.reset();\n            currentBgColor_.reset();\n            clazzes_.clear();\n         }\n         else if (codeVal == BOLD)\n         {\n            clazzes_.add(BOLD_STYLE);\n         }\n         else if (codeVal == BLURRED)\n         {\n            // NYI clazzes_.add(BLURRED_STYLE);\n         }\n         else if (codeVal == BOLD_BLURRED_OFF)\n         {\n            clazzes_.remove(BOLD_STYLE);\n            // NYI clazzes_.remove(BLURRED_STYLE);\n         }\n         else if (codeVal == ITALIC)\n         {\n            clazzes_.add(ITALIC_STYLE);\n         }\n         else if (codeVal == ITALIC_OFF)\n         {\n            clazzes_.remove(ITALIC_STYLE);\n         }\n         else if (codeVal == UNDERLINE)\n         {\n            clazzes_.add(UNDERLINE_STYLE);\n         }\n         else if (codeVal == UNDERLINE_OFF)\n         {\n            clazzes_.remove(UNDERLINE_STYLE);\n         }\n         else if (codeVal == BLINKSLOW || codeVal == BLINKFAST)\n         {\n            clazzes_.add(BLINK_STYLE);\n         }\n         else if (codeVal == BLINK_OFF)\n         {\n            clazzes_.remove(BLINK_STYLE);\n         }\n         else if (codeVal == INVERSE)\n         {\n            if (!inverted_)\n            {\n               resetForeground();\n               resetBackground();\n               Color newFg = invertFgColor();\n               Color newBg = invertBgColor();\n               currentColor_ = newFg;\n               currentBgColor_ = newBg;\n               inverted_ = true;\n            }\n         }\n         else if (codeVal == INVERSE_OFF)\n         {\n            if (inverted_)\n            {\n               resetForeground();\n               resetBackground();\n               Color newFg = invertFgColor();\n               Color newBg = invertBgColor();\n               currentColor_ = newFg;\n               currentBgColor_ = newBg;\n               inverted_ = false;\n            }\n         }\n         else if (codeVal == HIDDEN)\n         {\n            clazzes_.add(HIDDEN_STYLE);\n         }\n         else if (codeVal == HIDDEN_OFF)\n         {\n            clazzes_.remove(HIDDEN_STYLE);\n         }\n         else if (codeVal == STRIKETHROUGH)\n         {\n            clazzes_.add(STRIKETHROUGH_STYLE);\n         }\n         else if (codeVal == STRIKETHROUGH_OFF)\n         {\n            clazzes_.remove(STRIKETHROUGH_STYLE);\n         }\n         else if (Color.isFgColorCode(codeVal))\n         {\n            currentColor_.setCode(codeVal);\n            resetForeground();\n            clazzes_.add(clazzForColor(codeVal));\n         }\n         else if (Color.isBgColorCode(codeVal))\n         {\n            currentBgColor_ = new Color(false, codeVal);\n            resetBackground();\n            clazzes_.add(clazzForBgColor(codeVal));\n         }\n         else if (codeVal == RESET_FOREGROUND)\n         {\n            currentColor_.reset();\n            resetForeground();\n         }\n         else if (codeVal == RESET_BACKGROUND)\n         {\n            currentBgColor_.reset();\n            resetBackground();\n         }\n         else if (codeVal == FOREGROUND_EXT)\n         {\n           extendedColor = codeVal;\n           extendedMarkerSeen = false;\n         }\n         else if (codeVal == BACKGROUND_EXT)\n         {\n           extendedColor = codeVal;\n           extendedMarkerSeen = false;\n         }\n         else\n         {\n            // ignore all others\n         }\n      }\n      return getStyle();\n   }\n",
    "new_code_raw": "   public AnsiClazzes processCode(String code)\n   {\n      if (code == null || code.length() < 2)\n         return null;\n      if (code.charAt(0) != '\\033' && code.charAt(code.length() - 1) != 'm')\n         return null;\n      if (code.length() == 2)\n      {\n         clazzes_.clear(); // CSIm is equivalent to CSI0m, which is 'reset'\n         blockClazzes_.clear();\n         return null;\n      }\n      \n      int extendedColor = 0;\n      boolean extendedMarkerSeen = false;\n      boolean extendedRGBMarkerSeen = false;\n      int extendedRGBColorsSeen = 0;\n      \n      String[] tokens = code.substring(2, code.length() - 1).split(\";\");\n      for (String token : tokens)\n      {\n         int codeVal = StringUtil.parseInt(token,  -1);\n         if (codeVal == -1)\n            continue;\n\n         if (extendedColor > 0)\n         {\n            if (!extendedMarkerSeen && !extendedRGBMarkerSeen)\n            {\n               if (codeVal == EXT_BY_INDEX)\n               {\n                  extendedMarkerSeen = true;\n                  continue;\n               }\n               else if (codeVal == EXT_BY_RGB)\n               {\n                  extendedRGBMarkerSeen = true;\n                  extendedRGBColorsSeen = 0;\n               }\n               else\n               {\n                  // unknown extended color format; hard to recover so\n                  // just reset back to defaults and return\n                  clazzes_.clear();\n                  blockClazzes_.clear();\n                  return null;\n               }\n            }\n            else\n            {\n               // We don't support colors specified via RGB, but parse the\n               // sequence then ignore it in case there are supported \n               // sequences after it\n               if (extendedRGBMarkerSeen)\n               {\n                  extendedRGBColorsSeen++;\n                  if (extendedRGBColorsSeen == 3 /*red, green, blue*/)\n                  {\n                     extendedColor = 0;\n                     extendedRGBMarkerSeen = false;\n                     extendedRGBColorsSeen = 0;\n                  }\n               }\n               else \n               {\n                  if (extendedColor == FOREGROUND_EXT)\n                  {\n                     if (codeVal >= 0 && codeVal <= 255)\n                     {\n                        currentColor_.setExtended(codeVal);\n                        resetForeground();\n                        clazzes_.add(Color.clazzForColorIndex(codeVal, \n                              false /*background*/));\n                     }\n                  }\n                  else\n                  {\n                     if (codeVal >= 0 && codeVal <= 255)\n                     {\n                        currentBgColor_.setExtended(codeVal);\n                        resetBackground();\n                        clazzes_.add(Color.clazzForColorIndex(codeVal, \n                              true /*background*/));\n                     }\n                  }\n                  extendedColor = 0;\n                  extendedMarkerSeen = false;\n               }\n            }\n         }\n         else if (codeVal == RESET)\n         {\n            inverted_ = false;\n            currentColor_.reset();\n            currentBgColor_.reset();\n            clazzes_.clear();\n            blockClazzes_.clear();\n         }\n         else if (codeVal == BOLD)\n         {\n            clazzes_.add(BOLD_STYLE);\n         }\n         else if (codeVal == BLURRED)\n         {\n            // NYI clazzes_.add(BLURRED_STYLE);\n         }\n         else if (codeVal == BOLD_BLURRED_OFF)\n         {\n            clazzes_.remove(BOLD_STYLE);\n            // NYI clazzes_.remove(BLURRED_STYLE);\n         }\n         else if (codeVal == ITALIC)\n         {\n            clazzes_.add(ITALIC_STYLE);\n         }\n         else if (codeVal == ITALIC_OFF)\n         {\n            clazzes_.remove(ITALIC_STYLE);\n         }\n         else if (codeVal == UNDERLINE)\n         {\n            clazzes_.add(UNDERLINE_STYLE);\n         }\n         else if (codeVal == UNDERLINE_OFF)\n         {\n            clazzes_.remove(UNDERLINE_STYLE);\n         }\n         else if (codeVal == BLINKSLOW || codeVal == BLINKFAST)\n         {\n            clazzes_.add(BLINK_STYLE);\n         }\n         else if (codeVal == BLINK_OFF)\n         {\n            clazzes_.remove(BLINK_STYLE);\n         }\n         else if (codeVal == INVERSE)\n         {\n            if (!inverted_)\n            {\n               resetForeground();\n               resetBackground();\n               Color newFg = invertFgColor();\n               Color newBg = invertBgColor();\n               currentColor_ = newFg;\n               currentBgColor_ = newBg;\n               inverted_ = true;\n            }\n         }\n         else if (codeVal == INVERSE_OFF)\n         {\n            if (inverted_)\n            {\n               resetForeground();\n               resetBackground();\n               Color newFg = invertFgColor();\n               Color newBg = invertBgColor();\n               currentColor_ = newFg;\n               currentBgColor_ = newBg;\n               inverted_ = false;\n            }\n         }\n         else if (codeVal == HIDDEN)\n         {\n            clazzes_.add(HIDDEN_STYLE);\n         }\n         else if (codeVal == HIDDEN_OFF)\n         {\n            clazzes_.remove(HIDDEN_STYLE);\n         }\n         else if (codeVal == STRIKETHROUGH)\n         {\n            clazzes_.add(STRIKETHROUGH_STYLE);\n         }\n         else if (codeVal == STRIKETHROUGH_OFF)\n         {\n            clazzes_.remove(STRIKETHROUGH_STYLE);\n         }\n         else if (Color.isFgColorCode(codeVal))\n         {\n            currentColor_.setCode(codeVal);\n            resetForeground();\n            clazzes_.add(clazzForColor(codeVal));\n         }\n         else if (Color.isBgColorCode(codeVal))\n         {\n            currentBgColor_ = new Color(false, codeVal);\n            resetBackground();\n            clazzes_.add(clazzForBgColor(codeVal));\n         }\n         else if (codeVal == RESET_FOREGROUND)\n         {\n            currentColor_.reset();\n            resetForeground();\n         }\n         else if (codeVal == RESET_BACKGROUND)\n         {\n            currentBgColor_.reset();\n            resetBackground();\n         }\n         else if (codeVal == FOREGROUND_EXT)\n         {\n           extendedColor = codeVal;\n           extendedMarkerSeen = false;\n         }\n         else if (codeVal == BACKGROUND_EXT)\n         {\n           extendedColor = codeVal;\n           extendedMarkerSeen = false;\n         }\n         else if (codeVal == FONT_NINE)\n         {\n            blockClazzes_.add(FONT_NINE_STYLE);\n         }\n         else if (codeVal == DEFAULT_FONT || \n               (codeVal >= FONT_ONE && codeVal <= FONT_EIGHT))\n         {\n            blockClazzes_.remove(FONT_NINE_STYLE);\n         }\n         else\n         {\n            // ignore all others\n         }\n      }\n      return getStyles();\n   }\n"
  },
  {
    "id": "RSB4760_apq8016_frameworks_support-14-Associations-FirstSentence",
    "old_comment_raw": "Gets the current route provider descriptor.",
    "new_comment_raw": "Gets the provider's descriptor.",
    "old_code_raw": "    public final RouteProviderDescriptor getDescriptor() {\n        return mDescriptor;\n    }\n",
    "new_code_raw": "    public final ProviderDescriptor getDescriptor() {\n        return mDescriptor;\n    }\n\n"
  },
  {
    "id": "runelite_runelite-143-FirstSentence-0",
    "old_comment_raw": "Convert a quantity to a nicely formatted stack size.",
    "new_comment_raw": "Convert a quantity to a nicely formatted stack size.",
    "old_code_raw": "\tpublic static String quantityToStackSize(int quantity)\n\t{\n\t\tif (quantity < 0)\n\t\t{\n\t\t\t// Integer.MIN_VALUE = -1 * Integer.MIN_VALUE so we need to correct for it.\n\t\t\treturn \"-\" + quantityToStackSize(quantity == Integer.MIN_VALUE ? Integer.MAX_VALUE : -quantity);\n\t\t}\n\t\telse if (quantity < 10_000)\n\t\t{\n\t\t\treturn NUMBER_FORMATTER.format(quantity);\n\t\t}\n\n\t\tString suffix = SUFFIXES[0];\n\t\tint divideBy = 1;\n\n\t\t// determine correct suffix by iterating backward through the list\n\t\t// of suffixes until the suffix results in a value >= 1\n\t\tfor (int i = (SUFFIXES.length - 1); i >= 0; i--)\n\t\t{\n\t\t\tdivideBy = (int) Math.pow(10, i * 3);\n\t\t\tif ((float) quantity / divideBy >= 1)\n\t\t\t{\n\t\t\t\tsuffix = SUFFIXES[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// get locale formatted string\n\t\tString formattedString = NUMBER_FORMATTER.format((float) quantity / divideBy);\n\n\t\t// strip down any digits past the 4 first\n\t\tformattedString = (formattedString.length() > 4 ? formattedString.substring(0, 4) : formattedString);\n\n\t\t// make sure the last character is not a \".\"\n\t\treturn (formattedString.endsWith(\".\") ? formattedString.substring(0, 3) : formattedString) + suffix;\n\t}\n",
    "new_code_raw": "\tpublic static String quantityToStackSize(long quantity)\n\t{\n\t\tif (quantity < 0)\n\t\t{\n\t\t\t// Long.MIN_VALUE = -1 * Long.MIN_VALUE so we need to correct for it.\n\t\t\treturn \"-\" + quantityToStackSize(quantity == Long.MIN_VALUE ? Long.MAX_VALUE : -quantity);\n\t\t}\n\t\telse if (quantity < 10_000)\n\t\t{\n\t\t\treturn NUMBER_FORMATTER.format(quantity);\n\t\t}\n\n\t\tString suffix = SUFFIXES[0];\n\t\tlong divideBy = 1;\n\n\t\t// determine correct suffix by iterating backward through the list\n\t\t// of suffixes until the suffix results in a value >= 1\n\t\tfor (int i = (SUFFIXES.length - 1); i >= 0; i--)\n\t\t{\n\t\t\tdivideBy = (long) Math.pow(10, i * 3);\n\t\t\tif ((double) quantity / divideBy >= 1)\n\t\t\t{\n\t\t\t\tsuffix = SUFFIXES[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// get locale formatted string\n\t\tString formattedString = NUMBER_FORMATTER.format((double) quantity / divideBy);\n\n\t\t// strip down any digits past the 4 first\n\t\tformattedString = (formattedString.length() > 4 ? formattedString.substring(0, 4) : formattedString);\n\n\t\t// make sure the last character is not a \".\"\n\t\treturn (formattedString.endsWith(\".\") ? formattedString.substring(0, 3) : formattedString) + suffix;\n\t}\n"
  },
  {
    "id": "nelsonsilva_vaadin-158-Associations-FirstSentence",
    "old_comment_raw": "Gets the 'right' CSS-attributes value in specified units.",
    "new_comment_raw": "Gets the 'right' attributes value in current units.",
    "old_code_raw": "        public float getRightValue() {\n            return rightValue == null ? 0 : rightValue.floatValue();\n        }\n",
    "new_code_raw": "        public Float getRightValue() {\n            return rightValue;\n        }\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-1740-FirstSentence-0",
    "old_comment_raw": "Test whether two geometries, not of type GeometryCollection are equal.",
    "new_comment_raw": "Test whether two geometries, not of type GeometryCollection are equal.",
    "old_code_raw": "\tprotected boolean testSimpleGeometryEquality(Geometry geom1, Geometry geom2) {\n\t\t//return geom1.equals(geom2);\n\t\treturn testTypeAndVertexEquality( geom1, geom2 ) && geom1.getSRID() == geom2.getSRID();\n\t}\n",
    "new_code_raw": "\tprotected boolean testSimpleGeometryEquality(Geometry geom1, Geometry geom2) {\n\t\t//return geom1.equals(geom2);\n\t\treturn testTypeAndVertexEquality( geom1, geom2 ) && equalSRID( geom1, geom2 );\n\t}\n"
  },
  {
    "id": "ushahidi_Crowdmap-Java-7-Associations-FirstSentence",
    "old_comment_raw": "Image items",
    "new_comment_raw": "Media items",
    "old_code_raw": "    public List<Image> getMedia() {\n        return this.media;\n    }\n",
    "new_code_raw": "    public List<Media> getMedia() {\n        return this.media;\n    }\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-1621-FirstSentence-0",
    "old_comment_raw": "A case-insensitive \"like\", similar to Postgres ilike operator",
    "new_comment_raw": "A case-insensitive \"like\", similar to Postgres ilike operator",
    "old_code_raw": "\tpublic static Criterion ilike(String propertyName, Object value) {\n\t\tif ( value == null ) {\n\t\t\tthrow new IllegalArgumentException( \"Comparison value passed to ilike cannot be null\" );\n\t\t}\n\t\treturn ilike( propertyName, value.toString(), MatchMode.ANYWHERE );\n\t}\n",
    "new_code_raw": "\tpublic static Criterion ilike(String propertyName, Object value) {\n\t\tif ( value == null ) {\n\t\t\tthrow new IllegalArgumentException( \"Comparison value passed to ilike cannot be null\" );\n\t\t}\n\t\treturn ilike( propertyName, value.toString(), MatchMode.EXACT );\n\t}\n"
  },
  {
    "id": "jenkinsci_testlink-plugin-8-Associations-FirstSentence",
    "old_comment_raw": "Retrieves the parsed Test Suite.",
    "new_comment_raw": "Retrieves a linked list with parsed Test Suites.",
    "old_code_raw": "\tpublic TestSuite getSuite()\n\t{\n\t\treturn this.testSuite;\n\t}\n",
    "new_code_raw": "\tpublic List<TestSuite> getSuite()\n\t{\n\t\treturn this.testSuites;\n\t}\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1739-FirstSentence-0",
    "old_comment_raw": "Converts the first character of the input into upper case .",
    "new_comment_raw": "Converts the first character of the input into upper case .",
    "old_code_raw": "  public String applyClassNamingPolicy(String input) {\n    if (input != null && input.length() > 0) {\n      String output = input.substring(0, 1).toUpperCase() + input.substring(1);\n      // class name can't have . so if dot exists remove the same\n      output = output.replace(\".\", \"\");\n      \n      return output;\n    }\n    else {\n      throw new CodeGenerationException(\"Error converting input to first letter caps becuase of null or empty input\");\n    }\n  }\n",
    "new_code_raw": "  public String applyClassNamingPolicy(String input) {\n    if (input != null && input.length() > 0) {\n      if (\"string\".equalsIgnoreCase(input)) {\n        return \"string\";\n      }\n      \n      String output = input.substring(0, 1).toUpperCase() + input.substring(1);\n      // class name can't have . so if dot exists remove the same\n      output = output.replace(\".\", \"\");\n      \n      return output;\n    }\n    else {\n      throw new CodeGenerationException(\"Error converting input to first letter caps becuase of null or empty input\");\n    }\n  }\n"
  },
  {
    "id": "yahoo_elide-2-Associations-FirstSentence",
    "old_comment_raw": "Checks if this persistent resource's underlying entity is sharable.",
    "new_comment_raw": "Checks if this persistent resource's underlying entity is shareable.",
    "old_code_raw": "    private boolean isShareable() {\n        return getRequestScope().getDictionary().isSharable(obj.getClass());\n    }\n",
    "new_code_raw": "    private boolean isShareable() {\n        return getRequestScope().getDictionary().isShareable(obj.getClass());\n    }\n\n"
  },
  {
    "id": "Atmosphere_atmosphere-626-FirstSentence-0",
    "old_comment_raw": "This method is used to determine the default CometSupport if all else fails",
    "new_comment_raw": "This method is used to determine the default CometSupport if all else fails",
    "old_code_raw": "    public CometSupport defaultCometSupport(final boolean preferBlocking) {\n        if (!preferBlocking && testClassExists(SERVLET_30)) {\n            return new Servlet30CometSupport(config);\n        } else {\n            return new BlockingIOCometSupport(config);\n        }\n    }\n",
    "new_code_raw": "    public CometSupport defaultCometSupport(final boolean preferBlocking) {\n        if (!preferBlocking && testClassExists(SERVLET_30)) {\n            if (detectWebSocketPresent().size() > 0) {\n                return new Servlet30CometSupportWithWebSocket(config);\n            }\n            return new Servlet30CometSupport(config);\n        } else {\n            return new BlockingIOCometSupport(config);\n        }\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2416-FirstSentence-0",
    "old_comment_raw": "NOTE: This compareTo is based on and made to be compatible with the one from IndexedFeatureLabel.",
    "new_comment_raw": "NOTE: For this compareTo, you must have a DocIDAnnotation,",
    "old_code_raw": "  public int compareTo(IndexedWord w) {\n    if (this.equals(IndexedWord.NO_WORD)) {\n      if (w.equals(IndexedWord.NO_WORD)) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n    if (w.equals(IndexedWord.NO_WORD)) {\n      return 1;\n    }\n\n    // Override the default comparator if pseudo-positions are set.\n    // This is needed for splicing trees together awkwardly in OpenIE.\n    if (!Double.isNaN(w.pseudoPosition) || !Double.isNaN(this.pseudoPosition)) {\n      double val = this.pseudoPosition() - w.pseudoPosition();\n      if (val < 0) { return -1; }\n      if (val > 0) { return 1; }\n      else { return 0; }\n    }\n\n    // Otherwise, compare using the normal doc/sentence/token index hierarchy\n    String docID = this.getString(CoreAnnotations.DocIDAnnotation.class);\n    int docComp = docID.compareTo(w.getString(CoreAnnotations.DocIDAnnotation.class));\n    if (docComp != 0) return docComp;\n\n    int sentComp = sentIndex() - w.sentIndex();\n    if (sentComp != 0) return sentComp;\n\n    int indexComp = index() - w.index();\n    if (indexComp != 0) return indexComp;\n\n    return copyCount() - w.copyCount();\n  }\n",
    "new_code_raw": "  public int compareTo(IndexedWord w) {\n    if (this.equals(IndexedWord.NO_WORD)) {\n      if (w.equals(IndexedWord.NO_WORD)) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n    if (w.equals(IndexedWord.NO_WORD)) {\n      return 1;\n    }\n\n    // Override the default comparator if pseudo-positions are set.\n    // This is needed for splicing trees together awkwardly in OpenIE.\n    if (!Double.isNaN(w.pseudoPosition) || !Double.isNaN(this.pseudoPosition)) {\n      double val = this.pseudoPosition() - w.pseudoPosition();\n      if (val < 0) { return -1; }\n      if (val > 0) { return 1; }\n      else { return 0; }\n    }\n\n    // Otherwise, compare using the normal doc/sentence/token index hierarchy\n    String docID = this.getString(CoreAnnotations.DocIDAnnotation.class);\n    int docComp = docID.compareTo(w.getString(CoreAnnotations.DocIDAnnotation.class));\n    if (docComp != 0) return docComp;\n\n    int sentComp = Integer.compare(sentIndex(), w.sentIndex());\n    if (sentComp != 0) return sentComp;\n\n    int indexComp = Integer.compare(index(), w.index());\n    if (indexComp != 0) return indexComp;\n\n    return Integer.compare(copyCount(), w.copyCount());\n  }\n"
  },
  {
    "id": "apache_calcite-774-FirstSentence-0",
    "old_comment_raw": "Returns whether there are any correlating variables in this statement.",
    "new_comment_raw": "Returns whether there are any correlating variables in this statement.",
    "old_code_raw": "    public boolean hasCorrelation() {\n      return !mapCorVarToCorRel.isEmpty();\n    }\n",
    "new_code_raw": "    public boolean hasCorrelation() {\n      return !mapCorToCorRel.isEmpty();\n    }\n"
  },
  {
    "id": "dbremner_fortress-77-Associations-FirstSentence",
    "old_comment_raw": "Gets the contention manager of the invoking Thread.",
    "new_comment_raw": "Gets the contention manager",
    "old_code_raw": "    static public ContentionManager getContentionManager() {\n        ThreadState threadState = BaseTask.getThreadState();\n        return threadState.manager();\n    }\n",
    "new_code_raw": "    static public ContentionManager getContentionManager() {\n        return cm;\n    }\n\n"
  },
  {
    "id": "zaproxy_zaproxy-2013-FirstSentence-0",
    "old_comment_raw": "Returns the  Context with the given name.",
    "new_comment_raw": "Returns the  Context with the given name.",
    "old_code_raw": "    private Context getContext(JSONObject params) throws ApiException {\n        return getContext(params.getString(CONTEXT_NAME));\n    }\n",
    "new_code_raw": "    private Context getContext(JSONObject params) throws ApiException {\n        return ApiUtils.getContextByName(params, CONTEXT_NAME);\n    }\n"
  },
  {
    "id": "sudosurootdev_frameworks_opt_telephony-14-Associations-FirstSentence",
    "old_comment_raw": "Returns whether the broadcast is an emergency (PWS) message type, including test messages, but excluding lower priority Amber alert broadcasts.",
    "new_comment_raw": "Returns whether the broadcast is an emergency (PWS) message type, including test messages and AMBER alerts.",
    "old_code_raw": "    public boolean isEmergencyAlertMessage() {\n        if (!mSmsCbMessage.isEmergencyMessage()) {\n            return false;\n        }\n        SmsCbCmasInfo cmasInfo = mSmsCbMessage.getCmasWarningInfo();\n        if (cmasInfo != null &&\n                cmasInfo.getMessageClass() == SmsCbCmasInfo.CMAS_CLASS_CHILD_ABDUCTION_EMERGENCY) {\n            return false;\n        }\n        return true;\n    }\n",
    "new_code_raw": "    public boolean isEmergencyAlertMessage() {\n        return mSmsCbMessage.isEmergencyMessage();\n    }\n\n"
  },
  {
    "id": "docker_java_docker_java-60-FirstSentence-0",
    "old_comment_raw": "Createa an Add if it matches, or missing if not.",
    "new_comment_raw": "Createa an Add if it matches, or missing if not.",
    "old_code_raw": "        public static Optional<Add> create(String statement) {\n            Matcher matcher = ADD_OR_COPY_PATTERN.matcher(statement.trim());\n            if (!matcher.find()) {\n                return Optional.absent();\n            }\n\n            if (matcher.groupCount() != 3) {\n                throw new DockerClientException(\"Wrong ADD or COPY format\");\n            }\n\n            return Optional.of(new Add(matcher));\n        }\n",
    "new_code_raw": "        public static Optional<Add> create(String statement) {\n            Matcher argumentMatcher = ARGUMENT_TOKENIZER.matcher(statement.trim());\n\n            if (!argumentMatcher.find()) {\n                return Optional.absent();\n            }\n\n            String commandName = argumentMatcher.group();\n            if (!(StringUtils.equals(commandName, \"ADD\") || StringUtils.equals(commandName, \"COPY\"))) {\n                return Optional.absent();\n            }\n\n            String lastToken = null;\n            Collection<String> sources = new ArrayList<>();\n\n            while (argumentMatcher.find()) {\n                if (lastToken != null) {\n                    sources.add(lastToken);\n                }\n                lastToken = argumentMatcher.group().replaceAll(\"(^\\\")|(\\\"$)\", \"\");\n            }\n\n            if (sources.isEmpty()) {\n                throw new DockerClientException(\"Wrong ADD or COPY format\");\n            }\n\n            return Optional.of(new Add(sources, lastToken));\n        }\n"
  },
  {
    "id": "apache_calcite-897-FirstSentence-0",
    "old_comment_raw": "Maps the ordinal of a field pre-flattening to the ordinal of the corresponding field post-flattening, and optionally returns its type.",
    "new_comment_raw": "Maps the ordinal of a field pre-flattening to the ordinal of the corresponding field post-flattening.",
    "old_code_raw": "  protected int getNewForOldInput(int oldOrdinal) {\n    assert currentRel != null;\n    int newOrdinal = 0;\n\n    // determine which input rel oldOrdinal references, and adjust\n    // oldOrdinal to be relative to that input rel\n    RelNode oldInput = null;\n    for (RelNode oldInput1 : currentRel.getInputs()) {\n      RelDataType oldInputType = oldInput1.getRowType();\n      int n = oldInputType.getFieldCount();\n      if (oldOrdinal < n) {\n        oldInput = oldInput1;\n        break;\n      }\n      RelNode newInput = getNewForOldRel(oldInput1);\n      newOrdinal += newInput.getRowType().getFieldCount();\n      oldOrdinal -= n;\n    }\n    assert oldInput != null;\n\n    RelDataType oldInputType = oldInput.getRowType();\n    newOrdinal += calculateFlattenedOffset(oldInputType, oldOrdinal);\n    return newOrdinal;\n  }\n",
    "new_code_raw": "  protected int getNewForOldInput(int oldOrdinal) {\n    return getNewFieldForOldInput(oldOrdinal).i;\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-979-FirstSentence-0",
    "old_comment_raw": "Clone this object.",
    "new_comment_raw": "Clone this object.",
    "old_code_raw": "    public Object clone() {\n        try {\n            return super.clone();\n        } catch (CloneNotSupportedException ex) {\n            throw new InternalError(\"Clone error\");\n        }\n    }\n",
    "new_code_raw": "    public Object clone() {\n        throw ExceptionUtils.unsupportedInGwt();\n//        try {\n//            return super.clone();\n//        } catch (CloneNotSupportedException ex) {\n//            throw new InternalError(\"Clone error\");\n//        }\n    }\n"
  },
  {
    "id": "eclipse_eclipse.platform.resources-92-Associations-FirstSentence",
    "old_comment_raw": "Converts a  URI to an  IPath.",
    "new_comment_raw": "Returns an  IPath representing this  URI in the local file system, or null if this URI does not represent a file in the local file system.",
    "old_code_raw": "\tpublic static IPath toPath(URI uri) {\n\t\tif (uri == null)\n\t\t\treturn null;\n\t\tif (EFS.SCHEME_FILE.equals(uri.getScheme()))\n\t\t\treturn new Path(uri.getSchemeSpecificPart());\n\t\treturn new Path(uri.getPath());\n\t}\n",
    "new_code_raw": "\tpublic static IPath toPath(URI uri) {\n\t\tAssert.isNotNull(uri);\n\t\tif (EFS.SCHEME_FILE.equals(uri.getScheme()))\n\t\t\treturn new Path(uri.getSchemeSpecificPart());\n\t\treturn null;\n\t}\n\n"
  },
  {
    "id": "debezium_debezium-995-FirstSentence-0",
    "old_comment_raw": "Convert the a value representing a Unsigned BIGINT value to the correct Unsigned INT representation.",
    "new_comment_raw": "Convert the a value representing a Unsigned BIGINT value to the correct Unsigned INT representation.",
    "old_code_raw": "    protected Object convertUnsignedBigint(Column column, Field fieldDefn, Object data){\n        if (data == null && !fieldDefn.schema().isOptional()) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0L;\n        }\n\n        if (data instanceof BigDecimal) {\n            return MySqlUnsignedIntegerConverter.convertUnsignedBigint((BigDecimal) data);\n        }\n        else if (data instanceof Number) {\n            return MySqlUnsignedIntegerConverter.convertUnsignedBigint(new BigDecimal(((Number) data).toString()));\n        }\n        else if (data instanceof String) {\n            return MySqlUnsignedIntegerConverter.convertUnsignedBigint(new BigDecimal((String) data));\n        }\n        else {\n            //We continue with the original converting method (numeric) since we have an unsigned Integer\n            return convertNumeric(column, fieldDefn, data);\n        }\n    }\n",
    "new_code_raw": "    protected Object convertUnsignedBigint(Column column, Field fieldDefn, Object data){\n        return convertValue(column, fieldDefn, data, 0L, (r) -> {\n            if (data instanceof BigDecimal) {\n                r.deliver(MySqlUnsignedIntegerConverter.convertUnsignedBigint((BigDecimal)data));\n            }\n            else if (data instanceof Number) {\n                r.deliver(MySqlUnsignedIntegerConverter.convertUnsignedBigint(new BigDecimal(((Number)data).toString())));\n            }\n            else if (data instanceof String) {\n                r.deliver(MySqlUnsignedIntegerConverter.convertUnsignedBigint(new BigDecimal((String)data)));\n            }\n            else {\n                r.deliver(convertNumeric(column, fieldDefn, data));\n            }\n        });\n    }\n"
  },
  {
    "id": "h4ck3rm1k3_josm-older-82-Associations-FirstSentence",
    "old_comment_raw": "Return a list of all selected objects.",
    "new_comment_raw": "Replies an unmodifiable collection of primitives currently selected in this dataset",
    "old_code_raw": "    public Collection<OsmPrimitive> getSelected() {\n        // It would be nice to have this be a copy-on-write list\n        // or an Collections.unmodifiableList().  It would be\n        // much faster for large selections.  May users just\n        // call this, and only check the .size().\n        return new ArrayList<OsmPrimitive>(selectedPrimitives);\n    }\n",
    "new_code_raw": "    public Collection<OsmPrimitive> getSelected() {\n        return Collections.unmodifiableSet(selectedPrimitives);\n    }\n\n"
  },
  {
    "id": "RobotiumTech_robotium-1308-FirstSentence-0",
    "old_comment_raw": "Returns a  List of the  CheckBoxes contained in the current  Activity.",
    "new_comment_raw": "Returns a  List of the  CheckBoxes contained in the current  Activity.",
    "old_code_raw": "\tpublic ArrayList<CheckBox> getCurrentCheckBoxes()\n\t{\n\t\treturn viewFetcher.getCurrentViews(CheckBox.class);\n\t}\n",
    "new_code_raw": "\tpublic ArrayList<CheckBox> getCurrentCheckBoxes() {\n\t\treturn ensureArrayListOrNull(viewFetcher.getCurrentViews(CheckBox.class));\n\t}\n"
  },
  {
    "id": "svn2github_worldwind-14-Associations-FirstSentence",
    "old_comment_raw": "Construct the text for the main label of a graphic.",
    "new_comment_raw": "Construct the text for labels in a Fire Support area graphic.",
    "old_code_raw": "    public String createText(MilStd2525TacticalGraphic graphic)\n    {\n        String functionId = graphic.getFunctionId();\n        if (CircularFireSupportArea.FUNCTION_ID_TARGET.equals(functionId))\n            return graphic.getText();\n        else\n            return createDateRangeText(graphic, functionId);\n    }\n",
    "new_code_raw": "    public String[] createText(MilStd2525TacticalGraphic graphic)\n    {\n        String[] result;\n\n        String functionId = graphic.getFunctionId();\n        if (CircularFireSupportArea.FUNCTION_ID_TARGET.equals(functionId))\n        {\n            result = new String[] { graphic.getText() };\n        }\n        else\n        {\n            boolean useSeparateTimeLabel = this.isShowSeparateTimeLabel(functionId);\n            String mainText = this.createMainText(graphic, functionId, !useSeparateTimeLabel);\n\n            if (useSeparateTimeLabel)\n            {\n                String timeText = this.createTimeRangeText(graphic);\n                result = new String[] { mainText, timeText };\n            }\n            else\n            {\n                result = new String[] { mainText };\n            }\n        }\n        return result;\n    }\n\n"
  },
  {
    "id": "graphql_java_graphql_java-127-FirstSentence-0",
    "old_comment_raw": "Returns a cloned parameters object with the new state",
    "new_comment_raw": "Returns a cloned parameters object with the new state",
    "old_code_raw": "    public InstrumentationFieldCompleteParameters withNewState(InstrumentationState instrumentationState) {\n        return new InstrumentationFieldCompleteParameters(\n                this.executionContext, executionStrategyParameters, this.fieldDef, this.typeInfo, instrumentationState);\n    }\n",
    "new_code_raw": "    public InstrumentationFieldCompleteParameters withNewState(InstrumentationState instrumentationState) {\n        return new InstrumentationFieldCompleteParameters(\n                this.executionContext, executionStrategyParameters, this.fieldDef, this.typeInfo, this.fetchedValue, instrumentationState);\n    }\n"
  },
  {
    "id": "Omegaphora_dalvik-4-Associations-FirstSentence",
    "old_comment_raw": "Returns an array containing Constructor objects describing all constructor which are defined by the receiver.",
    "new_comment_raw": "Returns an array containing  Constructor objects for all constructors declared in the class represented by this  Class.",
    "old_code_raw": "    public Constructor<T>[] getDeclaredConstructors() throws SecurityException {\n        checkDeclaredMemberAccess();\n        return getDeclaredConstructors(this, false);\n    }\n",
    "new_code_raw": "    public Constructor[] getDeclaredConstructors() throws SecurityException {\n        // BEGIN android-note\n        // trying to get closer to the RI which returns a raw constructor array.\n        // copied from newer version of harmony\n        // END android-note\n        checkDeclaredMemberAccess();\n        return getDeclaredConstructors(this, false);\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2600-FirstSentence-0",
    "old_comment_raw": "uploads an image (required)",
    "new_comment_raw": "uploads an image (required)",
    "old_code_raw": "  public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws ApiException {\n    return uploadFileWithRequiredFileWithHttpInfo(petId, file, additionalMetadata).getData();\n      }\n",
    "new_code_raw": "  public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException {\n    return uploadFileWithRequiredFileWithHttpInfo(petId, requiredFile, additionalMetadata).getData();\n      }\n"
  },
  {
    "id": "apache_kylin-528-FirstSentence-0",
    "old_comment_raw": "Compares the bytes in this object to the specified byte array",
    "new_comment_raw": "Define the sort order of the BytesWritable.",
    "old_code_raw": "    public int compareTo(final byte[] that) {\n        return WritableComparator.compareBytes(this.data, this.offset, this.length, that, 0, that.length);\n    }\n",
    "new_code_raw": "    public int compareTo(ByteArrayWritable that) {\n        return WritableComparator.compareBytes(this.data, this.offset, this.length, that.data, that.offset,\n                that.length);\n    }\n"
  },
  {
    "id": "querydsl_querydsl-533-FirstSentence-0",
    "old_comment_raw": "Create the intersection of the given arguments",
    "new_comment_raw": "Create the intersection of the given arguments",
    "old_code_raw": "    public static Predicate and(Predicate left, Predicate right){\n        return new PredicateOperation(Ops.AND, left, right);\n    }\n",
    "new_code_raw": "    public static Predicate and(Predicate left, Predicate right){\n        return PredicateOperation.create(Ops.AND, left, right);\n    }\n"
  },
  {
    "id": "google_iosched-19-Associations-FirstSentence",
    "old_comment_raw": "Whether to display the WelcomeActivity.",
    "new_comment_raw": "Tracks whether to display this activity.",
    "old_code_raw": "    public static boolean shouldDisplay(Context context) {\n        WelcomeActivityContent fragment = getCurrentFragment(context);\n        if (fragment == null) {\n            return false;\n        }\n        return true;\n    }\n",
    "new_code_raw": "    public static boolean shouldDisplay(Context context) {\n        WelcomeActivityContent fragment = getCurrentFragment(context);\n        return fragment != null;\n    }\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-336-FirstSentence-0",
    "old_comment_raw": "Invalidates any  #registerPendingPut(SessionImplementor, Object, long) previously registered pending puts and disables further registrations ensuring a subsequent call to  #acquirePutFromLoadLock(SessionImplementor, Object, long) will return false.",
    "new_comment_raw": "Invalidates any  #registerPendingPut(SessionImplementor, Object, long) previously registered pending puts and disables further registrations ensuring a subsequent call to  #acquirePutFromLoadLock(SessionImplementor, Object, long) will return false.",
    "old_code_raw": "\tpublic boolean beginInvalidatingKey(Object key, Object lockOwner) {\n\t\tfor (;;) {\n\t\t\tPendingPutMap pending = new PendingPutMap(null);\n\t\t\tPendingPutMap prev = pendingPuts.putIfAbsent(key, pending);\n\t\t\tif (prev != null) {\n\t\t\t\tpending = prev;\n\t\t\t}\n\t\t\tif (pending.acquireLock(60, TimeUnit.SECONDS)) {\n\t\t\t\ttry {\n\t\t\t\t\tif (pending.isRemoved()) {\n\t\t\t\t\t\tif (trace) {\n\t\t\t\t\t\t\tlog.tracef(\"Record removed when waiting for the lock.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tlong now = System.currentTimeMillis();\n\t\t\t\t\tpending.invalidate(now, expirationPeriod);\n\t\t\t\t\tpending.addInvalidator(lockOwner, now, expirationPeriod);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tpending.releaseLock();\n\t\t\t\t}\n\t\t\t\tif (trace) {\n\t\t\t\t\tlog.tracef(\"beginInvalidatingKey(%s#%s, %s) ends with %s\", cache.getName(), key, lockOwner, pending);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlog.tracef(\"beginInvalidatingKey(%s#%s, %s) failed to acquire lock\", cache.getName(), key);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n",
    "new_code_raw": "\tpublic boolean beginInvalidatingKey(Object lockOwner, Object key) {\n\t\treturn beginInvalidatingWithPFER(lockOwner, key, null);\n\t}\n"
  },
  {
    "id": "JetBrains_jdk8u_jaxp-45-Associations-FirstSentence",
    "old_comment_raw": "get all built-in DVs, which are stored in a Map keyed by the name",
    "new_comment_raw": "get all built-in DVs, which are stored in a hashtable keyed by the name",
    "old_code_raw": "    @Override\n    public Map<String, DatatypeValidator> getBuiltInTypes() {\n        final HashMap<String, DatatypeValidator> toReturn = new HashMap<>(fBuiltInTypes);\n        toReturn.putAll(XML11BUILTINTYPES);\n        return toReturn;\n    }\n",
    "new_code_raw": "    public Hashtable getBuiltInTypes() {\n        Hashtable toReturn = (Hashtable)fBuiltInTypes.clone();\n        Enumeration xml11Keys = fXML11BuiltInTypes.keys();\n        while (xml11Keys.hasMoreElements()) {\n            Object key = xml11Keys.nextElement();\n            toReturn.put(key, fXML11BuiltInTypes.get(key));\n        }\n        return toReturn;\n    }\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-1748-FirstSentence-0",
    "old_comment_raw": "Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.",
    "new_comment_raw": "Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.",
    "old_code_raw": "  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n\n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n\n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1:\n          { return tokenFactory.makeToken(yytext(), yychar, yylength());\n          }\n        case 4: break;\n        case 2:\n          { return tokenFactory.makeToken(NEWLINE, yychar, yylength());\n          }\n        case 5: break;\n        case 3:\n          {\n          }\n        case 6: break;\n        default:\n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return null;\n              }\n          }\n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n",
    "new_code_raw": "  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n              {\n                return null;\n              }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { return tokenFactory.makeToken(yytext(), yychar, yylength());\n            }\n          case 4: break;\n          case 2: \n            { return tokenFactory.makeToken(NEWLINE, yychar, yylength());\n            }\n          case 5: break;\n          case 3: \n            { \n            }\n          case 6: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n"
  },
  {
    "id": "apache_lenya-335-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Get the line number",
    "old_code_raw": "    public final int getEndLine() {\n        return bufline[bufpos];\n    }\n",
    "new_code_raw": "    public final int getEndLine() {\n        return this.bufline[this.bufpos];\n    }\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2379-FirstSentence-0",
    "old_comment_raw": "Open a BufferedReader to a File.",
    "new_comment_raw": "Open a BufferedReader to a File.",
    "old_code_raw": "  public static BufferedReader readerFromFile(File file, String encoding) {\n    InputStream is = null;\n    try {\n      is = inputStreamFromFile(file);\n      return new BufferedReader(new InputStreamReader(is, encoding));\n    } catch (IOException ioe) {\n      IOUtils.closeIgnoringExceptions(is);\n      throw new RuntimeIOException(ioe);\n    }\n  }\n",
    "new_code_raw": "  public static BufferedReader readerFromFile(File file, String encoding) {\n    InputStream is = null;\n    try {\n      is = inputStreamFromFile(file);\n      if (encoding == null) {\n        return new BufferedReader(new InputStreamReader(is));\n      } else {\n        return new BufferedReader(new InputStreamReader(is, encoding));\n      }\n    } catch (IOException ioe) {\n      IOUtils.closeIgnoringExceptions(is);\n      throw new RuntimeIOException(ioe);\n    }\n  }\n"
  },
  {
    "id": "apache_clerezza-52-Associations-FirstSentence",
    "old_comment_raw": "Converts a node to a BlankNode if it is a Blank Node otherwise to a Iri.",
    "new_comment_raw": "Converts a node to a BNode if it is a Blank Node otherwise to a UriRef.",
    "old_code_raw": "    public BlankNodeOrIri convertNonLiteral(Node node) {\n        if (node == null) {\n            throw new IllegalArgumentException(\"null argument not allowed\");\n        }\n        if (node.isBlank()) {\n            return convertJenaNode2TriaBlankNode(node);\n        }\n        if (node.isURI()) {\n            return convertJenaUri2UriRef(node);\n        }\n        throw new RuntimeException(\"cannot convert \" + node + \" to BlankNodeOrIri\");\n    }\n",
    "new_code_raw": "    public NonLiteral convertNonLiteral(Node node) {\n        if (node == null) {\n            throw new IllegalArgumentException(\"null argument not allowed\");\n        }\n        if (node.isBlank()) {\n            return convertJenaNode2TriaBlankNode(node);\n        }\n        if (node.isURI()) {\n            return convertJenaUri2UriRef(node);\n        }\n        throw new RuntimeException(\"cannot convert \" + node + \" to NonLiteral\");\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2014-FirstSentence-0",
    "old_comment_raw": "Test serialization of outer string types",
    "new_comment_raw": "Test serialization of outer string types",
    "old_code_raw": "    public String fakeOuterStringSerialize(String body) throws ApiException {\n        ApiResponse<String> resp = fakeOuterStringSerializeWithHttpInfo(body);\n        return resp.getData();\n    }\n",
    "new_code_raw": "    public String fakeOuterStringSerialize(String body) throws ApiException {\n        ApiResponse<String> localVarResp = fakeOuterStringSerializeWithHttpInfo(body);\n        return localVarResp.getData();\n    }\n"
  },
  {
    "id": "Graylog2_graylog2-server-22-Associations-FirstSentence",
    "old_comment_raw": "Check if the Elasticsearch  org.elasticsearch.node.Node is connected and that there are other nodes in the cluster.",
    "new_comment_raw": "Check if Elasticsearch is available and that there are data nodes in the cluster.",
    "old_code_raw": "    public boolean isConnected() {\n        Map<String, DiscoveryNode> nodeMap = nodes.get();\n        return nodeMap != null && !nodeMap.isEmpty();\n    }\n",
    "new_code_raw": "    public boolean isConnected() {\n        final Health request = new Health.Builder()\n                .local()\n                .timeout(Ints.saturatedCast(requestTimeout.toSeconds()))\n                .build();\n\n        final JestResult result = JestUtils.execute(jestClient, request, () -> \"Couldn't check connection status of Elasticsearch\");\n        final int numberOfDataNodes = Optional.of(result.getJsonObject())\n            .map(json -> asInteger(json.get(\"number_of_data_nodes\")))\n            .orElse(0);\n        return numberOfDataNodes > 0;\n    }\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-1938-FirstSentence-0",
    "old_comment_raw": "Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.",
    "new_comment_raw": "Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.",
    "old_code_raw": "  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          int zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 38: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '/');\n                  }\n                  if (normalizeSpace) {\n                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 55: break;\n        case 43: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 9;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 10;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { // try to work around an apparent jflex bug where it\n                          // gets a space at the token end by getting\n                          // wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n\t\t\t  return getNext();\n          }\n        case 56: break;\n        case 11: \n          { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 57: break;\n        case 19: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 58: break;\n        case 8: \n          { return handleQuotes(yytext(), false);\n          }\n        case 59: break;\n        case 35: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), false);\n          }\n        case 60: break;\n        case 27: \n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 61: break;\n        case 33: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 62: break;\n        case 49: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNormalizedAmpNext();\n          }\n        case 63: break;\n        case 36: \n          { return getNormalizedAmpNext();\n          }\n        case 64: break;\n        case 23: \n          { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n          }\n        case 65: break;\n        case 37: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '/');\n                  }\n                  if (normalizeSpace) {\n                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 66: break;\n        case 53: \n          // lookahead expression with fixed lookahead length\n          yypushback(4);\n          { return getNext();\n          }\n        case 67: break;\n        case 46: \n          // lookahead expression with fixed lookahead length\n          yypushback(2);\n          { return getNext();\n          }\n        case 68: break;\n        case 42: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 15;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 69: break;\n        case 41: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 16;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 17;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 70: break;\n        case 40: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 13;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 71: break;\n        case 3: \n          { return getNext();\n          }\n        case 72: break;\n        case 24: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext();\n          }\n        case 73: break;\n        case 51: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 74: break;\n        case 26: \n          { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n          }\n        case 75: break;\n        case 6: \n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 76: break;\n        case 29: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 3;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 4;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 77: break;\n        case 16: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 78: break;\n        case 2: \n          { return getNext(\"<\", yytext());\n          }\n        case 79: break;\n        case 48: \n          { yypushback(2) ; return getNext();\n          }\n        case 80: break;\n        case 30: \n          { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 81: break;\n        case 18: \n          { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 82: break;\n        case 54: \n          { String txt = yytext();\n                          if (normalizeSpace) {\n                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 83: break;\n        case 50: \n          { yypushback(3) ; return getNext();\n          }\n        case 84: break;\n        case 25: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), true);\n          }\n        case 85: break;\n        case 39: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 5;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 6;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n          }\n        case 86: break;\n        case 21: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 87: break;\n        case 17: \n          { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 88: break;\n        case 13: \n          { return handleEllipsis(yytext());\n          }\n        case 89: break;\n        case 34: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 1;\n          { /* invert quote - often but not always right */\n                  return handleQuotes(yytext(), true);\n          }\n        case 90: break;\n        case 14: \n          { return normalizeFractions(yytext());\n          }\n        case 91: break;\n        case 15: \n          { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 92: break;\n        case 47: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 11;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 12;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 93: break;\n        case 7: \n          { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n          }\n        case 94: break;\n        case 9: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 95: break;\n        case 45: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                               yytext());\n          }\n        case 96: break;\n        case 4: \n          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n          }\n        case 97: break;\n        case 28: \n          { return getNext(removeSoftHyphens(yytext()), yytext());\n          }\n        case 98: break;\n        case 20: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 99: break;\n        case 12: \n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 100: break;\n        case 31: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 101: break;\n        case 10: \n          { return getNext(\">\", yytext());\n          }\n        case 102: break;\n        case 32: \n          { // this one should only match if we're basically at the end of file\n                          // since the last one matches two things, even newlines\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 103: break;\n        case 22: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 104: break;\n        case 52: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 7;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 8;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { // try to work around an apparent jflex bug where it\n                          // gets a space at the token end by getting\n                          // wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 105: break;\n        case 1: \n          { String str = yytext();\n          int first = str.charAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n          }\n        case 106: break;\n        case 44: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 107: break;\n        case 5: \n          { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n          }\n        case 108: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                if (invertible) {\n            prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n",
    "new_code_raw": "  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          int zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 38: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '/');\n                  }\n                  if (normalizeSpace) {\n                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 55: break;\n        case 43: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 9;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 10;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { // try to work around an apparent jflex bug where it\n                          // gets a space at the token end by getting\n                          // wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n\t\t\t  return getNext();\n          }\n        case 56: break;\n        case 11: \n          { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 57: break;\n        case 19: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 58: break;\n        case 8: \n          { return handleQuotes(yytext(), false);\n          }\n        case 59: break;\n        case 35: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), false);\n          }\n        case 60: break;\n        case 27: \n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 61: break;\n        case 33: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 62: break;\n        case 49: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNormalizedAmpNext();\n          }\n        case 63: break;\n        case 36: \n          { return getNormalizedAmpNext();\n          }\n        case 64: break;\n        case 23: \n          { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n          }\n        case 65: break;\n        case 37: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '/');\n                  }\n                  if (normalizeSpace) {\n                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 66: break;\n        case 53: \n          // lookahead expression with fixed lookahead length\n          yypushback(4);\n          { return getNext();\n          }\n        case 67: break;\n        case 46: \n          // lookahead expression with fixed lookahead length\n          yypushback(2);\n          { return getNext();\n          }\n        case 68: break;\n        case 42: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 15;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 69: break;\n        case 41: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 16;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 17;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 70: break;\n        case 40: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 13;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 71: break;\n        case 3: \n          { return getNext();\n          }\n        case 72: break;\n        case 24: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext();\n          }\n        case 73: break;\n        case 51: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 74: break;\n        case 26: \n          { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n          }\n        case 75: break;\n        case 6: \n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 76: break;\n        case 29: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 3;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 4;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 77: break;\n        case 16: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 78: break;\n        case 2: \n          { return getNext(\"<\", yytext());\n          }\n        case 79: break;\n        case 30: \n          { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 80: break;\n        case 18: \n          { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 81: break;\n        case 54: \n          { String txt = yytext();\n                          if (normalizeSpace) {\n                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 82: break;\n        case 50: \n          { yypushback(3) ; return getNext();\n          }\n        case 83: break;\n        case 25: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), true);\n          }\n        case 84: break;\n        case 39: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 5;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 6;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n          }\n        case 85: break;\n        case 21: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 86: break;\n        case 17: \n          { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 87: break;\n        case 13: \n          { return handleEllipsis(yytext());\n          }\n        case 88: break;\n        case 34: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 1;\n          { /* invert quote - often but not always right */\n                  return handleQuotes(yytext(), true);\n          }\n        case 89: break;\n        case 14: \n          { return normalizeFractions(yytext());\n          }\n        case 90: break;\n        case 15: \n          { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 91: break;\n        case 47: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 11;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 12;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 92: break;\n        case 7: \n          { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n          }\n        case 93: break;\n        case 9: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 94: break;\n        case 45: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                               yytext());\n          }\n        case 95: break;\n        case 4: \n          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n          }\n        case 96: break;\n        case 28: \n          { return getNext(removeSoftHyphens(yytext()), yytext());\n          }\n        case 97: break;\n        case 48: \n          { if (keepAssimilations) {\n                            yypushback(2) ; return getNext(); \n                          } else {\n                            return getNext();\n                          }\n          }\n        case 98: break;\n        case 20: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 99: break;\n        case 12: \n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 100: break;\n        case 31: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 101: break;\n        case 10: \n          { return getNext(\">\", yytext());\n          }\n        case 102: break;\n        case 32: \n          { // this one should only match if we're basically at the end of file\n                          // since the last one matches two things, even newlines\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 103: break;\n        case 22: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 104: break;\n        case 52: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 7;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 8;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { // try to work around an apparent jflex bug where it\n                          // gets a space at the token end by getting\n                          // wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 105: break;\n        case 1: \n          { String str = yytext();\n          int first = str.charAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n          }\n        case 106: break;\n        case 44: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 107: break;\n        case 5: \n          { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n          }\n        case 108: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                if (invertible) {\n            prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n"
  },
  {
    "id": "RSB4760_apq8016_frameworks_support-203-Associations-FirstSentence",
    "old_comment_raw": "Gets the hint text to display in the query text field.",
    "new_comment_raw": "Returns the hint text that will be displayed in the query text field.",
    "old_code_raw": "    public CharSequence getQueryHint() {\n        if (mQueryHint != null) {\n            return mQueryHint;\n        } else if (IS_AT_LEAST_FROYO && mSearchable != null) {\n            CharSequence hint = null;\n            int hintId = mSearchable.getHintId();\n            if (hintId != 0) {\n                hint = getContext().getString(hintId);\n            }\n            return hint;\n        }\n        return null;\n    }\n",
    "new_code_raw": "    public CharSequence getQueryHint() {\n        final CharSequence hint;\n        if (mQueryHint != null) {\n            hint = mQueryHint;\n        } else if (IS_AT_LEAST_FROYO && mSearchable != null && mSearchable.getHintId() != 0) {\n            hint = getContext().getText(mSearchable.getHintId());\n        } else {\n            hint = mDefaultQueryHint;\n        }\n        return hint;\n    }\n\n"
  },
  {
    "id": "SeleniumHQ_selenium-792-FirstSentence-0",
    "old_comment_raw": "Configures and returns a new  XpiDriverService using the default configuration.",
    "new_comment_raw": "Configures and returns a new  XpiDriverService using the default configuration.",
    "old_code_raw": "  public static XpiDriverService createDefaultService() {\n    try {\n      return new XpiDriverService.Builder().usingAnyFreePort().build();\n    } catch (WebDriverException e) {\n      throw new IllegalStateException(e.getMessage(), e.getCause());\n    }\n  }\n",
    "new_code_raw": "  public static XpiDriverService createDefaultService() {\n    try {\n      return new Builder().build();\n    } catch (WebDriverException e) {\n      throw new IllegalStateException(e.getMessage(), e.getCause());\n    }\n  }\n"
  },
  {
    "id": "jenkinsci_scm-api-plugin-9-Associations-FirstSentence",
    "old_comment_raw": "SPI for  #fetchActions(TaskListener).",
    "new_comment_raw": "SPI for  #fetchActions(SCMSourceEvent,TaskListener).",
    "old_code_raw": "    @NonNull\n    protected Map<Class<? extends Action>, Action> retrieveActions(@NonNull TaskListener listener)\n            throws IOException, InterruptedException {\n        return Collections.emptyMap();\n    }\n",
    "new_code_raw": "    @NonNull\n    protected List<Action> retrieveActions(@NonNull SCMSourceEvent event,\n                                           @NonNull TaskListener listener)\n            throws IOException, InterruptedException {\n        return Collections.emptyList();\n    }\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-1101-FirstSentence-0",
    "old_comment_raw": "Obtain a lob creator for the given session.",
    "new_comment_raw": "Obtain a lob creator for the given session.",
    "old_code_raw": "\tpublic static LobCreator getLobCreator(SessionImplementor session) {\n\t\treturn session.getFactory()\n\t\t\t\t.getJdbcServices()\n\t\t\t\t.getLobCreator( session );\n\t}\n",
    "new_code_raw": "\tpublic static LobCreator getLobCreator(SessionImplementor session) {\n\t\treturn session.getFactory()\n\t\t\t\t.getServiceRegistry()\n\t\t\t\t.getService( JdbcServices.class )\n\t\t\t\t.getLobCreator( session );\n\t}\n"
  },
  {
    "id": "twitter_commons-25-Associations-FirstSentence",
    "old_comment_raw": "Creates a  TokenStream that aggregates the outputs of a given set of  TokenStreams.",
    "new_comment_raw": "Creates a  TwitterTokenStream that aggregates the outputs of a given set of  TokenStreams.",
    "old_code_raw": "  public static final TokenStream of(TokenStream... streams) {\n    return new TokenStreamAggregator(streams);\n  }\n",
    "new_code_raw": "  public static final TwitterTokenStream of(TwitterTokenStream... streams) {\n    return new TokenStreamAggregator(streams);\n  }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1922-FirstSentence-0",
    "old_comment_raw": "Get user by user name",
    "new_comment_raw": "Get user by user name",
    "old_code_raw": "  public User getUserByName(String username) throws ApiException {\n    Object localVarPostBody = null;\n    \n    // verify the required parameter 'username' is set\n    if (username == null) {\n      throw new ApiException(400, \"Missing the required parameter 'username' when calling getUserByName\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/user/{username}\"\n      .replaceAll(\"\\\\{\" + \"username\" + \"\\\\}\", apiClient.escapeString(username.toString()));\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/xml\", \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<User> localVarReturnType = new GenericType<User>() {};\n    return apiClient.invokeAPI(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public User getUserByName(String username) throws ApiException {\n    return getUserByNameWithHttpInfo(username).getData();\n      }\n"
  },
  {
    "id": "svn2github_my-5-Associations-FirstSentence",
    "old_comment_raw": "Call  OOXML#isValid(Document) on each XML subdocuments.",
    "new_comment_raw": "Call  Validator#isValid() on each XML subdocuments.",
    "old_code_raw": "    public final Map<String, String> validateSubDocuments() {\r\n        final OOXML ooxml = OOXML.get(getVersion());\r\n        final Map<String, String> res = new HashMap<String, String>();\r\n        for (final String s : subdocNames) {\r\n            if (this.getEntries().contains(s)) {\r\n                final String valid = ooxml.getValidator(this.getDocument(s)).isValid();\r\n                if (valid != null)\r\n                    res.put(s, valid);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n",
    "new_code_raw": "    public final Map<String, String> validateSubDocuments() {\r\n        final OOXML ooxml = this.getFormatVersion().getXML();\r\n        if (!ooxml.canValidate())\r\n            return null;\r\n        final Map<String, String> res = new HashMap<String, String>();\r\n        for (final String s : subdocNames) {\r\n            if (this.getEntries().contains(s)) {\r\n                final String valid = ooxml.getValidator(this.getDocument(s)).isValid();\r\n                if (valid != null)\r\n                    res.put(s, valid);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\n"
  },
  {
    "id": "apache_drill-196-FirstSentence-0",
    "old_comment_raw": "The schema can be a top level schema which doesn't have its own tables, but refers to one of the default sub schemas for table look up.",
    "new_comment_raw": "The schema can be a top level schema which doesn't have its own tables, but refers to one of the default sub schemas for table look up.",
    "old_code_raw": "  public AbstractSchema getDefaultSchema() {\n    return this;\n  }\n",
    "new_code_raw": "  public Schema getDefaultSchema() {\n    return this;\n  }\n"
  },
  {
    "id": "apache_oodt-1-Associations-FirstSentence",
    "old_comment_raw": "Runs validation on  CmdLineArgs and returns the options which failed validation.",
    "new_comment_raw": "Runs validation on  CmdLineArgs and returns the validation results.",
    "old_code_raw": "   public static Set<CmdLineOptionInstance> validate(CmdLineArgs cmdLineArgs) {\n      Validate.notNull(cmdLineArgs);\n\n      HashSet<CmdLineOptionInstance> optionsFailed = new HashSet<CmdLineOptionInstance>();\n      for (CmdLineOptionInstance optionInst : cmdLineArgs\n            .getSpecifiedOptions()) {\n         if (!CmdLineUtils.validate(optionInst)) {\n            optionsFailed.add(optionInst);\n         }\n      }\n      return optionsFailed;\n   }\n",
    "new_code_raw": "   public static List<CmdLineOptionValidator.Result> validate(\n         CmdLineArgs cmdLineArgs) {\n      Validate.notNull(cmdLineArgs);\n\n      List<CmdLineOptionValidator.Result> results = Lists.newArrayList();\n      for (CmdLineOptionInstance optionInst : cmdLineArgs\n            .getSpecifiedOptions()) {\n         results.addAll(CmdLineUtils.validate(optionInst));\n      }\n      return results;\n   }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2540-FirstSentence-0",
    "old_comment_raw": "Place an order for a pet",
    "new_comment_raw": "Place an order for a pet",
    "old_code_raw": "  public Order placeOrder(Order body) throws ApiException {\n    Call call = placeOrderCall(body, null, null);\n    Type returnType = new TypeToken<Order>(){}.getType();\n    return apiClient.execute(call, returnType);\n  }\n",
    "new_code_raw": "  public Order placeOrder(Order body) throws ApiException {\n    ApiResponse<Order> resp = placeOrderWithHttpInfo(body);\n    return resp.getData();\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2623-FirstSentence-0",
    "old_comment_raw": "uploads an image",
    "new_comment_raw": "uploads an image",
    "old_code_raw": "  public void  uploadFile (Long petId, String additionalMetadata, File file) throws ApiException {\n    Object postBody = null;\n    \n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n       throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFile\");\n    }\n    \n\n    // create path and map variables\n    String path = \"/pet/{petId}/uploadImage\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString()));\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n\n    \n\n    \n\n    String[] contentTypes = {\n      \"multipart/form-data\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder builder = MultipartEntityBuilder.create();\n      \n      if (additionalMetadata != null) {\n        builder.addTextBody(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      \n      if (file != null) {\n        builder.addBinaryBody(\"file\", file);\n      }\n      \n\n      HttpEntity httpEntity = builder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n      formParams.put(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata));\n      \n      \n    }\n\n    try {\n      String response = apiInvoker.invokeAPI(basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType);\n      if(response != null){\n        return ;\n      }\n      else {\n        return ;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n",
    "new_code_raw": "  public ApiResponse  uploadFile (Long petId, String additionalMetadata, File file) throws ApiException {\n    Object postBody = null;\n    \n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n       throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFile\");\n    }\n    \n\n    // create path and map variables\n    String path = \"/pet/{petId}/uploadImage\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString()));\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n\n    \n\n    \n\n    String[] contentTypes = {\n      \"multipart/form-data\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder builder = MultipartEntityBuilder.create();\n      \n      if (additionalMetadata != null) {\n        builder.addTextBody(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      \n      if (file != null) {\n        builder.addBinaryBody(\"file\", file);\n      }\n      \n\n      HttpEntity httpEntity = builder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n      formParams.put(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata));\n      \n      \n    }\n\n    try {\n      String response = apiInvoker.invokeAPI(basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType);\n      if(response != null){\n        return (ApiResponse) ApiInvoker.deserialize(response, \"\", ApiResponse.class);\n      }\n      else {\n        return null;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n"
  },
  {
    "id": "google_physical-web-11-Associations-FirstSentence",
    "old_comment_raw": "Check if two PwPairs are equal based on rank.",
    "new_comment_raw": "Check if two PwPairs are equal.",
    "old_code_raw": "  public boolean equals(Object other) {\n    if (other instanceof PwPair) {\n      PwPair otherPwPair = (PwPair) other;\n      return getRank() == otherPwPair.getRank();\n    }\n    return false;\n  }\n",
    "new_code_raw": "  @Override\n  public boolean equals(Object other) {\n    if (this == other) {\n      return true;\n    }\n\n    if (other instanceof PwPair) {\n      PwPair otherPwPair = (PwPair) other;\n      return getRank() == otherPwPair.getRank() &&\n          mUrlDevice.equals(otherPwPair.mUrlDevice) &&\n          mPwsResult.equals(otherPwPair.mPwsResult);\n    }\n    return false;\n  }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-429-FirstSentence-0",
    "old_comment_raw": "Get the textual value of the specified time instant.",
    "new_comment_raw": "Get the textual value of the specified time instant.",
    "old_code_raw": "    public String getAsText(long millis, Locale locale) {\n        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(get(millis));\n    }\n",
    "new_code_raw": "    public String getAsText(long instant, Locale locale) {\n        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(get(instant));\n    }\n"
  },
  {
    "id": "eseawind_opening-trunk-11-Associations-FirstSentence",
    "old_comment_raw": "Reads the provided input stream as a UTF-8 string and then closes the stream.",
    "new_comment_raw": "Reads the provided input stream as a string and then closes the stream.",
    "old_code_raw": "    public static String asString(final InputStream is) throws IOException {\n        final BufferedReader reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\n        try {\n            return reader.readLine();\n        } finally {\n            reader.close();\n        }\n    }\n",
    "new_code_raw": "    public static String asString(final InputStream is, Charset charset) throws IOException {\n        final BufferedReader reader = new BufferedReader(new InputStreamReader(is, charset));\n        try {\n            final String firstLine = reader.readLine();\n            if (firstLine == null) {\n                return \"\";\n            }\n            final StringBuilder builder = new StringBuilder(firstLine);\n            for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                builder.append(EOL);\n                builder.append(line);\n            }\n            return builder.toString();\n        } finally {\n            reader.close();\n        }\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1991-FirstSentence-0",
    "old_comment_raw": "returns the OpenAPI type for the property.",
    "new_comment_raw": "returns the OpenAPI type for the property.",
    "old_code_raw": "    public String getSchemaType(Schema schema) {\n        // TODO better logic to handle compose schema\n        if (schema instanceof ComposedSchema) { // composed schema\n            ComposedSchema cs = (ComposedSchema) schema;\n            if (cs.getAllOf() != null) {\n                for (Schema s : cs.getAllOf()) {\n                    if (s != null) {\n                        // using the first schema defined in allOf\n                        schema = s;\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (StringUtils.isNotBlank(schema.get$ref())) { // reference to another definition/schema\n            // get the schema/model name from $ref\n            String schemaName = ModelUtils.getSimpleRef(schema.get$ref());\n            if (StringUtils.isNotEmpty(schemaName)) {\n                return getAlias(schemaName);\n            } else {\n                LOGGER.warn(\"Error obtaining the datatype from ref:\" + schema.get$ref() + \". Default to 'object'\");\n                return \"object\";\n            }\n        } else { // primitive type or model\n            return getAlias(getPrimitiveType(schema));\n        }\n    }\n",
    "new_code_raw": "    public String getSchemaType(Schema schema) {\n        if (schema instanceof ComposedSchema) { // composed schema\n            ComposedSchema cs = (ComposedSchema) schema;\n            List<Schema> schemas = ModelUtils.getInterfaces(cs);\n            if (cs.getAllOf() != null) {\n                for (Schema s : cs.getAllOf()) {\n                    if (s != null) {\n                        //schema = s;\n                    }\n                    //LOGGER.info(\"ALL OF SCHEMA: {}\", s);\n                }\n\n                LOGGER.info(\"Composed schema not yet supported: {}\", cs);\n                // get the model (allOf)\n                return getAlias(\"UNKNOWN_COMPOSED_SCHMEA\");\n            } else if (cs.getAnyOf() != null) { // anyOf\n                List<String> names = new ArrayList<String>();\n                for (Schema s : schemas) {\n                    if (StringUtils.isNotBlank(s.get$ref())) { // reference to another definition/schema\n                        String schemaName = ModelUtils.getSimpleRef(s.get$ref());\n                        if (StringUtils.isNotEmpty(schemaName)) {\n                            names.add(getAlias(schemaName));\n                        } else {\n                            LOGGER.warn(\"Error obtaining the datatype from ref:\" + schema.get$ref() + \". Default to 'object'\");\n                            return \"object\";\n                        }\n                    } else {\n                        // primitive type or model\n                        names.add(getAlias(getPrimitiveType(s)));\n                    }\n                    return \"anyOf<\" + String.join(\",\", names) + \">\";\n                }\n            } else if (cs.getOneOf() != null) { // oneOf\n                List<String> names = new ArrayList<String>();\n                for (Schema s : schemas) {\n                    if (StringUtils.isNotBlank(s.get$ref())) { // reference to another definition/schema\n                        String schemaName = ModelUtils.getSimpleRef(s.get$ref());\n                        if (StringUtils.isNotEmpty(schemaName)) {\n                            names.add(getAlias(schemaName));\n                        } else {\n                            LOGGER.warn(\"Error obtaining the datatype from ref:\" + schema.get$ref() + \". Default to 'object'\");\n                            return \"object\";\n                        }\n                    } else {\n                        // primitive type or model\n                        names.add(getAlias(getPrimitiveType(s)));\n                    }\n                    return \"oneOf<\" + String.join(\",\", names) + \">\";\n                }\n            }\n        }\n\n        if (StringUtils.isNotBlank(schema.get$ref())) { // reference to another definition/schema\n            // get the schema/model name from $ref\n            String schemaName = ModelUtils.getSimpleRef(schema.get$ref());\n            if (StringUtils.isNotEmpty(schemaName)) {\n                return getAlias(schemaName);\n            } else {\n                LOGGER.warn(\"Error obtaining the datatype from ref:\" + schema.get$ref() + \". Default to 'object'\");\n                return \"object\";\n            }\n        } else { // primitive type or model\n            return getAlias(getPrimitiveType(schema));\n        }\n    }\n"
  },
  {
    "id": "graphql_java_graphql_java-453-FirstSentence-0",
    "old_comment_raw": "Transforms a GrapQLSchema and returns a new GraphQLSchema object.",
    "new_comment_raw": "Transforms a GraphQLSchema and returns a new GraphQLSchema object.",
    "old_code_raw": "    public static GraphQLSchema transformSchema(GraphQLSchema schema, GraphQLTypeVisitor visitor) {\n        SchemaTransformer schemaTransformer = new SchemaTransformer();\n        return schemaTransformer.transform(schema, visitor);\n    }\n",
    "new_code_raw": "    public static GraphQLSchema transformSchema(GraphQLSchema schema, GraphQLTypeVisitor visitor) {\n        return transformSchema(schema, TraversalType.ALL, visitor);\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1505-FirstSentence-0",
    "old_comment_raw": "Convert the given SQLException into Hibernate's JDBCException hierarchy.",
    "new_comment_raw": "Convert the given SQLException into Hibernate's JDBCException hierarchy.",
    "old_code_raw": "\tpublic JDBCException convert(SQLException sqlException, String message, String sql) {\n\t\tString sqlState = JDBCExceptionHelper.extractSqlState( sqlException );\n\n\t\tif ( sqlState != null ) {\n\t\t\tString sqlStateClassCode = JDBCExceptionHelper.determineSqlStateClassCode( sqlState );\n\n\t\t\tif ( sqlStateClassCode != null ) {\n\t\t\t\tif ( SQL_GRAMMAR_CATEGORIES.contains( sqlStateClassCode ) ) {\n\t\t\t\t\treturn new SQLGrammarException( message, sqlException, sql );\n\t\t\t\t}\n\t\t\t\telse if ( INTEGRITY_VIOLATION_CATEGORIES.contains( sqlStateClassCode ) ) {\n\t\t\t\t\tString constraintName = extracter.extractConstraintName( sqlException );\n\t\t\t\t\treturn new ConstraintViolationException( message, sqlException, sql, constraintName );\n\t\t\t\t}\n\t\t\t\telse if ( CONNECTION_CATEGORIES.contains( sqlStateClassCode ) ) {\n\t\t\t\t\treturn new JDBCConnectionException( message, sqlException, sql );\n\t\t\t\t}\n\t\t\t\telse if ( DATA_CATEGORIES.contains( sqlStateClassCode ) ) {\n\t\t\t\t\treturn new DataException( message, sqlException, sql );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( \"40001\".equals( sqlState ) ) {\n\t\t\t\treturn new LockAcquisitionException( message, sqlException, sql );\n\t\t\t}\n\n\t\t\tif ( \"61000\".equals( sqlState ) ) {\n\t\t\t\t// oracle sql-state code for deadlock\n\t\t\t\treturn new LockAcquisitionException( message, sqlException, sql );\n\t\t\t}\n\t\t}\n\n\t\treturn handledNonSpecificException( sqlException, message, sql );\n\t}\n",
    "new_code_raw": "\tpublic JDBCException convert(SQLException sqlException, String message, String sql) {\n\t\tString sqlState = JDBCExceptionHelper.extractSqlState( sqlException );\n\n\t\tif ( sqlState != null ) {\n\t\t\tString sqlStateClassCode = JDBCExceptionHelper.determineSqlStateClassCode( sqlState );\n\n\t\t\tif ( sqlStateClassCode != null ) {\n\t\t\t\tif ( SQL_GRAMMAR_CATEGORIES.contains( sqlStateClassCode ) ) {\n\t\t\t\t\treturn new SQLGrammarException( message, sqlException, sql );\n\t\t\t\t}\n\t\t\t\telse if ( INTEGRITY_VIOLATION_CATEGORIES.contains( sqlStateClassCode ) ) {\n\t\t\t\t\tString constraintName = extracter.extractConstraintName( sqlException );\n\t\t\t\t\treturn new ConstraintViolationException( message, sqlException, sql, constraintName );\n\t\t\t\t}\n\t\t\t\telse if ( CONNECTION_CATEGORIES.contains( sqlStateClassCode ) ) {\n\t\t\t\t\treturn new JDBCConnectionException( message, sqlException, sql );\n\t\t\t\t}\n\t\t\t\telse if ( DATA_CATEGORIES.contains( sqlStateClassCode ) ) {\n\t\t\t\t\treturn new DataException( message, sqlException, sql );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( \"40001\".equals( sqlState ) ) {\n\t\t\t\treturn new LockAcquisitionException( message, sqlException, sql );\n\t\t\t}\n\n\t\t\tif ( \"61000\".equals( sqlState ) ) {\n\t\t\t\t// oracle sql-state code for deadlock\n\t\t\t\treturn new LockAcquisitionException( message, sqlException, sql );\n\t\t\t}\n\n\t\t\tif ( \"40XL1\".equals( sqlState ) || \"40XL2\".equals( sqlState )) {\n\t\t\t\t// Derby \"A lock could not be obtained within the time requested.\"\n\t\t\t\treturn new PessimisticLockException( message, sqlException, sql );\n\t\t\t}\n\t\t}\n\n\t\treturn handledNonSpecificException( sqlException, message, sql );\n\t}\n"
  },
  {
    "id": "alibaba_jstorm-69-FirstSentence-0",
    "old_comment_raw": "create executor to receive tuples and run bolt/spout execute function",
    "new_comment_raw": "create executor to receive tuples and run bolt/spout execute function",
    "old_code_raw": "\tpublic TaskShutdownDameon execute() throws Exception {\n\n\t\t// create heartbeat\n\t\tTaskHeartbeatRunable hb = new TaskHeartbeatRunable(zkCluster,\n\t\t\t\ttopologyid, taskid, uptime, taskStats, taskStatus, stormConf);\n\n\t\tAsyncLoopThread heartbeat_thread = new AsyncLoopThread(hb, false,\n\t\t\t\tThread.MIN_PRIORITY, true);\n\n\t\tIConnection puller = context.bind(topologyid, taskid, false);\n\n\t\tTaskSendTargets sendTargets = echoToSystemBolt();\n\n\t\t// create thread to get tuple from zeroMQ,\n\t\t// and pass the tuple to bolt/spout\n\t\tRunnableCallback baseExecutor = mkExecutor(puller, sendTargets);\n\t\tAsyncLoopThread executor_threads = new AsyncLoopThread(baseExecutor,\n\t\t\t\tfalse, Thread.MAX_PRIORITY, true);\n\n\t\tAsyncLoopThread[] all_threads = { executor_threads, heartbeat_thread };\n\n\t\tLOG.info(\"Finished loading task \" + componentid + \":\" + taskid);\n\n\t\treturn getShutdown(all_threads, heartbeat_thread, puller);\n\t}\n",
    "new_code_raw": "\tpublic TaskShutdownDameon execute() throws Exception {\n\n\t\t// create heartbeat\n\t\tTaskHeartbeatRunable hb = new TaskHeartbeatRunable(zkCluster,\n\t\t\t\ttopologyid, taskid, uptime, taskStats, taskStatus, stormConf);\n\n\t\tAsyncLoopThread heartbeat_thread = new AsyncLoopThread(hb, false,\n\t\t\t\tThread.MIN_PRIORITY, true);\n\n\t\tIConnection puller = context.bind(topologyid, taskid, false);\n\n\t\tTaskSendTargets sendTargets = echoToSystemBolt();\n\n\t\t// create thread to get tuple from zeroMQ,\n\t\t// and pass the tuple to bolt/spout\n\t\tRunnableCallback baseExecutor = mkExecutor(puller, sendTargets);\n\t\tAsyncLoopThread executor_threads = new AsyncLoopThread(baseExecutor,\n\t\t\t\tfalse, Thread.MAX_PRIORITY, true);\n\t\t\n\t\tList<AsyncLoopThread> allThreads = new ArrayList<AsyncLoopThread>();\n\t\tallThreads.add(heartbeat_thread);\n\t\tallThreads.add(executor_threads);\n\n\t\tLOG.info(\"Finished loading task \" + componentid + \":\" + taskid);\n\n\t\treturn getShutdown(allThreads, heartbeat_thread, puller, baseExecutor);\n\t}\n"
  },
  {
    "id": "wso2-extensions_siddhi-execution-extrema-0-Associations-FirstSentence",
    "old_comment_raw": "Method to find whether a value d% greater than or equal to min exists within l length window, by looping through older events.",
    "new_comment_raw": "Method to find whether a value preBoundChange% greater than or equal to min exists within maxPreBound length window, by looping through older events.",
    "old_code_raw": "    private StreamEvent findIfActualMin(attributeDetails latestEvent) {\n        int indexCurrentMin = valueStack.indexOf(currentMin);\n        int actual_L = valueStack.indexOf(latestEvent) - indexCurrentMin;\n        // If latest event is at a distance greater than L from min, min is not eligible to be sent as output\n        if (actual_L > L) {\n            currentMin.notEligibleForRealMin();\n            return null;\n        }\n        int actual_l = 1;\n        double dThreshold = currentMin.getValue() + currentMin.getValue() * d / 100;\n        while (actual_l <= l && indexCurrentMin - actual_l >= 0) {\n            if (valueStack.get(indexCurrentMin - actual_l).getValue() >= dThreshold) {\n                StreamEvent outputEvent = eventStack.get(indexCurrentMin);\n                complexEventPopulater.populateComplexEvent(outputEvent, new Object[] { \"min\", actual_l, actual_L });\n                currentMin.sentOutputAsRealMin();\n                return outputEvent;\n            }\n            ++actual_l;\n        }\n        // Completed iterating through l older events. No events which satisfy d condition found.\n        // Therefore min is not eligible to be sent as output.\n        currentMin.notEligibleForRealMin();\n        return null;\n    }\n",
    "new_code_raw": "    private StreamEvent findIfActualMin(AttributeDetails latestEvent) {\n        int indexCurrentMin = valueStack.indexOf(currentMin);\n        int postBound = valueStack.indexOf(latestEvent) - indexCurrentMin;\n        // If latest event is at a distance greater than maxPostBound from min, min is not eligible to be sent as output\n        if (postBound > maxPostBound) {\n            currentMin.notEligibleForRealMin();\n            return null;\n        }\n        // If maxPreBound is 0, no need to check preBoundChange. Send output with postBound value\n        if (maxPreBound == 0) {\n            StreamEvent outputEvent = eventStack.get(indexCurrentMin);\n            complexEventPopulater.populateComplexEvent(outputEvent, new Object[] { \"min\", 0, postBound });\n            currentMin.sentOutputAsRealMin();\n            return outputEvent;\n        }\n        int preBound = 1;\n        double dThreshold = currentMin.getValue() + currentMin.getValue() * preBoundChange / 100;\n        while (preBound <= maxPreBound && indexCurrentMin - preBound >= 0) {\n            if (valueStack.get(indexCurrentMin - preBound).getValue() >= dThreshold) {\n                StreamEvent outputEvent = eventStack.get(indexCurrentMin);\n                complexEventPopulater.populateComplexEvent(outputEvent, new Object[] { \"min\", preBound, postBound });\n                currentMin.sentOutputAsRealMin();\n                return outputEvent;\n            }\n            ++preBound;\n        }\n        // Completed iterating through maxPreBound older events. No events which satisfy preBoundChange condition found.\n        // Therefore min is not eligible to be sent as output.\n        currentMin.notEligibleForRealMin();\n        return null;\n    }\n\n"
  },
  {
    "id": "debezium_debezium-1151-FirstSentence-0",
    "old_comment_raw": "Build the  ColumnNameFilter that determines whether a column identified by a given  ColumnId is to be included, using the given comma-separated regular expression patterns defining which columns (if any) should be excluded.",
    "new_comment_raw": "Build the  ColumnNameFilter that determines whether a column identified by a given  ColumnId is to be included, using the given comma-separated regular expression patterns defining which columns (if any) should be excluded.",
    "old_code_raw": "        public static ColumnNameFilter getInstance(String fullyQualifiedColumnNames) {\n            Predicate<ColumnId> delegate = Predicates.excludes(fullyQualifiedColumnNames, ColumnId::toString);\n\n            return new ColumnNameFilter() {\n\n                @Override\n                public boolean matches(String catalogName, String schemaName, String tableName, String columnName) {\n                    return delegate.test(new ColumnId(new TableId(catalogName, schemaName, tableName), columnName));\n                }\n            };\n        }\n",
    "new_code_raw": "        public static ColumnNameFilter getInstance(String fullyQualifiedColumnNames) {\n            Predicate<ColumnId> delegate = Predicates.excludes(fullyQualifiedColumnNames, ColumnId::toString);\n            return (catalogName, schemaName, tableName, columnName) -> delegate.test(new ColumnId(new TableId(catalogName, schemaName, tableName), columnName));\n        }\n"
  },
  {
    "id": "querydsl_querydsl-1436-FirstSentence-0",
    "old_comment_raw": "Expr : left.indexOf(right, i)",
    "new_comment_raw": "Expr : left.indexOf(right)",
    "old_code_raw": "    public static ENumber<Integer> indexOf(Expr<String> left, String right, int i) {\n        return operationFactory.createNumber(Integer.class,Ops.INDEXOF_2ARGS, left, exprFactory.createConstant(right), exprFactory.createConstant(i));\n    }\n",
    "new_code_raw": "    public static ENumber<Integer> indexOf(Expr<String> left, String right) {\n        return operationFactory.createNumber(Integer.class, Ops.INDEXOF, left,\n                exprFactory.createConstant(right));\n    }\n"
  },
  {
    "id": "mtedone_podam-68-FirstSentence-0",
    "old_comment_raw": "It returns the getter for the given field.",
    "new_comment_raw": "It returns the getter for the given field.",
    "old_code_raw": "\tpublic static Method getGetterFor(Field field) {\n\t\tString name = field.getName().substring(0, 1).toUpperCase()\n\t\t\t\t+ field.getName().substring(1);\n\t\ttry {\n\t\t\treturn field.getDeclaringClass().getMethod(\"get\" + name);\n\t\t} catch (NoSuchMethodException e) {\n\t\t\tLOG.info(\"No getter method for \" + name, e);\n\t\t\treturn null;\n\t\t}\n\t}\n",
    "new_code_raw": "\tpublic static Method getGetterFor(Field field) {\n\t\tString name = field.getName().substring(0, 1).toUpperCase()\n\t\t\t\t+ field.getName().substring(1);\n\n\t\tString methodName;\n\t\tif (boolean.class.isAssignableFrom(field.getType()) ||\n\t\t\tBoolean.class.isAssignableFrom(field.getType())) {\n\t\t\tmethodName = \"is\" + name;\n\t\t} else {\n\t\t\tmethodName = \"get\" + name;\n\t\t}\n\n\t\ttry {\n\t\t\treturn field.getDeclaringClass().getMethod(methodName);\n\t\t} catch (NoSuchMethodException e) {\n\t\t\tif (methodName.startsWith(\"is\")) {\n\t\t\t\tmethodName = \"get\" + name;\n\t\t\t\ttry {\n\t\t\t\t\treturn field.getDeclaringClass().getMethod(methodName);\n\t\t\t\t} catch (NoSuchMethodException e2) {\n\t\t\t\t}\n\t\t\t}\n\t\t\tLOG.info(\"No getter {}() for field {}[{}]\", methodName,\n\t\t\t\t\tfield.getDeclaringClass().getName(), field.getName());\n\t\t\treturn null;\n\t\t}\n\t}\n"
  },
  {
    "id": "apache_geode-345-Associations-FirstSentence",
    "old_comment_raw": "Method for convenience to create error result for error in GemFire while executing command.",
    "new_comment_raw": "Method for convenience to create error result for error in Geode while executing command.",
    "old_code_raw": "  public static Result createGemFireErrorResult(String message) {\n    return createErrorResult(ERRORCODE_GEMFIRE_ERROR,\n        \"Could not process command due to GemFire error. \" + message);\n  }\n",
    "new_code_raw": "  public static Result createGemFireErrorResult(String message) {\n    return createErrorResult(ERRORCODE_GEODE_ERROR,\n        \"Could not process command due to error. \" + message);\n  }\n\n"
  },
  {
    "id": "apache_kylin-487-FirstSentence-0",
    "old_comment_raw": "Update a cube status from ready to disabled.",
    "new_comment_raw": "Update a cube status from ready to disabled.",
    "old_code_raw": "    public CubeInstance disableCube(CubeInstance cube) throws IOException {\n        aclEvaluate.hasProjectWritePermission(cube.getProjectInstance());\n        Message msg = MsgPicker.getMsg();\n\n        String cubeName = cube.getName();\n\n        RealizationStatusEnum ostatus = cube.getStatus();\n        if (null != ostatus && !RealizationStatusEnum.READY.equals(ostatus)) {\n            throw new BadRequestException(String.format(msg.getDISABLE_NOT_READY_CUBE(), cubeName, ostatus));\n        }\n\n        cube.setStatus(RealizationStatusEnum.DISABLED);\n\n        try {\n            CubeUpdate cubeBuilder = new CubeUpdate(cube);\n            cubeBuilder.setStatus(RealizationStatusEnum.DISABLED);\n            return getCubeManager().updateCube(cubeBuilder);\n        } catch (IOException e) {\n            cube.setStatus(ostatus);\n            throw e;\n        }\n    }\n",
    "new_code_raw": "    public CubeInstance disableCube(CubeInstance cube) throws IOException {\n        aclEvaluate.hasProjectWritePermission(cube.getProjectInstance());\n        Message msg = MsgPicker.getMsg();\n\n        String cubeName = cube.getName();\n\n        RealizationStatusEnum ostatus = cube.getStatus();\n        if (null != ostatus && !RealizationStatusEnum.READY.equals(ostatus)) {\n            throw new BadRequestException(String.format(msg.getDISABLE_NOT_READY_CUBE(), cubeName, ostatus));\n        }\n\n        return getCubeManager().updateCubeStatus(cube, RealizationStatusEnum.DISABLED);\n    }\n"
  },
  {
    "id": "jenkinsci_acceptance-test-harness-80-Associations-FirstSentence",
    "old_comment_raw": "Returns the first two columns of the \"Warnings\"-tab as key => value pairs, skipping the header row.",
    "new_comment_raw": "Returns the first and the specified columns of the \"Origin\"-tab as key => value pairs, skipping the header row.",
    "old_code_raw": "    public SortedMap<String, String> getOriginTabContentsAsStrings() {\n        openTab(Tab.ORIGIN);\n        return mapTableCellsKeyValue(String.class, getVisibleTableRows(true, true), 3);\n    }\n",
    "new_code_raw": "    public SortedMap<String, String> getOriginTabContentsAsStrings(final Origin selectedColumn) {\n        openTab(Tab.ORIGIN);\n        return mapTableCellsKeyValue(String.class, getVisibleTableRows(true, false),\n                selectedColumn.column);\n    }\n\n"
  },
  {
    "id": "sarxos_webcam_capture-18-FirstSentence-0",
    "old_comment_raw": "Get RAW image ByteBuffer.",
    "new_comment_raw": "Get RAW image ByteBuffer.",
    "old_code_raw": "\tpublic ByteBuffer getImageBytes() {\n\n\t\tif (!isReady()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tassert driver != null;\n\t\tassert device != null;\n\n\t\t// some devices can support direct image buffers, and for those call\n\t\t// processor task, and for those which does not support direct image\n\t\t// buffers, just convert image to RGB byte array\n\n\t\tif (device instanceof BufferAccess) {\n\t\t\treturn new WebcamReadBufferTask(driver, device).getBuffer();\n\t\t} else {\n\t\t\tBufferedImage image = getImage();\n\t\t\tif (image != null) {\n\t\t\t\treturn ByteBuffer.wrap(ImageUtils.toRawByteArray(image));\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n",
    "new_code_raw": "\tpublic ByteBuffer getImageBytes() {\n\n\t\tif (!isReady()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tassert driver != null;\n\t\tassert device != null;\n\n\t\t// some devices can support direct image buffers, and for those call\n\t\t// processor task, and for those which does not support direct image\n\t\t// buffers, just convert image to RGB byte array\n\n\t\tif (device instanceof BufferAccess) {\n\t\t\treturn new WebcamGetBufferTask(driver, device).getBuffer();\n\t\t} else {\n\t\t\tthrow new IllegalStateException(String.format(\"Driver %s does not support buffer access\", driver.getClass().getName()));\n\t\t}\n\t}\n"
  },
  {
    "id": "apache_lenya-279-Associations-FirstSentence",
    "old_comment_raw": "Returns the publication directory.",
    "new_comment_raw": "Returns the publication path.",
    "old_code_raw": "    public String getPublicationPath() {\n        return publicationPath;\n    }\n",
    "new_code_raw": "    public String getPublicationPath() {\n        return this.publicationPath;\n    }\n\n"
  },
  {
    "id": "docker_java_docker_java-73-FirstSentence-0",
    "old_comment_raw": "Returns whether the status indicates a successful pull operation",
    "new_comment_raw": "Returns whether the status indicates a successful pull operation",
    "old_code_raw": "    public boolean isPullSuccessIndicated() {\n        if (isErrorIndicated() || getStatus() == null) {\n            return false;\n        }\n\n        return (getStatus().contains(DOWNLOAD_COMPLETE) || getStatus().contains(IMAGE_UP_TO_DATE)\n                || getStatus().contains(DOWNLOADED_NEWER_IMAGE) || getStatus().contains(LEGACY_REGISTRY));\n    }\n",
    "new_code_raw": "    public boolean isPullSuccessIndicated() {\n        if (isErrorIndicated() || getStatus() == null) {\n            return false;\n        }\n\n        return (getStatus().contains(DOWNLOAD_COMPLETE) ||\n                getStatus().contains(IMAGE_UP_TO_DATE) ||\n                getStatus().contains(DOWNLOADED_NEWER_IMAGE) ||\n                getStatus().contains(LEGACY_REGISTRY) ||\n                getStatus().contains(DOWNLOADED_SWARM)\n        );\n    }\n"
  },
  {
    "id": "apache_jsecurity-67-Associations-FirstSentence",
    "old_comment_raw": "Performs the multi-realm authentication attempt by calling back to a  ModularAuthenticationStrategy object as each realm is consulted for Account for the specified token.",
    "new_comment_raw": "Performs the multi-realm authentication attempt by calling back to a  ModularAuthenticationStrategy object as each realm is consulted for AuthenticationInfo for the specified token.",
    "old_code_raw": "    protected Account doMultiRealmAuthentication(Collection<? extends Realm> realms, AuthenticationToken token) {\n\n        ModularAuthenticationStrategy strategy = getModularAuthenticationStrategy();\n\n        Account aggregate = strategy.beforeAllAttempts(realms, token);\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Iterating through [\" + realms.size() + \"] realms for PAM authentication\");\n        }\n\n        for (Realm realm : realms) {\n\n            if (realm.supports(token)) {\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Attempting to authenticate token [\" + token + \"] \" +\n                            \"using realm of type [\" + realm + \"]\");\n                }\n\n                aggregate = strategy.beforeAttempt(realm, token, aggregate);\n\n                Account account = null;\n                Throwable t = null;\n                try {\n                    account = realm.getAccount(token);\n                } catch (Throwable throwable) {\n                    t = throwable;\n                    if (log.isTraceEnabled()) {\n                        String msg = \"Realm [\" + realm + \"] threw an exception during a multi-realm authentication attempt:\";\n                        log.trace(msg, t);\n                    }\n                }\n\n                aggregate = strategy.afterAttempt(realm, token, account, aggregate, t);\n\n            } else {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Realm of type [\" + realm + \"] does not support token \" +\n                            \"[\" + token + \"].  Skipping realm.\");\n                }\n            }\n        }\n\n        aggregate = strategy.afterAllAttempts(token, aggregate);\n\n        return aggregate;\n    }\n",
    "new_code_raw": "    protected AuthenticationInfo doMultiRealmAuthentication(Collection<? extends Realm> realms, AuthenticationToken token) {\n\n        ModularAuthenticationStrategy strategy = getModularAuthenticationStrategy();\n\n        AuthenticationInfo aggregate = strategy.beforeAllAttempts(realms, token);\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Iterating through [\" + realms.size() + \"] realms for PAM authentication\");\n        }\n\n        for (Realm realm : realms) {\n\n            if (realm.supports(token)) {\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Attempting to authenticate token [\" + token + \"] \" +\n                            \"using realm of type [\" + realm + \"]\");\n                }\n\n                AuthenticationInfo info = null;\n                Throwable t = null;\n                try {\n                    info = realm.getAuthenticationInfo(token);\n                } catch (Throwable throwable) {\n                    t = throwable;\n                    if (log.isTraceEnabled()) {\n                        String msg = \"Realm [\" + realm + \"] threw an exception during a multi-realm authentication attempt:\";\n                        log.trace(msg, t);\n                    }\n                }\n\n                aggregate = strategy.afterAttempt(realm, token, info, aggregate, t);\n\n            } else {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Realm of type [\" + realm + \"] does not support token \" +\n                            \"[\" + token + \"].  Skipping realm.\");\n                }\n            }\n        }\n\n        aggregate = strategy.afterAllAttempts(token, aggregate);\n\n        return aggregate;\n    }\n\n"
  },
  {
    "id": "apache_flume-72-FirstSentence-0",
    "old_comment_raw": "Find a the enum type by its integer value, as defined in the Thrift IDL.",
    "new_comment_raw": "Find a the enum type by its integer value, as defined in the Thrift IDL.",
    "old_code_raw": "  public static FlumeNodeState findByValue(int value) { \n    return BY_VALUE.get(value);\n  }\n",
    "new_code_raw": "  public static FlumeNodeState findByValue(int value) { \n    switch (value) {\n      case 0:\n        return HELLO;\n      case 1:\n        return IDLE;\n      case 2:\n        return CONFIGURING;\n      case 3:\n        return ACTIVE;\n      case 4:\n        return ERROR;\n      case 5:\n        return LOST;\n      case 6:\n        return DECOMMISSIONED;\n      default:\n        return null;\n    }\n  }\n"
  },
  {
    "id": "debezium_debezium-1007-FirstSentence-0",
    "old_comment_raw": "Converts a value object for an expected JDBC type of  Types#DATE to the number of days past epoch, but represented as a  java.util.Date value at midnight on the date.",
    "new_comment_raw": "Converts a value object for an expected JDBC type of  Types#DATE to the number of days past epoch, but represented as a  java.util.Date value at midnight on the date.",
    "old_code_raw": "    protected Object convertDateToEpochDaysAsDate(Column column, Field fieldDefn, Object data) {\n        if (data == null && !fieldDefn.schema().isOptional()) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return new java.util.Date(0L); // return epoch\n        }\n        try {\n            int epochDay = Date.toEpochDay(data, adjuster);\n            long epochMillis = TimeUnit.DAYS.toMillis(epochDay);\n            return new java.util.Date(epochMillis);\n        } catch (IllegalArgumentException e) {\n            logger.warn(\"Unexpected JDBC DATE value for field {} with schema {}: class={}, value={}\", fieldDefn.name(),\n                        fieldDefn.schema(), data.getClass(), data);\n            return null;\n        }\n    }\n",
    "new_code_raw": "    protected Object convertDateToEpochDaysAsDate(Column column, Field fieldDefn, Object data) {\n        // epoch is the fallback value\n        return convertValue(column, fieldDefn, data, new java.util.Date(0L), (r) -> {\n            try {\n                int epochDay = Date.toEpochDay(data, adjuster);\n                long epochMillis = TimeUnit.DAYS.toMillis(epochDay);\n                r.deliver(new java.util.Date(epochMillis));\n            } catch (IllegalArgumentException e) {\n                logger.warn(\"Unexpected JDBC DATE value for field {} with schema {}: class={}, value={}\", fieldDefn.name(),\n                            fieldDefn.schema(), data.getClass(), data);\n            }\n        });\n    }\n"
  },
  {
    "id": "apache_calcite-983-FirstSentence-0",
    "old_comment_raw": "Returns a bitmap of the grouping fields.",
    "new_comment_raw": "Returns a bit set of the grouping fields.",
    "old_code_raw": "  public BitSet getGroupSet() {\n    return groupSet;\n  }\n",
    "new_code_raw": "  public ImmutableBitSet getGroupSet() {\n    return groupSet;\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-952-FirstSentence-0",
    "old_comment_raw": "Check whether the given tables/query-spaces are to be executed against given the currently queued actions.",
    "new_comment_raw": "Check whether the given tables/query-spaces are to be executed against given the currently queued actions.",
    "old_code_raw": "\tpublic boolean areTablesToBeUpdated(Set tables) {\n\t\treturn areTablesToUpdated( updates, tables ) ||\n\t\t\t\tareTablesToUpdated( insertions, tables ) ||\n\t\t\t\tareTablesToUpdated( unresolvedInsertions.getDependentEntityInsertActions(), tables ) ||\n\t\t\t\tareTablesToUpdated( deletions, tables ) ||\n\t\t\t\tareTablesToUpdated( collectionUpdates, tables ) ||\n\t\t\t\tareTablesToUpdated( collectionCreations, tables ) ||\n\t\t\t\tareTablesToUpdated( collectionRemovals, tables );\n\t}\n",
    "new_code_raw": "\tpublic boolean areTablesToBeUpdated(Set tables) {\n\t\treturn areTablesToUpdated( updates, tables ) ||\n\t\t\t\tareTablesToUpdated( insertions, tables ) ||\n\t\t\t\tareTablesToUpdated( unresolvedInsertions.getDependentEntityInsertActions(), tables ) ||\n\t\t\t\tareTablesToUpdated( deletions, tables ) ||\n\t\t\t\tareTablesToUpdated( collectionUpdates, tables ) ||\n\t\t\t\tareTablesToUpdated( collectionCreations, tables ) ||\n\t\t\t\tareTablesToUpdated( collectionQueuedOps, tables ) ||\n\t\t\t\tareTablesToUpdated( collectionRemovals, tables );\n\t}\n"
  },
  {
    "id": "codehaus_cake-6-Associations-FirstSentence",
    "old_comment_raw": "Analogous to  #get(WithAttributes) except returning a primitive double.",
    "new_comment_raw": "Extracts the attribute map from the specified  WithAttributes and returns the value of this attribute from the map.",
    "old_code_raw": "    public double get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n",
    "new_code_raw": "    public double get(WithAttributes withAttributes) {\r\n        return withAttributes.getAttributes().get(this);\r\n    }\r\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2057-FirstSentence-0",
    "old_comment_raw": "Output the type declaration of the property",
    "new_comment_raw": "Output the type declaration of the property",
    "old_code_raw": "    public String getTypeDeclaration(Schema schema) {\n        String oasType = getSchemaType(schema);\n        if (typeMapping.containsKey(oasType)) {\n            return typeMapping.get(oasType);\n        }\n        return oasType;\n    }\n",
    "new_code_raw": "    public String getTypeDeclaration(Schema schema) {\n        if (schema == null) {\n            LOGGER.warn(\"Null schema found. Default type to `NULL_SCHMEA_ERR`\");\n            return \"NULL_SCHMEA_ERR\";\n        }\n\n        String oasType = getSchemaType(schema);\n        if (typeMapping.containsKey(oasType)) {\n            return typeMapping.get(oasType);\n        }\n\n        return oasType;\n    }\n"
  },
  {
    "id": "apache_calcite-910-FirstSentence-0",
    "old_comment_raw": "Creates mock hint strategies.",
    "new_comment_raw": "Creates mock hint strategies with given builder.",
    "old_code_raw": "    private static HintStrategyTable createHintStrategies() {\n      return HintStrategyTable.builder()\n        .addHintStrategy(\"no_hash_join\", HintStrategies.JOIN)\n        .addHintStrategy(\"time_zone\", HintStrategies.SET_VAR)\n        .addHintStrategy(\"REPARTITION\", HintStrategies.SET_VAR)\n        .addHintStrategy(\"index\", HintStrategies.TABLE_SCAN)\n        .addHintStrategy(\"properties\", HintStrategies.TABLE_SCAN)\n        .addHintStrategy(\n            \"resource\", HintStrategies.or(\n            HintStrategies.PROJECT, HintStrategies.AGGREGATE, HintStrategies.CALC))\n        .addHintStrategy(\"AGG_STRATEGY\", HintStrategies.AGGREGATE)\n        .addHintStrategy(\"use_hash_join\",\n          HintStrategies.and(HintStrategies.JOIN,\n            HintStrategies.explicit((hint, rel) -> {\n              if (!(rel instanceof LogicalJoin)) {\n                return false;\n              }\n              LogicalJoin join = (LogicalJoin) rel;\n              final List<String> tableNames = hint.listOptions;\n              final List<String> inputTables = join.getInputs().stream()\n                  .filter(input -> input instanceof TableScan)\n                  .map(scan -> Util.last(scan.getTable().getQualifiedName()))\n                  .collect(Collectors.toList());\n              return equalsStringList(tableNames, inputTables);\n            })))\n        .build();\n    }\n",
    "new_code_raw": "    static HintStrategyTable createHintStrategies(HintStrategyTable.Builder builder) {\n      return builder\n        .addHintStrategy(\"no_hash_join\", HintStrategies.JOIN)\n        .addHintStrategy(\"time_zone\", HintStrategies.SET_VAR)\n        .addHintStrategy(\"REPARTITION\", HintStrategies.SET_VAR)\n        .addHintStrategy(\"index\", HintStrategies.TABLE_SCAN)\n        .addHintStrategy(\"properties\", HintStrategies.TABLE_SCAN)\n        .addHintStrategy(\n            \"resource\", HintStrategies.or(\n            HintStrategies.PROJECT, HintStrategies.AGGREGATE, HintStrategies.CALC))\n        .addHintStrategy(\"AGG_STRATEGY\",\n            HintStrategies.AGGREGATE,\n            (hint, errorHandler) -> errorHandler.check(\n                hint.listOptions.size() == 1\n                    && (hint.listOptions.get(0).equalsIgnoreCase(\"ONE_PHASE\")\n                        || hint.listOptions.get(0).equalsIgnoreCase(\"TWO_PHASE\")),\n                \"Hint {} only allows single option, \"\n                    + \"allowed options: [ONE_PHASE, TWO_PHASE]\",\n                hint.hintName\n            ))\n        .addHintStrategy(\"use_hash_join\",\n          HintStrategies.and(HintStrategies.JOIN,\n            HintStrategies.explicit((hint, rel) -> {\n              if (!(rel instanceof LogicalJoin)) {\n                return false;\n              }\n              LogicalJoin join = (LogicalJoin) rel;\n              final List<String> tableNames = hint.listOptions;\n              final List<String> inputTables = join.getInputs().stream()\n                  .filter(input -> input instanceof TableScan)\n                  .map(scan -> Util.last(scan.getTable().getQualifiedName()))\n                  .collect(Collectors.toList());\n              return equalsStringList(tableNames, inputTables);\n            })))\n        .build();\n    }\n"
  },
  {
    "id": "querydsl_querydsl-376-FirstSentence-0",
    "old_comment_raw": "Return the query results as ScrollableResults.",
    "new_comment_raw": "Return the query results as ScrollableResults.",
    "old_code_raw": "    public ScrollableResults scroll(ScrollMode mode, Expr<?>[] args) {\n        return createQuery(args).scroll(mode);\n    }\n",
    "new_code_raw": "    public ScrollableResults scroll(ScrollMode mode, Expr<?>[] args) {\n        Query query = createQuery(args);\n        reset();\n        return query.scroll(mode);\n    }\n"
  },
  {
    "id": "jenkinsci_scaleway-cloud-plugin-0-Associations-FirstSentence",
    "old_comment_raw": "Retrieve a handle to the associated  com.segator.jenkins.scaleway.Cloud",
    "new_comment_raw": "Retrieve a handle to the associated  com.github.segator.jenkins.scaleway.ScalewayCloud",
    "old_code_raw": "    public Cloud getCloud() {\n        return (Cloud) Jenkins.getInstance().getCloud(cloudName);\n    }\n",
    "new_code_raw": "    public ScalewayCloud getCloud() {\n        Jenkins instance = Jenkins.getInstance();\n        if (instance != null) {\n            return (ScalewayCloud) instance.getCloud(cloudName);\n        }\n        return null;\n    }\n\n"
  },
  {
    "id": "apache_calcite-300-FirstSentence-0",
    "old_comment_raw": "Returns the  BuiltInMetadata.UniqueKeys#getUniqueKeys(boolean) statistic.",
    "new_comment_raw": "Returns the  BuiltInMetadata.UniqueKeys#getUniqueKeys(boolean) statistic.",
    "old_code_raw": "  public static Set<BitSet> getUniqueKeys(RelNode rel) {\n    final BuiltInMetadata.UniqueKeys metadata =\n        rel.metadata(BuiltInMetadata.UniqueKeys.class);\n    return metadata.getUniqueKeys(false);\n  }\n",
    "new_code_raw": "  public static Set<ImmutableBitSet> getUniqueKeys(RelNode rel) {\n    final BuiltInMetadata.UniqueKeys metadata =\n        rel.metadata(BuiltInMetadata.UniqueKeys.class);\n    return metadata.getUniqueKeys(false);\n  }\n"
  },
  {
    "id": "JohannesBuchner_Jake-5-Associations-FirstSentence",
    "old_comment_raw": "Tests if two contents are equal.",
    "new_comment_raw": "Tests if two notes are equal.",
    "old_code_raw": "\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (obj != null && obj.getClass().equals(this.getClass())) {\n\t\t\tNoteObject that = (NoteObject) obj;\n\t\t\treturn (this.content.equals(that.getContent()));\n\t\t}\n\t\treturn false;\n\t}\n",
    "new_code_raw": "\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (obj != null && obj.getClass().equals(this.getClass())) {\n\t\t\tNoteObject that = (NoteObject) obj;\n\t\t\t\n\t\t\tif (content == null && that.getContent() != null) return false;\n\t\t\tif (content != null && !content.equals(that.getContent())) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1910-FirstSentence-0",
    "old_comment_raw": "Test serialization of outer boolean types",
    "new_comment_raw": "Test serialization of outer boolean types",
    "old_code_raw": "  public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/boolean\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException {\n    return fakeOuterBooleanSerializeWithHttpInfo(body).getData();\n      }\n"
  },
  {
    "id": "apache_drill-1429-FirstSentence-0",
    "old_comment_raw": "Checks if the given path exists.",
    "new_comment_raw": "Returns true if path exists, false otherwise.",
    "old_code_raw": "  public boolean hasPath(final String path, final boolean consistent) {\n    Preconditions.checkNotNull(path, \"path is required\");\n\n    final String target = PathUtils.join(root, path);\n    try {\n      if (consistent) {\n        return curator.checkExists().forPath(target) != null;\n      } else {\n        return getCache().getCurrentData(target) != null;\n      }\n    } catch (final Exception e) {\n      throw new DrillRuntimeException(\"error while checking path on zookeeper\", e);\n    }\n  }\n",
    "new_code_raw": "  public boolean hasPath(final String path, final boolean consistent) {\n    return hasPath(path, consistent, null);\n  }\n"
  },
  {
    "id": "wdullaer_MaterialDateTimePicker-15-FirstSentence-0",
    "old_comment_raw": "Snap the input to a selectable value",
    "new_comment_raw": "Snap the input to a selectable value",
    "old_code_raw": "    private Timepoint roundToValidTime(Timepoint newSelection, int currentItemShowing) {\n        switch(currentItemShowing) {\n            case HOUR_INDEX:\n                newSelection = mController.roundToNearest(newSelection, Timepoint.TYPE.HOUR);\n                break;\n            case MINUTE_INDEX:\n                newSelection = mController.roundToNearest(newSelection, Timepoint.TYPE.MINUTE);\n                break;\n            case SECOND_INDEX:\n                newSelection = mController.roundToNearest(newSelection, Timepoint.TYPE.SECOND);\n                break;\n            default:\n                newSelection = mCurrentTime;\n        }\n        return newSelection;\n    }\n",
    "new_code_raw": "    private Timepoint roundToValidTime(Timepoint newSelection, int currentItemShowing) {\n        switch(currentItemShowing) {\n            case HOUR_INDEX:\n                return mController.roundToNearest(newSelection, null);\n            case MINUTE_INDEX:\n                return mController.roundToNearest(newSelection, Timepoint.TYPE.HOUR);\n            default:\n                return mController.roundToNearest(newSelection, Timepoint.TYPE.MINUTE);\n        }\n    }\n"
  },
  {
    "id": "jenkinsci_analysis-core-plugin-6-Associations-FirstSentence",
    "old_comment_raw": "Returns the action of the previous build.",
    "new_comment_raw": "Returns the previous build result.",
    "old_code_raw": "    public BuildResult getPreviousResult() {\n        return getPreviousAction().getResult();\n    }\n",
    "new_code_raw": "    public BuildResult getPreviousResult() {\n        ResultAction<? extends BuildResult> action = getPreviousAction();\n        if (action != null) {\n            return action.getResult();\n        }\n        throw new NoSuchElementException(\"No previous result available\");\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2169-FirstSentence-0",
    "old_comment_raw": "To test \\&quot;client\\&quot; model",
    "new_comment_raw": "To test \\&quot;client\\&quot; model",
    "old_code_raw": "    public Mono<Client> testClientModel(Client body) throws RestClientException {\n        Object postBody = body;\n        \n        // verify the required parameter 'body' is set\n        if (body == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling testClientModel\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"/fake\").build().toUriString();\n\n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "new_code_raw": "    public Mono<Client> testClientModel(Client body) throws RestClientException {\n        Object postBody = body;\n        \n        // verify the required parameter 'body' is set\n        if (body == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling testClientModel\");\n        }\n        \n        // create path and map variables\n        final Map<String, Object> pathParams = new HashMap<String, Object>();\n\n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(\"/fake\", HttpMethod.PATCH, pathParams, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType);\n    }\n"
  },
  {
    "id": "debezium_debezium-977-FirstSentence-0",
    "old_comment_raw": "Create the path to a file within the test data directory at the given relative path.",
    "new_comment_raw": "Create the path to a file within the test data directory at the given relative path.",
    "old_code_raw": "        public static Path createTestingPath(String relativePath) {\n            return Paths.get(\"target/data\", relativePath).toAbsolutePath();\n        }\n",
    "new_code_raw": "        public static Path createTestingPath(String relativePath) {\n            return Paths.get(dataDir(), relativePath).toAbsolutePath();\n        }\n"
  },
  {
    "id": "eclipse_mylyn.reviews-0-Associations-FirstSentence",
    "old_comment_raw": "Returns the meta object for the reference list ' org.eclipse.mylyn.reviews.core.model.ITopic#getComments Comments'.",
    "new_comment_raw": "Returns the meta object for the containment reference list '  org.eclipse.mylyn.reviews.core.model.ITopic#getComments Comments'.",
    "old_code_raw": "\tpublic EReference getTopic_Comments() {\n\t\treturn (EReference) topicEClass.getEStructuralFeatures().get(2);\n\t}\n",
    "new_code_raw": "\tpublic EReference getTopic_Comments() {\n\t\treturn (EReference) topicEClass.getEStructuralFeatures().get(1);\n\t}\n\n"
  },
  {
    "id": "RobotiumTech_robotium-1351-FirstSentence-0",
    "old_comment_raw": "Searches for a text string and returns  true if the searched text is found a given number of times.",
    "new_comment_raw": "Searches for a text string and returns  true if the searched text is found a given number of times.",
    "old_code_raw": "\tpublic boolean searchText(String text, int minimumNumberOfMatches, boolean scroll) {\n\t\treturn searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, scroll);\n\t}\n",
    "new_code_raw": "\tpublic boolean searchText(String text, int minimumNumberOfMatches, boolean scroll) {\n\t\treturn searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, scroll, false);\n\t}\n"
  },
  {
    "id": "mccraigmccraig_prefuse-64-Associations-FirstSentence",
    "old_comment_raw": "Indicates if the given file ends with a file extension of \".gz\", indicating a GZip file.",
    "new_comment_raw": "Indicates if the given file ends with a file extension of \".gz\" or \".Z\", indicating a GZip file.",
    "old_code_raw": "    public static boolean isGZipFile(String file) {\n        return \"gz\".equals(getExtension(file));\n    }\n",
    "new_code_raw": "    public static boolean isGZipFile(String file) {\n    \tString ext = getExtension(file);\n        return \"gz\".equals(ext) || \"z\".equals(ext);\n    }\n\n"
  },
  {
    "id": "debezium_debezium-1301-FirstSentence-0",
    "old_comment_raw": "Determine if the supplied value is one of the predefined options.",
    "new_comment_raw": "Determine if the supplied value is one of the predefined options.",
    "old_code_raw": "        public static Version parse(String value, String defaultValue) {\n            Version mode = parse(value);\n            if (mode == null && defaultValue != null) {\n                mode = parse(defaultValue);\n            }\n            return mode;\n        }\n",
    "new_code_raw": "        public static EventProcessingFailureHandlingMode parse(String value) {\n            if (value == null) {\n                return null;\n            }\n\n            value = value.trim();\n\n            for (EventProcessingFailureHandlingMode option : EventProcessingFailureHandlingMode.values()) {\n                if (option.getValue().equalsIgnoreCase(value)) {\n                    return option;\n                }\n            }\n\n            return null;\n        }\n"
  },
  {
    "id": "RobotiumTech_robotium-1504-FirstSentence-0",
    "old_comment_raw": "Determines if no more scrolling can be done.",
    "new_comment_raw": "Determines if a previous text is the same as the current.",
    "old_code_raw": "\tprivate boolean isSameText() {\n\t\tArrayList<TextView> textViewList = soloView.getCurrentTextViews(null);\n\t\tint size = textViewList.size();\n\t\tint constant = 0;\n\t\tif (size > 2)\n\t\t\tconstant = 2;\n\t\telse\n\t\t\tconstant = size;\n\t\t\n\t\tif (checkTextView != null\n\t\t\t\t&& !checkTextView.getText().equals(\n\t\t\t\t\t\tsoloView.getCurrentTextViews(null).get(\n\t\t\t\t\t\t\t\tsoloView.getCurrentTextViews(null).size()\n\t\t\t\t\t\t\t\t\t\t- constant).getText())) {\n\t\t\tcheckTextView = textViewList.get(size - constant);\n\t\t\treturn true;\n\t\t} else if (checkTextView == null) {\n\t\t\tcheckTextView = textViewList.get(size - constant);\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t\treturn false;\n\t}\n",
    "new_code_raw": "\tprivate boolean isSameText() {\n\t\tArrayList<TextView> textViewList = soloView.getCurrentTextViews(null);\n\t\tint size = textViewList.size();\n\t\tint constant = 0;\n\t\tif (size > 2)\n\t\t\tconstant = 2;\n\t\telse\n\t\t\tconstant = size;\n\t\t\n\t\tif (checkTextView != null\n\t\t\t\t&& !checkTextView.getText().equals(\n\t\t\t\t\t\ttextViewList.get(size - constant).getText())) {\n\t\t\tcheckTextView = textViewList.get(size - constant);\n\t\t\treturn false;\n\t\t} else if (checkTextView == null) {\n\t\t\tcheckTextView = textViewList.get(size - constant);\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t\treturn true;\n\t}\n"
  },
  {
    "id": "JodaOrg_joda_time-876-FirstSentence-0",
    "old_comment_raw": "Instructs the printer to emit a short locale-specific dayOfWeek text.",
    "new_comment_raw": "Instructs the printer to emit a short locale-specific dayOfWeek text.",
    "old_code_raw": "    public DateTimeFormatterBuilder appendDayOfWeekShortText() {\n        return appendShortText(iChronoUTC.dayOfWeek());\n    }\n",
    "new_code_raw": "    public DateTimeFormatterBuilder appendDayOfWeekShortText() {\n        return appendShortText(DateTimeFieldType.dayOfWeek());\n    }\n"
  },
  {
    "id": "debezium_debezium-36-FirstSentence-0",
    "old_comment_raw": "Parse the supplied string, extracting the first 3 parts into a Collection.",
    "new_comment_raw": "Parse the supplied  . string.",
    "old_code_raw": "    public static CollectionId parse(String str) {\n        String[] parts = IDENTIFIER_SEPARATOR_PATTERN.split(str);\n        if (parts.length < 3) {\n            return null;\n        }\n        return new CollectionId(parts[0], parts[1], parts[2]);\n    }\n",
    "new_code_raw": "    public static CollectionId parse(String replicaSetName, String str) {\n        final int dotPosition = str.indexOf('.');\n        if (dotPosition == -1 || (dotPosition + 1) == str.length() || dotPosition == 0) {\n            return null;\n        }\n        return new CollectionId(replicaSetName, str.substring(0, dotPosition), str.substring(dotPosition + 1));\n    }\n"
  },
  {
    "id": "SeleniumHQ_selenium-638-FirstSentence-0",
    "old_comment_raw": "Enhance the interfaces implemented by this instance of WebDriver iff that instance is a  org.openqa.selenium.remote.RemoteWebDriver.",
    "new_comment_raw": "Enhance the interfaces implemented by this instance of WebDriver iff that instance is a  org.openqa.selenium.remote.RemoteWebDriver.",
    "old_code_raw": "  public WebDriver augment(WebDriver driver) {\n    // TODO(simon): We should really add a \"SelfDescribing\" interface for this\n    if (!(driver instanceof RemoteWebDriver)) {\n      return driver;\n    }\n\n    Map<String, ?> capabilities = ((RemoteWebDriver) driver).getCapabilities().asMap();\n\n    CompoundHandler handler = new CompoundHandler((RemoteWebDriver) driver);\n\n    for (Map.Entry<String, ?> capablityName : capabilities.entrySet()) {\n      AugmenterProvider augmenter = augmentors.get(capablityName.getKey());\n      if (augmenter == null) {\n        continue;\n      }\n\n      Object value = capablityName.getValue();\n      if (value instanceof Boolean && !((Boolean) value).booleanValue()) {\n        continue;\n      }\n\n      handler.addCapabilityHander(augmenter.getDescribedInterface(),\n          augmenter.getImplementation(value));\n    }\n\n    if (handler.isNeedingApplication()) {\n      // Gather the existing interfaces\n      Set<Class<?>> interfaces = new HashSet<Class<?>>();\n      interfaces.addAll(handler.getInterfaces());\n      interfaces.addAll(getInterfacesFrom(driver.getClass()));\n\n      return (WebDriver) Proxy.newProxyInstance(getClass().getClassLoader(),\n          interfaces.toArray(new Class<?>[interfaces.size()]), handler);\n    }\n\n    return driver;\n  }\n",
    "new_code_raw": "  public WebDriver augment(WebDriver driver) {\n    // TODO(simon): We should really add a \"SelfDescribing\" interface for this\n    if (!(driver instanceof RemoteWebDriver)) {\n      return driver;\n    }\n\n    Map<String, ?> capabilities = ((RemoteWebDriver) driver).getCapabilities().asMap();\n\n    CompoundHandler handler = new CompoundHandler((RemoteWebDriver) driver);\n\n    for (Map.Entry<String, ?> capablityName : capabilities.entrySet()) {\n      AugmenterProvider augmenter = augmentors.get(capablityName.getKey());\n      if (augmenter == null) {\n        continue;\n      }\n\n      Object value = capablityName.getValue();\n      if (value instanceof Boolean && !((Boolean) value).booleanValue()) {\n        continue;\n      }\n\n      handler.addCapabilityHander(augmenter.getDescribedInterface(),\n          augmenter.getImplementation(value));\n    }\n\n    if (handler.isNeedingApplication()) {\n      // Gather the existing interfaces\n      Set<Class<?>> interfaces = new HashSet<Class<?>>();\n      interfaces.addAll(handler.getInterfaces());\n      interfaces.addAll(getInterfacesFrom(driver.getClass()));\n\n      Enhancer enhancer = new Enhancer();\n      enhancer.setInterfaces(interfaces.toArray(new Class<?>[interfaces.size()]));\n      enhancer.setCallback(handler);\n      enhancer.setSuperclass(driver.getClass());\n\n      RemoteWebDriver remote = (RemoteWebDriver) enhancer.create();\n      remote.setCommandExecutor(((RemoteWebDriver) driver).getCommandExecutor());\n      remote.setElementConverter(((RemoteWebDriver) driver).getElementConverter());\n      return remote;\n    }\n\n    return driver;\n  }\n"
  },
  {
    "id": "Atmosphere_atmosphere-857-FirstSentence-0",
    "old_comment_raw": "Jetty 7 and up WebSocket support.",
    "new_comment_raw": "Jetty 7.2 & 8.0.0-M1/M2and up WebSocket support.",
    "old_code_raw": "    protected WebSocket doWebSocketConnect(final HttpServletRequest request, final String protocol) {\n        logger.info(\"WebSocket upgrade requested\");\n\n        return new WebSocket() {\n            private WebSocketProcessor webSocketProcessor;\n\n            @Override\n            public void onConnect(WebSocket.Outbound outbound) {\n                webSocketProcessor = new WebSocketProcessor(AtmosphereServlet.this, new JettyWebSocketSupport(outbound));\n                try {\n                    webSocketProcessor.connect(new JettyRequestFix(request));\n                } catch (IOException e) {\n                    logger.warn(\"failed to connect to web socket\", e);\n                }\n            }\n\n            @Override\n            public void onMessage(byte frame, String data) {\n                webSocketProcessor.broadcast(frame, data);\n            }\n\n            @Override\n            public void onMessage(byte frame, byte[] data, int offset, int length) {\n                webSocketProcessor.broadcast(frame, new String(data, offset, length));\n            }\n\n            @Override\n            public void onFragment(boolean more, byte opcode, byte[] data, int offset, int length) {\n                webSocketProcessor.broadcast(opcode, new String(data, offset, length));\n            }\n\n            @Override\n            public void onDisconnect() {\n                webSocketProcessor.close();\n            }\n        };\n    }\n",
    "new_code_raw": "    public WebSocket doWebSocketConnect(final HttpServletRequest request, final String protocol) {\n        logger.info(\"WebSocket upgrade requested\");\n\n        return new JettyWebSocketListener(request,this);\n    }\n"
  },
  {
    "id": "react_native_community_react_native_image_picker-17-FirstSentence-0",
    "old_comment_raw": "Create a new file",
    "new_comment_raw": "Create a new file",
    "old_code_raw": "  private File createNewFile(final boolean forcePictureDirectory) {\n    String filename = \"image-\" + UUID.randomUUID().toString() + \".jpg\";\n    if (tmpImage && forcePictureDirectory != true) {\n      return new File(mReactContext.getCacheDir(), filename);\n    } else {\n      File path = Environment.getExternalStoragePublicDirectory(\n              Environment.DIRECTORY_PICTURES);\n      File f = new File(path, filename);\n\n      try {\n        path.mkdirs();\n        f.createNewFile();\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n      return f;\n    }\n  }\n",
    "new_code_raw": "  private File createNewFile() {\n    String filename = \"image-\" + UUID.randomUUID().toString() + \".jpg\";\n    File path;\n    if (tmpImage) {\n      path = mReactContext.getExternalCacheDir();\n    } else {\n      path = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES);\n    }\n\n    File f = new File(path, filename);\n    try {\n      path.mkdirs();\n      f.createNewFile();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n\n    return f;\n  }\n"
  },
  {
    "id": "eclipse_rt.equinox.bundles-60-Associations-FirstSentence",
    "old_comment_raw": "Obtains a ISTextExpert instance for processing structured text with the specified type handler and the specified environment.",
    "new_comment_raw": "Obtains a IStructuredTextExpert instance for processing structured text with the specified type handler and the specified environment.",
    "old_code_raw": "\tstatic public ISTextExpert getExpert(String type, STextEnvironment environment) {\n\t\tISTextExpert expert;\n\t\tif (environment == null)\n\t\t\tenvironment = STextEnvironment.DEFAULT;\n\t\tsynchronized (sharedExperts) {\n\t\t\tMap experts = (Map) sharedExperts.get(type);\n\t\t\tif (experts == null) {\n\t\t\t\texperts = new HashMap(); // environment -> expert\n\t\t\t\tsharedExperts.put(type, experts);\n\t\t\t}\n\t\t\texpert = (ISTextExpert) experts.get(environment);\n\t\t\tif (expert == null) {\n\t\t\t\tSTextTypeHandler handler = STextTypeHandlerFactory.getHandler(type);\n\t\t\t\tif (handler == null)\n\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid type argument\"); //$NON-NLS-1$\n\t\t\t\texpert = new STextImpl(handler, environment, false);\n\t\t\t\texperts.put(type, expert);\n\t\t\t}\n\t\t}\n\t\treturn expert;\n\t}\n",
    "new_code_raw": "\tstatic public IStructuredTextExpert getExpert(String type, StructuredTextEnvironment environment) {\n\t\tIStructuredTextExpert expert;\n\t\tif (environment == null)\n\t\t\tenvironment = StructuredTextEnvironment.DEFAULT;\n\t\tsynchronized (sharedExperts) {\n\t\t\tMap experts = (Map) sharedExperts.get(type);\n\t\t\tif (experts == null) {\n\t\t\t\texperts = new HashMap(); // environment -> expert\n\t\t\t\tsharedExperts.put(type, experts);\n\t\t\t}\n\t\t\texpert = (IStructuredTextExpert) experts.get(environment);\n\t\t\tif (expert == null) {\n\t\t\t\tStructuredTextTypeHandler handler = StructuredTextTypeHandlerFactory.getHandler(type);\n\t\t\t\tif (handler == null)\n\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid type argument\"); //$NON-NLS-1$\n\t\t\t\texpert = new StructuredTextImpl(handler, environment, false);\n\t\t\t\texperts.put(type, expert);\n\t\t\t}\n\t\t}\n\t\treturn expert;\n\t}\n\n"
  },
  {
    "id": "RobotiumTech_robotium-1246-FirstSentence-0",
    "old_comment_raw": "This method returns a button with a certain index.",
    "new_comment_raw": "This method returns a button with a certain index.",
    "old_code_raw": "\tpublic Button getButton(int index) {\n\t\tArrayList<Button> buttonList = getCurrentButtons();\n\t\treturn buttonList.get(index);\n\t}\n",
    "new_code_raw": "\tpublic Button getButton(int index) {\n\t\tButton button = soloView.getButton(index);\n\t\treturn button;\n\t}\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2426-FirstSentence-0",
    "old_comment_raw": "Create a CoreLabel from its serialized counterpart.",
    "new_comment_raw": "Create a CoreMap representing a sentence from this protocol buffer.",
    "old_code_raw": "  public CoreLabel fromProto(CoreNLPProtos.Token proto) {\n    CoreLabel word = new CoreLabel();\n    // Required fields\n    word.setWord(proto.getWord());\n    // Optional fields\n    if (proto.hasPos()) { word.setTag(proto.getPos()); }\n    if (proto.hasValue()) { word.setValue(proto.getValue()); }\n    if (proto.hasCategory()) { word.setCategory(proto.getCategory()); }\n    if (proto.hasBefore()) { word.setBefore(proto.getBefore()); }\n    if (proto.hasAfter()) { word.setAfter(proto.getAfter()); }\n    if (proto.hasOriginalText()) { word.setOriginalText(proto.getOriginalText()); }\n    if (proto.hasNer()) { word.setNER(proto.getNer()); }\n    if (proto.hasLemma()) { word.setLemma(proto.getLemma()); }\n    if (proto.hasBeginChar()) { word.setBeginPosition(proto.getBeginChar()); }\n    if (proto.hasEndChar()) { word.setEndPosition(proto.getEndChar()); }\n    if (proto.hasSpeaker()) { word.set(SpeakerAnnotation.class, proto.getSpeaker()); }\n    if (proto.hasUtterance()) { word.set(UtteranceAnnotation.class, proto.getUtterance()); }\n    if (proto.hasBeginIndex()) { word.set(BeginIndexAnnotation.class, proto.getBeginIndex()); }\n    if (proto.hasEndIndex()) { word.set(EndIndexAnnotation.class, proto.getEndIndex()); }\n    if (proto.hasTokenBeginIndex()) { word.set(TokenBeginAnnotation.class, proto.getTokenBeginIndex()); }\n    if (proto.hasTokenEndIndex()) { word.set(TokenEndAnnotation.class, proto.getTokenEndIndex()); }\n    if (proto.hasNormalizedNER()) { word.set(NormalizedNamedEntityTagAnnotation.class, proto.getNormalizedNER()); }\n    if (proto.hasTimexValue()) { word.set(TimexAnnotation.class, fromProto(proto.getTimexValue())); }\n    if (proto.hasHasXmlContext() && proto.getHasXmlContext()) { word.set(XmlContextAnnotation.class, proto.getXmlContextList()); }\n    if (proto.hasCorefClusterID()) { word.set(CorefClusterIdAnnotation.class, proto.getCorefClusterID()); }\n    if (proto.hasAnswer()) { word.set(AnswerAnnotation.class, proto.getAnswer()); }\n    if (proto.hasOperator()) { word.set(NaturalLogicAnnotations.OperatorAnnotation.class, fromProto(proto.getOperator())); }\n    if (proto.hasPolarity()) { word.set(NaturalLogicAnnotations.PolarityAnnotation.class, fromProto(proto.getPolarity())); }\n    // Non-default annotators\n    if (proto.hasGender()) { word.set(GenderAnnotation.class, proto.getGender()); }\n    if (proto.hasTrueCase()) { word.set(TrueCaseAnnotation.class, proto.getTrueCase()); }\n    if (proto.hasTrueCaseText()) { word.set(TrueCaseTextAnnotation.class, proto.getTrueCaseText()); }\n    // Return\n    return word;\n  }\n",
    "new_code_raw": "  private static CoreMap fromProto(CoreNLPProtos.Sentence proto) {\n    CoreMap sentence = new ArrayCoreMap();\n    // Required fields\n    sentence.set(TokenBeginAnnotation.class, proto.getTokenOffsetBegin());\n    sentence.set(TokenEndAnnotation.class, proto.getTokenOffsetEnd());\n    // Optional fields\n    if (proto.hasSentenceIndex()) { sentence.set(SentenceIndexAnnotation.class, proto.getSentenceIndex()); }\n    if (proto.hasCharacterOffsetBegin()) { sentence.set(CharacterOffsetBeginAnnotation.class, proto.getCharacterOffsetBegin()); }\n    if (proto.hasCharacterOffsetEnd()) { sentence.set(CharacterOffsetEndAnnotation.class, proto.getCharacterOffsetEnd()); }\n    if (proto.hasParseTree()) { sentence.set(TreeAnnotation.class, fromProto(proto.getParseTree())); }\n    // Non-default fields\n    if (proto.hasHasRelationAnnotations() && proto.getHasRelationAnnotations()) {\n      // set entities\n      List<EntityMention> entities = new ArrayList<EntityMention>();\n      for (CoreNLPProtos.Entity entity : proto.getEntityList()) { entities.add(fromProto(entity, sentence)); }\n      sentence.set(EntityMentionsAnnotation.class, entities);\n      // set relations\n      List<RelationMention> relations = new ArrayList<RelationMention>();\n      for (CoreNLPProtos.Relation relation : proto.getRelationList()) { relations.add(fromProto(relation, sentence)); }\n      sentence.set(RelationMentionsAnnotation.class, relations);\n    }\n    // Return\n    return sentence;\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1833-FirstSentence-0",
    "old_comment_raw": "Number of lines returned by all the executions of this query (from DB)",
    "new_comment_raw": "Number of lines returned by all the executions of this query (from DB)",
    "old_code_raw": "\tpublic long getExecutionRowCount() {\n\t\treturn executionRowCount.get();\n\t}\n",
    "new_code_raw": "\tpublic long getExecutionRowCount() {\n\t\treturn executionRowCount.sum();\n\t}\n"
  },
  {
    "id": "apache_qpid-jms-17-Associations-FirstSentence",
    "old_comment_raw": "Add properties to a URI",
    "new_comment_raw": "Enumerate the properties of the target object and add them as additional entries to the query string of the given URI.",
    "old_code_raw": "    public static String addPropertiesToURI(URI uri, Map<String, String> props) throws Exception {\n        return addPropertiesToURI(uri.toString(), props);\n    }\n",
    "new_code_raw": "    public static String addPropertiesToURI(URI uri, Map<String, String> properties) throws Exception {\n        return addPropertiesToURI(uri.toString(), properties);\n    }\n\n"
  },
  {
    "id": "debezium_debezium-871-FirstSentence-0",
    "old_comment_raw": "Converts a value object for an expected JDBC type of  Types#DOUBLE.",
    "new_comment_raw": "Converts a value object for an expected JDBC type of  Types#DOUBLE.",
    "old_code_raw": "    protected Object convertDouble(Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0.0d;\n        }\n        if (data instanceof Double) return data;\n        if (data instanceof Number) {\n            // Includes BigDecimal and other numeric values ...\n            Number value = (Number) data;\n            return new Double(value.doubleValue());\n        }\n        if (data instanceof Boolean) {\n            return ((Boolean) data).booleanValue() ? DOUBLE_TRUE : DOUBLE_FALSE;\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n",
    "new_code_raw": "    protected Object convertDouble(Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0.0d;\n        }\n        if (data instanceof Double) return data;\n        if (data instanceof Number) {\n            // Includes BigDecimal and other numeric values ...\n            Number value = (Number) data;\n            return new Double(value.doubleValue());\n        }\n        if (data instanceof Boolean) {\n            return NumberConversions.getDouble((Boolean) data);\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n"
  },
  {
    "id": "eclipse_emf.diffmerge.core-0-Associations-FirstSentence",
    "old_comment_raw": "Return a new unique Ecore identifier for the given element, if relevant.",
    "new_comment_raw": "Return a new unique intrinsic ID for the given element, if relevant.",
    "old_code_raw": "  protected String getNewIdFor(EObject element_p) {\r\n    return copyPhysicalIds()? null: EcoreUtil.generateUUID();\r\n  }\r\n",
    "new_code_raw": "  protected String getNewIdFor(EObject element_p) {\r\n    return copyXmlIds()? null: EcoreUtil.generateUUID();\r\n  }\r\n\n"
  },
  {
    "id": "apache_kylin-450-FirstSentence-0",
    "old_comment_raw": "Update CubeDesc with the input.",
    "new_comment_raw": "Update CubeDesc with the input.",
    "old_code_raw": "    public CubeDesc updateCubeDesc(CubeDesc desc) throws IOException {\n        // Validate CubeDesc\n        if (desc.getUuid() == null || desc.getName() == null) {\n            throw new IllegalArgumentException();\n        }\n        String name = desc.getName();\n        if (!cubeDescMap.containsKey(name)) {\n            throw new IllegalArgumentException(\"CubeDesc '\" + name + \"' does not exist.\");\n        }\n\n        try {\n            desc.init(config, getMetadataManager().getAllTablesMap());\n        } catch (IllegalStateException e) {\n            desc.addError(e.getMessage(), true);\n            return desc;\n        } catch (IllegalArgumentException e) {\n            desc.addError(e.getMessage(), true);\n            return desc;\n        }\n\n        // Semantic validation\n        CubeMetadataValidator validator = new CubeMetadataValidator();\n        ValidateContext context = validator.validate(desc, true);\n        if (!context.ifPass()) {\n            return desc;\n        }\n\n        desc.setSignature(desc.calculateSignature());\n\n        // Save Source\n        String path = desc.getResourcePath();\n        getStore().putResource(path, desc, CUBE_DESC_SERIALIZER);\n\n        // Reload the CubeDesc\n        CubeDesc ndesc = loadCubeDesc(path);\n        // Here replace the old one\n        cubeDescMap.put(ndesc.getName(), desc);\n\n        return ndesc;\n    }\n",
    "new_code_raw": "    public CubeDesc updateCubeDesc(CubeDesc desc) throws IOException {\n        // Validate CubeDesc\n        if (desc.getUuid() == null || desc.getName() == null) {\n            throw new IllegalArgumentException();\n        }\n        String name = desc.getName();\n        if (!cubeDescMap.containsKey(name)) {\n            throw new IllegalArgumentException(\"CubeDesc '\" + name + \"' does not exist.\");\n        }\n\n        try {\n            desc.init(config, getMetadataManager().getAllTablesMap());\n        } catch (Exception e) {\n            desc.addError(e.getMessage());\n            return desc;\n        }\n\n        // Semantic validation\n        CubeMetadataValidator validator = new CubeMetadataValidator();\n        ValidateContext context = validator.validate(desc);\n        if (!context.ifPass()) {\n            return desc;\n        }\n\n        desc.setSignature(desc.calculateSignature());\n\n        // Save Source\n        String path = desc.getResourcePath();\n        getStore().putResource(path, desc, CUBE_DESC_SERIALIZER);\n\n        // Reload the CubeDesc\n        CubeDesc ndesc = loadCubeDesc(path, false);\n        // Here replace the old one\n        cubeDescMap.put(ndesc.getName(), desc);\n\n        return ndesc;\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1976-FirstSentence-0",
    "old_comment_raw": "Provides protected access to the underlying  EntityManagerFactoryImpl.",
    "new_comment_raw": "Provides protected access to the underlying  SessionFactoryImpl.",
    "old_code_raw": "\tpublic  EntityManagerFactoryImpl getEntityManagerFactory() {\n\t\treturn entityManagerFactory;\n\t}\n",
    "new_code_raw": "\tpublic  SessionFactoryImpl getEntityManagerFactory() {\n\t\treturn sessionFactory;\n\t}\n"
  },
  {
    "id": "processing_processing-213-FirstSentence-0",
    "old_comment_raw": "Any modes that extend JavaMode can override this method to add additional",
    "new_comment_raw": "Any modes that extend JavaMode can override this method to add additional",
    "old_code_raw": "  public String getSearchPath() {\n    // Java Mode doesn't need any default external jars at the moment.\n    // This is here for Android Mode so that it can add its android.jar file.\n    return null;\n  }\n",
    "new_code_raw": "  public String getSearchPath() {\n    return getCoreLibrary().getJarPath();\n  }\n"
  },
  {
    "id": "jenkinsci_android-emulator-plugin-11-Associations-FirstSentence",
    "old_comment_raw": "Waits for a socket on the remote machine's localhost to become available, or times out.",
    "new_comment_raw": "Waits for an emulator to say what socket its using, or times out.",
    "old_code_raw": "    private boolean waitForSocket(Launcher launcher, int port, int timeout) {\n        try {\n            LocalPortOpenTask task = new LocalPortOpenTask(port, timeout);\n            return launcher.getChannel().call(task);\n        } catch (InterruptedException ex) {\n            // Ignore\n        } catch (IOException e) {\n            // Ignore\n        }\n\n        return false;\n    }\n",
    "new_code_raw": "    private int waitForSocket(Launcher launcher, int port, int timeout) {\n        try {\n            LocalPortReceiveAdbPortTask task = new LocalPortReceiveAdbPortTask(port, timeout);\n            return launcher.getChannel().call(task);\n        } catch (InterruptedException ex) {\n            // Ignore\n        } catch (IOException e) {\n            // Ignore\n        }\n        return -1;\n    }\n\n"
  },
  {
    "id": "querydsl_querydsl-553-FirstSentence-0",
    "old_comment_raw": "Get the type(path) expression",
    "new_comment_raw": "Get the type(path) expression",
    "old_code_raw": "    public static StringExpression type(EntityPath<?> path) {\n        return StringOperation.create(JPQLTemplates.TYPE, path);\n    }\n",
    "new_code_raw": "    public static StringExpression type(EntityPath<?> path) {\n        return StringOperation.create(JPQLOps.TYPE, path);\n    }\n"
  },
  {
    "id": "ariejan_slick2d-56-Associations-FirstSentence",
    "old_comment_raw": "Get the y location of the center of this circle",
    "new_comment_raw": "Get the y position of the top of this shape.",
    "old_code_raw": "    public float getY() {\r\n        return center[1];\r\n    }\r\n",
    "new_code_raw": "    public float getY() {\r\n        if(top == null) {\r\n            calculateTop();\r\n        }\r\n\r\n        return top.floatValue();\r\n    }\r\n\n"
  },
  {
    "id": "dropwizard_dropwizard-17-FirstSentence-0",
    "old_comment_raw": "Appends a trailing '/' to a  URL object.",
    "new_comment_raw": "Appends a trailing '/' to a  URL object.",
    "old_code_raw": "    public static URL appendTrailingSlash(final URL originalURL) {\n        try {\n            return !originalURL.getPath().endsWith(\"/\") ? new URL(originalURL.getProtocol(),\n                                                                  originalURL.getHost(),\n                                                                  originalURL.getPort(),\n                                                                  originalURL.getFile() + '/') : originalURL;\n        } catch (MalformedURLException ignored) { // shouldn't happen\n            throw new IllegalArgumentException(\"Invalid resource URL: \" + originalURL);\n        }\n    }\n",
    "new_code_raw": "    public static URL appendTrailingSlash(URL originalURL) {\n        try {\n            return originalURL.getPath().endsWith(\"/\") ? originalURL :\n                    new URL(originalURL.getProtocol(),\n                            originalURL.getHost(),\n                            originalURL.getPort(),\n                            originalURL.getFile() + '/');\n        } catch (MalformedURLException ignored) { // shouldn't happen\n            throw new IllegalArgumentException(\"Invalid resource URL: \" + originalURL);\n        }\n    }\n"
  },
  {
    "id": "apache_derby-17-Associations-FirstSentence",
    "old_comment_raw": "Get the string representation for the underlying physical connection.",
    "new_comment_raw": "Get the string representation for this connection.",
    "old_code_raw": "    public String toString() \n    {\n        try\n        {\n            return getRealConnection().toString();\n        }\n        catch ( SQLException e )\n        {\n            return \"<no connection>\";\n        }\n    }\n",
    "new_code_raw": "    public String toString() \n    {\n        if ( connString == null )\n        {\n            String wrappedString;\n            try\n            {\n                wrappedString = getRealConnection().toString();\n            }\n            catch ( SQLException e )\n            {\n                wrappedString = \"<none>\";\n            }\n            \n            connString = this.getClass().getName() + \"@\" + this.hashCode() +\n                \", Wrapped Connection = \" + wrappedString;\n        }\n        \n        return connString;\n    }\n\n"
  },
  {
    "id": "querydsl_querydsl-585-FirstSentence-0",
    "old_comment_raw": "Clone the state of this query to a new instance",
    "new_comment_raw": "Clone the state of this query to a new instance",
    "old_code_raw": "    public Q clone() {\n        JPQLTemplates existingTemplates = getTemplates();\n        if (existingTemplates != null) {\n            return clone(entityManager, existingTemplates);\n        }else {\n            return clone(entityManager);\n        }\n    }\n",
    "new_code_raw": "    public Q clone() {\n        return clone(entityManager, getTemplates());\n    }\n"
  },
  {
    "id": "apache_jsecurity-43-Associations-FirstSentence",
    "old_comment_raw": "Convenience implementation that returns getAuthenticationTokenClass().isAssignableFrom( tokenClass );.",
    "new_comment_raw": "Convenience implementation that returns getAuthenticationTokenClass().isAssignableFrom( token.getClass() );.",
    "old_code_raw": "    public boolean supports(Class tokenClass) {\n        return getAuthenticationTokenClass().isAssignableFrom( tokenClass );\n    }\n",
    "new_code_raw": "    public boolean supports(AuthenticationToken token) {\n        if ( log.isInfoEnabled() ) {\n            log.info( \"Received null AuthenticationToken.  Returning false for supports(token) implementation (can't \" +\n                \"process null tokens).\" );\n        }\n        return token != null && getAuthenticationTokenClass().isAssignableFrom(token.getClass());\n    }\n\n"
  },
  {
    "id": "apache_drill-1127-FirstSentence-0",
    "old_comment_raw": "Perform merging of (typically spilled) batches.",
    "new_comment_raw": "Perform merging of (typically spilled) batches.",
    "old_code_raw": "  private SortResults mergeSpilledRuns() {\n    logger.debug(\"Starting consolidate phase. Batches = {}, Records = {}, Memory = {}, In-memory batches {}, spilled runs {}\",\n                 metrics.getInputBatchCount(), metrics.getInputRowCount(),\n                 allocator.getAllocatedMemory(),\n                 bufferedBatches.size(), spilledRuns.size());\n\n    // Consolidate batches to a number that can be merged in\n    // a single last pass.\n\n    loop:\n    for (;;) {\n      MergeTask task = memManager.consolidateBatches(\n          allocator.getAllocatedMemory(),\n          bufferedBatches.size(),\n          spilledRuns.size());\n      switch (task.action) {\n      case SPILL:\n        spillFromMemory();\n        break;\n      case MERGE:\n        mergeRuns(task.count);\n        break;\n      case NONE:\n        break loop;\n      default:\n        throw new IllegalStateException(\"Unexpected action: \" + task.action);\n      }\n    }\n\n    int mergeRowCount = memManager.getMergeBatchRowCount();\n    return spilledRuns.finalMerge(bufferedBatches.removeAll(), outputBatch, mergeRowCount);\n  }\n",
    "new_code_raw": "  private SortResults mergeSpilledRuns() {\n    logger.debug(\"Starting consolidate phase. Batches = {}, Records = {}, Memory = {}, In-memory batches {}, spilled runs {}\",\n                 metrics.getInputBatchCount(), metrics.getInputRowCount(),\n                 allocator.getAllocatedMemory(),\n                 bufferedBatches.size(), spilledRuns.size());\n\n    // Consolidate batches to a number that can be merged in\n    // a single last pass.\n\n    loop:\n    for (;;) {\n      MergeTask task = memManager.consolidateBatches(\n          allocator.getAllocatedMemory(),\n          bufferedBatches.size(),\n          spilledRuns.size());\n      switch (task.action) {\n      case SPILL:\n        spillFromMemory();\n        break;\n      case MERGE:\n        mergeRuns(task.count);\n        break;\n      case NONE:\n        break loop;\n      default:\n        throw new IllegalStateException(\"Unexpected action: \" + task.action);\n      }\n    }\n\n    int mergeRowCount = memManager.getMergeBatchRowCount();\n    return spilledRuns.finalMerge(bufferedBatches.removeAll(), outputBatch, mergeRowCount, allocHelper);\n  }\n"
  },
  {
    "id": "merikan_skltpservices-googlecode-6-Associations-FirstSentence",
    "old_comment_raw": "Maps contact body information.",
    "new_comment_raw": "Create a MedicationMedicalRecord using the information in the current ehr13606 composition.",
    "old_code_raw": "    protected MedicationMedicalRecordBodyType mapBody(final EHREXTRACT ehrExtract, final int compositionIndex) {\n        final COMPOSITION composition = ehrExtract.getAllCompositions().get(compositionIndex);\n\n        final MedicationMedicalRecordBodyType bodyType = new MedicationMedicalRecordBodyType();\n        \n        \n        AdditionalPatientInformationType apit = new AdditionalPatientInformationType();\n        apit.setDateOfBirth(\"2010-01-31\");\n        \n        CVType gender = new CVType();\n        gender.setCode(\"abc\");\n        gender.setCodeSystem(\"def\");\n        gender.setDisplayName(\"ghi\");\n        gender.setOriginalText(\"jkl\");\n        apit.setGender(gender);\n        \n        bodyType.setAdditionalPatientInformation(apit);\n        \n        MedicationPrescriptionType mpt = new MedicationPrescriptionType();\n        \n        mpt.setDispensationAuthorization(new DispensationAuthorizationType());\n        mpt.setEndOfTreatment(\"2014-12-31\");\n        mpt.setEndOfTreatmentReason(new CVType());\n        mpt.setEvaluator(new HealthcareProfessionalType());\n        mpt.setPrecedingPrescriptionId(new IIType());\n        mpt.setPrescriber(new HealthcareProfessionalType());\n        mpt.setPrescriptionChainId(new IIType());\n        mpt.setPrescriptionId(new IIType());\n        mpt.setPrescriptionStatus(new CVType());\n        mpt.setSelfMedication(false);\n        mpt.setStartOfFirstTreatment(\"2014-01-31\");\n        mpt.setSucceedingPrescriptionId(new IIType());\n        mpt.setTypeOfPrescription(TypeOfPrescriptionEnum.INS\u00c4TTNING);\n        \n        bodyType.setMedicationPrescription(mpt);\n\n        for (final CONTENT content : composition.getContent()) {\n            for (final ITEM item : ((ENTRY) content).getItems()) {\n            \t\n            \t\n            \tlog.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + (item instanceof ELEMENT ? \"ELEMENT\" : \"CLUSTER\"));\n\n                switch (item.getMeaning().getCode()) {\n                    case \"lkm-ord-tid\":   // Ordinationstidpunkt\n                        mpt.setStartOfTreatment(\"2014-02-28\");\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)item));\n                        break;\n                    case \"lkm-ord-not\":   // Notat\n                        mpt.setPrescriptionNote(\"Here is a note\");\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)item));\n                        break;\n                    case \"lkm-ord-utv\":   // Utv\u00e4rderingstidpunkt\n                        mpt.setEvaluationTime(\"123\");\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)item));\n                        break;\n                    case \"lkm-ord-and\":   // \u00c4ndam\u00e5l\n                        mpt.setTreatmentPurpose(\"There is a purpose to this treatment\");\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)item));\n                        break;\n                        \n\n                    case \"lkm-dos\"    :   // Dosering\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue());\n                    \tCLUSTER c = (CLUSTER)item;\n                    \tList<ITEM> parts = c.getParts();\n                    \tfor (ITEM part : parts) {\n                        \tlog.debug(part.getMeaning().getCode());\n                            if (\"lkm-dst\".equals(part.getMeaning().getCode())) {\n                                c = (CLUSTER)part;\n                                \n                                List<ITEM> dosparts = c.getParts();\n                                for (ITEM dospart : dosparts) {\n                                    log.debug(dospart.getMeaning().getCode() + \" \" + dospart.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)dospart));\n                                }\n                            }\n                        }\n                        break;\n                        \n                    case \"lkm-lva\"    :   // L\u00e4kemedelsval\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue());\n                        c = (CLUSTER)item;\n                        parts = c.getParts();\n                        for (ITEM part : parts) {\n                            log.debug(part.getMeaning().getCode());\n                            \n                            switch (item.getMeaning().getCode()) {\n                            case \"lkm-lva-kom\" :\n                                log.debug(part.getMeaning().getCode() + \" \" + part.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)part));\n                                break;\n                            case \"lkm-lva-typ\" :\n                                log.debug(part.getMeaning().getCode() + \" \" + part.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)part));\n                                break;\n                            case \"lkm-lva-ext\" :\n                                log.debug(part.getMeaning().getCode() + \" \" + part.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)part));\n                                break;\n                            case \"lkm-lkm-lva\":\n                                log.debug(part.getMeaning().getCode() + \" \" + part.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)part));\n                                break;\n                            }\n                        }\n                        // mpt.setDrug(new DrugChoiceType());\n                        // EHRUtil.getElementTextValue((ELEMENT)item);\n                        break;\n                        \n                        \n                    case \"lkm-for-tid\":   // F\u00f6rskrivningstidpunkt\n                        mpt.setStartOfTreatment(\"2014-02-28\");\n                        break;\n                    case \"lkm-for-uiv\":   // Utl\u00e4mningsintervall\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)item));\n                        break;\n                    case \"lkm-for-mpt\":   // M\u00e4ngd per tillf\u00e4lle\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)item));\n                        break;\n                    case \"lkm-for-tot\":   // Totalm\u00e4ngd\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)item));\n                        break;\n                    case \"lkm-for-fpe\":   // F\u00f6rpackningsenhet\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)item));\n                        break;\n                    case \"lkm-for-dbs\":   // Distributionss\u00e4tt\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)item));\n                        break;\n                }\n            }\n        }\n        return bodyType;\n    }\n",
    "new_code_raw": "    protected MedicationMedicalRecordBodyType mapBody(final EHREXTRACT ehrExtract, final int compositionIndex) {\n    \n        final COMPOSITION composition = ehrExtract.getAllCompositions().get(compositionIndex);\n        \n        // parse this composition into values stored in a Map\n        Map<String,String> ehr13606values = retrieveValues(composition, compositionIndex);\n        \n        // use the ehr values to build a medication medical history record body\n        return buildBody(ehr13606values);\n    }\n\n"
  },
  {
    "id": "apache_calcite-744-FirstSentence-0",
    "old_comment_raw": "Creates the HTTP client that communicates with the Avatica server.",
    "new_comment_raw": "Creates the HTTP client that communicates with the Avatica server.",
    "old_code_raw": "  AvaticaHttpClient getHttpClient(AvaticaConnection connection, ConnectionConfig config) {\n    URL url;\n    try {\n      url = new URL(config.url());\n    } catch (MalformedURLException e) {\n      throw new RuntimeException(e);\n    }\n\n    return new AvaticaHttpClientImpl(url);\n  }\n",
    "new_code_raw": "  AvaticaHttpClient getHttpClient(AvaticaConnection connection, ConnectionConfig config) {\n    URL url;\n    try {\n      url = new URL(config.url());\n    } catch (MalformedURLException e) {\n      throw new RuntimeException(e);\n    }\n\n    AvaticaHttpClientFactory httpClientFactory = config.httpClientFactory();\n\n    return httpClientFactory.getClient(url, config);\n  }\n"
  },
  {
    "id": "eclipse_emf-128-Associations-FirstSentence",
    "old_comment_raw": "Returns the result of interpretting the object as an instance of 'sType'.",
    "new_comment_raw": "Returns the result of interpretting the object as an instance of 'Customers Type'.",
    "old_code_raw": "  public Object caseCustomersType(CustomersType object)\n  {\n    return null;\n  }\n",
    "new_code_raw": "  public T caseCustomersType(CustomersType object)\n  {\n    return null;\n  }\n\n"
  },
  {
    "id": "SeleniumHQ_selenium-536-FirstSentence-0",
    "old_comment_raw": "Returns all browser cookies.",
    "new_comment_raw": "Returns all browser cookies.",
    "old_code_raw": "  public static Command<Cookies> getAllCookies() {\n    return new Command<>(\n      DOMAIN_NAME + \".getAllCookies\",\n      ImmutableMap.of(),\n      map(\"cookies\", Cookies.class));\n  }\n",
    "new_code_raw": "  public static Command<List<Cookie>> getAllCookies() {\n    return new Command<>(\n      DOMAIN_NAME + \".getAllCookies\",\n      ImmutableMap.of(),\n      map(\"cookies\", new TypeToken<List<Cookie>>() {}.getType()));\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-467-FirstSentence-0",
    "old_comment_raw": "Gets the value as a String in the ISO8601 duration format.",
    "new_comment_raw": "Gets the value as a String in the ISO8601 duration format including only seconds and milliseconds.",
    "old_code_raw": "    public String toString() {\n        return ISOPeriodFormat.getInstance().standard().print(toPeriod());\n    }\n",
    "new_code_raw": "    public String toString() {\n        long millis = getMillis();\n        StringBuffer buf = new StringBuffer();\n        buf.append(\"PT\");\n        FormatUtils.appendUnpaddedInteger(buf, millis / 1000);\n        long part = Math.abs(millis % 1000);\n        if (part > 0) {\n            buf.append('.');\n            FormatUtils.appendPaddedInteger(buf, part, 3);\n        }\n        buf.append('S');\n        return buf.toString();\n    }\n"
  },
  {
    "id": "apache_kylin-440-FirstSentence-0",
    "old_comment_raw": "Check whether the cube can match the sql digest with TopN measure",
    "new_comment_raw": "Check whether the cube can match the sql digest with TopN measure",
    "old_code_raw": "    public static boolean isMatchedWithTopN(CubeInstance cube, SQLDigest digest) {\n        Collection<TblColRef> dimensionColumns = CubeDimensionDeriver.getDimensionColumns(digest);\n        \n        boolean matchDimensions = isMatchedWithDimensions(dimensionColumns, cube);\n\n        if (matchDimensions == true) {\n            return false;\n        }\n\n        Collection<FunctionDesc> functions = digest.aggregations;\n        if (functions == null || functions.size() != 1) {\n            // topN only allow one measure\n            return false;\n        }\n\n        return isMatchedWithTopN(dimensionColumns, cube, digest);\n    }\n",
    "new_code_raw": "    public static boolean isMatchedWithTopN(CubeInstance cube, SQLDigest digest) {\n\n        boolean hasTopN = hasTopNMeasure(cube.getDescriptor());\n        \n        if (hasTopN == false) {\n            return false;\n        }\n        \n        Collection<TblColRef> dimensionColumns = CubeDimensionDeriver.getDimensionColumns(digest);\n        \n        boolean matchDimensions = isMatchedWithDimensions(dimensionColumns, cube);\n\n        if (matchDimensions == true) {\n            return false;\n        }\n\n        Collection<FunctionDesc> functions = digest.aggregations;\n        if (functions == null || functions.size() != 1) {\n            // topN only allow one measure\n            return false;\n        }\n\n        return isMatchedWithTopN(dimensionColumns, cube, digest);\n    }\n"
  },
  {
    "id": "JetBrains_adt-tools-base-187-Associations-FirstSentence",
    "old_comment_raw": "Return the directory containing the toolchain.",
    "new_comment_raw": "Return the path containing the prebuilt toolchain.",
    "old_code_raw": "    private File getToolchainPath(\n            Toolchain toolchain,\n            String toolchainVersion,\n            Abi abi) {\n        String version = toolchainVersion.isEmpty()\n                ? getDefaultToolchainVersion(toolchain, abi).toString()\n                : toolchainVersion;\n\n        File prebuiltFolder = new File(\n                ndkDirectory,\n                \"toolchains/\" + getToolchainPrefix(toolchain, abi) + \"-\" + version + \"/prebuilt\");\n\n        String osName = System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH);\n        String hostOs;\n        if (osName.contains(\"windows\")) {\n            hostOs = \"windows\";\n        } else if (osName.contains(\"mac\")) {\n            hostOs = \"darwin\";\n        } else {\n            hostOs = \"linux\";\n        }\n\n        // There should only be one directory in the prebuilt folder.  If there are more than one\n        // attempt to determine the right one based on the operating system.\n        File[] toolchainPaths = prebuiltFolder.listFiles(\n                new FileFilter() {\n                    @Override\n                    public boolean accept(File file) {\n                        return file.isDirectory();\n                    }\n                });\n\n        if (toolchainPaths == null) {\n            throw new InvalidUserDataException(\"Unable to find toolchain: \"\n                    + prebuiltFolder);\n        }\n        if (toolchainPaths.length == 1) {\n            return toolchainPaths[0];\n        }\n\n        // Use 64-bit toolchain if available.\n        File toolchainPath = new File(prebuiltFolder, hostOs + \"-x86_64\");\n        if (toolchainPath.isDirectory()) {\n            return toolchainPath;\n        }\n\n        // Fallback to 32-bit if we can't find the 64-bit toolchain.\n        String osString = (osName.equals(\"windows\")) ? hostOs : hostOs + \"-x86\";\n        toolchainPath = new File(prebuiltFolder, osString);\n        if (toolchainPath.isDirectory()) {\n            return toolchainPath;\n        } else {\n            throw new InvalidUserDataException(\"Unable to find toolchain prebuilt folder in: \"\n                    + prebuiltFolder);\n        }\n    }\n",
    "new_code_raw": "    private File getToolchainPath(Abi abi) {\n        return getToolchainPath(toolchain, toolchainVersion, abi);\n    }\n\n"
  },
  {
    "id": "SeleniumHQ_selenium-441-FirstSentence-0",
    "old_comment_raw": "Gets the SOCKS version (4 or 5).",
    "new_comment_raw": "Gets the SOCKS version (4 or 5).",
    "old_code_raw": "  public String getSocksVersion() {\n    return socksVersion;\n  }\n",
    "new_code_raw": "  public Integer getSocksVersion() {\n    return socksVersion;\n  }\n"
  },
  {
    "id": "trygvis_jop-74-Associations-FirstSentence",
    "old_comment_raw": "Get a collection of all (loaded) interfaces this class directly implements.",
    "new_comment_raw": "Get a set of all (loaded) interfaces this class directly implements.",
    "old_code_raw": "    public Collection<ClassInfo> getInterfaces() {\n        return interfaces;\n    }\n",
    "new_code_raw": "    public Set<ClassInfo> getInterfaces() {\n        String[] names = classGen.getInterfaceNames();\n        Set<ClassInfo> interfaces = new HashSet<ClassInfo>(names.length);\n        for (String name : names) {\n            ClassInfo cls = getAppInfo().getClassInfo(name);\n            if (cls != null) {\n                interfaces.add(cls);\n            }\n        }\n        return interfaces;\n    }\n\n"
  },
  {
    "id": "apache_drill-1122-FirstSentence-0",
    "old_comment_raw": "Creates table entry using table name and list of partition columns if any.",
    "new_comment_raw": "Creates table entry using table name and list of partition columns if any.",
    "old_code_raw": "  public CreateTableEntry createNewTable(String tableName, List<String> partitionColumns) {\n    return createNewTable(tableName, partitionColumns, StorageStrategy.PERSISTENT);\n  }\n",
    "new_code_raw": "  public CreateTableEntry createNewTable(String tableName, List<String> partitionColumns) {\n    return createNewTable(tableName, partitionColumns, StorageStrategy.DEFAULT);\n  }\n"
  },
  {
    "id": "orfjackal_ikayaki-45-Associations-FirstSentence",
    "old_comment_raw": "Returns current known position.",
    "new_comment_raw": "Returns the position where the handler is currently, or where it is heading right now.",
    "old_code_raw": "    public int getPosition() {\n        return this.currentPosition;\n\n    }\n",
    "new_code_raw": "    public int getPosition() {\n        return currentPosition;\n\n    }\n\n"
  },
  {
    "id": "apache_kylin-512-FirstSentence-0",
    "old_comment_raw": "Update a cube status from disable to ready.",
    "new_comment_raw": "Update a cube status from disable to ready.",
    "old_code_raw": "    @PreAuthorize(Constant.ACCESS_HAS_ROLE_ADMIN + \" or hasPermission(#cube, 'ADMINISTRATION') or hasPermission(#cube, 'OPERATION')  or hasPermission(#cube, 'MANAGEMENT')\")\n    public CubeInstance enableCube(CubeInstance cube) throws IOException, JobException {\n        String cubeName = cube.getName();\n\n        RealizationStatusEnum ostatus = cube.getStatus();\n        if (!cube.getStatus().equals(RealizationStatusEnum.DISABLED)) {\n            throw new InternalErrorException(\"Only disabled cube can be enabled, status of \" + cubeName + \" is \" + ostatus);\n        }\n\n        if (cube.getSegments(SegmentStatusEnum.READY).size() == 0) {\n            throw new InternalErrorException(\"Cube \" + cubeName + \" dosen't contain any READY segment\");\n        }\n\n        final List<CubingJob> cubingJobs = listAllCubingJobs(cube.getName(), null, EnumSet.of(ExecutableState.READY, ExecutableState.RUNNING));\n        if (!cubingJobs.isEmpty()) {\n            throw new JobException(\"Enable is not allowed with a running job.\");\n        }\n        if (!cube.getDescriptor().calculateSignature().equals(cube.getDescriptor().getSignature())) {\n            cube = this.releaseAllSegments(cube);\n        }\n\n        try {\n            return getCubeManager().updateCube(cube, null, null, null, RealizationStatusEnum.READY);\n        } catch (IOException e) {\n            cube.setStatus(ostatus);\n            throw e;\n        }\n    }\n",
    "new_code_raw": "    @PreAuthorize(Constant.ACCESS_HAS_ROLE_ADMIN + \" or hasPermission(#cube, 'ADMINISTRATION') or hasPermission(#cube, 'OPERATION')  or hasPermission(#cube, 'MANAGEMENT')\")\n    public CubeInstance enableCube(CubeInstance cube) throws IOException, JobException {\n        String cubeName = cube.getName();\n\n        RealizationStatusEnum ostatus = cube.getStatus();\n        if (!cube.getStatus().equals(RealizationStatusEnum.DISABLED)) {\n            throw new InternalErrorException(\"Only disabled cube can be enabled, status of \" + cubeName + \" is \" + ostatus);\n        }\n\n        if (cube.getSegments(SegmentStatusEnum.READY).size() == 0) {\n            throw new InternalErrorException(\"Cube \" + cubeName + \" dosen't contain any READY segment\");\n        }\n\n        final List<CubingJob> cubingJobs = listAllCubingJobs(cube.getName(), null, EnumSet.of(ExecutableState.READY, ExecutableState.RUNNING));\n        if (!cubingJobs.isEmpty()) {\n            throw new JobException(\"Enable is not allowed with a running job.\");\n        }\n        if (!cube.getDescriptor().calculateSignature().equals(cube.getDescriptor().getSignature())) {\n            this.releaseAllSegments(cube);\n        }\n\n        cube.setStatus(RealizationStatusEnum.READY);\n        try {\n            return getCubeManager().updateCube(cube);\n        } catch (IOException e) {\n            cube.setStatus(ostatus);\n            throw e;\n        }\n    }\n"
  },
  {
    "id": "apache_calcite-874-FirstSentence-0",
    "old_comment_raw": "Called by reflection based on the definition of the user-defined function in the schema.",
    "new_comment_raw": "Table function that generates a maze.",
    "old_code_raw": "  public static ScannableTable generate(int width, int height, int seed) {\n    return new MazeTable(width, height, seed);\n  }\n",
    "new_code_raw": "  public static ScannableTable generate(int width, int height, int seed) {\n    return new MazeTable(width, height, seed, false);\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1776-FirstSentence-0",
    "old_comment_raw": "Determine the optimizer to use.",
    "new_comment_raw": "Determine the optimizer to use.",
    "old_code_raw": "\tprotected String determineOptimizationStrategy(Properties params, int incrementSize) {\n\t\t// if the increment size is greater than one, we prefer pooled optimization; but we first\n\t\t// need to see if the user prefers POOL or POOL_LO...\n\t\tfinal String defaultPooledOptimizerStrategy = ConfigurationHelper.getBoolean( Environment.PREFER_POOLED_VALUES_LO, params, false )\n\t\t\t\t? StandardOptimizerDescriptor.POOLED_LO.getExternalName()\n\t\t\t\t: StandardOptimizerDescriptor.POOLED.getExternalName();\n\t\tfinal String defaultOptimizerStrategy = incrementSize <= 1\n\t\t\t\t? StandardOptimizerDescriptor.NONE.getExternalName()\n\t\t\t\t: defaultPooledOptimizerStrategy;\n\t\treturn ConfigurationHelper.getString( OPT_PARAM, params, defaultOptimizerStrategy );\n\t}\n",
    "new_code_raw": "\tprotected String determineOptimizationStrategy(Properties params, int incrementSize) {\n\t\treturn ConfigurationHelper.getString(\n\t\t\t\tOPT_PARAM,\n\t\t\t\tparams,\n\t\t\t\tOptimizerFactory.determineImplicitOptimizerName( incrementSize, params )\n\t\t);\n\t}\n"
  },
  {
    "id": "udacity_ud851_Sunshine-7-FirstSentence-0",
    "old_comment_raw": "The entry point to your Job.",
    "new_comment_raw": "The entry point to your Job.",
    "old_code_raw": "    public boolean onStartJob(final JobParameters jobParameters) {\n\n        mFetchWeatherThread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n\n                Context context = getApplicationContext();\n                SunshineSyncTask.syncWeather(context);\n//              COMPLETED (6) Once the weather data is sync'd, call jobFinished with the appropriate arguements\n                jobFinished(jobParameters, false);\n            }\n        });\n\n        mFetchWeatherThread.start();\n\n        return true;\n    }\n",
    "new_code_raw": "    public boolean onStartJob(final JobParameters jobParameters) {\n\n        mFetchWeatherTask = new AsyncTask<Void, Void, Void>(){\n            @Override\n            protected Void doInBackground(Void... voids) {\n                Context context = getApplicationContext();\n                SunshineSyncTask.syncWeather(context);\n                return null;\n            }\n\n            @Override\n            protected void onPostExecute(Void aVoid) {\n                //  COMPLETED (6) Once the weather data is sync'd, call jobFinished with the appropriate arguements\n                jobFinished(jobParameters, false);\n            }\n        };\n\n        mFetchWeatherTask.execute();\n        return true;\n    }\n"
  },
  {
    "id": "zaproxy_zaproxy-2127-FirstSentence-0",
    "old_comment_raw": "Reads given length from the channel.",
    "new_comment_raw": "Reads given length from the given stream.",
    "old_code_raw": "\t\tprivate ByteBuffer read(SocketChannel channel, int length) throws IOException {\n\t\t\tByteBuffer buffer = ByteBuffer.allocate(length);\n\t\t\t\n\t\t\tint bytesRead = 0;\n\t\t\tdo {\n\t\t\t\tbytesRead += channel.read(buffer);\n\t\t\t} while (length != bytesRead);\n\t\t\t\n\t\t\tbuffer.flip();\n\t\t\t\n\t\t\tint freeSpace = currentFrame.capacity() - currentFrame.position();\n\t\t\tif (freeSpace < bytesRead) {\n\t\t\t\tcurrentFrame = reallocate(currentFrame, currentFrame.position() + bytesRead);\n\t\t\t}\n\n\t\t\t// add bytes to current frame and reset to be able to read again\n\t\t\tcurrentFrame.put(buffer);\n\t\t\tbuffer.rewind();\n\t\t\t\n\t\t\treturn buffer;\n\t\t}\n",
    "new_code_raw": "\t\tprivate byte[] read(InputStream in, int length) throws IOException {\n\t\t\tbyte[] buffer = new byte[length];\n\t\t\t\n\t\t\tint bytesRead = 0;\n\t\t\tdo {\n\t\t\t\tbytesRead += in.read(buffer);\n\t\t\t} while (length != bytesRead);\n\t\t\t\n\t\t\tint freeSpace = currentFrame.capacity() - currentFrame.position();\n\t\t\tif (freeSpace < bytesRead) {\n\t\t\t\tcurrentFrame = reallocate(currentFrame, currentFrame.position() + bytesRead);\n\t\t\t}\n\n\t\t\t// add bytes to current frame and reset to be able to read again\n\t\t\tcurrentFrame.put(buffer);\n\t\t\t\n\t\t\treturn buffer;\n\t\t}\n"
  },
  {
    "id": "debezium_debezium-851-FirstSentence-0",
    "old_comment_raw": "Converts a value object for an expected JDBC type of  Types#TIME to  MicroTime values, or microseconds past midnight.",
    "new_comment_raw": "Converts a value object for an expected JDBC type of  Types#TIME to  MicroTime values, or microseconds past midnight.",
    "old_code_raw": "    protected Object convertTimeToMicrosPastMidnight(Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0L; // return epoch\n        }\n        try {\n            return MicroTime.toMicroOfDay(data);\n        } catch (IllegalArgumentException e) {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n    }\n",
    "new_code_raw": "    protected Object convertTimeToMicrosPastMidnight(Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0L; // return epoch\n        }\n        try {\n            return MicroTime.toMicroOfDay(data, adjuster);\n        } catch (IllegalArgumentException e) {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n    }\n"
  },
  {
    "id": "querydsl_querydsl-567-FirstSentence-0",
    "old_comment_raw": "Create a left or right expression",
    "new_comment_raw": "Create a left or right expression",
    "old_code_raw": "    public static Predicate or(Predicate left, Predicate right) {\n        return PredicateOperation.create(Ops.OR, left, right);\n    }\n",
    "new_code_raw": "    public static Predicate or(Predicate left, Predicate right) {\n        left = (Predicate) extract(left);\n        right = (Predicate) extract(right);\n        if (left == null) {\n            return right;\n        } else if (right == null) {\n            return left;\n        } else {\n            return PredicateOperation.create(Ops.OR, left, right);\n        }\n    }\n"
  },
  {
    "id": "nelsonsilva_vaadin-42-Associations-FirstSentence",
    "old_comment_raw": "Updates the visible items by given prefix.",
    "new_comment_raw": "Updates the visible items by given key.",
    "old_code_raw": "\t\tpublic ArrayList filterContent(String prefix) {\n\t\t\t// prefix MUST be in lowercase\n\t\t\tif (\"\".equals(prefix)) {\n\t\t\t\tthis.filteredItemsBuffer = new ArrayList(getItemIds());\n\t\t\t\treturn this.filteredItemsBuffer;\n\n\t\t\t} else if (items != null) { \n\t\t\t\t// all items will be iterated and tested.\n\t\t\t\t// SLOW when there are lot of items.\n\t\t\t\t// TODO Should we add \n\t\t\t\tthis.filteredItemsBuffer = new ArrayList();\n\t\t\t\tfor (Iterator iter = items.getItemIds().iterator(); iter\n\t\t\t\t\t\t.hasNext();) {\n\t\t\t\t\tObject id = iter.next();\n\n\t\t\t\t\tItem item = getItem(id);\n\t\t\t\t\tString test = \"\";\n\t\t\t\t\tif (getItemCaptionMode() == ITEM_CAPTION_MODE_PROPERTY)\n\t\t\t\t\t\ttest = item.getItemProperty(getItemCaptionPropertyId())\n\t\t\t\t\t\t\t\t.getValue().toString().trim();\n\t\t\t\t\telse\n\t\t\t\t\t\ttest = String.valueOf(id);\n\n\t\t\t\t\tif (test.toLowerCase().startsWith(prefix)) {\n\t\t\t\t\t\tthis.filteredItemsBuffer.add(id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.filteredItemsBuffer;\n\t\t}\n",
    "new_code_raw": "\t\tpublic ArrayList filterContent(String key) {\n\t\t\treturn this.of.filter(key);\n\t\t}\n\n"
  },
  {
    "id": "RobotiumTech_robotium-1413-FirstSentence-0",
    "old_comment_raw": "Scrolls down a list with a given index.",
    "new_comment_raw": "Scrolls down a list with a given index.",
    "old_code_raw": "\tpublic boolean scrollDownList(int index) {\n\t\treturn scroller.scrollList(ListView.class, waiter.waitForAndGetView(index, ListView.class), Scroller.DOWN, null);\n\t}\n",
    "new_code_raw": "\tpublic boolean scrollDownList(int index) {\n\t\treturn scroller.scrollList(waiter.waitForAndGetView(index, ListView.class), Scroller.DOWN);\n\t}\n"
  },
  {
    "id": "jdcasey_maven-plugins-fixes-142-Associations-FirstSentence",
    "old_comment_raw": "Read the announcement generated file.",
    "new_comment_raw": "Read the content of the generated announcement file.",
    "old_code_raw": "    protected FileReader readAnnouncement( File file )\n        throws MojoExecutionException\n    {\n        FileReader fileReader;\n        try\n        {\n            fileReader = new FileReader( file );\n        }\n        catch ( FileNotFoundException fnfe )\n        {\n            throw new MojoExecutionException( \"File not found. \" + file );\n        }\n        return fileReader;\n    }\n",
    "new_code_raw": "    protected String readAnnouncement( File file )\n        throws MojoExecutionException\n    {\n        InputStreamReader reader = null;\n        FileInputStream inputStream = null;\n        try\n        {\n            inputStream = new FileInputStream( file );\n\n            if ( StringUtils.isEmpty( templateEncoding ) )\n            {\n                templateEncoding = ReaderFactory.FILE_ENCODING;\n                getLog().warn( \"File encoding has not been set, using platform encoding '\" + templateEncoding\n                                   + \"', i.e. build is platform dependent!\" );\n            }\n\n            reader = new InputStreamReader( inputStream, templateEncoding );\n            return IOUtil.toString( reader );\n        }\n        catch ( FileNotFoundException fnfe )\n        {\n            throw new MojoExecutionException( \"File not found. \" + file );\n        }\n        catch ( UnsupportedEncodingException uee )\n        {\n            throw new MojoExecutionException( \"Unsupported encoding: '\" + templateEncoding + \"'\" );\n        }\n        catch ( IOException ioe )\n        {\n            throw new MojoExecutionException( \"Failed to read the announcement file.\", ioe );\n        }\n        finally\n        {\n            IOUtil.close( inputStream );\n            IOUtil.close( reader );\n        }\n    }\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-1492-FirstSentence-0",
    "old_comment_raw": "Create an audit reader associated with an open entity manager.",
    "new_comment_raw": "Create an audit reader associated with an open entity manager.",
    "old_code_raw": "    public static AuditReader get(EntityManager entityManager) throws AuditException {\n        if (entityManager.getDelegate() instanceof Session) {\n            return get((Session) entityManager.getDelegate());\n        }\n\n        if (entityManager.getDelegate() instanceof EntityManager) {\n\t\t\tentityManager = (EntityManager) entityManager.getDelegate();\n            if (entityManager.getDelegate() instanceof Session) {\n                return get((Session) entityManager.getDelegate());\n            }\n        }\n\n        throw new AuditException(\"Hibernate EntityManager not present!\");\n    }\n",
    "new_code_raw": "    public static AuditReader get(EntityManager entityManager) throws AuditException {\n        if (entityManager.getDelegate() instanceof Session) {\n            return get((Session) entityManager.getDelegate());\n        }\n\n        if (entityManager.getDelegate() instanceof EntityManager) {\n            return get((EntityManager) entityManager.getDelegate());\n        }\n\n        throw new AuditException(\"Hibernate EntityManager not present!\");\n    }\n"
  },
  {
    "id": "jenkinsci_scm-api-plugin-7-Associations-FirstSentence",
    "old_comment_raw": "SPI for  #fetchActions(SCMRevision, TaskListener).",
    "new_comment_raw": "SPI for  #fetchActions(SCMRevision, SCMHeadEvent, TaskListener).",
    "old_code_raw": "    @NonNull\n    protected Map<Class<? extends Action>, Action> retrieveActions(@NonNull SCMRevision revision,\n                                                                   @NonNull TaskListener listener)\n            throws IOException, InterruptedException {\n        return Collections.emptyMap();\n    }\n",
    "new_code_raw": "    @NonNull\n    protected List<Action> retrieveActions(@NonNull SCMRevision revision,\n                                           @NonNull SCMHeadEvent event,\n                                           @NonNull TaskListener listener)\n            throws IOException, InterruptedException {\n        return Collections.emptyList();\n    }\n\n"
  },
  {
    "id": "apache_activemq-1123-FirstSentence-0",
    "old_comment_raw": "Returns the timeout to use for blocking creating new sessions",
    "new_comment_raw": "Returns the timeout to use for blocking creating new sessions",
    "old_code_raw": "    public long getBlockIfSessionPoolIsFullTimeout() {\n        return this.sessionPool.getMaxWait();\n    }\n",
    "new_code_raw": "    public long getBlockIfSessionPoolIsFullTimeout() {\n        return this.sessionPool.getMaxWaitMillis();\n    }\n"
  },
  {
    "id": "querydsl_querydsl-1441-FirstSentence-0",
    "old_comment_raw": "Template method, override to customize.",
    "new_comment_raw": "template method",
    "old_code_raw": "    protected String convert(Path<?> path, Object value){\n        return value.toString();\n    }\n",
    "new_code_raw": "    protected String[] convert(Path<?> leftHandSide, Object rightHandSide) {\n        String str = rightHandSide.toString();\n        if (lowerCase){\n            str = str.toLowerCase();\n        }\n        if (splitTerms) {            \n            if (str.equals(\"\")) {\n                return new String[] { str };\n            } else {\n                return StringUtils.split(str);\n            }\n        } else {\n            return new String[] { str };\n        }\n    }\n"
  },
  {
    "id": "apache_calcite-979-FirstSentence-0",
    "old_comment_raw": "Gets the list size threshold under which  #convertInToOr is used.",
    "new_comment_raw": "Gets the list size threshold under which  #convertInToOr is used.",
    "old_code_raw": "  protected int getInSubqueryThreshold() {\n    return IN_SUBQUERY_THRESHOLD;\n  }\n",
    "new_code_raw": "  protected int getInSubqueryThreshold() {\n    return config.getInSubqueryThreshold();\n  }\n"
  },
  {
    "id": "graphql_java_graphql_java-315-FirstSentence-0",
    "old_comment_raw": "Executes the graphql query using the provided input object ",
    "new_comment_raw": "Executes the graphql query using the provided input object ",
    "old_code_raw": "    public CompletableFuture<ExecutionResult> executeAsync(ExecutionInput executionInput) {\n        log.debug(\"Executing request. operation name: {}. query: {}. variables {} \", executionInput.getOperationName(), executionInput.getQuery(), executionInput.getVariables());\n\n        InstrumentationState instrumentationState = instrumentation.createState();\n\n        InstrumentationExecutionParameters instrumentationParameters = new InstrumentationExecutionParameters(executionInput, instrumentationState);\n        InstrumentationContext<ExecutionResult> executionInstrumentation = instrumentation.beginExecution(instrumentationParameters);\n        CompletableFuture<ExecutionResult> executionResult = parseValidateAndExecute(executionInput, instrumentationState);\n        //\n        // finish up instrumentation\n        executionResult = executionResult.whenComplete(executionInstrumentation::onEnd);\n        //\n        // allow instrumentation to tweak the result\n        executionResult = executionResult.thenCompose(result -> instrumentation.instrumentExecutionResult(result, instrumentationParameters));\n        return executionResult;\n    }\n",
    "new_code_raw": "    public CompletableFuture<ExecutionResult> executeAsync(ExecutionInput executionInput) {\n        try {\n            log.debug(\"Executing request. operation name: {}. query: {}. variables {} \", executionInput.getOperationName(), executionInput.getQuery(), executionInput.getVariables());\n\n            InstrumentationState instrumentationState = instrumentation.createState();\n\n            InstrumentationExecutionParameters instrumentationParameters = new InstrumentationExecutionParameters(executionInput, this.graphQLSchema, instrumentationState);\n            InstrumentationContext<ExecutionResult> executionInstrumentation = instrumentation.beginExecution(instrumentationParameters);\n            CompletableFuture<ExecutionResult> executionResult = parseValidateAndExecute(executionInput, instrumentationState);\n            //\n            // finish up instrumentation\n            executionResult = executionResult.whenComplete(executionInstrumentation::onEnd);\n            //\n            // allow instrumentation to tweak the result\n            executionResult = executionResult.thenCompose(result -> instrumentation.instrumentExecutionResult(result, instrumentationParameters));\n            return executionResult;\n        } catch (AbortExecutionException abortException) {\n            ExecutionResultImpl executionResult = new ExecutionResultImpl(abortException);\n            return CompletableFuture.completedFuture(executionResult);\n        }\n    }\n"
  },
  {
    "id": "jenkinsci_gitlab-oauth-plugin-5-Associations-FirstSentence",
    "old_comment_raw": "Create  GitHubRepositoryName from URL",
    "new_comment_raw": "Create  GitlabRepositoryName from URL",
    "old_code_raw": "    public static GitHubRepositoryName create(final String url) {\n        LOGGER.log(Level.FINE, \"Constructing from URL {0}\", url);\n        for (Pattern p : URL_PATTERNS) {\n            Matcher m = p.matcher(url.trim());\n            if (m.matches()) {\n                LOGGER.log(Level.FINE, \"URL matches {0}\", m);\n                GitHubRepositoryName ret = new GitHubRepositoryName(m.group(1), m.group(2),\n                        m.group(3));\n                LOGGER.log(Level.FINE, \"Object is {0}\", ret);\n                return ret;\n            }\n        }\n        LOGGER.log(Level.WARNING, \"Could not match URL {0}\", url);\n        return null;\n    }\n",
    "new_code_raw": "    public static GitlabRepositoryName create(final String url) {\n        LOGGER.log(Level.FINE, \"Constructing from URL {0}\", url);\n        for (Pattern p : URL_PATTERNS) {\n            Matcher m = p.matcher(url.trim());\n            if (m.matches()) {\n                LOGGER.log(Level.FINE, \"URL matches {0}\", m);\n                GitlabRepositoryName ret = new GitlabRepositoryName(m.group(1), m.group(2),\n                        m.group(3));\n                LOGGER.log(Level.FINE, \"Object is {0}\", ret);\n                return ret;\n            }\n        }\n        LOGGER.log(Level.WARNING, \"Could not match URL {0}\", url);\n        return null;\n    }\n\n"
  },
  {
    "id": "processing_processing-1228-FirstSentence-0",
    "old_comment_raw": "Used in place of element.getFloatAttribute(a) because we can have a unit suffix (length or coordinate).",
    "new_comment_raw": "Used in place of element.getFloatAttribute(a) because we can have a unit suffix (length or coordinate).",
    "old_code_raw": "  static protected float getFloatWithUnit(XML element, String attribute) {\n    String val = element.getString(attribute);\n    return (val == null) ? 0 : parseUnitSize(val);\n  }\n",
    "new_code_raw": "  static protected float getFloatWithUnit(XML element, String attribute, float relativeTo) {\n    String val = element.getString(attribute);\n    return (val == null) ? 0 : parseUnitSize(val, relativeTo);\n  }\n"
  },
  {
    "id": "apache_lenya-372-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Returns the directory prefix",
    "old_code_raw": "    public String toString() {\n        return \"-P: \" + directory_prefix;\n    }\n",
    "new_code_raw": "    public String toString() {\n        return \"-P: \" + this.directory_prefix;\n    }\n\n"
  },
  {
    "id": "wildfly_quickstart-14-FirstSentence-0",
    "old_comment_raw": "Looks up and returns the proxy to remote stateless calculator bean",
    "new_comment_raw": "Looks up and returns the proxy to remote stateless calculator bean",
    "old_code_raw": "    private static RemoteCalculator lookupRemoteStatelessCalculator() throws NamingException {\n        final Hashtable jndiProperties = new Hashtable();\n        jndiProperties.put(Context.URL_PKG_PREFIXES, \"org.jboss.ejb.client.naming\");\n        final Context context = new InitialContext(jndiProperties);\n\n        // The JNDI lookup name for a stateless session bean has the syntax of:\n        // ejb:<appName>/<moduleName>/<distinctName>/<beanName>!<viewClassName>\n        //\n        // <appName> The application name is the name of the EAR that the EJB is deployed in\n        // (without the .ear). If the EJB JAR is not deployed in an EAR then this is\n        // blank. The app name can also be specified in the EAR's application.xml\n        //\n        // <moduleName> By the default the module name is the name of the EJB JAR file (without the\n        // .jar suffix). The module name might be overridden in the ejb-jar.xml\n        //\n        // <distinctName> : AS7 allows each deployment to have an (optional) distinct name.\n        // This example does not use this so leave it blank.\n        //\n        // <beanName> : The name of the session been to be invoked.\n        //\n        // <viewClassName>: The fully qualified classname of the remote interface. Must include\n        // the whole package name.\n\n        // let's do the lookup\n        return (RemoteCalculator) context.lookup(\"ejb:/jboss-as-ejb-remote-server-side/CalculatorBean!\"\n                + RemoteCalculator.class.getName());\n    }\n",
    "new_code_raw": "    private static RemoteCalculator lookupRemoteStatelessCalculator() throws NamingException {\n        final Hashtable jndiProperties = new Hashtable();\n        jndiProperties.put(Context.URL_PKG_PREFIXES, \"org.jboss.ejb.client.naming\");\n        final Context context = new InitialContext(jndiProperties);\n\n        // The JNDI lookup name for a stateless session bean has the syntax of:\n        // ejb:<appName>/<moduleName>/<distinctName>/<beanName>!<viewClassName>\n        //\n        // <appName> The application name is the name of the EAR that the EJB is deployed in\n        // (without the .ear). If the EJB JAR is not deployed in an EAR then this is\n        // blank. The app name can also be specified in the EAR's application.xml\n        //\n        // <moduleName> By the default the module name is the name of the EJB JAR file (without the\n        // .jar suffix). The module name might be overridden in the ejb-jar.xml\n        //\n        // <distinctName> : WildFly allows each deployment to have an (optional) distinct name.\n        // This example does not use this so leave it blank.\n        //\n        // <beanName> : The name of the session been to be invoked.\n        //\n        // <viewClassName>: The fully qualified classname of the remote interface. Must include\n        // the whole package name.\n\n        // let's do the lookup\n        return (RemoteCalculator) context.lookup(\"ejb:/wildfly-ejb-remote-server-side/CalculatorBean!\"\n                + RemoteCalculator.class.getName());\n    }\n"
  },
  {
    "id": "Omegaphora_dalvik-61-Associations-FirstSentence",
    "old_comment_raw": "Returns the FileChannel equivalent to this stream.",
    "new_comment_raw": "Gets this file's  FileChannel object.",
    "old_code_raw": "    public final synchronized FileChannel getChannel() {\n        return channel;\n    }\n",
    "new_code_raw": "    public final FileChannel getChannel() {\n        synchronized(this) {\n            if(channel == null) {\n                channel = FileChannelFactory.getFileChannel(this, fd.descriptor,\n                        options);\n            }\n            return channel;\n        }\n    }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-776-FirstSentence-0",
    "old_comment_raw": "Get the minute of day field type.",
    "new_comment_raw": "Get the minute of day field type.",
    "old_code_raw": "    public static DateTimeFieldType minuteOfDay() {\n        return MINUTE_OF_DAY;\n    }\n",
    "new_code_raw": "    public static DateTimeFieldType minuteOfDay() {\n        return MINUTE_OF_DAY_TYPE;\n    }\n"
  },
  {
    "id": "technosophos_sinciput-1-Associations-FirstSentence",
    "old_comment_raw": "Returns a map of document IDs and values.",
    "new_comment_raw": "Returns a DocumentCollection of document IDs and metadata.",
    "old_code_raw": "\tpublic java.util.Map<String, String[]> getMetadataByName(String name, String[] docs) \n\t\t\tthrows RepositoryAccessException {\n\t\t\n\t\t\n\t\t/*\n\t\t * Loop through all IDs, getting a document with only attribute DocID\n\t\t * If docID matches, fetch name too?\n\t\t */\n\t\t\n\t\tHashMap<String, String[]> vals = new HashMap<String, String[]>();\n\t\t\n\t\tHashSet<String> activeFields = new HashSet<String>();\n\t\tHashSet<String> lazyFields = new HashSet<String>();\n\t\t\n\t\tactiveFields.add(LUCENE_DOCID_FIELD);\n\t\tlazyFields.add(name);\n\t\t\n\t\tSetBasedFieldSelector fsel = new SetBasedFieldSelector(activeFields, lazyFields);\n\t\tIndexReader lreader;\n\t\t\n\t\ttry {\n\t\t\tlreader = this.getIndexReader();\n\t\t\tint last = lreader.maxDoc();\n\t\t\tDocument d;\n\t\t\tString docID;\n\t\t\tfor(int i = 0; i < last; ++i) {\n\t\t\t\tif(!lreader.isDeleted(i)) {\n\t\t\t\t\td = lreader.document(i, fsel);\n\t\t\t\t\tdocID = d.get(LUCENE_DOCID_FIELD);\n\t\t\t\t\tfor(String did: docs)\n\t\t\t\t\t\tif(did.equals(docID)) vals.put(docID, d.getValues(name));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tlreader.close();\n\t\t} catch (java.io.IOException ioe) {\n\t\t\tthrow new RepositoryAccessException(\"IOException: \" + ioe.getMessage());\n\t\t}\n\t\t\n\t\treturn vals;\n\t}\n",
    "new_code_raw": "\tpublic DocumentCollection getMetadataByName(String name, String[] docs)  \n\t\t\tthrows RepositoryAccessException {\n\t\t\n\t\tString[] names = {name};\n\t\treturn this.getDocCollection(names, docs);\n\t\t\n\t\t/*\n\t\tHashMap<String, String[]> vals = new HashMap<String, String[]>();\n\t\t\n\t\tHashSet<String> activeFields = new HashSet<String>();\n\t\tHashSet<String> lazyFields = new HashSet<String>();\n\t\t\n\t\tactiveFields.add(LUCENE_DOCID_FIELD);\n\t\tlazyFields.add(name);\n\t\t\n\t\tSetBasedFieldSelector fsel = new SetBasedFieldSelector(activeFields, lazyFields);\n\t\tIndexReader lreader;\n\t\t\n\t\ttry {\n\t\t\tlreader = this.getIndexReader();\n\t\t\tint last = lreader.maxDoc();\n\t\t\tDocument d;\n\t\t\tString docID;\n\t\t\tfor(int i = 0; i < last; ++i) {\n\t\t\t\tif(!lreader.isDeleted(i)) {\n\t\t\t\t\td = lreader.document(i, fsel);\n\t\t\t\t\tdocID = d.get(LUCENE_DOCID_FIELD);\n\t\t\t\t\tfor(String did: docs)\n\t\t\t\t\t\tif(did.equals(docID)) vals.put(docID, d.getValues(name));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tlreader.close();\n\t\t} catch (java.io.IOException ioe) {\n\t\t\tthrow new RepositoryAccessException(\"IOException: \" + ioe.getMessage());\n\t\t}\n\t\t\n\t\treturn vals;\n\t\t*/\n\t}\n\n"
  },
  {
    "id": "JodaOrg_joda_time-1015-FirstSentence-0",
    "old_comment_raw": "Returns a formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, three digit fraction of second, and time zone offset (HH:mm:ss.SSSZZ).",
    "new_comment_raw": "Returns a formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, three digit fraction of second, and time zone offset (HH:mm:ss.SSSZZ).",
    "old_code_raw": "    public static DateTimeFormatter time() {\n        if (t == null) {\n            t = new DateTimeFormatterBuilder()\n                .append(hourMinuteSecondFraction())\n                .append(offsetElement())\n                .toFormatter();\n        }\n        return t;\n    }\n",
    "new_code_raw": "    public static DateTimeFormatter time() {\n        return Constants.t;\n    }\n"
  },
  {
    "id": "apache_lenya-390-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Get Image src attributes",
    "old_code_raw": "    public List getImageSrcs(boolean duplicate) {\n        if (duplicate) {\n            return htmlHandler.getAllImageSrcs();\n        } else {\n            return htmlHandler.getImageSrcs();\n        }\n    }\n",
    "new_code_raw": "    public List getImageSrcs(boolean duplicate) {\n        if (duplicate) {\n            return this.htmlHandler.getAllImageSrcs();\n        }\n        return this.htmlHandler.getImageSrcs();\n    }\n\n"
  },
  {
    "id": "SeleniumHQ_selenium-715-FirstSentence-0",
    "old_comment_raw": "finds the requested role from the parameters.",
    "new_comment_raw": "finds the requested role from the parameters.",
    "old_code_raw": "  public static GridRole find(String[] args) {\n    if (args == null) {\n      return NOT_GRID;\n    }\n    for (int i = 0; i < args.length; i++) {\n      if (\"-role\".equals(args[i])) {\n        if (i == args.length - 1) {\n          throw new GridConfigurationException(\n              \"-role needs to be followed by the role of this component in the grid.\");\n        } else {\n          String role = args[i + 1].toLowerCase();\n          if (nodeAliases.contains(role)) {\n            return NODE;\n          } else if (\"hub\".equals(role)) {\n            return HUB;\n          } else if (\"standalone\".equals(role)) {\n            return NOT_GRID;\n          } else {\n            return null;\n          }\n        }\n      }\n    }\n    return NOT_GRID;\n  }\n",
    "new_code_raw": "  public static GridRole find(String[] args) {\n    if (args == null) {\n      return NOT_GRID;\n    }\n    for (int i = 0; i < args.length; i++) {\n      if (\"-role\".equals(args[i])) {\n        if (i == args.length - 1) {\n          return null;\n        } else {\n          String role = args[i + 1].toLowerCase();\n          if (nodeAliases.contains(role)) {\n            return NODE;\n          } else if (\"hub\".equals(role)) {\n            return HUB;\n          } else if (\"standalone\".equals(role)) {\n            return NOT_GRID;\n          } else {\n            return null;\n          }\n        }\n      }\n    }\n    return NOT_GRID;\n  }\n"
  },
  {
    "id": "ncdc_Qpid-1-82-Associations-FirstSentence",
    "old_comment_raw": "Retrive the ObjectName for the given Exchange on the test Virtualhost.",
    "new_comment_raw": "Retrive the ObjectName for the given Exchange on a VirtualHost.",
    "old_code_raw": "    public ObjectName getExchangeObjectName(String virtualHostName, String exchange)\n    {\n        // Get the name of the test manager\n        AllObjects allObject = new AllObjects(_mbsc);\n        allObject.querystring = \"org.apache.qpid:type=VirtualHost.Exchange,VirtualHost=\" + virtualHostName + \",name=\" + exchange + \",*\";\n\n        Set<ObjectName> objectNames = allObject.returnObjects();\n\n        _test.assertNotNull(\"Null ObjectName Set returned\", objectNames);\n        _test.assertEquals(\"Incorrect number of exchange with name '\" + exchange +\n                           \"' returned\", 1, objectNames.size());\n\n        // We have verified we have only one value in objectNames so return it\n        return objectNames.iterator().next();\n    }\n",
    "new_code_raw": "    @SuppressWarnings(\"static-access\")\n    public ObjectName getExchangeObjectName(String virtualHostName, String exchange)\n    {\n        // Get the name of the test manager\n        AllObjects allObject = new AllObjects(_mbsc);\n        allObject.querystring = \"org.apache.qpid:type=VirtualHost.Exchange,VirtualHost=\" + virtualHostName + \",name=\" + exchange + \",*\";\n\n        Set<ObjectName> objectNames = allObject.returnObjects();\n\n        _test.assertNotNull(\"Null ObjectName Set returned\", objectNames);\n        _test.assertEquals(\"Incorrect number of exchange with name '\" + exchange + \"' returned\", 1, objectNames.size());\n\n        // We have verified we have only one value in objectNames so return it\n        ObjectName objectName = objectNames.iterator().next();\n\t\t_test.getLogger().info(\"Loading: \" + objectName);\n        return objectName;\n    }\n\n"
  },
  {
    "id": "zaproxy_zaproxy-2050-FirstSentence-0",
    "old_comment_raw": "Returns the textual representation of the issue that prevents the add-on or extension from being run, if any.",
    "new_comment_raw": "Returns the textual representation of the issue that prevents the add-on or extension from being run, if any.",
    "old_code_raw": "    public static String getDependencyIssue(AddOn.BaseRunRequirements requirements) {\n        if (!requirements.hasDependencyIssue()) {\n            return null;\n        }\n\n        List<Object> issueDetails = requirements.getDependencyIssueDetails();\n        switch (requirements.getDependencyIssue()) {\n        case CYCLIC:\n            return \"Cyclic dependency with: \" + issueDetails.get(0);\n        case OLDER_VERSION:\n            return \"Older version still installed: \" + issueDetails.get(0);\n        case MISSING:\n            String addOnId = (String) issueDetails.get(0);\n            return MessageFormat.format(\"Add-On with ID \\\"{0}\\\"\", addOnId);\n        case PACKAGE_VERSION_NOT_BEFORE:\n            AddOn addOn = (AddOn) issueDetails.get(0);\n            return MessageFormat.format(\n                    \"Add-on \\\"{0}\\\" with version not before {1} (found version {2})\",\n                    addOn.getName(),\n                    issueDetails.get(1),\n                    Integer.valueOf(addOn.getFileVersion()));\n        case PACKAGE_VERSION_NOT_FROM:\n            addOn = (AddOn) issueDetails.get(0);\n            return MessageFormat.format(\n                    \"Add-on \\\"{0}\\\" with version not after {1} (found version {2})\",\n                    addOn.getName(),\n                    issueDetails.get(1),\n                    Integer.valueOf(addOn.getFileVersion()));\n        case VERSION:\n            addOn = (AddOn) issueDetails.get(0);\n            if (addOn.getVersion() == null) {\n                return MessageFormat.format(\n                        \"Add-on \\\"{0}\\\" with semantic version >= {1} (found no semantic version)\",\n                        addOn.getName(),\n                        issueDetails.get(1));\n            }\n            return MessageFormat.format(\n                    \"Add-on \\\"{0}\\\" with semantic version >= {1} (found version {2})\",\n                    addOn.getName(),\n                    issueDetails.get(1),\n                    addOn.getVersion());\n        default:\n            LOGGER.warn(\"Failed to handle dependency issue with name \\\"\" + requirements.getDependencyIssue().name()\n                    + \"\\\" and details: \" + issueDetails);\n            return null;\n        }\n    }\n",
    "new_code_raw": "    public static String getDependencyIssue(AddOn.BaseRunRequirements requirements) {\n        if (!requirements.hasDependencyIssue()) {\n            return null;\n        }\n\n        List<Object> issueDetails = requirements.getDependencyIssueDetails();\n        switch (requirements.getDependencyIssue()) {\n        case CYCLIC:\n            return \"Cyclic dependency with: \" + issueDetails.get(0);\n        case OLDER_VERSION:\n            return \"Older version still installed: \" + issueDetails.get(0);\n        case MISSING:\n            String addOnId = (String) issueDetails.get(0);\n            return MessageFormat.format(\"Add-On with ID \\\"{0}\\\"\", addOnId);\n        case VERSION:\n            AddOn addOn = (AddOn) issueDetails.get(0);\n            return MessageFormat.format(\n                    \"Add-on \\\"{0}\\\" with version matching {1} (found version {2})\",\n                    addOn.getName(),\n                    issueDetails.get(1),\n                    addOn.getVersion());\n        default:\n            LOGGER.warn(\"Failed to handle dependency issue with name \\\"\" + requirements.getDependencyIssue().name()\n                    + \"\\\" and details: \" + issueDetails);\n            return null;\n        }\n    }\n"
  },
  {
    "id": "frohoff_jdk6-56-Associations-FirstSentence",
    "old_comment_raw": "Returns the path component at the specified index.",
    "new_comment_raw": "Returns the path element at the specified index.",
    "old_code_raw": "    public Object getPathComponent(int element) {\n        int          pathLength = getPathCount();\n\n        if(element < 0 || element >= pathLength)\n            throw new IllegalArgumentException(\"Index \" + element + \" is out of the specified range\");\n\n        TreePath         path = this;\n\n        for(int i = pathLength-1; i != element; i--) {\n           path = path.parentPath;\n        }\n        return path.lastPathComponent;\n    }\n",
    "new_code_raw": "    public Object getPathComponent(int index) {\n        int          pathLength = getPathCount();\n\n        if(index < 0 || index >= pathLength)\n            throw new IllegalArgumentException(\"Index \" + index +\n                                           \" is out of the specified range\");\n\n        TreePath         path = this;\n\n        for(int i = pathLength-1; i != index; i--) {\n            path = path.getParentPath();\n        }\n        return path.getLastPathComponent();\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2545-FirstSentence-0",
    "old_comment_raw": "Finds Pets by tags",
    "new_comment_raw": "Finds Pets by tags",
    "old_code_raw": "  public List<Pet> findPetsByTags(List<String> tags) throws ApiException {\n    ApiResponse<List<Pet>> resp = findPetsByTagsWithHttpInfo(tags);\n    return resp.getData();\n  }\n",
    "new_code_raw": "  public List<Pet> findPetsByTags(List<String> tags) throws ApiException {\n    Call call = findPetsByTagsCall(tags);\n    Type returnType = new TypeToken<List<Pet>>(){}.getType();\n    return apiClient.execute(call, returnType);\n  }\n"
  },
  {
    "id": "eclipse_reddeer-53-Associations-FirstSentence",
    "old_comment_raw": "Gets child of the project item with given text without decorators.",
    "new_comment_raw": "Gets child of the project item.",
    "old_code_raw": "\tpublic ProjectItem getChild(String text) {\n\t\tString[] childPath = new String[path.length + 1];\n\t\tSystem.arraycopy(path, 0, childPath, 0, path.length);\n\t\tchildPath[childPath.length - 1] = text;\n\t\treturn new ProjectItem(treeViewerHandler.getTreeItem(\n\t\t\t\ttreeItem, text), project, childPath);\n\t}\n",
    "new_code_raw": "\tpublic ProjectItem getChild(String text) {\n\t\tString[] childPath = new String[path.length + 1];\n\t\tSystem.arraycopy(path, 0, childPath, 0, path.length);\n\t\tchildPath[childPath.length - 1] = text;\n\t\treturn project.getProjectItem(childPath);\n\t}\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1905-FirstSentence-0",
    "old_comment_raw": "Get enumNumber",
    "new_comment_raw": "Get enumNumber",
    "old_code_raw": "  public EnumNumberEnum getEnumNumber() {\n    return enumNumber;\n  }\n",
    "new_code_raw": "  public Double getEnumNumber() {\n    if (enumNumber == null) {\n      return null;\n    }\n    return enumNumber.value();\n  }\n"
  },
  {
    "id": "SeleniumHQ_selenium-993-FirstSentence-0",
    "old_comment_raw": "Wraps up values as type: some_type, value: some_value objects",
    "new_comment_raw": "Wraps up values as type: some_type, value: some_value objects",
    "old_code_raw": "    static JSONObject wrapArgumentForScriptExecution(Object argument) {\n      JSONObject wrappedArgument = new JSONObject();\n      try {\n        if (argument instanceof String) {\n          wrappedArgument.put(\"type\", \"STRING\");\n          wrappedArgument.put(\"value\", argument);\n        } else if (argument instanceof Boolean) {\n          wrappedArgument.put(\"type\", \"BOOLEAN\");\n          wrappedArgument.put(\"value\", argument);\n        } else if (argument instanceof Number) {\n          wrappedArgument.put(\"type\", \"NUMBER\");\n          wrappedArgument.put(\"value\", argument);\n        } else if (argument instanceof ChromeWebElement) {\n          wrappedArgument.put(\"type\", \"ELEMENT\");\n          wrappedArgument.put(\"value\", ((ChromeWebElement)argument).getElementId());\n        } else {\n          throw new IllegalArgumentException(\"Could not wrap up \" +\n                \"javascript parameter \" + argument +\n                \"(class: \" + argument.getClass() + \")\");\n        }\n      } catch (JSONException e) {\n        throw new WebDriverException(e);\n      }\n      return wrappedArgument;\n    }\n",
    "new_code_raw": "    static Object wrapArgumentForScriptExecution(Object argument) {\n      JSONObject wrappedArgument = new JSONObject();\n      try {\n        if (argument instanceof String) {\n          wrappedArgument.put(\"type\", \"STRING\");\n          wrappedArgument.put(\"value\", argument);\n        } else if (argument instanceof Boolean) {\n          wrappedArgument.put(\"type\", \"BOOLEAN\");\n          wrappedArgument.put(\"value\", argument);\n        } else if (argument instanceof Number) {\n          wrappedArgument.put(\"type\", \"NUMBER\");\n          wrappedArgument.put(\"value\", argument);\n        } else if (argument instanceof ChromeWebElement) {\n          wrappedArgument.put(\"type\", \"ELEMENT\");\n          wrappedArgument.put(\"value\", ((ChromeWebElement)argument).getElementId());\n        } else if (argument instanceof Collection<?>) {\n          JSONArray array = new JSONArray();\n          for (Object o : (Collection<?>)argument) {\n            array.put(wrapArgumentForScriptExecution(o));\n          }\n          return array;\n        } else {\n          throw new IllegalArgumentException(\"Could not wrap up \" +\n                \"javascript parameter \" + argument +\n                \"(class: \" + argument.getClass() + \")\");\n        }\n      } catch (JSONException e) {\n        throw new WebDriverException(e);\n      }\n      return wrappedArgument;\n    }\n"
  },
  {
    "id": "apache_derby-100-Associations-FirstSentence",
    "old_comment_raw": "Get parameter metadata from EmbedPreparedStatement or",
    "new_comment_raw": "Retrieve the ParameterMetaData for the prepared statement.",
    "old_code_raw": "\tprotected EmbedParameterSetMetaData getParameterMetaData() throws SQLException\n\t{\n\t\tif (stmtPmeta != null)\n\t\t\treturn stmtPmeta;\n\n\t\tEmbedParameterSetMetaData pmeta = null;\n\t\tClass[] getParameterMetaDataParam = {};\n\t\ttry {\n\t\t\tMethod sh =\n\t\t\t\tgetPreparedStatement().getClass().getMethod(\"getEmbedParameterSetMetaData\", getParameterMetaDataParam);\n\t\t\tpmeta = (EmbedParameterSetMetaData)\n\t\t\t\tsh.invoke(getPreparedStatement(),null);\n\t\t\tstmtPmeta = pmeta;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\thandleReflectionException(e);\n\t\t}\n\t\treturn stmtPmeta;\n\t}\n",
    "new_code_raw": "\tprotected EngineParameterMetaData getParameterMetaData() throws SQLException\n\t{\n\t\tif (stmtPmeta != null)\n\t\t\treturn stmtPmeta;\n\n\t\tstmtPmeta = ((EnginePreparedStatement)ps).getEmbedParameterSetMetaData();\n        \n        return stmtPmeta;\n\t}\n\n"
  },
  {
    "id": "apache_calcite-628-FirstSentence-0",
    "old_comment_raw": "Converts a list to a string, one item per line.",
    "new_comment_raw": "Converts a list to a string, one item per line.",
    "old_code_raw": "  public Tester getTester(SqlConformance conformance) {\n    return new AdvisorTestImpl(conformance);\n  }\n",
    "new_code_raw": "  public SqlTester getTester() {\n    return new SqlTesterImpl(new AdvisorTesterFactory());\n  }\n"
  },
  {
    "id": "apache_axis1-java-93-Associations-FirstSentence",
    "old_comment_raw": "Returns the value associated with the named property - or null if not defined/set.",
    "new_comment_raw": "Returns the value associated with the named property",
    "old_code_raw": "    public Object getProperty(String name) {\n        if (name != null)\n            return callProperties.get(name);\n        return null;\n    } // getProperty\n",
    "new_code_raw": "    public Object getProperty(String name) {\n        if (name == null || !isPropertySupported(name))\n            throw new IllegalArgumentException();\n        return callProperties.get(name);\n    } // getProperty\n\n"
  },
  {
    "id": "apache_avro-18-FirstSentence-0",
    "old_comment_raw": "Gets the configured compression codec from the task context.",
    "new_comment_raw": "Gets the configured compression codec from the task context.",
    "old_code_raw": "  protected static CodecFactory getCompressionCodec(TaskAttemptContext context) {\n    if (FileOutputFormat.getCompressOutput(context)) {\n      // Default to deflate compression.\n      int compressionLevel = context.getConfiguration().getInt(\n          org.apache.avro.mapred.AvroOutputFormat.DEFLATE_LEVEL_KEY,\n          org.apache.avro.mapred.AvroOutputFormat.DEFAULT_DEFLATE_LEVEL);\n      \n      String outputCodec = context.getConfiguration()\n        .get(AvroJob.CONF_OUTPUT_CODEC);\n\n      if (outputCodec == null) {\n        String compressionCodec = context.getConfiguration().get(\"mapred.output.compression.codec\");\n        String avroCodecName = HadoopCodecFactory.getAvroCodecName(compressionCodec);\n        if ( avroCodecName != null){\n          context.getConfiguration().set(AvroJob.CONF_OUTPUT_CODEC, avroCodecName);\n          return HadoopCodecFactory.fromHadoopString(compressionCodec);\n        } else {\n          return CodecFactory.deflateCodec(compressionLevel);\n        }\n      } else if (DataFileConstants.DEFLATE_CODEC.equals(outputCodec)) {\n          return CodecFactory.deflateCodec(compressionLevel);\n        } else {\n          return CodecFactory.fromString(outputCodec);\n        }\n      \n      }\n\n    // No compression.\n    return CodecFactory.nullCodec();\n  }\n",
    "new_code_raw": "  protected static CodecFactory getCompressionCodec(TaskAttemptContext context) {\n    if (FileOutputFormat.getCompressOutput(context)) {\n      // Default to deflate compression.\n      int deflateLevel = context.getConfiguration().getInt(\n          org.apache.avro.mapred.AvroOutputFormat.DEFLATE_LEVEL_KEY,\n          CodecFactory.DEFAULT_DEFLATE_LEVEL);\n      int xzLevel = context.getConfiguration().getInt(\n              org.apache.avro.mapred.AvroOutputFormat.XZ_LEVEL_KEY,\n              CodecFactory.DEFAULT_XZ_LEVEL);\n      \n      String outputCodec = context.getConfiguration()\n        .get(AvroJob.CONF_OUTPUT_CODEC);\n\n      if (outputCodec == null) {\n        String compressionCodec = context.getConfiguration().get(\"mapred.output.compression.codec\");\n        String avroCodecName = HadoopCodecFactory.getAvroCodecName(compressionCodec);\n        if ( avroCodecName != null){\n          context.getConfiguration().set(AvroJob.CONF_OUTPUT_CODEC, avroCodecName);\n          return HadoopCodecFactory.fromHadoopString(compressionCodec);\n        } else {\n          return CodecFactory.deflateCodec(deflateLevel);\n        }\n      } else if (DataFileConstants.DEFLATE_CODEC.equals(outputCodec)) {\n        return CodecFactory.deflateCodec(deflateLevel);\n      } else if (DataFileConstants.XZ_CODEC.equals(outputCodec)) {\n          return CodecFactory.xzCodec(xzLevel);\n        } else {\n          return CodecFactory.fromString(outputCodec);\n        }\n      \n      }\n\n    // No compression.\n    return CodecFactory.nullCodec();\n  }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2376-FirstSentence-0",
    "old_comment_raw": "Indicates whether or not a new result is available.",
    "new_comment_raw": "Indicates whether a not a new result is available.",
    "old_code_raw": "  public boolean peek() {\n    if (outputQueue.isEmpty()) {\n      return false;\n    } else {\n       return orderResults ? outputQueue.containsKey(returnedItemCounter + 1) : true;\n    }\n  }\n",
    "new_code_raw": "  public boolean peek() {\n    if (outputQueue.isEmpty()) {\n      return false;\n    } else {\n      final int nextId = outputQueue.peek().id;\n      return orderResults ? nextId == lastReturnedId + 1 : true;\n    }\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2135-FirstSentence-0",
    "old_comment_raw": "uploads an image (required) 200 - successful operation",
    "new_comment_raw": "uploads an image (required) 200 - successful operation",
    "old_code_raw": "    public ResponseEntity<ModelApiResponse> uploadFileWithRequiredFileWithHttpInfo(Long petId, File requiredFile, String additionalMetadata) throws RestClientException {\n        Object postBody = null;\n        \n        // verify the required parameter 'petId' is set\n        if (petId == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n        }\n        \n        // verify the required parameter 'requiredFile' is set\n        if (requiredFile == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\");\n        }\n        \n        // create path and map variables\n        final Map<String, Object> uriVariables = new HashMap<String, Object>();\n        uriVariables.put(\"petId\", petId);\n        String path = apiClient.expandPath(\"/fake/{petId}/uploadImageWithRequiredFile\", uriVariables);\n\n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        if (additionalMetadata != null)\n            formParams.add(\"additionalMetadata\", additionalMetadata);\n        if (requiredFile != null)\n            formParams.add(\"requiredFile\", new FileSystemResource(requiredFile));\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"multipart/form-data\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"petstore_auth\" };\n\n        ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "new_code_raw": "    public ResponseEntity<ModelApiResponse> uploadFileWithRequiredFileWithHttpInfo(Long petId, File requiredFile, String additionalMetadata) throws RestClientException {\n        Object postBody = null;\n        \n        // verify the required parameter 'petId' is set\n        if (petId == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n        }\n        \n        // verify the required parameter 'requiredFile' is set\n        if (requiredFile == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\");\n        }\n        \n        // create path and map variables\n        final Map<String, Object> uriVariables = new HashMap<String, Object>();\n        uriVariables.put(\"petId\", petId);\n        String path = apiClient.expandPath(\"/fake/{petId}/uploadImageWithRequiredFile\", uriVariables);\n\n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        if (additionalMetadata != null)\n            formParams.add(\"additionalMetadata\", additionalMetadata);\n        if (requiredFile != null)\n            formParams.add(\"requiredFile\", new FileSystemResource(requiredFile));\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"multipart/form-data\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"petstore_auth\" };\n\n        ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType);\n    }\n"
  },
  {
    "id": "scribejava_scribejava-4-Associations-FirstSentence",
    "old_comment_raw": "Obtains a  Map of the body parameters.",
    "new_comment_raw": "Obtains a  ParameterList of the body parameters.",
    "old_code_raw": "  public Map<String, String> getBodyParams()\n  {\n    return bodyParams;\n  }\n",
    "new_code_raw": "  public ParameterList getBodyParams()\n  {\n    return bodyParams;\n  }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-579-FirstSentence-0",
    "old_comment_raw": "Rounds to the nearest whole unit of this field on a copy of this TimeOnly, favoring the ceiling if halfway.",
    "new_comment_raw": "Rounds to the nearest whole unit of this field on a copy of this TimeOnly, favoring the ceiling if halfway.",
    "old_code_raw": "    public TimeOnly roundHalfCeilingCopy() {\n        TimeOnly instant = iInstant;\n        return (TimeOnly)instant.toCopy(iField.roundHalfCeiling(instant.getMillis()));\n    }\n",
    "new_code_raw": "    public TimeOnly roundHalfCeilingCopy() {\n        TimeOnly instant = iInstant;\n        return (TimeOnly)instant.withMillis(iField.roundHalfCeiling(instant.getMillis()));\n    }\n"
  },
  {
    "id": "querydsl_querydsl-550-FirstSentence-0",
    "old_comment_raw": "Returns the mutator for the property with the given name.",
    "new_comment_raw": "Returns the mutator for the property with the given name.",
    "old_code_raw": "    public Method getWriteMethod(String name) {\n        return (Method) writeMethods.get(name);\n    }\n",
    "new_code_raw": "    public Method getWriteMethod(String name) {\n        return writeMethods.get(name);\n    }\n"
  },
  {
    "id": "zaproxy_zaproxy-277-Associations-FirstSentence",
    "old_comment_raw": "Initialises the  Control singleton without view and proxy.",
    "new_comment_raw": "Initialises the  Control singleton without view.",
    "old_code_raw": "    protected Control initControl() {\n        Control.initSingletonWithoutViewAndProxy(getControlOverrides());\n        return Control.getSingleton();\n    }\n",
    "new_code_raw": "    protected Control initControl(boolean ignoreProxyError) {\n    \tif (!Control.initSingletonWithoutView(getControlOverrides()) && ! ignoreProxyError) {\n    \t\treturn null;\n    \t}\n        return Control.getSingleton();\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2045-FirstSentence-0",
    "old_comment_raw": "Creates list of users with given input array",
    "new_comment_raw": "Creates list of users with given input array",
    "old_code_raw": "    public ApiResponse<Void> createUsersWithListInputWithHttpInfo(List<User> body) throws ApiException {\n        okhttp3.Call call = createUsersWithListInputValidateBeforeCall(body, null, null);\n        return apiClient.execute(call);\n    }\n",
    "new_code_raw": "    public ApiResponse<Void> createUsersWithListInputWithHttpInfo(List<User> body) throws ApiException {\n        okhttp3.Call localVarCall = createUsersWithListInputValidateBeforeCall(body, null, null);\n        return localVarApiClient.execute(localVarCall);\n    }\n"
  },
  {
    "id": "Omegaphora_dalvik-385-Associations-FirstSentence",
    "old_comment_raw": "Acquires the shared lock only if it is not held exclusively by another thread at the time of invocation.",
    "new_comment_raw": "Acquires the read lock only if the write lock is not held by another thread at the time of invocation.",
    "old_code_raw": "        public  boolean tryLock() {\n            return sync.nonfairTryAcquireShared(1) >= 0;\n        }\n",
    "new_code_raw": "        public  boolean tryLock() {\n            return sync.tryReadLock();\n        }\n\n"
  },
  {
    "id": "querydsl_querydsl-226-FirstSentence-0",
    "old_comment_raw": "filter the given iterator using the given expressionevaluator that evaluates to true / false",
    "new_comment_raw": "filter the given iterator using the given expressionevaluator that evaluates to true / false",
    "old_code_raw": "            public boolean evaluate(S object) {\n                return QueryIteratorUtils.<Boolean>evaluate(ev, object);\n            }            \n",
    "new_code_raw": "            public boolean evaluate(S object) {\n                return ev.<Boolean>evaluate(object);\n            }            \n"
  },
  {
    "id": "RSB4760_apq8016_frameworks_support-53-Associations-FirstSentence",
    "old_comment_raw": "Gets the content playback position as a long integer number of milliseconds from the beginning of the content.",
    "new_comment_raw": "Gets the content playback position as a floating point number of seconds from the beginning of the content.",
    "old_code_raw": "    public long getContentPosition() {\n        return mBundle.getLong(KEY_CONTENT_POSITION, -1);\n    }\n",
    "new_code_raw": "    public double getContentPosition() {\n        return mBundle.getDouble(KEY_CONTENT_POSITION, -1);\n    }\n\n"
  },
  {
    "id": "apache_activemq-1116-FirstSentence-0",
    "old_comment_raw": "Create a  MessageAck that will acknowledge the given  MessageDispatch.",
    "new_comment_raw": "Create a  MessageAck that will acknowledge the given  MessageDispatch.",
    "old_code_raw": "    public MessageAck createMessageAck(MessageDispatch md) {\n        return new MessageAck(md, MessageAck.STANDARD_ACK_TYPE, 1);\n    }\n",
    "new_code_raw": "    public MessageAck createMessageAck(MessageDispatch md) {\n        return new MessageAck(md, MessageAck.INDIVIDUAL_ACK_TYPE, 1);\n    }\n"
  },
  {
    "id": "JetBrains_jdk8u_jaxp-52-Associations-FirstSentence",
    "old_comment_raw": "Get a list of all compile error messages",
    "new_comment_raw": "Get a Vector containing all compile error messages",
    "old_code_raw": "    public ArrayList<ErrorMsg> getErrors() {\n        return _parser.getErrors();\n    }\n",
    "new_code_raw": "    public Vector getErrors() {\n        return _parser.getErrors();\n    }\n\n"
  },
  {
    "id": "runelite_runelite-135-FirstSentence-0",
    "old_comment_raw": "Finds the most recent archive for the given indexId/archiveId",
    "new_comment_raw": "Finds the most recent archive for the given indexId/archiveId",
    "old_code_raw": "\tpublic ArchiveEntry findMostRecentArchive(Connection con, int indexId, int archiveId)\n\t{\n\t\treturn con.createQuery(\"select archive.id, archive.archiveId, archive.nameHash, archive.revision from archive \"\n\t\t\t+ \"join index_archive on index_archive.archive = archive.id \"\n\t\t\t+ \"join `index` on index.id = index_archive.index \"\n\t\t\t+ \"where index.indexId = :indexId and archive.archiveId = :archiveId \"\n\t\t\t+ \"group by archive.id \"\n\t\t\t+ \"order by archive.revision desc \"\n\t\t\t+ \"limit 1\")\n\t\t\t.addParameter(\"indexId\", indexId)\n\t\t\t.addParameter(\"archiveId\", archiveId)\n\t\t\t.executeAndFetchFirst(ArchiveEntry.class);\n\t}\n",
    "new_code_raw": "\tpublic ArchiveEntry findMostRecentArchive(Connection con, int indexId, int archiveId)\n\t{\n\t\treturn con.createQuery(\"select archive.id, archive.archiveId, archive.nameHash,\" +\n\t\t\t\" archive.crc, archive.revision, archive.hash from archive \"\n\t\t\t+ \"join index_archive on index_archive.archive = archive.id \"\n\t\t\t+ \"join `index` on index.id = index_archive.index \"\n\t\t\t+ \"where index.indexId = :indexId and archive.archiveId = :archiveId \"\n\t\t\t+ \"group by archive.id \"\n\t\t\t+ \"order by archive.revision desc \"\n\t\t\t+ \"limit 1\")\n\t\t\t.addParameter(\"indexId\", indexId)\n\t\t\t.addParameter(\"archiveId\", archiveId)\n\t\t\t.executeAndFetchFirst(ArchiveEntry.class);\n\t}\n"
  },
  {
    "id": "facebook_fresco-243-FirstSentence-0",
    "old_comment_raw": "Performs lookup of a series of disk cache keys in a single thread.",
    "new_comment_raw": "Performs key-value look up in disk cache.",
    "old_code_raw": "  public Task<EncodedImage> get(List<CacheKey> keys, final AtomicBoolean isCancelled) {\n    Preconditions.checkArgument(!keys.isEmpty());\n\n    for (CacheKey key : keys) {\n      final EncodedImage pinnedImage = mStagingArea.get(key);\n      if (pinnedImage != null) {\n        return foundPinnedImage(key, pinnedImage);\n      }\n    }\n\n    Task<EncodedImage> masterTask = getAsync(keys.get(0), isCancelled);\n    if (keys.size() == 1) {\n      return masterTask;\n    }\n    for (final CacheKey key : keys.subList(1, keys.size())) {\n      masterTask = masterTask.continueWithTask(\n          new Continuation<EncodedImage, Task<EncodedImage>>() {\n            @Override\n            public Task<EncodedImage> then(Task<EncodedImage> previousTask) throws Exception {\n              // If we've got a hit, stop. If this is cancelled, stop. Otherwise, keep going.\n              if (previousTask.isCancelled() || previousTask.getResult() != null) {\n                return previousTask;\n              }\n              return getAsync(key, isCancelled);\n            }\n          },\n          mReadExecutor);\n    }\n    return masterTask;\n  }\n",
    "new_code_raw": "  public Task<EncodedImage> get(CacheKey key, AtomicBoolean isCancelled) {\n    final EncodedImage pinnedImage = mStagingArea.get(key);\n    if (pinnedImage != null) {\n      return foundPinnedImage(key, pinnedImage);\n    }\n    return getAsync(key, isCancelled);\n  }\n"
  },
  {
    "id": "querydsl_querydsl-706-FirstSentence-0",
    "old_comment_raw": "Create a new Template expression",
    "new_comment_raw": "Create a new Template expression",
    "old_code_raw": "    public static StringTemplate stringTemplate(String template, ImmutableList<?> args) {\n        return new StringTemplate(createTemplate(template), args);\n    }\n",
    "new_code_raw": "    public static StringTemplate stringTemplate(String template, ImmutableList<?> args) {\n        return stringTemplate(createTemplate(template), args);\n    }\n"
  },
  {
    "id": "wso2-extensions_identity-agent-onprem-userstore-5-Associations-FirstSentence",
    "old_comment_raw": "Get node ip connected to the access token",
    "new_comment_raw": "Get server ip connected with the given node.",
    "old_code_raw": "    public String getConnectedServer(AccessToken accessToken) {\n        AgentMgtDao agentMgtDao = new AgentMgtDao();\n        return agentMgtDao.getConnectedServer(accessToken.getId());\n    }\n",
    "new_code_raw": "    public String getConnectedServer(AccessToken accessToken, String node) {\n\n        AgentMgtDao agentMgtDao = new AgentMgtDao();\n        return agentMgtDao.getConnectedServer(accessToken.getId(), node);\n\n    }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-510-FirstSentence-0",
    "old_comment_raw": "Get the minimum value that this field can have.",
    "new_comment_raw": "Get the minimum value that this field can have.",
    "old_code_raw": "    public int getMinimumValue() {\n        return MIN;\n    }\n",
    "new_code_raw": "    public int getMinimumValue() {\n        return DateTimeConstants.MONDAY;\n    }\n"
  },
  {
    "id": "svn2github_my-33-Associations-FirstSentence",
    "old_comment_raw": "The list of modules depending on the passed one.",
    "new_comment_raw": "The list of installed modules depending on the passed one.",
    "old_code_raw": "    public synchronized final List<String> getDependentModulesRecursively(final String id) throws Exception {\r\n        final List<String> res = new ArrayList<String>();\r\n        for (final String depModule : getDependentModules(id)) {\r\n            res.add(depModule);\r\n            // the graph has no cycle, so we don't need to protected against infinite loop\r\n\r\n            res.addAll(this.getDependentModulesRecursively(depModule));\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n",
    "new_code_raw": "    public final List<ModuleReference> getDependentModulesRecursively(final ModuleReference ref) throws Exception {\r\n        return getDependentModulesRecursively(ref, new ArrayList<ModuleReference>());\r\n    }\r\n\n"
  },
  {
    "id": "gabrielemariotti_cardslib-15-FirstSentence-0",
    "old_comment_raw": "This method returns the complete View used",
    "new_comment_raw": "This method returns the complete View used",
    "old_code_raw": "    public CardView getCardView() {\n        return mCardView;\n    }\n",
    "new_code_raw": "    public CommonCardView getCardView() {\n        return mCardView;\n    }\n"
  },
  {
    "id": "apache_activemq-1009-FirstSentence-0",
    "old_comment_raw": "Returns the current  InboundContext used by the current thread which is processing a message.",
    "new_comment_raw": "Returns the current  InboundContext used by the current thread which is processing a message.",
    "old_code_raw": "    public static InboundContext getActiveSessionAndProducer() {\n        return (InboundContext) threadLocal.get();\n    }\n",
    "new_code_raw": "    public static InboundContext getActiveSessionAndProducer() {\n        return threadLocal.get();\n    }\n"
  },
  {
    "id": "eclipse_reddeer-121-Associations-FirstSentence",
    "old_comment_raw": "Gets a server of specified type with the given name.",
    "new_comment_raw": "Gets a server of specified type with a given name",
    "old_code_raw": "\tpublic <T extends Server> T getServer(Class<T> clazz, String name) {\n\t\tfor (Server server : getServers()){\n\t\t\tif (server.isValid() && server.getLabel().getName().equals(name)){\n\t\t\t\treturn server.getAdapter(clazz);\n\t\t\t}\n\t\t}\n\t\tlog.info(\"Requested server '\" + name + \"' was not found on Servers view\");\n\t\tlog.info(\"Available servers are: \" + LoggingUtils.format(getServersNames()));\n\t\tthrow new EclipseLayerException(\"There is no server with name \" + name);\n\t}\n",
    "new_code_raw": "\tpublic <T extends Server> Server getServer(Class<T> clazz, String name) {\n\t\tfor (Server server : getServers()){\n\t\t\tif (server.isValid() && server.getLabel().getName().equals(name)){\n\t\t\t\treturn server.getAdapter(clazz);\n\t\t\t}\n\t\t}\n\t\tlog.info(\"Requested server '\" + name + \"' was not found on Servers view\");\n\t\tlog.info(\"Available servers are: \" + LoggingUtils.format(getServersNames()));\n\t\tthrow new EclipseLayerException(\"There is no server with name \" + name);\n\t}\n\n"
  },
  {
    "id": "debezium_debezium-1137-FirstSentence-0",
    "old_comment_raw": "Converts the Protobuf value for a  io.debezium.connector.postgresql.proto.PgProto.DatumMessage plugin message to a Java value based on the type of the column from the message.",
    "new_comment_raw": "Converts the Protobuf value for a  io.debezium.connector.postgresql.proto.PgProto.DatumMessage plugin message to a Java value based on the type of the column from the message.",
    "old_code_raw": "    public Object getValue(PgProto.DatumMessage datumMessage, PgConnectionSupplier connection, boolean includeUnknownDatatypes) {\n        int columnType = (int) datumMessage.getColumnType();\n        switch (columnType) {\n            case PgOid.BOOL:\n                return datumMessage.hasDatumBool() ? datumMessage.getDatumBool() : null;\n            case PgOid.INT2:\n            case PgOid.INT4:\n                return datumMessage.hasDatumInt32() ? datumMessage.getDatumInt32() : null;\n            case PgOid.INT8:\n            case PgOid.OID:\n            case PgOid.MONEY:\n                return datumMessage.hasDatumInt64() ? datumMessage.getDatumInt64() : null;\n            case PgOid.FLOAT4:\n                return datumMessage.hasDatumFloat()? datumMessage.getDatumFloat() : null;\n            case PgOid.FLOAT8:\n                return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null;\n            case PgOid.NUMERIC:\n                if (datumMessage.hasDatumDouble()) {\n                    // For backwards compatibility only to enable independent upgrade of Postgres plug-in\n                    return datumMessage.getDatumDouble();\n                }\n                else if (datumMessage.hasDatumString()) {\n                    final String s = datumMessage.getDatumString();\n                    return PostgresValueConverter.toSpecialValue(s).orElseGet(() -> new SpecialValueDecimal(new BigDecimal(s)));\n                }\n                return null;\n            case PgOid.CHAR:\n            case PgOid.VARCHAR:\n            case PgOid.BPCHAR:\n            case PgOid.TEXT:\n            case PgOid.JSON:\n            case PgOid.JSONB_OID:\n            case PgOid.XML:\n            case PgOid.UUID:\n            case PgOid.BIT:\n            case PgOid.VARBIT:\n            case PgOid.INET_OID:\n            case PgOid.CIDR_OID:\n            case PgOid.MACADDR_OID:\n            case PgOid.MACADDR8_OID:\n                return datumMessage.hasDatumString() ? datumMessage.getDatumString() : null;\n            case PgOid.DATE:\n                return datumMessage.hasDatumInt32() ? (long) datumMessage.getDatumInt32() : null;\n            case PgOid.TIMESTAMP:\n                if (!datumMessage.hasDatumInt64()) {\n                    return null;\n                }\n                // these types are sent by the plugin as LONG - microseconds since Unix Epoch\n                // but we'll convert them to nanos which is the smallest unit\n                final LocalDateTime serverLocal = Conversions.toLocalDateTimeUTC(datumMessage.getDatumInt64());\n                return Conversions.toEpochNanos(serverLocal.toInstant(ZoneOffset.UTC));\n            case PgOid.TIMESTAMPTZ:\n            case PgOid.TIME:\n                if (!datumMessage.hasDatumInt64()) {\n                    return null;\n                }\n                // these types are sent by the plugin as LONG - microseconds since Unix Epoch\n                // but we'll convert them to nanos which is the smallest unit\n                return TimeUnit.NANOSECONDS.convert(datumMessage.getDatumInt64(), TimeUnit.MICROSECONDS);\n            case PgOid.TIMETZ:\n                if (!datumMessage.hasDatumDouble()) {\n                    return null;\n                }\n                // the value is sent as a double microseconds, convert to nano\n                return BigDecimal.valueOf(datumMessage.getDatumDouble() * 1000).longValue();\n            case PgOid.INTERVAL:\n                // these are sent as doubles by the plugin since their storage is larger than 8 bytes\n                return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null;\n            // the plugin will send back a TZ formatted string\n            case PgOid.BYTEA:\n                return datumMessage.hasDatumBytes() ? datumMessage.getDatumBytes().toByteArray() : null;\n            case PgOid.POINT: {\n                PgProto.Point datumPoint = datumMessage.getDatumPoint();\n                return new PGpoint(datumPoint.getX(), datumPoint.getY());\n            }\n            case PgOid.TSRANGE_OID:\n            case PgOid.TSTZRANGE_OID:\n            case PgOid.DATERANGE_OID:\n            case PgOid.INT4RANGE_OID:\n            case PgOid.NUM_RANGE_OID:\n            case PgOid.INT8RANGE_OID:\n                return datumMessage.hasDatumBytes() ? new String(datumMessage.getDatumBytes().toByteArray(), Charset.forName(\"UTF-8\")) : null;\n            case PgOid.INT2_ARRAY:\n            case PgOid.INT4_ARRAY:\n            case PgOid.INT8_ARRAY:\n            case PgOid.TEXT_ARRAY:\n            case PgOid.NUMERIC_ARRAY:\n            case PgOid.FLOAT4_ARRAY:\n            case PgOid.FLOAT8_ARRAY:\n            case PgOid.BOOL_ARRAY:\n            case PgOid.DATE_ARRAY:\n            case PgOid.TIME_ARRAY:\n            case PgOid.TIMETZ_ARRAY:\n            case PgOid.TIMESTAMP_ARRAY:\n            case PgOid.TIMESTAMPTZ_ARRAY:\n            case PgOid.BYTEA_ARRAY:\n            case PgOid.VARCHAR_ARRAY:\n            case PgOid.OID_ARRAY:\n            case PgOid.BPCHAR_ARRAY:\n            case PgOid.MONEY_ARRAY:\n            case PgOid.NAME_ARRAY:\n            case PgOid.INTERVAL_ARRAY:\n            case PgOid.CHAR_ARRAY:\n            case PgOid.VARBIT_ARRAY:\n            case PgOid.UUID_ARRAY:\n            case PgOid.XML_ARRAY:\n            case PgOid.POINT_ARRAY:\n            case PgOid.JSONB_ARRAY:\n            case PgOid.JSON_ARRAY:\n            case PgOid.REF_CURSOR_ARRAY:\n            case PgOid.INET_ARRAY:\n            case PgOid.CIDR_ARRAY:\n            case PgOid.MACADDR_ARRAY:\n            case PgOid.MACADDR8_ARRAY:\n            case PgOid.TSRANGE_ARRAY:\n            case PgOid.TSTZRANGE_ARRAY:\n            case PgOid.DATERANGE_ARRAY:\n            case PgOid.INT4RANGE_ARRAY:\n            case PgOid.NUM_RANGE_ARRAY:\n            case PgOid.INT8RANGE_ARRAY:\n            return getArray(datumMessage, connection, columnType);\n\n            case PgOid.UNSPECIFIED:\n                return null;\n\n            default:\n                PostgresType type = typeRegistry.get(columnType);\n                if (type.getOid() == typeRegistry.geometryOid() || type.getOid() == typeRegistry.geographyOid() || type.getOid() == typeRegistry.citextOid() ) {\n                    return datumMessage.getDatumBytes().toByteArray();\n                }\n                if(type.getOid() == typeRegistry.hstoreOid()) {\n                    return datumMessage.getDatumBytes().toByteArray();\n                }\n                if (type.getOid() == typeRegistry.geometryArrayOid() ||\n                        type.getOid() == typeRegistry.geographyArrayOid() ||\n                        type.getOid() == typeRegistry.citextArrayOid() ||\n                        type.getOid() == typeRegistry.hstoreArrayOid()) {\n                    return getArray(datumMessage, connection, columnType);\n                }\n                // unknown data type is sent by decoder as binary value\n                if (includeUnknownDatatypes && datumMessage.hasDatumBytes()) {\n                    return datumMessage.getDatumBytes().toByteArray();\n                }\n\n                return null;\n        }\n    }\n",
    "new_code_raw": "    public Object getValue(PgProto.DatumMessage datumMessage, PgConnectionSupplier connection, boolean includeUnknownDatatypes) {\n        int columnType = (int) datumMessage.getColumnType();\n        switch (columnType) {\n            case PgOid.BOOL:\n                return datumMessage.hasDatumBool() ? datumMessage.getDatumBool() : null;\n            case PgOid.INT2:\n            case PgOid.INT4:\n                return datumMessage.hasDatumInt32() ? datumMessage.getDatumInt32() : null;\n            case PgOid.INT8:\n            case PgOid.OID:\n            case PgOid.MONEY:\n                return datumMessage.hasDatumInt64() ? datumMessage.getDatumInt64() : null;\n            case PgOid.FLOAT4:\n                return datumMessage.hasDatumFloat()? datumMessage.getDatumFloat() : null;\n            case PgOid.FLOAT8:\n                return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null;\n            case PgOid.NUMERIC:\n                if (datumMessage.hasDatumDouble()) {\n                    // For backwards compatibility only to enable independent upgrade of Postgres plug-in\n                    return datumMessage.getDatumDouble();\n                }\n                else if (datumMessage.hasDatumString()) {\n                    final String s = datumMessage.getDatumString();\n                    return PostgresValueConverter.toSpecialValue(s).orElseGet(() -> new SpecialValueDecimal(new BigDecimal(s)));\n                }\n                return null;\n            case PgOid.CHAR:\n            case PgOid.VARCHAR:\n            case PgOid.BPCHAR:\n            case PgOid.TEXT:\n            case PgOid.JSON:\n            case PgOid.JSONB_OID:\n            case PgOid.XML:\n            case PgOid.UUID:\n            case PgOid.BIT:\n            case PgOid.VARBIT:\n            case PgOid.INET_OID:\n            case PgOid.CIDR_OID:\n            case PgOid.MACADDR_OID:\n            case PgOid.MACADDR8_OID:\n                return datumMessage.hasDatumString() ? datumMessage.getDatumString() : null;\n            case PgOid.DATE:\n                return datumMessage.hasDatumInt32() ? (long) datumMessage.getDatumInt32() : null;\n            case PgOid.TIMESTAMP:\n                if (!datumMessage.hasDatumInt64()) {\n                    return null;\n                }\n                // these types are sent by the plugin as LONG - microseconds since Unix Epoch\n                return Conversions.toInstantFromMicros(datumMessage.getDatumInt64());\n            case PgOid.TIMESTAMPTZ:\n                if (!datumMessage.hasDatumInt64()) {\n                    return null;\n                }\n                // these types are sent by the plugin as LONG - microseconds since Unix Epoch\n                return Conversions.toInstantFromMicros(datumMessage.getDatumInt64()).atOffset(ZoneOffset.UTC);\n            case PgOid.TIME:\n                if (!datumMessage.hasDatumInt64()) {\n                    return null;\n                }\n\n                // these types are sent by the plugin as LONG - microseconds since Unix Epoch\n                return Duration.of(datumMessage.getDatumInt64(), ChronoUnit.MICROS);\n            case PgOid.TIMETZ:\n                if (!datumMessage.hasDatumDouble()) {\n                    return null;\n                }\n                // the value is sent as a double microseconds\n                return Conversions.toInstantFromMicros((long) datumMessage.getDatumDouble())\n                        .atOffset(ZoneOffset.UTC)\n                        .toOffsetTime();\n            case PgOid.INTERVAL:\n                // these are sent as doubles by the plugin since their storage is larger than 8 bytes\n                return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null;\n            // the plugin will send back a TZ formatted string\n            case PgOid.BYTEA:\n                return datumMessage.hasDatumBytes() ? datumMessage.getDatumBytes().toByteArray() : null;\n            case PgOid.POINT: {\n                PgProto.Point datumPoint = datumMessage.getDatumPoint();\n                return new PGpoint(datumPoint.getX(), datumPoint.getY());\n            }\n            case PgOid.TSRANGE_OID:\n            case PgOid.TSTZRANGE_OID:\n            case PgOid.DATERANGE_OID:\n            case PgOid.INT4RANGE_OID:\n            case PgOid.NUM_RANGE_OID:\n            case PgOid.INT8RANGE_OID:\n                return datumMessage.hasDatumBytes() ? new String(datumMessage.getDatumBytes().toByteArray(), Charset.forName(\"UTF-8\")) : null;\n            case PgOid.INT2_ARRAY:\n            case PgOid.INT4_ARRAY:\n            case PgOid.INT8_ARRAY:\n            case PgOid.TEXT_ARRAY:\n            case PgOid.NUMERIC_ARRAY:\n            case PgOid.FLOAT4_ARRAY:\n            case PgOid.FLOAT8_ARRAY:\n            case PgOid.BOOL_ARRAY:\n            case PgOid.DATE_ARRAY:\n            case PgOid.TIME_ARRAY:\n            case PgOid.TIMETZ_ARRAY:\n            case PgOid.TIMESTAMP_ARRAY:\n            case PgOid.TIMESTAMPTZ_ARRAY:\n            case PgOid.BYTEA_ARRAY:\n            case PgOid.VARCHAR_ARRAY:\n            case PgOid.OID_ARRAY:\n            case PgOid.BPCHAR_ARRAY:\n            case PgOid.MONEY_ARRAY:\n            case PgOid.NAME_ARRAY:\n            case PgOid.INTERVAL_ARRAY:\n            case PgOid.CHAR_ARRAY:\n            case PgOid.VARBIT_ARRAY:\n            case PgOid.UUID_ARRAY:\n            case PgOid.XML_ARRAY:\n            case PgOid.POINT_ARRAY:\n            case PgOid.JSONB_ARRAY:\n            case PgOid.JSON_ARRAY:\n            case PgOid.REF_CURSOR_ARRAY:\n            case PgOid.INET_ARRAY:\n            case PgOid.CIDR_ARRAY:\n            case PgOid.MACADDR_ARRAY:\n            case PgOid.MACADDR8_ARRAY:\n            case PgOid.TSRANGE_ARRAY:\n            case PgOid.TSTZRANGE_ARRAY:\n            case PgOid.DATERANGE_ARRAY:\n            case PgOid.INT4RANGE_ARRAY:\n            case PgOid.NUM_RANGE_ARRAY:\n            case PgOid.INT8RANGE_ARRAY:\n            return getArray(datumMessage, connection, columnType);\n\n            case PgOid.UNSPECIFIED:\n                return null;\n\n            default:\n                PostgresType type = typeRegistry.get(columnType);\n                if (type.getOid() == typeRegistry.geometryOid() || type.getOid() == typeRegistry.geographyOid() || type.getOid() == typeRegistry.citextOid() ) {\n                    return datumMessage.getDatumBytes().toByteArray();\n                }\n                if(type.getOid() == typeRegistry.hstoreOid()) {\n                    return datumMessage.getDatumBytes().toByteArray();\n                }\n                if (type.getOid() == typeRegistry.geometryArrayOid() ||\n                        type.getOid() == typeRegistry.geographyArrayOid() ||\n                        type.getOid() == typeRegistry.citextArrayOid() ||\n                        type.getOid() == typeRegistry.hstoreArrayOid()) {\n                    return getArray(datumMessage, connection, columnType);\n                }\n                // unknown data type is sent by decoder as binary value\n                if (includeUnknownDatatypes && datumMessage.hasDatumBytes()) {\n                    return datumMessage.getDatumBytes().toByteArray();\n                }\n\n                return null;\n        }\n    }\n"
  },
  {
    "id": "jenkinsci_analysis-core-plugin-35-Associations-FirstSentence",
    "old_comment_raw": "Returns the project this action belongs to.",
    "new_comment_raw": "Returns the job this action belongs to.",
    "old_code_raw": "    public final AbstractProject<?, ?> getProject() {\r\n        return project;\r\n    }\r\n",
    "new_code_raw": "    public final Job<?, ?> getProject() {\r\n        return job;\r\n    }\r\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-1983-FirstSentence-0",
    "old_comment_raw": "Get the SQL command used to drop the named schema",
    "new_comment_raw": "Get the SQL command used to drop the named schema",
    "old_code_raw": "\tpublic String getDropSchemaCommand(String schemaName) {\n\t\treturn \"drop schema \" + schemaName;\n\t}\n",
    "new_code_raw": "\tpublic String[] getDropSchemaCommand(String schemaName) {\n\t\treturn new String[] {\"drop schema \" + schemaName};\n\t}\n"
  },
  {
    "id": "eseawind_opening-trunk-7-Associations-FirstSentence",
    "old_comment_raw": "Retreives an object from a heap with the specified name and type.",
    "new_comment_raw": "Retrieves an object from a heap with the specified name and type, or  null if the name is  null.",
    "old_code_raw": "    @SuppressWarnings(\"unchecked\")\n    public static <T> T getObject(Heap heap, JsonValue name, Class<T> type) throws HeapException {\n        Object o = heap.get(name.required().asString());\n        if (o != null && !(type.isInstance(o))) {\n            throw new JsonValueException(name, \"expecting heap object of type \" + type.getName());\n        }\n        return (T) o;\n    }\n",
    "new_code_raw": "    public static <T> T getObject(Heap heap, JsonValue name, Class<T> type) throws HeapException {\n        if (name.isNull()) {\n            return null;\n        }\n        return getRequiredObject(heap, name, type);\n    }\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-1009-FirstSentence-0",
    "old_comment_raw": "Locate the column index corresponding to the given column name via the cache.",
    "new_comment_raw": "Locate the column index corresponding to the given column name via the cache.",
    "old_code_raw": "\tprivate int findColumn(String columnName) throws SQLException {\n\t\treturn columnNameCache.getIndexForColumnName( columnName, rs );\n\t}\n",
    "new_code_raw": "\tprivate Integer findColumn(String columnName) throws SQLException {\n\t\treturn columnNameCache.getIndexForColumnName( columnName, rs );\n\t}\n"
  },
  {
    "id": "JetBrains_jdk8u_jaxp-42-Associations-FirstSentence",
    "old_comment_raw": "Returns an Iterator of all child nodes of this node.",
    "new_comment_raw": "Returns an Enumeration of all child nodes of this node.",
    "old_code_raw": "    protected final Iterator<SyntaxTreeNode> elements() {\n        return _contents.iterator();\n    }\n",
    "new_code_raw": "    protected final Enumeration elements() {\n        return _contents.elements();\n    }\n\n"
  },
  {
    "id": "pwittchen_ReactiveNetwork-16-FirstSentence-0",
    "old_comment_raw": "Filter, which returns true if at least one given state occurred",
    "new_comment_raw": "Filter, which returns true if at least one given state occurred",
    "old_code_raw": "  public static Predicate<Connectivity> hasState(final NetworkInfo.State... states) {\n    return new Predicate<Connectivity>() {\n      @Override public boolean test(@NonNull Connectivity connectivity) throws Exception {\n        for (NetworkInfo.State state : states) {\n          if (connectivity.getState() == state) {\n            return true;\n          }\n        }\n        return false;\n      }\n    };\n  }\n",
    "new_code_raw": "  public static Predicate<Connectivity> hasState(final NetworkInfo.State... states) {\n    return new Predicate<Connectivity>() {\n      @Override public boolean test(@NonNull Connectivity connectivity) throws Exception {\n        for (NetworkInfo.State state : states) {\n          if (connectivity.state() == state) {\n            return true;\n          }\n        }\n        return false;\n      }\n    };\n  }\n"
  },
  {
    "id": "spring_projects_spring_integration_samples-10-FirstSentence-0",
    "old_comment_raw": "Poll for files, add an error channel, split into lines route the start/end markers to  #markers() and the lines to  #lines().",
    "new_comment_raw": "Poll for files, add an error channel, split into lines route the start/end markers to  #markers() and the lines to  #lines().",
    "old_code_raw": "\tpublic IntegrationFlow fromFile() {\n\t\treturn IntegrationFlows.from(Files.inboundAdapter(new File(\"/tmp/in\"))\n\t\t\t\t\t.preventDuplicates(false)\n\t\t\t\t\t.patternFilter(\"*.txt\"), e -> e.poller(Pollers.fixedDelay(5000).errorChannel(tfrErrorChannel())))\n\t\t\t\t.handle(Files.splitter(true, true))\n\t\t\t\t.<Object, Class<?>>route(Object::getClass, m -> m\n\t\t\t\t\t\t.channelMapping(FileSplitter.FileMarker.class, \"markers.input\")\n\t\t\t\t\t\t.channelMapping(String.class, \"lines.input\"))\n\t\t\t\t.get();\n\t}\n",
    "new_code_raw": "\tpublic IntegrationFlow fromFile() {\n\t\treturn IntegrationFlows.from(\n\t\t\t\tFiles.inboundAdapter(new File(\"/tmp/in\"))\n\t\t\t\t\t\t.preventDuplicates(false)\n\t\t\t\t\t\t.patternFilter(\"*.txt\"), e -> e.poller(Pollers.fixedDelay(5000)\n\t\t\t\t\t\t.errorChannel(\"tfrErrors.input\")))\n\t\t\t\t.handle(Files.splitter(true, true))\n\t\t\t\t.<Object, Class<?>>route(Object::getClass, m -> m\n\t\t\t\t\t\t.channelMapping(FileSplitter.FileMarker.class, \"markers.input\")\n\t\t\t\t\t\t.channelMapping(String.class, \"lines.input\"))\n\t\t\t\t.get();\n\t}\n"
  },
  {
    "id": "kaendfinger_pircbotx-106-Associations-FirstSentence",
    "old_comment_raw": "Returns the address of the sender as a long.",
    "new_comment_raw": "Returns the address of the sender",
    "old_code_raw": "\tpublic long getNumericalAddress() {\r\n\t\treturn address;\r\n\t}\r\n",
    "new_code_raw": "\tpublic InetAddress getNumericalAddress() {\r\n\t\treturn address;\r\n\t}\r\n\n"
  },
  {
    "id": "apache_drill-1293-FirstSentence-0",
    "old_comment_raw": "Returns schema path with for arrays without index.",
    "new_comment_raw": "Returns schema path with for arrays without index.",
    "old_code_raw": "  public SchemaPath getUnIndexed() {\n    NameSegment nameSegment = getUnIndexedNameSegment(rootSegment, null);\n    return new SchemaPath(nameSegment);\n  }\n",
    "new_code_raw": "  public SchemaPath getUnIndexed() {\n    return new SchemaPath(getUnIndexedNameSegment(rootSegment, null));\n  }\n"
  },
  {
    "id": "apache_calcite-862-FirstSentence-0",
    "old_comment_raw": "Creates an expression of the default value for the given type, casting if necessary to ensure that the expression is the exact type.",
    "new_comment_raw": "Creates a literal of the default value for the given type.",
    "old_code_raw": "  public RexNode makeZeroLiteral(RelDataType type, boolean allowCast) {\n    if (type.isNullable()) {\n      type = typeFactory.createTypeWithNullability(type, false);\n    }\n    RexLiteral literal;\n    switch (type.getSqlTypeName()) {\n    case CHAR:\n      return makeCharLiteral(\n          new NlsString(Util.spaces(type.getPrecision()), null, null));\n    case VARCHAR:\n      literal = makeCharLiteral(new NlsString(\"\", null, null));\n      if (allowCast) {\n        return makeCast(type, literal);\n      } else {\n        return literal;\n      }\n    case BINARY:\n      return makeBinaryLiteral(\n          new ByteString(new byte[type.getPrecision()]));\n    case VARBINARY:\n      literal = makeBinaryLiteral(ByteString.EMPTY);\n      if (allowCast) {\n        return makeCast(type, literal);\n      } else {\n        return literal;\n      }\n    case TINYINT:\n    case SMALLINT:\n    case INTEGER:\n    case BIGINT:\n    case DECIMAL:\n      return makeExactLiteral(BigDecimal.ZERO, type);\n    case FLOAT:\n    case REAL:\n    case DOUBLE:\n      return makeApproxLiteral(BigDecimal.ZERO, type);\n    case BOOLEAN:\n      return booleanFalse;\n    case TIME:\n      return makeTimeLiteral(\n          DateTimeUtil.zeroCalendar, type.getPrecision());\n    case DATE:\n      return makeDateLiteral(DateTimeUtil.zeroCalendar);\n    case TIMESTAMP:\n      return makeTimestampLiteral(\n          DateTimeUtil.zeroCalendar, type.getPrecision());\n    default:\n      throw Util.unexpected(type.getSqlTypeName());\n    }\n  }\n",
    "new_code_raw": "  public RexNode makeZeroLiteral(RelDataType type) {\n    return makeLiteral(zeroValue(type), type, false);\n  }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-720-FirstSentence-0",
    "old_comment_raw": "Wrap a collection of threads (Runnables) to be logged by Redwood.",
    "new_comment_raw": "Wrap a collection of threads (Runnables) to be logged by Redwood.",
    "old_code_raw": "    public static Iterable<Runnable> thread(final String title, Iterable<Runnable> runnables){\n      //--Preparation\n      //(variables)\n      final AtomicBoolean haveStarted = new AtomicBoolean(false);\n      final ReentrantLock metaInfoLock = new ReentrantLock();\n      final AtomicInteger numPending = new AtomicInteger(0);\n      final Iterator<Runnable> iter = runnables.iterator();\n      //--Create Runnables\n      return new IterableIterator<>(new Iterator<Runnable>() {\n        @Override\n        public boolean hasNext() {\n          return iter.hasNext();\n        }\n        @Override\n        public synchronized Runnable next() {\n          final Runnable runnable = iter.next();\n          // (don't flood the queu)\n          while (numPending.get() > 100) {\n            try { Thread.sleep(100); }\n            catch (InterruptedException e) { }\n          }\n          numPending.incrementAndGet();\n          // (add the job)\n          Runnable toReturn = new Runnable(){\n            public void run(){\n              boolean threadFinished = false;\n              try{\n                //(signal start of threads)\n                metaInfoLock.lock();\n                if(!haveStarted.getAndSet(true)){\n                  startThreads(title); //<--this must be a blocking operation\n                }\n                metaInfoLock.unlock();\n                //(run runnable)\n                try{\n                  runnable.run();\n                } catch (Exception e){\n                  e.printStackTrace();\n                  System.exit(1);\n                } catch (AssertionError e) {\n                  e.printStackTrace();\n                  System.exit(1);\n                }\n                //(signal end of thread)\n                finishThread();\n                threadFinished = true;\n                //(signal end of threads)\n                int numStillPending = numPending.decrementAndGet();\n                if(numStillPending <= 0 && !iter.hasNext()){\n                  endThreads(title);\n                }\n              } catch(Throwable t){\n                t.printStackTrace();\n                if (!threadFinished) { finishThread(); }\n              }\n            }\n          };\n          return toReturn;\n        }\n\n        @Override\n        public void remove() {\n          iter.remove();\n        }\n      });\n    }\n",
    "new_code_raw": "    public static Iterable<Runnable> thread(final String title, Iterable<Runnable> runnables){\n      //--Preparation\n      //(variables)\n      final AtomicBoolean haveStarted = new AtomicBoolean(false);\n      final ReentrantLock metaInfoLock = new ReentrantLock();\n      final AtomicInteger numPending = new AtomicInteger(0);\n      final Iterator<Runnable> iter = runnables.iterator();\n      //--Create Runnables\n      return new IterableIterator<>(new Iterator<Runnable>() {\n        @Override\n        public boolean hasNext() {\n          synchronized (iter) {\n            return iter.hasNext();\n          }\n        }\n        @Override\n        public synchronized Runnable next() {\n          final Runnable runnable;\n          synchronized (iter) {\n            runnable = iter.next();\n          }\n          // (don't flood the queu)\n          while (numPending.get() > 100) {\n            try { Thread.sleep(100); }\n            catch (InterruptedException e) { }\n          }\n          numPending.incrementAndGet();\n          // (add the job)\n          Runnable toReturn = new Runnable(){\n            public void run(){\n              boolean threadFinished = false;\n              try{\n                //(signal start of threads)\n                metaInfoLock.lock();\n                if(!haveStarted.getAndSet(true)){\n                  startThreads(title); //<--this must be a blocking operation\n                }\n                metaInfoLock.unlock();\n                //(run runnable)\n                try{\n                  runnable.run();\n                } catch (Exception e){\n                  e.printStackTrace();\n                  System.exit(1);\n                } catch (AssertionError e) {\n                  e.printStackTrace();\n                  System.exit(1);\n                }\n                //(signal end of thread)\n                finishThread();\n                threadFinished = true;\n                //(signal end of threads)\n                int numStillPending = numPending.decrementAndGet();\n                synchronized (iter) {\n                  if (numStillPending <= 0 && !iter.hasNext()) {\n                    endThreads(title);\n                  }\n                }\n              } catch(Throwable t){\n                t.printStackTrace();\n                if (!threadFinished) { finishThread(); }\n              }\n            }\n          };\n          return toReturn;\n        }\n\n        @Override\n        public void remove() {\n          synchronized (iter) {\n            iter.remove();\n          }\n        }\n      });\n    }\n"
  },
  {
    "id": "heuermh_ensembl-rest-client-6-Associations-FirstSentence",
    "old_comment_raw": "Create and return a new variation service with the default server URL.",
    "new_comment_raw": "Create and return a new variation service with the default endpoint URL.",
    "old_code_raw": "    public VariationService createVariationService() {\n        return createVariationService(defaultServerUrl);\n    }\n",
    "new_code_raw": "    public VariationService createVariationService() {\n        return createVariationService(defaultEndpointUrl);\n    }\n\n"
  },
  {
    "id": "LawnchairLauncher_Lawnchair-28-FirstSentence-0",
    "old_comment_raw": "Creates a new UserFolder, inflated from R.layout.user_folder.",
    "new_comment_raw": "Creates a new UserFolder, inflated from R.layout.user_folder.",
    "old_code_raw": "    static Folder fromXml(Launcher launcher) {\n        return (Folder) launcher.getLayoutInflater().inflate(R.layout.user_folder, null);\n    }\n",
    "new_code_raw": "    static Folder fromXml(Context context) {\n        return (Folder) LayoutInflater.from(context).inflate(R.layout.user_folder, null);\n    }\n"
  },
  {
    "id": "jenkinsci_scm-api-plugin-10-Associations-FirstSentence",
    "old_comment_raw": "Gets all actions used to decorate the behavior of this branch.",
    "new_comment_raw": "Returns an empty list.",
    "old_code_raw": "    @NonNull\n    @Exported(name=\"actions\")\n    public List<? extends Action> getAllActions() {\n        List<Action> actions = new ArrayList<Action>();\n        for (TransientActionFactory<?> taf : ExtensionList.lookup(TransientActionFactory.class)) {\n            if (taf.type().isInstance(this)) {\n                try {\n                    actions.addAll(createFor(taf));\n                } catch (Exception e) {\n                    LOGGER.log(Level.SEVERE, \"Could not load actions from \" + taf + \" for \" + this, e);\n                }\n            }\n        }\n        return Collections.unmodifiableList(actions);\n    }\n",
    "new_code_raw": "    @Restricted(DoNotUse.class)\n    @Deprecated\n    @NonNull\n    public List<? extends Action> getAllActions() {\n        return Collections.emptyList();\n    }\n\n"
  },
  {
    "id": "cryptomator_cryptomator-16-FirstSentence-0",
    "old_comment_raw": "Resolves a relative path (separated by '/') to a folder, e.g.",
    "new_comment_raw": "Resolves a relative path (separated by '/') to a folder, e.g.",
    "old_code_raw": "\tpublic static Folder resolveFolder(Folder dir, String relativePath) {\n\t\tfinal String[] fragments = StringUtils.split(relativePath, '/');\n\t\tif (ArrayUtils.isEmpty(fragments)) {\n\t\t\tthrow new IllegalArgumentException(\"Empty relativePath\");\n\t\t}\n\t\treturn resolveFolder(dir, Arrays.stream(fragments).iterator());\n\t}\n",
    "new_code_raw": "\tpublic static Folder resolveFolder(Folder dir, String relativePath) {\n\t\tfinal String[] fragments = StringUtils.split(relativePath, '/');\n\t\tif (ArrayUtils.isEmpty(fragments)) {\n\t\t\treturn dir;\n\t\t}\n\t\treturn resolveFolder(dir, Arrays.stream(fragments).iterator());\n\t}\n"
  },
  {
    "id": "apache_lenya-337-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Get the line begin",
    "old_code_raw": "    public final int getBeginLine() {\n        return bufline[tokenBegin];\n    }\n",
    "new_code_raw": "    public final int getBeginLine() {\n        return this.bufline[this.tokenBegin];\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2038-FirstSentence-0",
    "old_comment_raw": "Delete purchase order by ID",
    "new_comment_raw": "Delete purchase order by ID",
    "old_code_raw": "    public ApiResponse<Void> deleteOrderWithHttpInfo(String orderId) throws ApiException {\n        okhttp3.Call call = deleteOrderValidateBeforeCall(orderId, null, null);\n        return apiClient.execute(call);\n    }\n",
    "new_code_raw": "    public ApiResponse<Void> deleteOrderWithHttpInfo(String orderId) throws ApiException {\n        okhttp3.Call localVarCall = deleteOrderValidateBeforeCall(orderId, null, null);\n        return localVarApiClient.execute(localVarCall);\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-448-FirstSentence-0",
    "old_comment_raw": "Sets this field in a copy of the TimeOfDay.",
    "new_comment_raw": "Sets this field in a copy of the TimeOfDay to a parsed text value.",
    "old_code_raw": "        public TimeOfDay setCopy(int value) {\n            int[] newValues = getField().set(iInstant, iFieldIndex, value);\n            return new TimeOfDay(iInstant, newValues);\n        }\n",
    "new_code_raw": "        public TimeOfDay setCopy(String text) {\n            return setCopy(text, null);\n        }\n"
  },
  {
    "id": "MilosKozak_AndroidAPS-112-FirstSentence-0",
    "old_comment_raw": "expect absolute request and allow both absolute and percent response based on pump capabilities",
    "new_comment_raw": "expect absolute request and allow both absolute and percent response based on pump capabilities",
    "old_code_raw": "    public boolean applyAPSRequest(APSResult request, Callback callback) {\n        PumpInterface pump = getActivePump();\n        request.rate = applyBasalConstraints(request.rate);\n        PumpEnactResult result;\n\n        if (!pump.isInitialized()) {\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpNotInitialized));\n            if (callback != null) {\n                callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpNotInitialized)).enacted(false).success(false)).run();\n            }\n            return false;\n        }\n\n        if (pump.isSuspended()) {\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpsuspended));\n            if (callback != null) {\n                callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpsuspended)).enacted(false).success(false)).run();\n            }\n            return false;\n        }\n\n        if (Config.logCongigBuilderActions)\n            log.debug(\"applyAPSRequest: \" + request.toString());\n        if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - pump.getBaseBasalRate()) < pump.getPumpDescription().basalStep) {\n            if (isTempBasalInProgress()) {\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: cancelTempBasal()\");\n                getCommandQueue().cancelTempBasal(false, callback);\n                return true;\n            } else {\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: Basal set correctly\");\n                if (callback != null) {\n                    callback.result(new PumpEnactResult().absolute(request.rate).duration(0).enacted(false).success(true).comment(\"Basal set correctly\")).run();\n                }\n                return false;\n            }\n        } else if (isTempBasalInProgress()\n                && getTempBasalRemainingMinutesFromHistory() > 5\n                && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < pump.getPumpDescription().basalStep) {\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: Temp basal set correctly\");\n            if (callback != null) {\n                callback.result(new PumpEnactResult().absolute(getTempBasalAbsoluteRateHistory()).duration(getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes()).enacted(false).success(true).comment(\"Temp basal set correctly\")).run();\n            }\n            return false;\n        } else {\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: setTempBasalAbsolute()\");\n            getCommandQueue().tempBasalAbsolute(request.rate, request.duration, false, callback);\n            return true;\n        }\n    }\n",
    "new_code_raw": "    public boolean applyAPSRequest(APSResult request, Callback callback) {\n        PumpInterface pump = getActivePump();\n        request.rate = applyBasalConstraints(request.rate);\n\n        if (!pump.isInitialized()) {\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpNotInitialized));\n            if (callback != null) {\n                callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpNotInitialized)).enacted(false).success(false)).run();\n            }\n            return false;\n        }\n\n        if (pump.isSuspended()) {\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpsuspended));\n            if (callback != null) {\n                callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpsuspended)).enacted(false).success(false)).run();\n            }\n            return false;\n        }\n\n        if (Config.logCongigBuilderActions)\n            log.debug(\"applyAPSRequest: \" + request.toString());\n        if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - pump.getBaseBasalRate()) < pump.getPumpDescription().basalStep) {\n            if (isTempBasalInProgress()) {\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: cancelTempBasal()\");\n                getCommandQueue().cancelTempBasal(false, callback);\n                if (request.smb == 0)\n                    return true;\n            } else {\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: Basal set correctly\");\n                if (callback != null) {\n                    callback.result(new PumpEnactResult().absolute(request.rate).duration(0).enacted(false).success(true).comment(\"Basal set correctly\")).run();\n                }\n                if (request.smb == 0)\n                    return false;\n            }\n        } else if (isTempBasalInProgress()\n                && getTempBasalRemainingMinutesFromHistory() > 5\n                && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < pump.getPumpDescription().basalStep) {\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: Temp basal set correctly\");\n            if (callback != null) {\n                callback.result(new PumpEnactResult().absolute(getTempBasalAbsoluteRateHistory()).duration(getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes()).enacted(false).success(true).comment(\"Temp basal set correctly\")).run();\n            }\n            if (request.smb == 0)\n                return false;\n        } else {\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: setTempBasalAbsolute()\");\n            getCommandQueue().tempBasalAbsolute(request.rate, request.duration, false, callback);\n\n            if (request.smb == 0) return true;\n        }\n        log.debug(\"SMB requested in config is: \" + request.smb);\n        if (request.smb != 0) {\n            long lastBolusTime = getLastBolusTime();\n            if (lastBolusTime != 0 && lastBolusTime + 3 * 60 * 1000 > System.currentTimeMillis()) {\n                log.debug(\"SMB requsted but still in 3 min interval\");\n            } else {\n                DetailedBolusInfo detailedBolusInfo = new DetailedBolusInfo();\n                detailedBolusInfo.eventType = CareportalEvent.CORRECTIONBOLUS;\n                detailedBolusInfo.insulin = request.smb;\n                detailedBolusInfo.isSMB = true;\n                detailedBolusInfo.source = Source.USER;\n                boolean smbDelivered = getCommandQueue().bolus(detailedBolusInfo, callback);\n                if (smbDelivered)\n                    return true;\n                else\n                    return false;\n            }\n        }\n        return true;\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-324-FirstSentence-0",
    "old_comment_raw": "Returns the annotation mirror for the specified annotation class from the  Element.",
    "new_comment_raw": "Checks whether the  Element hosts an annotation of the specified class.",
    "old_code_raw": "\tpublic static AnnotationMirror getAnnotationMirror(Element element, Class<? extends Annotation> clazz) {\n\t\tassert element != null;\n\t\tassert clazz != null;\n\n\t\tAnnotationMirror mirror = null;\n\t\tfor ( AnnotationMirror am : element.getAnnotationMirrors() ) {\n\t\t\tif ( isAnnotationMirrorOfType( am, clazz ) ) {\n\t\t\t\tmirror = am;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn mirror;\n\t}\n",
    "new_code_raw": "\tpublic static AnnotationMirror getAnnotationMirror(Element element, Class<? extends Annotation> clazz) {\n\t\tassert clazz != null;\n\t\treturn getAnnotationMirror( element, clazz.getName() );\n\t}\n"
  },
  {
    "id": "JodaOrg_joda_time-745-FirstSentence-0",
    "old_comment_raw": "Get the year field for this chronology.",
    "new_comment_raw": "Get the year field for this chronology.",
    "old_code_raw": "    public DateTimeField year() {\n        return UnsupportedDateTimeField.getInstance(\"year\", years());\n    }\n",
    "new_code_raw": "    public DateTimeField year() {\n        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.year(), years());\n    }\n"
  },
  {
    "id": "nelsonsilva_vaadin-152-Associations-FirstSentence",
    "old_comment_raw": "EXPERIMENTAL.",
    "new_comment_raw": "Locates an element using a String locator (path) which identifies a DOM element.",
    "old_code_raw": "    public Element getElementByPath(String path) {\n        // ApplicationConnection.getConsole()\n        // .log(\"getElementByPath(\" + path + \")\");\n\n        // Path is of type \"PID/componentPart\"\n        String parts[] = path.split(SUBPART_SEPARATOR, 2);\n        String widgetPath = parts[0];\n        Widget w = getWidgetFromPath(widgetPath);\n        if (w == null) {\n            return null;\n        }\n\n        if (parts.length == 1) {\n            int pos = widgetPath.indexOf(\"domChild\");\n            if (pos == -1) {\n                return w.getElement();\n            }\n\n            // Contains dom reference to a sub element of the widget\n            String subPath = widgetPath.substring(pos);\n            return getElementByDOMPath(w.getElement(), subPath);\n        } else if (parts.length == 2) {\n            if (w instanceof SubPartAware) {\n                // ApplicationConnection.getConsole().log(\n                // \"subPartAware: \" + parts[1]);\n                return ((SubPartAware) w).getSubPartElement(parts[1]);\n            } else {\n                // ApplicationConnection.getConsole().error(\n                // \"getElementByPath failed because \"\n                // + Util.getSimpleName(w)\n                // + \" is not SubPartAware\");\n                return null;\n            }\n        }\n\n        return null;\n    }\n",
    "new_code_raw": "    public Element getElementByPath(String path) {\n        /*\n         * Path is of type \"targetWidgetPath#componentPart\" or\n         * \"targetWidgetPath\".\n         */\n        String parts[] = path.split(SUBPART_SEPARATOR, 2);\n        String widgetPath = parts[0];\n        Widget w = getWidgetFromPath(widgetPath);\n        if (w == null) {\n            return null;\n        }\n\n        if (parts.length == 1) {\n            int pos = widgetPath.indexOf(\"domChild\");\n            if (pos == -1) {\n                return w.getElement();\n            }\n\n            // Contains dom reference to a sub element of the widget\n            String subPath = widgetPath.substring(pos);\n            return getElementByDOMPath(w.getElement(), subPath);\n        } else if (parts.length == 2) {\n            if (w instanceof SubPartAware) {\n                return ((SubPartAware) w).getSubPartElement(parts[1]);\n            }\n        }\n\n        return null;\n    }\n\n"
  },
  {
    "id": "apache_calcite-250-FirstSentence-0",
    "old_comment_raw": "Creates a new projection based on the original projection, adjusting all input refs using an adjustment array passed in.",
    "new_comment_raw": "Creates a new projection based on the original projection, adjusting all input refs using an adjustment array passed in.",
    "old_code_raw": "  public ProjectRel createNewProject(RelNode projChild, int[] adjustments) {\n    List<Pair<RexNode, String>> projects =\n        new ArrayList<Pair<RexNode, String>>();\n\n    if (origProj != null) {\n      for (Pair<RexNode, String> p : origProj.getNamedProjects()) {\n        projects.add(\n            Pair.of(\n                convertRefsAndExprs(\n                    p.left,\n                    projChild.getRowType().getFieldList(),\n                    adjustments),\n                p.right));\n      }\n    } else {\n      for (Ord<RelDataTypeField> field : Ord.zip(childFields)) {\n        projects.add(\n            Pair.of(\n                (RexNode) rexBuilder.makeInputRef(\n                    field.e.getType(), field.i), field.e.getName()));\n      }\n    }\n    return (ProjectRel) CalcRel.createProject(\n        projChild,\n        Pair.left(projects),\n        Pair.right(projects));\n  }\n",
    "new_code_raw": "  public ProjectRel createNewProject(RelNode projChild, int[] adjustments) {\n    List<Pair<RexNode, String>> projects =\n        new ArrayList<Pair<RexNode, String>>();\n\n    if (origProj != null) {\n      for (Pair<RexNode, String> p : origProj.getNamedProjects()) {\n        projects.add(\n            Pair.of(\n                convertRefsAndExprs(\n                    p.left,\n                    projChild.getRowType().getFieldList(),\n                    adjustments),\n                p.right));\n      }\n    } else {\n      for (Ord<RelDataTypeField> field : Ord.zip(childFields)) {\n        projects.add(\n            Pair.of(\n                (RexNode) rexBuilder.makeInputRef(\n                    field.e.getType(), field.i), field.e.getName()));\n      }\n    }\n    return (ProjectRel) CalcRel.createProject(\n        projChild,\n        Pair.left(projects),\n        Pair.right(projects),\n        true /* optimize to avoid trivial projections, as per javadoc */);\n  }\n"
  },
  {
    "id": "RobotiumTech_robotium-1485-FirstSentence-0",
    "old_comment_raw": "Searches for a button with the given search string and returns true if the searched button is found a given number of times",
    "new_comment_raw": "Searches for a button with the given regex string and returns true if the searched button is found a given number of times",
    "old_code_raw": "\tprivate boolean searchForButton(String search, int matches) {\n\t\tsleeper.sleep();\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(search);\n\t\tMatcher matcher;\n\t\tArrayList<Button> buttonList = viewFetcher.getCurrentViews(Button.class);\n\t\tif(matches == 0)\n\t\t\tmatches = 1;\n\t\tfor(Button button : buttonList){\n\t\t\tmatcher = p.matcher(button.getText().toString());\n\t\t\tif(matcher.find()){\t\n\t\t\t\tcountMatches++;\n\t\t\t}\n\t\t\tif (countMatches == matches) {\n\t\t\t\tcountMatches = 0;\n\t\t\t\treturn true;\n\t\t\t} \t\n\t\t}\n\n\t\tif (scroller.scroll(Scroller.Direction.DOWN))\n\t\t{\n\t\t\treturn searchForButton(search, matches);\n\t\t} else {\n\t\t\tif (countMatches > 0)\n\t\t\t\tLog.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + search);\n\t\t\tcountMatches = 0;\n\t\t\treturn false;\n\t\t}\n\n\t}\n",
    "new_code_raw": "\tprivate boolean searchForButton(String regex, int matches) {\n\t\tsleeper.sleep();\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(regex);\n\t\tMatcher matcher;\n\t\tArrayList<Button> buttonList = viewFetcher.getCurrentViews(Button.class);\n\t\tif(matches == 0)\n\t\t\tmatches = 1;\n\t\tfor(Button button : buttonList){\n\t\t\tmatcher = p.matcher(button.getText().toString());\n\t\t\tif(matcher.find()){\t\n\t\t\t\tcountMatches++;\n\t\t\t}\n\t\t\tif (countMatches == matches) {\n\t\t\t\tcountMatches = 0;\n\t\t\t\treturn true;\n\t\t\t} \t\n\t\t}\n\n\t\tif (scroller.scroll(Scroller.Direction.DOWN))\n\t\t{\n\t\t\treturn searchForButton(regex, matches);\n\t\t} else {\n\t\t\tif (countMatches > 0)\n\t\t\t\tLog.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + regex);\n\t\t\tcountMatches = 0;\n\t\t\treturn false;\n\t\t}\n\n\t}\n"
  },
  {
    "id": "Atmosphere_atmosphere-639-FirstSentence-0",
    "old_comment_raw": "Invoke the proprietary  CometSupport",
    "new_comment_raw": "Invoke the proprietary  CometSupport",
    "old_code_raw": "    public Action doCometSupport(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException {\n        req.setAttribute(BROADCASTER_FACTORY, broadcasterFactory);\n        req.setAttribute(PROPERTY_USE_STREAM, useStreamForFlushingComments);\n        req.setAttribute(BROADCASTER_CLASS, broadcasterClassName);\n        req.setAttribute(ATMOSPHERE_CONFIG, config);\n\n        AtmosphereRequest r = null;\n        Action a = null;\n        try {\n            if (config.getInitParameter(ALLOW_QUERYSTRING_AS_REQUEST) != null\n                    && (isIECandidate(req) || req.getParameter(HeaderConfig.JSONP_CALLBACK_NAME) != null)\n                    && req.getAttribute(WebSocket.WEBSOCKET_SUSPEND) == null) {\n\n                Map<String, String> headers = configureQueryStringAsRequest(req);\n                String body = headers.remove(ATMOSPHERE_POST_BODY);\n                if (body != null && body.isEmpty()) {\n                    body = null;\n                }\n\n                r = new AtmosphereRequest.Builder()\n                        .headers(headers)\n                        .method(body != null && req.getMethod().equalsIgnoreCase(\"GET\") ? \"POST\" : req.getMethod())\n                        .body(body)\n                        .request(req).build();\n\n                a = cometSupport.service(r, res);\n            } else {\n                return cometSupport.service(AtmosphereRequest.wrap(req), res);\n            }\n        } catch (IllegalStateException ex) {\n            if (ex.getMessage() != null && ex.getMessage().startsWith(\"Tomcat failed\")) {\n                if (!isFilter) {\n                    logger.warn(\"Failed using comet support: {}, error: {} Is the Nio or Apr Connector enabled?\", cometSupport.getClass().getName(),\n                            ex.getMessage());\n                    logger.warn(\"Using BlockingIOCometSupport.\");\n                }\n                logger.trace(ex.getMessage(), ex);\n\n                cometSupport = new BlockingIOCometSupport(config);\n                doCometSupport(req, res);\n            } else {\n                logger.error(\"AtmosphereServlet exception\", ex);\n                throw ex;\n            }\n        } finally {\n            if (r != null && a != null && a.type != Action.TYPE.SUSPEND) {\n                r.destroy();\n            }\n        }\n        return null;\n    }\n",
    "new_code_raw": "    public Action doCometSupport(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException {\n        req.setAttribute(BROADCASTER_FACTORY, broadcasterFactory);\n        req.setAttribute(PROPERTY_USE_STREAM, useStreamForFlushingComments);\n        req.setAttribute(BROADCASTER_CLASS, broadcasterClassName);\n        req.setAttribute(ATMOSPHERE_CONFIG, config);\n\n        AtmosphereRequest r = null;\n        Action a = null;\n        try {\n            if (config.getInitParameter(ALLOW_QUERYSTRING_AS_REQUEST) != null\n                    && (isIECandidate(req) || req.getParameter(HeaderConfig.JSONP_CALLBACK_NAME) != null)\n                    && req.getAttribute(WebSocket.WEBSOCKET_SUSPEND) == null) {\n\n                Map<String, String> headers = configureQueryStringAsRequest(req);\n                String body = headers.remove(ATMOSPHERE_POST_BODY);\n                if (body != null && body.isEmpty()) {\n                    body = null;\n                }\n\n                r = new AtmosphereRequest.Builder()\n                        .headers(headers)\n                        .method(body != null && req.getMethod().equalsIgnoreCase(\"GET\") ? \"POST\" : req.getMethod())\n                        .body(body)\n                        .request(req).build();\n\n                a = cometSupport.service(r, res);\n            } else {\n                if (AtmosphereRequest.class.isAssignableFrom(req.getClass())) {\n                    return cometSupport.service(req, res);\n                } else {\n                    return cometSupport.service(AtmosphereRequest.wrap(req), res);\n                }\n            }\n        } catch (IllegalStateException ex) {\n            if (ex.getMessage() != null && ex.getMessage().startsWith(\"Tomcat failed\")) {\n                if (!isFilter) {\n                    logger.warn(\"Failed using comet support: {}, error: {} Is the Nio or Apr Connector enabled?\", cometSupport.getClass().getName(),\n                            ex.getMessage());\n                    logger.warn(\"Using BlockingIOCometSupport.\");\n                }\n                logger.trace(ex.getMessage(), ex);\n\n                cometSupport = new BlockingIOCometSupport(config);\n                doCometSupport(req, res);\n            } else {\n                logger.error(\"AtmosphereServlet exception\", ex);\n                throw ex;\n            }\n        } finally {\n            if (r != null && a != null && a.type != Action.TYPE.SUSPEND) {\n                r.destroy();\n            }\n        }\n        return null;\n    }\n"
  },
  {
    "id": "apache_tomee-88-Associations-FirstSentence",
    "old_comment_raw": "Returns the openejb-tomcat-loader.jar file",
    "new_comment_raw": "Returns the tomee-loader.jar file",
    "old_code_raw": "    public File getOpenEJBTomcatLoaderJar() {\n        return findOpenEJBJar(\"openejb-tomcat-loader\");\n    }\n",
    "new_code_raw": "    public File getOpenEJBTomcatLoaderJar() {\n        return findOpenEJBJar(\"tomee-loader\");\n    }\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2187-FirstSentence-0",
    "old_comment_raw": "Get the index of the head word for a given span, based off of the dependency parse.",
    "new_comment_raw": "Get the index of the head word for a given span, based off of the dependency parse.",
    "old_code_raw": "  public int headOfSpan(Span tokenSpan) {\n    // Error checks\n    if (tokenSpan.size() == 0) {\n      throw new IllegalArgumentException(\"Cannot find head word of empty span!\");\n    }\n    List<Optional<Integer>> governors = sentence.governors();\n    if (tokenSpan.start() >= governors.size()) {\n      throw new IllegalArgumentException(\"Span is out of range: \" + tokenSpan + \"; sentence: \" + sentence);\n    }\n    if (tokenSpan.end() > governors.size()) {\n      throw new IllegalArgumentException(\"Span is out of range: \" + tokenSpan + \"; sentence: \" + sentence);\n    }\n\n    // Find where to start searching up the dependency tree\n    int candidateStart = tokenSpan.end() - 1;\n    Optional<Integer> parent;\n    while ( !(parent = governors.get(candidateStart)).isPresent() ) {\n      candidateStart -= 1;\n      if (candidateStart < tokenSpan.start()) {\n        // Case: nothing in this span has a head. Default to right-most element.\n        return tokenSpan.end() - 1;\n      }\n    }\n    int candidate = candidateStart;\n\n    // Search up the dependency tree\n    Set<Integer> seen = new HashSet<>();\n    while (parent.isPresent() && parent.get() >= tokenSpan.start() && parent.get() < tokenSpan.end()) {\n      candidate = parent.get();\n      if (seen.contains(candidate)) {\n        return candidate;\n      }\n      seen.add(candidate);\n      parent = governors.get(candidate);\n    }\n\n    // Return\n    return candidate;\n  }\n",
    "new_code_raw": "  public int headOfSpan(Span tokenSpan) {\n    // Error checks\n    if (tokenSpan.size() == 0) {\n      throw new IllegalArgumentException(\"Cannot find head word of empty span!\");\n    }\n\n    // Find where to start searching up the dependency tree\n    int candidateStart = tokenSpan.end() - 1;\n    Optional<Integer> parent;\n    while ( !(parent = sentence.governor(candidateStart)).isPresent() ) {\n      candidateStart -= 1;\n      if (candidateStart < tokenSpan.start()) {\n        // Case: nothing in this span has a head. Default to right-most element.\n        return tokenSpan.end() - 1;\n      }\n    }\n    int candidate = candidateStart;\n\n    // Search up the dependency tree\n    while (parent.isPresent() && parent.get() >= tokenSpan.start() && parent.get() < tokenSpan.end()) {\n      candidate = parent.get();\n      parent = sentence.governor(candidate);\n    }\n\n    // Return\n    return candidate;\n  }\n"
  },
  {
    "id": "mulesoft_google-connectors-suite-0-Associations-FirstSentence",
    "old_comment_raw": "Returns an instance of  org.mule.module.google.calendar.model.CalendarList listing the calendars of the user that owns the OAuth access token.",
    "new_comment_raw": "Returns a paginated iterator with instances of  org.mule.module.google.calendar.model.CalendarList listing the calendars of the user that owns the OAuth access token.",
    "old_code_raw": "    @Processor\n    @Inject\n    @OAuthProtected\n\t@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)\n    public List<CalendarList> getCalendarList(\n    \t\tMuleMessage message,\n    \t\t@Optional @Default(\"100\") int maxResults,\n    \t\t@Optional String pageToken,\n    \t\t@Optional @Default(\"false\") boolean showHidden) throws IOException {\n\n    \tcom.google.api.services.calendar.Calendar.CalendarList.List calendars = this.client.calendarList().list();\n    \tcom.google.api.services.calendar.model.CalendarList list = calendars.setMaxResults(maxResults)\n    \t\t.setPageToken(pageToken)\n    \t\t.setShowHidden(showHidden)\n    \t\t.execute();\n    \t\n    \tthis.saveNextPageToken(list, message);\n    \treturn CalendarList.valueOf(list.getItems(), CalendarList.class);\n    }\n",
    "new_code_raw": "    @Processor\n    @OAuthProtected\n\t@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)\n    @Paged\n    public PagingDelegate<CalendarList> getCalendarList(\n    \t\tfinal @Optional @Default(\"false\") boolean showHidden,\n    \t\tfinal PagingConfiguration pagingConfiguration) throws IOException {\n    \t\n    \treturn new TokenBasedPagingDelegate<CalendarList>() {\n    \t\t\n    \t\t@Override\n    \t\tpublic List<CalendarList> doGetPage() throws IOException {\n\t\t\t\tcom.google.api.services.calendar.Calendar.CalendarList.List calendars = client.calendarList().list();\n\t\t\t\tcom.google.api.services.calendar.model.CalendarList list = calendars.setMaxResults(pagingConfiguration.getFetchSize())\n\t\t\t\t\t\t.setPageToken(this.getPageToken())\n\t\t\t\t\t\t.setShowHidden(showHidden)\n\t\t\t\t\t\t.execute();\n\t\t\t\t\n\t\t\t\tsetPageToken(list.getNextPageToken());\n\t\t\t\treturn CalendarList.valueOf(list.getItems(), CalendarList.class);\n    \t\t}\n\t\t};\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2159-FirstSentence-0",
    "old_comment_raw": "Find purchase order by ID",
    "new_comment_raw": "Find purchase order by ID",
    "old_code_raw": "    public Mono<Order> getOrderById(Long orderId) throws RestClientException {\n        Object postBody = null;\n        \n        // verify the required parameter 'orderId' is set\n        if (orderId == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'orderId' when calling getOrderById\");\n        }\n        \n        // create path and map variables\n        final Map<String, Object> uriVariables = new HashMap<String, Object>();\n        uriVariables.put(\"order_id\", orderId);\n        String path = UriComponentsBuilder.fromPath(\"/store/order/{order_id}\").buildAndExpand(uriVariables).toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application/xml\", \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Order> returnType = new ParameterizedTypeReference<Order>() {};\n        return apiClient.invokeAPI(path, HttpMethod.GET, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "new_code_raw": "    public Mono<Order> getOrderById(Long orderId) throws RestClientException {\n        Object postBody = null;\n        \n        // verify the required parameter 'orderId' is set\n        if (orderId == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'orderId' when calling getOrderById\");\n        }\n        \n        // create path and map variables\n        final Map<String, Object> uriVariables = new HashMap<String, Object>();\n        uriVariables.put(\"order_id\", orderId);\n        String path = UriComponentsBuilder.fromPath(\"/store/order/{order_id}\").buildAndExpand(uriVariables).toUriString();\n\n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application/xml\", \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Order> returnType = new ParameterizedTypeReference<Order>() {};\n        return apiClient.invokeAPI(path, HttpMethod.GET, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType);\n    }\n"
  },
  {
    "id": "mulesoft_google-connectors-suite-4-Associations-FirstSentence",
    "old_comment_raw": "Lists the user's files.",
    "new_comment_raw": "Returns a paginated  Iterator with the user's  org.mule.module.google.drive.model.Files.",
    "old_code_raw": "\t@Processor\n    @OAuthProtected\n\t@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)\n\t@Inject\n\tpublic List<File> listFiles(\n\t\t\tMuleMessage message,\n\t\t\t@Optional @Default(\"100\") int maxResults,\n\t\t\t@Optional String query,\n    \t\t@Optional @Default(\"#[flowVars['GoogleDrive_NEXT_PAGE_TOKEN']]\") String pageToken) throws IOException {\n\t\t\n\t\tFileList response = this.client.files().list()\n\t\t\t\t\t\t\t.setMaxResults(maxResults)\n\t\t\t\t\t\t\t.setPageToken(pageToken)\n\t\t\t\t\t\t\t.setQ(query)\n\t\t\t\t\t\t\t.execute();\n\t\t\n\t\tPaginationUtils.savePageToken(NEXT_PAGE_TOKEN, response.getNextPageToken(), message);\n\t\treturn File.valueOf(response.getItems(), File.class);\n\t}\n",
    "new_code_raw": "\t@Processor\n    @OAuthProtected\n\t@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)\n\t@Paged\n\tpublic PagingDelegate<File> listFiles(\n\t\t\tfinal @Optional @Default(\"100\") int maxResults,\n\t\t\tfinal @Optional String query,\n    \t\tfinal PagingConfiguration pagingConfiguration) throws IOException {\n\t\t\n\t\treturn new TokenBasedPagingDelegate<File>() {\n    \t\t\n    \t\t@Override\n    \t\tpublic List<File> doGetPage() throws IOException {\n    \t\t\tFileList response = client.files().list()\n\t\t\t\t\t\t.setMaxResults(maxResults)\n\t\t\t\t\t\t.setPageToken(this.getPageToken())\n\t\t\t\t\t\t.setQ(query)\n\t\t\t\t\t\t.execute();\n    \t\t\t\n    \t\t\tthis.setPageToken(response.getNextPageToken());\n\t\n    \t\t\treturn File.valueOf(response.getItems(), File.class);\n    \t\t}\n\t\t};\n\t}\n\n"
  },
  {
    "id": "debezium_debezium-935-FirstSentence-0",
    "old_comment_raw": "Converts a value object for an expected type of  java.time.Duration to  Long values that represents the time in microseconds.",
    "new_comment_raw": "Converts a value object for an expected type of  java.time.Duration to  Long values that represents the time in microseconds.",
    "old_code_raw": "    protected Object convertDurationToMicroseconds(Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0;\n        }\n        try {\n            if (data instanceof Duration) return ((Duration) data).toNanos() / 1_000;\n        } catch (IllegalArgumentException e) {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n",
    "new_code_raw": "    protected Object convertDurationToMicroseconds(Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0L;\n        }\n        try {\n            if (data instanceof Duration) return ((Duration) data).toNanos() / 1_000;\n        } catch (IllegalArgumentException e) {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n"
  },
  {
    "id": "google_certificate-transparency-java-4-Associations-FirstSentence",
    "old_comment_raw": "Parses a  Ct.TimestampedEntry from binary encoding.",
    "new_comment_raw": "Parses a  TimestampedEntry from binary encoding.",
    "old_code_raw": "  public static Ct.TimestampedEntry parseTimestampedEntry(InputStream in) {\n    Ct.TimestampedEntry.Builder timestampedEntry = Ct.TimestampedEntry.newBuilder();\n\n    long timestamp = readNumber(in, CTConstants.TIMESTAMP_LENGTH);\n    timestampedEntry.setTimestamp(timestamp);\n\n    int entryType = (int) readNumber(in, CTConstants.LOG_ENTRY_TYPE_LENGTH);\n    timestampedEntry.setEntryType(Ct.LogEntryType.valueOf(entryType));\n\n    Ct.SignedEntry.Builder signedEntryBuilder = Ct.SignedEntry.newBuilder();\n    if (entryType == Ct.LogEntryType.X509_ENTRY_VALUE) {\n\n      int length = (int) readNumber(in, 3);\n      ByteString x509 = ByteString.copyFrom(readFixedLength(in, length));\n      signedEntryBuilder.setX509(x509);\n\n    } else if (entryType == Ct.LogEntryType.PRECERT_ENTRY_VALUE) {\n      Ct.PreCert.Builder preCertBuilder = Ct.PreCert.newBuilder();\n\n      byte[] arr = readFixedLength(in, 32);\n      preCertBuilder.setIssuerKeyHash(ByteString.copyFrom(arr));\n\n      // set tbs certificate\n      arr = readFixedLength(in, 2);\n      int length = (int) readNumber(in, 2);\n\n      preCertBuilder.setTbsCertificate(ByteString.copyFrom(readFixedLength(in, length)));\n      preCertBuilder.build();\n\n      signedEntryBuilder.setPrecert(preCertBuilder);\n    } else {\n      throw new SerializationException(String.format(\"Unknown entry type: %d\", entryType));\n    }\n    signedEntryBuilder.build();\n    timestampedEntry.setSignedEntry(signedEntryBuilder);\n\n    return timestampedEntry.build();\n  }\n",
    "new_code_raw": "  public static TimestampedEntry parseTimestampedEntry(InputStream in) {\n    TimestampedEntry timestampedEntry = new TimestampedEntry();\n\n    timestampedEntry.timestamp = readNumber(in, CTConstants.TIMESTAMP_LENGTH);\n\n    int entryType = (int) readNumber(in, CTConstants.LOG_ENTRY_TYPE_LENGTH);\n    timestampedEntry.entryType = Ct.LogEntryType.valueOf(entryType);\n\n    Ct.SignedEntry.Builder signedEntryBuilder = Ct.SignedEntry.newBuilder();\n    if (entryType == Ct.LogEntryType.X509_ENTRY_VALUE) {\n\n      int length = (int) readNumber(in, 3);\n      ByteString x509 = ByteString.copyFrom(readFixedLength(in, length));\n      signedEntryBuilder.setX509(x509);\n\n    } else if (entryType == Ct.LogEntryType.PRECERT_ENTRY_VALUE) {\n      Ct.PreCert.Builder preCertBuilder = Ct.PreCert.newBuilder();\n\n      byte[] arr = readFixedLength(in, 32);\n      preCertBuilder.setIssuerKeyHash(ByteString.copyFrom(arr));\n\n      // set tbs certificate\n      arr = readFixedLength(in, 2);\n      int length = (int) readNumber(in, 2);\n\n      preCertBuilder.setTbsCertificate(ByteString.copyFrom(readFixedLength(in, length)));\n      preCertBuilder.build();\n\n      signedEntryBuilder.setPrecert(preCertBuilder);\n    } else {\n      throw new SerializationException(String.format(\"Unknown entry type: %d\", entryType));\n    }\n    timestampedEntry.signedEntry = signedEntryBuilder.build();\n\n    return timestampedEntry;\n  }\n\n"
  },
  {
    "id": "rstudio_rstudio-119-FirstSentence-0",
    "old_comment_raw": "Selects the first item in the menu if no items are currently selected.",
    "new_comment_raw": "Selects the first item in the menu if no items are currently selected.",
    "old_code_raw": "  private boolean selectFirstItemIfNoneSelected() {\n    if (selectedItem == null) {\n      for (MenuItem nextItem : items) {\n        if (nextItem.isEnabled()) {\n          selectItem(nextItem);\n          break;\n        }\n      }\n      return true;\n    }\n    return false;\n }\n",
    "new_code_raw": "  private boolean selectFirstItemIfNoneSelected() {\n    if (selectedItem == null) {\n      for (MenuItem nextItem : items) {\n        if (nextItem.isEnabled() && nextItem.isVisible()) {\n          selectItem(nextItem);\n          return true;\n        }\n      }\n      for (MenuItem nextItem : items) {\n        if (nextItem.isVisible()) {\n          selectItem(nextItem);\n          return true;\n        }\n      }\n      return true;\n    }\n    return false;\n }\n"
  },
  {
    "id": "querydsl_querydsl-41-Associations-FirstSentence",
    "old_comment_raw": "Returns a applyer for the given primitive type.",
    "new_comment_raw": "Returns a transformer for the given primitive type.",
    "old_code_raw": "    protected Function getTypeFunction( Class aType ) {\r\n        return (Function) typeFunctions.get( aType );\r\n    }\r\n",
    "new_code_raw": "    protected Function<?,?> getTypeFunction(Class<?> aType) {\r\n        return (Function<?,?>) defaultFunctions.get(aType);\r\n    }\r\n\n"
  },
  {
    "id": "SeleniumHQ_selenium-711-FirstSentence-0",
    "old_comment_raw": "Forcibly kills a process, using OS tools like \"kill\" as a last resort",
    "new_comment_raw": "Forcibly kills a process, using OS tools like \"kill\" as a last resort",
    "old_code_raw": "  public static int killProcess(Process process) {\n    int exitValue;\n\n    // first, wait a second to see if the process will die on it's own (we will likely have asked\n    // the process to kill itself just before calling this method\n    try {\n      exitValue = waitForProcessDeath(process, 1000);\n      closeAllStreamsAndDestroyProcess( process);\n      if (exitValue == 0) {\n        return exitValue;\n      }\n    } catch (Exception e) {\n      // no? ok, no biggie, now let's force kill it...\n    }\n\n    process.destroy();\n    try {\n      exitValue = waitForProcessDeath(process, 10000);\n      closeAllStreamsAndDestroyProcess( process);\n    } catch (ProcessStillAliveException ex) {\n      if (Platform.getCurrent().is(Platform.WINDOWS)) {\n        throw ex;\n      }\n      try {\n        log.info(\"Process didn't die after 10 seconds\");\n        kill9(process);\n        exitValue = waitForProcessDeath(process, 10000);\n        closeAllStreamsAndDestroyProcess( process);\n      } catch (Exception e) {\n        log.warning(\"Process refused to die after 10 seconds, and couldn't kill9 it\");\n        e.printStackTrace();\n        throw new RuntimeException(\n            \"Process refused to die after 10 seconds, and couldn't kill9 it: \" + e.getMessage(),\n            ex);\n      }\n    }\n    return exitValue;\n  }\n",
    "new_code_raw": "  public static int killProcess(Process process) {\n    if (thisIsWindows()) {\n      return killWinProcess(process);\n    } else {\n      return killUnixProcess(process);\n    }\n  }\n"
  },
  {
    "id": "apache_struts1-30-Associations-FirstSentence",
    "old_comment_raw": "Return the ApplicationConfig object is it exists, null otherwise.",
    "new_comment_raw": "Return the ModuleConfig object is it exists, null otherwise.",
    "old_code_raw": "    public static ApplicationConfig getModuleConfig(HttpServletRequest request,ServletContext context) {\n        ApplicationConfig appConfig = (ApplicationConfig)\n            request.getAttribute(Globals.MODULE_KEY);\n        if (appConfig == null) {\n            appConfig = (ApplicationConfig)\n                context.getAttribute(Globals.MODULE_KEY);\n        }\n       return appConfig;\n    }\n",
    "new_code_raw": "    public static ModuleConfig getModuleConfig(HttpServletRequest request,ServletContext context) {\n        ModuleConfig moduleConfig = (ModuleConfig)\n            request.getAttribute(Globals.MODULE_KEY);\n        if (moduleConfig == null) {\n            moduleConfig = (ModuleConfig)\n                context.getAttribute(Globals.MODULE_KEY);\n        }\n       return moduleConfig;\n    }\n\n"
  },
  {
    "id": "debezium_debezium-1018-FirstSentence-0",
    "old_comment_raw": "Converts a value object for an expected JDBC type of  Types#BOOLEAN.",
    "new_comment_raw": "Converts a value object for an expected JDBC type of  Types#BOOLEAN.",
    "old_code_raw": "    protected Object convertBoolean(Column column, Field fieldDefn, Object data) {\n        if (data == null && !fieldDefn.schema().isOptional()) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return false;\n        }\n        if (data instanceof Boolean) return data;\n        if (data instanceof Short) return ((Short) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;\n        if (data instanceof Integer) return ((Integer) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;\n        if (data instanceof Long) return ((Long) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;\n        return handleUnknownData(column, fieldDefn, data);\n    }\n",
    "new_code_raw": "    protected Object convertBoolean(Column column, Field fieldDefn, Object data) {\n        return convertValue(column, fieldDefn, data, false, (r) -> {\n            if (data instanceof Boolean) {\n                r.deliver(data);\n            }\n            else if (data instanceof Short) {\n                r.deliver(((Short) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE);\n            }\n            else if (data instanceof Integer) {\n                r.deliver(((Integer) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE);\n            }\n            else if (data instanceof Long) {\n                r.deliver(((Long) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE);\n            }\n        });\n    }\n"
  },
  {
    "id": "apache_activemq-1280-FirstSentence-0",
    "old_comment_raw": "appends to the list",
    "new_comment_raw": "Update the value of the item with the given key in the list if ot exists, otherwise it appends the value to the end of the list.",
    "old_code_raw": "    synchronized public Value put(Transaction tx, Key key, Value value) throws IOException {\n        return add(tx, key, value);\n    }\n",
    "new_code_raw": "    synchronized public Value put(Transaction tx, Key key, Value value) throws IOException {\n\n        Value oldValue = null;\n\n        if (lastGetNodeCache != null) {\n\n            if(lastGetEntryCache.getKey().equals(key)) {\n                oldValue = lastGetEntryCache.setValue(value);\n                lastGetEntryCache.setValue(value);\n                lastGetNodeCache.storeUpdate(tx);\n                return oldValue;\n            }\n\n            // This searches from the last location of a call to get for the element to replace\n            // all the way to the end of the ListIndex.\n            Iterator<Map.Entry<Key, Value>> iterator = lastGetNodeCache.iterator(tx);\n            while (iterator.hasNext()) {\n                Map.Entry<Key, Value> entry = iterator.next();\n                if (entry.getKey().equals(key)) {\n                    oldValue = entry.setValue(value);\n                    ((ListIterator) iterator).getCurrent().storeUpdate(tx);\n                    return oldValue;\n                }\n            }\n        }\n\n        // Not found because the cache wasn't set or its not at the end of the list so we\n        // start from the beginning and go to the cached location or the end, then we do\n        // an add if its not found.\n        Iterator<Map.Entry<Key, Value>> iterator = iterator(tx);\n        while (iterator.hasNext() && ((ListIterator) iterator).getCurrent() != lastGetNodeCache) {\n            Map.Entry<Key, Value> entry = iterator.next();\n            if (entry.getKey().equals(key)) {\n                oldValue = entry.setValue(value);\n                ((ListIterator) iterator).getCurrent().storeUpdate(tx);\n                return oldValue;\n            }\n        }\n\n        // Not found so add it last.\n        return add(tx, key, value);\n    }\n"
  },
  {
    "id": "processing_processing-46-FirstSentence-0",
    "old_comment_raw": "Returns the shared color provider.",
    "new_comment_raw": "Returns the shared color provider.",
    "old_code_raw": "\t public ProcessingColorProvider getProcessingColorProvider() {\n\t \tif (fColorProvider == null)\n\t\t\tfColorProvider= new ProcessingColorProvider();\n\t\treturn fColorProvider;\n\t}\n",
    "new_code_raw": "\t public ProcessingColorProvider getProcessingColorProvider() {\n\t\treturn (fColorProvider == null) ? new ProcessingColorProvider() : fColorProvider;\n\t}\n"
  },
  {
    "id": "JodaOrg_joda_time-484-FirstSentence-0",
    "old_comment_raw": "Checks if the field type specified is supported by this local datetime and chronology.",
    "new_comment_raw": "Checks if the field type specified is supported by this local date and chronology.",
    "old_code_raw": "    public boolean isSupported(DateTimeFieldType type) {\n        if (type == null) {\n            return false;\n        }\n        DateTimeField field = type.getField(getChronology());\n        if (DATE_DURATION_TYPES.contains(type.getDurationType()) ||\n            field.getDurationField().getUnitMillis() >= getChronology().days().getUnitMillis()) {\n            return field.isSupported();\n        }\n        return false;\n    }\n",
    "new_code_raw": "    public boolean isSupported(DateTimeFieldType type) {\n        if (type == null) {\n            return false;\n        }\n        return isSupported(type.getDurationType());\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-1423-FirstSentence-0",
    "old_comment_raw": "Waits for a text to be shown.",
    "new_comment_raw": "Waits for a text to be shown.",
    "old_code_raw": "\tpublic boolean waitForText(String text, int minimumNumberOfMatches, long timeout, boolean scroll) {\n\t\treturn waiter.waitForText(text, minimumNumberOfMatches, timeout, scroll);\n    }\n",
    "new_code_raw": "\tpublic boolean waitForText(String text, int minimumNumberOfMatches, long timeout, boolean scroll) {\n\t\tTextView textView = waiter.waitForText(text, minimumNumberOfMatches, timeout, scroll);\n\t\treturn textView != null;\n\t\t\n    }\n"
  },
  {
    "id": "biddyweb_android-rcs-ims-stack-103-Associations-FirstSentence",
    "old_comment_raw": "Utility to check if a phone number is associated to a RCS account",
    "new_comment_raw": "Utility to check if a phone number is associated to an entry in the rich address book provider",
    "old_code_raw": "    public boolean isRcsAssociated(final String phoneNumber) {\n    \treturn !getRcsRawContactIdFromPhoneNumber(phoneNumber).isEmpty();\n    }\n",
    "new_code_raw": "    public boolean isRcsAssociated(final String phoneNumber) {\n        boolean result = false;\n        Cursor cur = ctx.getContentResolver().query(RichAddressBookData.CONTENT_URI, \n                new String[]{RichAddressBookData.KEY_CONTACT_NUMBER}, \n                RichAddressBookData.KEY_CONTACT_NUMBER + \"=?\", \n                new String[]{phoneNumber}, \n                null);\n        if (cur!=null){\n            if (cur.moveToFirst()) {\n                result = true;\n            }\n            cur.close();\n        }else{\n            result = false;\n        }\n        return result;\n    }\n\n"
  },
  {
    "id": "zaproxy_zaproxy-2181-FirstSentence-0",
    "old_comment_raw": "This method initializes txtPattern",
    "new_comment_raw": "This method initializes txtPattern",
    "old_code_raw": "\tprivate JTextField getTxtPattern() {\n\t\tif (txtPattern == null) {\n\t\t\ttxtPattern = new JTextField();\n\t\t}\n\t\treturn txtPattern;\n\t}\n",
    "new_code_raw": "\tprivate ZapTextField getTxtPattern() {\n\t\tif (txtPattern == null) {\n\t\t\ttxtPattern = new ZapTextField();\n\t\t}\n\t\treturn txtPattern;\n\t}\n"
  },
  {
    "id": "lingochamp_FileDownloader-78-FirstSentence-0",
    "old_comment_raw": "Recommend used to telling the FileDownloader Engine that the task with the  url and the  path has already completed downloading, in case of your task has already downloaded by other ways(not by FileDownloader Engine), and after success to set the task completed, FileDownloader will check the task with  url and the  path whether completed by  totalBytes.",
    "new_comment_raw": "Recommend used to telling the FileDownloader Engine that a bulk of tasks have already downloaded by other ways(not by the FileDownloader Engine).",
    "old_code_raw": "    public boolean setTaskCompleted(String url, String path, long totalBytes) {\n        return FileDownloadServiceProxy.getImpl().setTaskCompleted(url, path, totalBytes);\n    }\n",
    "new_code_raw": "    public boolean setTaskCompleted(List<FileDownloadTaskAtom> taskAtomList) {\n        return FileDownloadServiceProxy.getImpl().setTaskCompleted(taskAtomList);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2585-FirstSentence-0",
    "old_comment_raw": "POST /fake/outer/string",
    "new_comment_raw": "POST /fake/outer/string",
    "old_code_raw": "        public String executeAs(Function<Response, Response> handler) {\n            Type type = new TypeToken<String>(){}.getType();\n            return getJSON().deserialize(execute(handler).asString(), type);\n        }\n",
    "new_code_raw": "        public String executeAs(Function<Response, Response> handler) {\n            Type type = new TypeToken<String>(){}.getType();\n            return execute(handler).as(type);\n        }\n"
  },
  {
    "id": "debezium_debezium-998-FirstSentence-0",
    "old_comment_raw": "Converts a value object for an expected JDBC type of  Types#TIMESTAMP to  Timestamp values, or milliseconds past epoch.",
    "new_comment_raw": "Converts a value object for an expected JDBC type of  Types#TIMESTAMP to  Timestamp values, or milliseconds past epoch.",
    "old_code_raw": "    protected Object convertTimestampToEpochMillis(Column column, Field fieldDefn, Object data) {\n        if (data == null && !fieldDefn.schema().isOptional()) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0L; // return epoch\n        }\n        try {\n            return Timestamp.toEpochMillis(data, adjuster);\n        } catch (IllegalArgumentException e) {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n    }\n",
    "new_code_raw": "    protected Object convertTimestampToEpochMillis(Column column, Field fieldDefn, Object data) {\n        // epoch is the fallback value\n        return convertValue(column, fieldDefn, data, 0L, (r) -> {\n            try {\n                r.deliver(Timestamp.toEpochMillis(data, adjuster));\n            } catch (IllegalArgumentException e) {\n            }\n        });\n    }\n"
  },
  {
    "id": "apache_axis1-java-242-Associations-FirstSentence",
    "old_comment_raw": "Returns the fully qualified name of the port for this Call object (if there is one).",
    "new_comment_raw": "Returns the fully qualified name of the port type for this Call object (if there is one).",
    "old_code_raw": "    public QName getPortTypeName() {\n        return portName == null ? new QName(\"\") : portName;\n    }\n",
    "new_code_raw": "    public QName getPortTypeName() {\n        return portTypeName == null ? new QName(\"\") : portTypeName;\n    }\n\n"
  },
  {
    "id": "RobotiumTech_robotium-1370-FirstSentence-0",
    "old_comment_raw": "Scrolls up a list with a given index.",
    "new_comment_raw": "Scrolls up a list with a given index.",
    "old_code_raw": "\tpublic boolean scrollUpList(int index) {\n\t\twaiter.waitForView(ListView.class, index);\n\t\treturn scroller.scrollList(index, Scroller.UP, null);\n\t}\n",
    "new_code_raw": "\tpublic boolean scrollUpList(int index) {\n\t\twaiter.waitForView(ListView.class, index);\n\t\treturn scroller.scrollList(ListView.class, 0, Scroller.UP, null);\n\t}\n"
  },
  {
    "id": "mulesoft_google-connectors-suite-7-Associations-FirstSentence",
    "old_comment_raw": "Lists all replies for a given comment @sample.xml ../../../doc/GoogleDriveConnector.xml.sample google-drive:list-comment-replies",
    "new_comment_raw": "Returns a paginated  Iterator with all the  org.mule.module.google.drive.model.CommentReply for a given comment @sample.xml ../../../doc/GoogleDriveConnector.xml.sample google-drive:list-comment-replies",
    "old_code_raw": "\t@Processor\n    @OAuthProtected\n\t@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)\n\t@Inject\n\tpublic List<CommentReply> listCommentReplies(\n\t\t\tMuleMessage message,\n\t\t\tString fileId,\n\t\t\tString commentId, \n\t\t\t@Optional @Default(\"false\") boolean includeDeleted,\n\t\t\t@Optional @Default(\"100\") int maxResults,\n\t\t\t@Optional @Default(\"#[flowVars['GoogleDrive_NEXT_PAGE_TOKEN']]\") String pageToken\n\t\t\t) throws IOException {\n\t\t\n\t\tCommentReplyList response = this.client.replies().list(fileId, commentId)\n\t\t\t\t\t\t\t\t\t\t.setIncludeDeleted(includeDeleted)\n\t\t\t\t\t\t\t\t\t\t.setMaxResults(maxResults)\n\t\t\t\t\t\t\t\t\t\t.setPageToken(pageToken)\n\t\t\t\t\t\t\t\t\t\t.execute();\n\t\t\n\n\t\tPaginationUtils.savePageToken(NEXT_PAGE_TOKEN, response.getNextPageToken(), message);\n\t\treturn CommentReply.valueOf(response.getItems(), CommentReply.class);\n\t}\n",
    "new_code_raw": "\t@Processor\n    @OAuthProtected\n\t@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)\n\t@Paged\n\tpublic PagingDelegate<CommentReply> listCommentReplies(\n\t\t\tfinal String fileId,\n\t\t\tfinal String commentId, \n\t\t\tfinal @Optional @Default(\"false\") boolean includeDeleted,\n\t\t\tfinal @Optional @Default(\"100\") int maxResults,\n\t\t\tfinal PagingConfiguration pagingConfiguration\n\t\t\t) throws IOException {\n\t\t\n\t\treturn new TokenBasedPagingDelegate<CommentReply>() {\n\t\t\t\n\t\t\t@Override\n\t\t\tprotected List<CommentReply> doGetPage() throws IOException {\n\t\t\t\tCommentReplyList response = client.replies().list(fileId, commentId)\n\t\t\t\t\t\t.setIncludeDeleted(includeDeleted)\n\t\t\t\t\t\t.setMaxResults(maxResults)\n\t\t\t\t\t\t.setPageToken(this.getPageToken())\n\t\t\t\t\t\t.execute();\n\t\t\t\t\n\t\t\t\tthis.setPageToken(response.getNextPageToken());\n\t\t\t\treturn CommentReply.valueOf(response.getItems(), CommentReply.class);\n\t\t\t}\n\t\t};\n\t}\n\n"
  },
  {
    "id": "apache_calcite-792-FirstSentence-0",
    "old_comment_raw": "Creates the default time format extraction function.",
    "new_comment_raw": "Creates the default time format extraction function.",
    "old_code_raw": "  public static TimeExtractionFunction createDefault() {\n    return new TimeExtractionFunction(ISO_TIME_FORMAT, null, \"UTC\", null);\n  }\n",
    "new_code_raw": "  public static TimeExtractionFunction createDefault(String timeZone) {\n    return new TimeExtractionFunction(ISO_TIME_FORMAT, null, timeZone, null);\n  }\n"
  },
  {
    "id": "apache_kylin-493-FirstSentence-0",
    "old_comment_raw": "Cancel/discard a job",
    "new_comment_raw": "Cancel/discard a job",
    "old_code_raw": "    public JobInstance cancel(@PathVariable String jobId) {\n\n        try {\n            final JobInstance jobInstance = jobService.getJobInstance(jobId);\n            return jobService.cancelJob(jobInstance);\n        } catch (Exception e) {\n            logger.error(e.getLocalizedMessage(), e);\n            throw new InternalErrorException(e);\n        }\n    }\n",
    "new_code_raw": "    public JobInstance cancel(@PathVariable String jobId) {\n\n        try {\n            final JobInstance jobInstance = jobService.getJobInstance(jobId);\n            jobService.cancelJob(jobInstance);\n            return jobService.getJobInstance(jobId);\n        } catch (Exception e) {\n            logger.error(e.getLocalizedMessage(), e);\n            throw new InternalErrorException(e);\n        }\n    }\n"
  },
  {
    "id": "debezium_debezium-943-FirstSentence-0",
    "old_comment_raw": "Converts the value (string representation) coming from wal2json plugin to a Java value based on the type of the column from the message.",
    "new_comment_raw": "Converts the value (string representation) coming from wal2json plugin to a Java value based on the type of the column from the message.",
    "old_code_raw": "    public Object getValue(String columnName, PostgresType type, String fullType, Value rawValue, final PgConnectionSupplier connection, boolean includeUnknownDatatypes) {\n        if (rawValue.isNull()) {\n            // nulls are null\n            return null;\n        }\n\n        if (type.isArrayType()) {\n            try {\n                final String dataString = rawValue.asString();\n                PgArray arrayData = new PgArray(connection.get(), type.getOid(), dataString);\n                Object deserializedArray = arrayData.getArray();\n                return Arrays.asList((Object[])deserializedArray);\n            }\n            catch (SQLException e) {\n                LOGGER.warn(\"Unexpected exception trying to process PgArray ({}) column '{}', {}\", fullType, columnName, e);\n            }\n            return null;\n        }\n\n        switch (type.getName()) {\n            // include all types from https://www.postgresql.org/docs/current/static/datatype.html#DATATYPE-TABLE\n            // plus aliases from the shorter names produced by older wal2json\n            case \"boolean\":\n            case \"bool\":\n                return rawValue.asBoolean();\n\n            case \"integer\":\n            case \"int\":\n            case \"int4\":\n            case \"smallint\":\n            case \"int2\":\n            case \"smallserial\":\n            case \"serial\":\n            case \"serial2\":\n            case \"serial4\":\n            case \"oid\":\n                return rawValue.asInteger();\n\n            case \"bigint\":\n            case \"bigserial\":\n            case \"int8\":\n                return rawValue.asLong();\n\n            case \"real\":\n            case \"float4\":\n                return rawValue.isNumber() ? rawValue.asFloat() : Float.valueOf(rawValue.asString());\n\n            case \"double precision\":\n            case \"float8\":\n                return rawValue.isNumber() ? rawValue.asDouble() : Double.valueOf(rawValue.asString());\n\n            case \"numeric\":\n            case \"decimal\":\n                if (rawValue.isInteger()) {\n                    return new SpecialValueDecimal(new BigDecimal(rawValue.asInteger()));\n                }\n                else if (rawValue.isLong()) {\n                    return new SpecialValueDecimal(new BigDecimal(rawValue.asLong()));\n                }\n                else if (rawValue.isBigInteger()) {\n                    return new SpecialValueDecimal(new BigDecimal(rawValue.asBigInteger()));\n                }\n                return SpecialValueDecimal.valueOf(rawValue.asString());\n\n            case \"character\":\n            case \"char\":\n            case \"character varying\":\n            case \"varchar\":\n            case \"bpchar\":\n            case \"text\":\n                return rawValue.asString();\n\n            case \"date\":\n                return DateTimeFormat.get().date(rawValue.asString());\n\n            case \"timestamp with time zone\":\n            case \"timestamptz\":\n                return DateTimeFormat.get().timestampWithTimeZone(rawValue.asString());\n\n            case \"timestamp\":\n            case \"timestamp without time zone\":\n                return DateTimeFormat.get().timestamp(rawValue.asString());\n\n            case \"time\":\n            case \"time without time zone\":\n                return DateTimeFormat.get().time(rawValue.asString());\n\n            case \"time with time zone\":\n            case \"timetz\":\n                return DateTimeFormat.get().timeWithTimeZone(rawValue.asString());\n\n            case \"bytea\":\n                return Strings.hexStringToByteArray(rawValue.asString());\n\n            // these are all PG-specific types and we use the JDBC representations\n            // note that, with the exception of point, no converters for these types are implemented yet,\n            // i.e. those values won't actually be propagated to the outbound message until that's the case\n            case \"box\":\n                try {\n                    return new PGbox(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"circle\":\n                try {\n                    return new PGcircle(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse circle {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"interval\":\n                try {\n                    return new PGInterval(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"line\":\n                try {\n                    return new PGline(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"lseg\":\n                try {\n                    return new PGlseg(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"money\":\n                try {\n                    return new PGmoney(rawValue.asString()).val;\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse money {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"path\":\n                try {\n                    return new PGpath(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"point\":\n                try {\n                    return new PGpoint(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"polygon\":\n                try {\n                    return new PGpolygon(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n\n            // PostGIS types are HexEWKB strings\n            // ValueConverter turns them into the correct types\n            case \"geometry\":\n            case \"geography\":\n                return rawValue.asString();\n\n            case \"bit\":\n            case \"bit varying\":\n            case \"varbit\":\n            case \"json\":\n            case \"jsonb\":\n            case \"xml\":\n            case \"uuid\":\n            case \"tstzrange\":\n                return rawValue.asString();\n            // catch-all for other known/builtin PG types\n            // TODO: improve with more specific/useful classes here?\n            case \"cidr\":\n            case \"inet\":\n            case \"macaddr\":\n            case \"macaddr8\":\n            case \"pg_lsn\":\n            case \"tsquery\":\n            case \"tsvector\":\n            case \"txid_snapshot\":\n            // catch-all for unknown (extension module/custom) types\n            default:\n                break;\n        }\n\n        if (includeUnknownDatatypes) {\n            // this includes things like PostGIS geometries or other custom types.\n            // leave up to the downstream message recipient to deal with.\n            LOGGER.debug(\"processing column '{}' with unknown data type '{}' as byte array\", columnName,\n                    fullType);\n            return rawValue.asString();\n        }\n        LOGGER.debug(\"Unknown column type {} for column {} \u00e2\u0080\u0093\u00c2\u00a0ignoring\", fullType, columnName);\n        return null;\n    }\n",
    "new_code_raw": "    public Object getValue(String columnName, PostgresType type, String fullType, Value rawValue, final PgConnectionSupplier connection, boolean includeUnknownDatatypes) {\n        if (rawValue.isNull()) {\n            // nulls are null\n            return null;\n        }\n\n        if (type.isArrayType()) {\n            try {\n                final String dataString = rawValue.asString();\n                PgArray arrayData = new PgArray(connection.get(), type.getOid(), dataString);\n                Object deserializedArray = arrayData.getArray();\n                return Arrays.asList((Object[])deserializedArray);\n            }\n            catch (SQLException e) {\n                LOGGER.warn(\"Unexpected exception trying to process PgArray ({}) column '{}', {}\", fullType, columnName, e);\n            }\n            return null;\n        }\n\n        switch (type.getName()) {\n            // include all types from https://www.postgresql.org/docs/current/static/datatype.html#DATATYPE-TABLE\n            // plus aliases from the shorter names produced by older wal2json\n            case \"boolean\":\n            case \"bool\":\n                return rawValue.asBoolean();\n\n            case \"integer\":\n            case \"int\":\n            case \"int4\":\n            case \"smallint\":\n            case \"int2\":\n            case \"smallserial\":\n            case \"serial\":\n            case \"serial2\":\n            case \"serial4\":\n            case \"oid\":\n                return rawValue.asInteger();\n\n            case \"bigint\":\n            case \"bigserial\":\n            case \"int8\":\n                return rawValue.asLong();\n\n            case \"real\":\n            case \"float4\":\n                return rawValue.isNumber() ? rawValue.asFloat() : Float.valueOf(rawValue.asString());\n\n            case \"double precision\":\n            case \"float8\":\n                return rawValue.isNumber() ? rawValue.asDouble() : Double.valueOf(rawValue.asString());\n\n            case \"numeric\":\n            case \"decimal\":\n                if (rawValue.isInteger()) {\n                    return new SpecialValueDecimal(new BigDecimal(rawValue.asInteger()));\n                }\n                else if (rawValue.isLong()) {\n                    return new SpecialValueDecimal(new BigDecimal(rawValue.asLong()));\n                }\n                else if (rawValue.isBigInteger()) {\n                    return new SpecialValueDecimal(new BigDecimal(rawValue.asBigInteger()));\n                }\n                return SpecialValueDecimal.valueOf(rawValue.asString());\n\n            case \"character\":\n            case \"char\":\n            case \"character varying\":\n            case \"varchar\":\n            case \"bpchar\":\n            case \"text\":\n                return rawValue.asString();\n\n            case \"date\":\n                return DateTimeFormat.get().date(rawValue.asString());\n\n            case \"timestamp with time zone\":\n            case \"timestamptz\":\n                return DateTimeFormat.get().timestampWithTimeZone(rawValue.asString());\n\n            case \"timestamp\":\n            case \"timestamp without time zone\":\n                final LocalDateTime serverLocal = Conversions.fromNanosToLocalDateTimeUTC(DateTimeFormat.get().timestamp(rawValue.asString()));\n                final Instant utc = serverLocal.atOffset(serverTimezone).toInstant();\n                return Conversions.toEpochNanos(utc);\n\n            case \"time\":\n            case \"time without time zone\":\n                return DateTimeFormat.get().time(rawValue.asString());\n\n            case \"time with time zone\":\n            case \"timetz\":\n                return DateTimeFormat.get().timeWithTimeZone(rawValue.asString());\n\n            case \"bytea\":\n                return Strings.hexStringToByteArray(rawValue.asString());\n\n            // these are all PG-specific types and we use the JDBC representations\n            // note that, with the exception of point, no converters for these types are implemented yet,\n            // i.e. those values won't actually be propagated to the outbound message until that's the case\n            case \"box\":\n                try {\n                    return new PGbox(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"circle\":\n                try {\n                    return new PGcircle(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse circle {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"interval\":\n                try {\n                    return new PGInterval(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"line\":\n                try {\n                    return new PGline(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"lseg\":\n                try {\n                    return new PGlseg(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"money\":\n                try {\n                    return new PGmoney(rawValue.asString()).val;\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse money {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"path\":\n                try {\n                    return new PGpath(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"point\":\n                try {\n                    return new PGpoint(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"polygon\":\n                try {\n                    return new PGpolygon(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n\n            // PostGIS types are HexEWKB strings\n            // ValueConverter turns them into the correct types\n            case \"geometry\":\n            case \"geography\":\n                return rawValue.asString();\n\n            case \"bit\":\n            case \"bit varying\":\n            case \"varbit\":\n            case \"json\":\n            case \"jsonb\":\n            case \"xml\":\n            case \"uuid\":\n            case \"tstzrange\":\n                return rawValue.asString();\n            // catch-all for other known/builtin PG types\n            // TODO: improve with more specific/useful classes here?\n            case \"cidr\":\n            case \"inet\":\n            case \"macaddr\":\n            case \"macaddr8\":\n            case \"pg_lsn\":\n            case \"tsquery\":\n            case \"tsvector\":\n            case \"txid_snapshot\":\n            // catch-all for unknown (extension module/custom) types\n            default:\n                break;\n        }\n\n        if (includeUnknownDatatypes) {\n            // this includes things like PostGIS geometries or other custom types.\n            // leave up to the downstream message recipient to deal with.\n            LOGGER.debug(\"processing column '{}' with unknown data type '{}' as byte array\", columnName,\n                    fullType);\n            return rawValue.asString();\n        }\n        LOGGER.debug(\"Unknown column type {} for column {} \u00e2\u0080\u0093\u00c2\u00a0ignoring\", fullType, columnName);\n        return null;\n    }\n"
  },
  {
    "id": "eclipse_eclipse.platform.team-56-Associations-FirstSentence",
    "old_comment_raw": "Gets the root.",
    "new_comment_raw": "Method getRoot.",
    "old_code_raw": "\tpublic IPath getRoot() {\n\t\treturn root;\n\t}\n",
    "new_code_raw": "\tpublic URL getRoot() {\n\t\treturn rootUrl;\n\t}\n\n"
  },
  {
    "id": "SeleniumHQ_selenium-761-FirstSentence-0",
    "old_comment_raw": "An expectation with the logical and condition of the given list of conditions.",
    "new_comment_raw": "An expectation with the logical and condition of the given list of conditions.",
    "old_code_raw": "  public static ExpectedCondition<Boolean> and(final ExpectedCondition<?>... conditions) {\n    return new ExpectedCondition<Boolean>() {\n      @Override\n      public Boolean apply(WebDriver driver) {\n        for (ExpectedCondition<?> condition : conditions) {\n          try {\n            Object result = condition.apply(driver);\n            if (result == null) {\n              return Boolean.FALSE;\n            } else if (result instanceof Boolean) {\n              if (!(Boolean) result) {\n                return Boolean.FALSE;\n              }\n            }\n          } catch (Exception e) {\n            return Boolean.FALSE;\n          }\n        }\n        return Boolean.TRUE;\n      }\n\n      @Override\n      public String toString() {\n        String message = \"all conditions to be valid: \";\n        for (ExpectedCondition<?> condition : conditions) {\n          message += condition.toString();\n        }\n        return message;\n      }\n    };\n  }\n",
    "new_code_raw": "  public static ExpectedCondition<Boolean> and(final ExpectedCondition<?>... conditions) {\n    return new ExpectedCondition<Boolean>() {\n      @Override\n      public Boolean apply(WebDriver driver) {\n        for (ExpectedCondition<?> condition : conditions) {\n          Object result = condition.apply(driver);\n\n          if (result instanceof Boolean) {\n            if (Boolean.FALSE.equals(result)) {\n              return false;\n            }\n          }\n\n          if (result == null) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      @Override\n      public String toString() {\n        StringBuilder message = new StringBuilder(\"all conditions to be valid: \");\n        Joiner.on(\" && \").appendTo(message, conditions);\n        return message.toString();\n      }\n    };\n  }\n"
  },
  {
    "id": "boundary_boundary-camel-components-0-Associations-FirstSentence",
    "old_comment_raw": "Parses the output of ping and populates a instance of  PingInfo",
    "new_comment_raw": "Parses the output of ping and populates a instance of  PingResult",
    "old_code_raw": "\tprotected PingInfo parse(int exitValue, List<String> outLines,List<String> errLines) {\n\t\tPingInfo info = new PingInfo();\n\t\tPattern roundTripTimePat = Pattern.compile(RTT_REG_EX);\n\t\tPattern transmitReceivePat = Pattern.compile(TRANSMITTED_RECEIVED_REG_EX);\n\t\tPattern noRouteToHostPat = Pattern.compile(NO_ROUTE_TO_HOST_REG_EX);\n\t\tPattern unknownHostPat = Pattern.compile(UNKNOWN_HOST_REG_EX);\n\n\t\tinfo.setHost(getHost());\n\n\t\t// Parse the output based on exit value of ping\n\t\tswitch (exitValue) {\n\n\t\t// Clean exit\n\t\tcase 0:\n\t\t\t// Extract the RTT times\n\t\t\tfor (String line : outLines) {\n\t\t\t\tMatcher matcher = roundTripTimePat.matcher(line);\n\t\t\t\tif (matcher.find()) {\n\t\t\t\t\tinfo.setRTTMin(Double.parseDouble(matcher.group(1)));\n\t\t\t\t\tinfo.setRTTAvg(Double.parseDouble(matcher.group(2)));\n\t\t\t\t\tinfo.setRTTMax(Double.parseDouble(matcher.group(3)));\n\t\t\t\t\tinfo.setRTTMDev(Double.parseDouble(matcher.group(4)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Extract the transmit and received counts\n\t\t\tfor (String line : outLines) {\n\t\t\t\tMatcher matcher = transmitReceivePat.matcher(line);\n\t\t\t\tif (matcher.find()) {\n\t\t\t\t\tinfo.setTransmitted(Integer.parseInt(matcher.group(1)));\n\t\t\t\t\tinfo.setReceived(Integer.parseInt(matcher.group(2)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// If no ICMP packages are returned then consider the test failed\n\t\t\tif (info.getReceived() == 0) {\n\t\t\t\tinfo.setStatus(ServiceStatus.FAIL);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinfo.setStatus(ServiceStatus.SUCCESS);\n\t\t\t}\n\t\t\tbreak;\n\t\t// Error case: 1) Unable to resolve host ; 2) Host unreachable\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 68:\n\t\t\tfor (String line : outLines) {\n\t\t\t\tMatcher matcher = transmitReceivePat.matcher(line);\n\t\t\t\tif (matcher.find()) {\n\t\t\t\t\tinfo.setTransmitted(Integer.parseInt(matcher.group(1)));\n\t\t\t\t\tinfo.setReceived(Integer.parseInt(matcher.group(2)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (String line: errLines) {\n\t\t\t\tMatcher matcher = unknownHostPat.matcher(line);\n\t\t\t\tif (matcher.find()) {\n\t\t\t\t\tinfo.setMessage(matcher.group(1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tinfo.setStatus(ServiceStatus.FAIL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert false: \"Unknown exit code\";\n\t\t}\n\n\t\treturn info;\n\t}\n",
    "new_code_raw": "\tprotected PingResult parse(int exitValue, List<String> outLines,List<String> errLines) {\n\t\tPingResult info = new PingResult();\n\t\tPattern roundTripTimePat = Pattern.compile(RTT_REG_EX);\n\t\tPattern transmitReceivePat = Pattern.compile(TRANSMITTED_RECEIVED_REG_EX);\n\t\tPattern noRouteToHostPat = Pattern.compile(NO_ROUTE_TO_HOST_REG_EX);\n\t\tPattern unknownHostPat = Pattern.compile(UNKNOWN_HOST_REG_EX);\n\n\t\tinfo.setHost(getHost());\n\n\t\t// Parse the output based on exit value of ping\n\t\tswitch (exitValue) {\n\n\t\t// Clean exit\n\t\tcase 0:\n\t\t\t// Extract the RTT times\n\t\t\tfor (String line : outLines) {\n\t\t\t\tMatcher matcher = roundTripTimePat.matcher(line);\n\t\t\t\tif (matcher.find()) {\n\t\t\t\t\tinfo.setRTTMin(Double.parseDouble(matcher.group(1)));\n\t\t\t\t\tinfo.setRTTAvg(Double.parseDouble(matcher.group(2)));\n\t\t\t\t\tinfo.setRTTMax(Double.parseDouble(matcher.group(3)));\n\t\t\t\t\tinfo.setRTTMDev(Double.parseDouble(matcher.group(4)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Extract the transmit and received counts\n\t\t\tfor (String line : outLines) {\n\t\t\t\tMatcher matcher = transmitReceivePat.matcher(line);\n\t\t\t\tif (matcher.find()) {\n\t\t\t\t\tinfo.setTransmitted(Integer.parseInt(matcher.group(1)));\n\t\t\t\t\tinfo.setReceived(Integer.parseInt(matcher.group(2)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// If no ICMP packages are returned then consider the test failed\n\t\t\tif (info.getReceived() == 0) {\n\t\t\t\tinfo.setStatus(ServiceStatus.FAIL);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinfo.setStatus(ServiceStatus.SUCCESS);\n\t\t\t}\n\t\t\tbreak;\n\t\t// Error case: 1) Unable to resolve host ; 2) Host unreachable\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 68:\n\t\t\tfor (String line : outLines) {\n\t\t\t\tMatcher matcher = transmitReceivePat.matcher(line);\n\t\t\t\tif (matcher.find()) {\n\t\t\t\t\tinfo.setTransmitted(Integer.parseInt(matcher.group(1)));\n\t\t\t\t\tinfo.setReceived(Integer.parseInt(matcher.group(2)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (String line: errLines) {\n\t\t\t\tMatcher matcher = unknownHostPat.matcher(line);\n\t\t\t\tif (matcher.find()) {\n\t\t\t\t\tinfo.setMessage(matcher.group(1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tinfo.setStatus(ServiceStatus.FAIL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert false: \"Unknown exit code\";\n\t\t}\n\n\t\treturn info;\n\t}\n\n"
  },
  {
    "id": "debezium_debezium-1035-FirstSentence-0",
    "old_comment_raw": "Converts a value object for an expected JDBC type of  Types#BIT of length 2+.",
    "new_comment_raw": "Converts a value object for an expected JDBC type of  Types#BIT of length 2+.",
    "old_code_raw": "    protected Object convertBits(Column column, Field fieldDefn, Object data, int numBytes) {\n        return convertValue(column, fieldDefn, data, false, (r) -> {\n            if (data instanceof Boolean) {\n                Boolean value = (Boolean) data;\n                r.deliver(new byte[] { value.booleanValue() ? (byte) 1 : (byte) 0 });\n            }\n            else if (data instanceof Short) {\n                Short value = (Short) data;\n                ByteBuffer buffer = ByteBuffer.allocate(Short.BYTES);\n                buffer.order(ByteOrder.LITTLE_ENDIAN);\n                buffer.putShort(value.shortValue());\n                r.deliver(buffer.array());\n            }\n            else if (data instanceof Integer) {\n                Integer value = (Integer) data;\n                ByteBuffer buffer = ByteBuffer.allocate(Integer.BYTES);\n                buffer.order(ByteOrder.LITTLE_ENDIAN);\n                buffer.putInt(value.intValue());\n                r.deliver(buffer.array());\n            }\n            else if (data instanceof Long) {\n                Long value = (Long) data;\n                ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);\n                buffer.order(ByteOrder.LITTLE_ENDIAN);\n                buffer.putLong(value.longValue());\n                r.deliver(buffer.array());\n            }\n            else if (data instanceof byte[]) {\n                byte[] bytes = (byte[]) data;\n                if (bytes.length == 1) {\n                    r.deliver(bytes);\n                }\n                if (byteOrderOfBitType() == ByteOrder.BIG_ENDIAN) {\n                    // Reverse it to little endian ...\n                    int i = 0;\n                    int j = bytes.length - 1;\n                    byte tmp;\n                    while (j > i) {\n                        tmp = bytes[j];\n                        bytes[j] = bytes[i];\n                        bytes[i] = tmp;\n                        ++i;\n                        --j;\n                    }\n                }\n                r.deliver(padLittleEndian(numBytes, bytes));\n            }\n            else if (data instanceof BitSet) {\n                byte[] bytes = ((BitSet) data).toByteArray();\n                r.deliver(padLittleEndian(numBytes, bytes));\n            }\n        });\n    }\n",
    "new_code_raw": "    protected Object convertBits(Column column, Field fieldDefn, Object data, int numBytes) {\n        return convertValue(column, fieldDefn, data, new byte[0], (r) -> {\n            if (data instanceof Boolean) {\n                Boolean value = (Boolean) data;\n                r.deliver(new byte[] { value.booleanValue() ? (byte) 1 : (byte) 0 });\n            }\n            else if (data instanceof Short) {\n                Short value = (Short) data;\n                ByteBuffer buffer = ByteBuffer.allocate(Short.BYTES);\n                buffer.order(ByteOrder.LITTLE_ENDIAN);\n                buffer.putShort(value.shortValue());\n                r.deliver(buffer.array());\n            }\n            else if (data instanceof Integer) {\n                Integer value = (Integer) data;\n                ByteBuffer buffer = ByteBuffer.allocate(Integer.BYTES);\n                buffer.order(ByteOrder.LITTLE_ENDIAN);\n                buffer.putInt(value.intValue());\n                r.deliver(buffer.array());\n            }\n            else if (data instanceof Long) {\n                Long value = (Long) data;\n                ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);\n                buffer.order(ByteOrder.LITTLE_ENDIAN);\n                buffer.putLong(value.longValue());\n                r.deliver(buffer.array());\n            }\n            else if (data instanceof byte[]) {\n                byte[] bytes = (byte[]) data;\n                if (bytes.length == 1) {\n                    r.deliver(bytes);\n                }\n                if (byteOrderOfBitType() == ByteOrder.BIG_ENDIAN) {\n                    // Reverse it to little endian ...\n                    int i = 0;\n                    int j = bytes.length - 1;\n                    byte tmp;\n                    while (j > i) {\n                        tmp = bytes[j];\n                        bytes[j] = bytes[i];\n                        bytes[i] = tmp;\n                        ++i;\n                        --j;\n                    }\n                }\n                r.deliver(padLittleEndian(numBytes, bytes));\n            }\n            else if (data instanceof BitSet) {\n                byte[] bytes = ((BitSet) data).toByteArray();\n                r.deliver(padLittleEndian(numBytes, bytes));\n            }\n        });\n    }\n"
  },
  {
    "id": "galderz_rhq-68-Associations-FirstSentence",
    "old_comment_raw": "Removes the package version from this channel, if it exists.",
    "new_comment_raw": "Removes the package version from this repo, if it exists.",
    "old_code_raw": "    public ChannelPackageVersion removePackageVersion(PackageVersion packageVersion) {\n        if ((this.channelPackageVersions == null) || (packageVersion == null)) {\n            return null;\n        }\n\n        ChannelPackageVersion doomed = null;\n\n        for (ChannelPackageVersion cpv : this.channelPackageVersions) {\n            if (packageVersion.equals(cpv.getChannelPackageVersionPK().getPackageVersion())) {\n                doomed = cpv;\n                break;\n            }\n        }\n\n        if (doomed != null) {\n            this.channelPackageVersions.remove(doomed);\n        }\n\n        return doomed;\n    }\n",
    "new_code_raw": "    public RepoPackageVersion removePackageVersion(PackageVersion packageVersion) {\n        if ((this.repoPackageVersions == null) || (packageVersion == null)) {\n            return null;\n        }\n\n        RepoPackageVersion doomed = null;\n\n        for (RepoPackageVersion cpv : this.repoPackageVersions) {\n            if (packageVersion.equals(cpv.getRepoPackageVersionPK().getPackageVersion())) {\n                doomed = cpv;\n                break;\n            }\n        }\n\n        if (doomed != null) {\n            this.repoPackageVersions.remove(doomed);\n        }\n\n        return doomed;\n    }\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-1754-FirstSentence-0",
    "old_comment_raw": "Resolve an AccessType from its external name.",
    "new_comment_raw": "Resolve an AccessType from its external name.",
    "old_code_raw": "\tpublic static AccessType fromExternalName(String externalName) {\n\t\tif ( externalName == null ) {\n\t\t\treturn null;\n\t\t}\n\t\tfor ( AccessType accessType : AccessType.values() ) {\n\t\t\tif ( accessType.getExternalName().equals( externalName ) ) {\n\t\t\t\treturn accessType;\n\t\t\t}\n\t\t}\n\t\tthrow new UnknownAccessTypeException( externalName );\n\t}\n",
    "new_code_raw": "\tpublic static AccessType fromExternalName(String externalName) {\n\t\tif ( externalName == null ) {\n\t\t\treturn null;\n\t\t}\n\t\tfor ( AccessType accessType : AccessType.values() ) {\n\t\t\tif ( accessType.getExternalName().equals( externalName ) ) {\n\t\t\t\treturn accessType;\n\t\t\t}\n\t\t}\n\t\t// Check to see if making upper-case matches an enum name.\n\t\ttry {\n\t\t\treturn AccessType.valueOf( externalName.toUpperCase( Locale.ROOT) );\n\t\t}\n\t\tcatch ( IllegalArgumentException e ) {\n\t\t\tthrow new UnknownAccessTypeException( externalName );\n\t\t}\n\t}\n"
  },
  {
    "id": "apache_calcite-914-FirstSentence-0",
    "old_comment_raw": "Looks at the usage of variables in first and second conjunction to decide if this kind of expression is currently supported for proving first => second.",
    "new_comment_raw": "Looks at the usage of variables in first and second conjunction to decide whether this kind of expression is currently supported for proving first implies second.",
    "old_code_raw": "  private boolean validate(RexNode first, RexNode second) {\n    if (first == null || second == null) {\n      return false;\n    }\n    if (!(first instanceof RexCall)\n        || !(second instanceof RexCall)) {\n      return false;\n    }\n    return true;\n  }\n",
    "new_code_raw": "  private boolean validate(RexNode first, RexNode second) {\n    return first instanceof RexCall && second instanceof RexCall;\n  }\n"
  },
  {
    "id": "docker_java_docker_java-48-FirstSentence-0",
    "old_comment_raw": "Parses a bind mount specification to a  Bind.",
    "new_comment_raw": "Parses a bind mount specification to a  Bind.",
    "old_code_raw": "\tpublic static Bind parse(String serialized) {\n\t\ttry {\n\t\t\tString[] parts = serialized.split(\":\");\n\t\t\tswitch (parts.length) {\n\t\t\tcase 2: {\n\t\t\t\treturn new Bind(parts[0], Volume.parse(parts[1]));\n\t\t\t}\n\t\t\tcase 3: {\n\t\t\t\tif (\"rw\".equals(parts[2].toLowerCase()))\n\t\t\t\t\treturn new Bind(parts[0], Volume.parse(parts[1]), false);\n\t\t\t\telse if (\"ro\".equals(parts[2].toLowerCase()))\n\t\t\t\t\treturn new Bind(parts[0], Volume.parse(parts[1]), true);\n\t\t\t\telse\n\t\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tthrow new IllegalArgumentException(\"Error parsing Bind '\" + serialized\n\t\t\t\t\t+ \"'\");\n\t\t}\n\t}\n",
    "new_code_raw": "\tpublic static Bind parse(String serialized) {\n\t\ttry {\n\t\t\tString[] parts = serialized.split(\":\");\n\t\t\tswitch (parts.length) {\n\t\t\tcase 2: {\n\t\t\t\treturn new Bind(parts[0], Volume.parse(parts[1]));\n\t\t\t}\n\t\t\tcase 3: {\n\t\t\t\tAccessMode accessMode = AccessMode.valueOf(parts[2].toLowerCase());\n\t\t\t\treturn new Bind(parts[0], Volume.parse(parts[1]), accessMode);\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tthrow new IllegalArgumentException(\"Error parsing Bind '\" + serialized\n\t\t\t\t\t+ \"'\");\n\t\t}\n\t}\n"
  },
  {
    "id": "eclipse_eclipse.platform.releng-12-Associations-FirstSentence",
    "old_comment_raw": "Return the ID of the last baseline build.",
    "new_comment_raw": "Return the ID of the last baseline build before the given date.",
    "old_code_raw": "public static String getLastBaselineBuild() {\n\tif (BUILDS == null) {\n\t\tqueryAllVariations(\"%\"); //$NON-NLS-1$\n\t}\n\treturn LAST_BASELINE_BUILD;\n}\n",
    "new_code_raw": "public static String getLastBaselineBuild(String date) {\n\tif (BUILDS == null) {\n\t\tqueryAllVariations(\"%\"); //$NON-NLS-1$\n\t}\n\tif (date == null) return LAST_BASELINE_BUILD;\n\tString lastBaselineBuild = null;\n\tfor (int i=0; i<BUILDS_LENGTH; i++) {\n\t\tString build = BUILDS[i];\n\t\tif (build.startsWith(AbstractResults.VERSION_REF)) {\n\t\t\tString buildDate = build.substring(build.indexOf('_')+1);\n\t\t\tif (buildDate.compareTo(date) < 0) {\n\t\t\t\tif (lastBaselineBuild == null || build.compareTo(lastBaselineBuild) > 0) {\n\t\t\t\t\tlastBaselineBuild = build;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn lastBaselineBuild;\n}\n\n"
  },
  {
    "id": "zaproxy_zaproxy-1939-FirstSentence-0",
    "old_comment_raw": "Parse this Http header using the String given.",
    "new_comment_raw": "Parse this Http header using the String given.",
    "old_code_raw": "    protected boolean parse(String data) throws Exception {\n\n        String \ttoken = null,\n\t\t\t\tname = null,\n\t\t\t\tvalue = null;\n        int pos = 0;\n        Pattern pattern = null;\n\n        if(data == null || data.equals(\"\")) {\n            return true;\n        }\n\n        if ((pos = data.indexOf(CRLF)) < 0) {\n        \tif ((pos = data.indexOf(LF)) < 0) {\n        \t\treturn false;\n        \t} else {\n        \t\tmLineDelimiter = LF;\n        \t\tpattern = patternLF;\n        \t}\n        } else {\n        \tmLineDelimiter = CRLF;\n        \tpattern = patternCRLF;\n        }\n        \n\t\tString[] split = pattern.split(data);\n\t\tmStartLine = split[0];\n\n\t\tStringBuffer sb = new StringBuffer(2048);\n\t\tfor (int i=1; i<split.length; i++)\n\t\t{\n\t\t\ttoken = split[i];\n\t\t\tif (token.equals(\"\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n            if((pos = token.indexOf(\":\")) < 0) {\n\t\t\t\tmMalformedHeader = true;\n                return false;\n            }\n            name  = token.substring(0, pos).trim();\n            value = token.substring(pos +1).trim();\n\n            if(name.equalsIgnoreCase(CONTENT_LENGTH)) {\n            \ttry {\n                \tmContentLength = Integer.parseInt(value);\n            \t} catch (NumberFormatException nfe){}\n            }\n\t\t\t\n            /*\n            if (name.equalsIgnoreCase(PROXY_CONNECTION)) {\n            \tsb.append(name + \": \" + _CLOSE + mLineDelimiter);\n            } else if (name.equalsIgnoreCase(CONNECTION)) {\n            \tsb.append(name + \": \" + _CLOSE + mLineDelimiter);\n            } else {\n            */\n\t\t\tsb.append(name + \": \" + value + mLineDelimiter);\n\t\t\t//}\n\t\t\t\n\t\t\taddInternalHeaderFields(name, value);\n\t\t}\n\n        mMsgHeader = sb.toString();\n\t\treturn true;\n\t}\n",
    "new_code_raw": "    protected boolean parse(String data) throws Exception {\n        if(data == null || data.isEmpty()) {\n            return true;\n        }\n\n        // ZAP: Replace all \"\\n\" with \"\\r\\n\" to parse correctly\n        String newData = data.replaceAll(\"(?<!\\r)\\n\", CRLF);\n        // ZAP: always use CRLF to comply with HTTP specification\n        // even if the data it's not directly used.\n        mLineDelimiter = CRLF;\n        \n\t\tString[] split = patternCRLF.split(newData);\n\t\tmStartLine = split[0];\n\t\t\n        String \ttoken = null,\n\t\t\t\tname = null,\n\t\t\t\tvalue = null;\n        int pos = 0;\n        \n        StringBuilder sb = new StringBuilder(2048);\n\t\tfor (int i=1; i<split.length; i++)\n\t\t{\n\t\t\ttoken = split[i];\n\t\t\tif (token.equals(\"\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n            if((pos = token.indexOf(\":\")) < 0) {\n\t\t\t\tmMalformedHeader = true;\n                return false;\n            }\n            name  = token.substring(0, pos).trim();\n            value = token.substring(pos +1).trim();\n\n            if(name.equalsIgnoreCase(CONTENT_LENGTH)) {\n            \ttry {\n                \tmContentLength = Integer.parseInt(value);\n            \t} catch (NumberFormatException nfe){}\n            }\n\t\t\t\n            /*\n            if (name.equalsIgnoreCase(PROXY_CONNECTION)) {\n            \tsb.append(name + \": \" + _CLOSE + mLineDelimiter);\n            } else if (name.equalsIgnoreCase(CONNECTION)) {\n            \tsb.append(name + \": \" + _CLOSE + mLineDelimiter);\n            } else {\n            */\n\t\t\tsb.append(name + \": \" + value + mLineDelimiter);\n\t\t\t//}\n\t\t\t\n\t\t\taddInternalHeaderFields(name, value);\n\t\t}\n\n        mMsgHeader = sb.toString();\n\t\treturn true;\n\t}\n"
  },
  {
    "id": "egonw_pathvisio-64-Associations-FirstSentence",
    "old_comment_raw": "Initiates an instance of  MainWindow that is monitored by Sleak.java, to monitor what handles (to OS device context) are in use.",
    "new_comment_raw": "Initiates an instance of  MainWindowBase that is monitored by Sleak.java, to monitor what handles (to OS device context) are in use.",
    "old_code_raw": "\tpublic MainWindow getSleakWindow() {\n\t\t//<DEBUG to find undisposed system resources>\n\t\tDeviceData data = new DeviceData();\n\t\tdata.tracking = true;\n\t\tDisplay display = new Display(data);\n\t\tSleak sleak = new Sleak();\n\t\tsleak.open();\n\t\t\n\t\tShell shell = new Shell(display);\n\t\twindow = new MainWindow(shell);\n\t\treturn window;\n\t\t//</DEBUG>\n\t}\n",
    "new_code_raw": "\tpublic MainWindowBase getSleakWindow() {\n\t\t//<DEBUG to find undisposed system resources>\n\t\tDeviceData data = new DeviceData();\n\t\tdata.tracking = true;\n\t\tDisplay display = new Display(data);\n\t\tSleak sleak = new Sleak();\n\t\tsleak.open();\n\t\t\n\t\tShell shell = new Shell(display);\n\t\twindow = new MainWindowBase(shell);\n\t\treturn window;\n\t\t//</DEBUG>\n\t}\n\n"
  },
  {
    "id": "JodaOrg_joda_time-944-FirstSentence-0",
    "old_comment_raw": "Subtracts two values throwing an exception if overflow occurs.",
    "new_comment_raw": "Subtracts two values throwing an exception if overflow occurs.",
    "old_code_raw": "    public static long safeSubtract(long val1, long val2) {\n        if (val2 == Long.MIN_VALUE) {\n            if (val1 <= 0L) {\n                return (val1 - val2);\n            }\n            throw new ArithmeticException(\"The calculation caused an overflow: \" + val1 +\" - \" + val2);\n        }\n        return safeAdd(val1, -val2);\n    }\n",
    "new_code_raw": "    public static long safeSubtract(long val1, long val2) {\n        long diff = val1 - val2;\n        // If there is a sign change, but the two values have different signs...\n        if ((val1 ^ diff) < 0 && (val1 ^ val2) < 0) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" - \" + val2);\n        }\n        return diff;\n    }\n"
  },
  {
    "id": "apache_lenya-417-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Get all Groups",
    "old_code_raw": "    final public Map getGroups() {\n        return groups;\n    }\n",
    "new_code_raw": "    final public Map getGroups() {\n        return this.groups;\n    }\n\n"
  },
  {
    "id": "debezium_debezium-1294-FirstSentence-0",
    "old_comment_raw": "Converts a value object for an expected JDBC type of  Types#BOOLEAN.",
    "new_comment_raw": "Converts a value object for an expected JDBC type of  Types#BOOLEAN.",
    "old_code_raw": "    protected Object convertBoolean(Column column, Field fieldDefn, Object data) {\n        if (data == null) return null;\n        if (data instanceof Boolean) return data;\n        if (data instanceof Short) return ((Short) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;\n        if (data instanceof Integer) return ((Integer) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;\n        if (data instanceof Long) return ((Long) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;\n        return handleUnknownData(column, fieldDefn, data);\n    }\n",
    "new_code_raw": "    protected Object convertBoolean(Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return false;\n        }\n        if (data instanceof Boolean) return data;\n        if (data instanceof Short) return ((Short) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;\n        if (data instanceof Integer) return ((Integer) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;\n        if (data instanceof Long) return ((Long) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;\n        return handleUnknownData(column, fieldDefn, data);\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-1115-FirstSentence-0",
    "old_comment_raw": "Compares this object with the specified object for equality based on start and end millis.",
    "new_comment_raw": "Compares this object with the specified object for equality based on start and end millis plus the chronology.",
    "old_code_raw": "    public boolean equals(Object readableInterval) {\n        if (this == readableInterval) {\n            return true;\n        }\n        if (readableInterval instanceof ReadableInterval == false) {\n            return false;\n        }\n        ReadableInterval other = (ReadableInterval) readableInterval;\n        return (getStartMillis() == other.getStartMillis() &&\n                getEndMillis() == other.getEndMillis());\n    }\n",
    "new_code_raw": "    public boolean equals(Object readableInterval) {\n        if (this == readableInterval) {\n            return true;\n        }\n        if (readableInterval instanceof ReadableInterval == false) {\n            return false;\n        }\n        ReadableInterval other = (ReadableInterval) readableInterval;\n        return (getStartMillis() == other.getStartMillis() &&\n                getEndMillis() == other.getEndMillis() &&\n                getChronology() == other.getChronology());\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-746-FirstSentence-0",
    "old_comment_raw": "Get the year of era field for this chronology.",
    "new_comment_raw": "Get the year of era field for this chronology.",
    "old_code_raw": "    public DateTimeField yearOfEra() {\n        return UnsupportedDateTimeField.getInstance(\"yearOfEra\", years());\n    }\n",
    "new_code_raw": "    public DateTimeField yearOfEra() {\n        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.yearOfEra(), years());\n    }\n"
  },
  {
    "id": "apache_portals-pluto-35-Associations-FirstSentence",
    "old_comment_raw": "Returns the stored portlet preferences array.",
    "new_comment_raw": "Returns the stored portlet preferences map.",
    "old_code_raw": "\tpublic InternalPortletPreference[] getStoredPreferences(\n\t\t\tPortletWindow portletWindow,\n\t\t\tPortletRequest request)\n\tthrows PortletContainerException {\n        String key = getFormattedKey(portletWindow, request);\n        InternalPortletPreference[] preferences = storage.get(key);\n        if (preferences == null) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"No portlet preferences found for: \" + key);\n            }\n            return new InternalPortletPreference[0];\n        } else {\n        \tif (LOG.isDebugEnabled()) {\n        \t\tLOG.debug(\"Got \" + preferences.length + \" stored preferences.\");\n        \t}\n        \treturn clonePreferences(preferences);\n        }\n    }\n",
    "new_code_raw": "\tpublic Map<String,InternalPortletPreference> getStoredPreferences(\n\t\t\tPortletWindow portletWindow,\n\t\t\tPortletRequest request)\n\tthrows PortletContainerException {\n        String key = getFormattedKey(portletWindow, request);\n        Map<String,InternalPortletPreference> preferences = storage.get(key);\n        if (preferences == null) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"No portlet preferences found for: \" + key);\n            }\n            return Collections.emptyMap();\n        } else {\n        \tif (LOG.isDebugEnabled()) {\n        \t\tLOG.debug(\"Got \" + preferences.size() + \" stored preferences.\");\n        \t}\n        \treturn clonePreferences(preferences);\n        }\n    }\n\n"
  },
  {
    "id": "SeleniumHQ_selenium-585-FirstSentence-0",
    "old_comment_raw": "Get the relative index of an element to its parent (starting from 0).",
    "new_comment_raw": "Get the relative index of an element to its parent (starting from 0).",
    "old_code_raw": "  public Number getElementIndex(String locator) {\n    WebElement element = elementFinder.findElement(driver, locator);\n    String script = \n      \"var _isCommentOrEmptyTextNode = function(node) {\\n\" + \n      \"    return node.nodeType == 8 || ((node.nodeType == 3) && !(/[^\\\\t\\\\n\\\\r ]/.test(node.data)));\\n\" + \n      \"}\\n\" +\n      \"    var element = arguments[0];\\n\" +\n      \"    var previousSibling;\\n\" + \n      \"    var index = 0;\\n\" + \n      \"    while ((previousSibling = element.previousSibling) != null) {\\n\" + \n      \"        if (!_isCommentOrEmptyTextNode(previousSibling)) {\\n\" + \n      \"            index++;\\n\" + \n      \"        }\\n\" + \n      \"        element = previousSibling;\\n\" + \n      \"    }\\n\" + \n      \"    return index;\";\n    return (Long) executeScript(script, element);\n  }\n",
    "new_code_raw": "  public Number getElementIndex(String locator) {\n    WebElement element = elementFinder.findElement(driver, locator);\n    String script = \n      \"var _isCommentOrEmptyTextNode = function(node) {\\n\" + \n      \"    return node.nodeType == 8 || ((node.nodeType == 3) && !(/[^\\\\t\\\\n\\\\r ]/.test(node.data)));\\n\" + \n      \"}\\n\" +\n      \"    var element = arguments[0];\\n\" +\n      \"    var previousSibling;\\n\" + \n      \"    var index = 0;\\n\" + \n      \"    while ((previousSibling = element.previousSibling) != null) {\\n\" + \n      \"        if (!_isCommentOrEmptyTextNode(previousSibling)) {\\n\" + \n      \"            index++;\\n\" + \n      \"        }\\n\" + \n      \"        element = previousSibling;\\n\" + \n      \"    }\\n\" + \n      \"    return index;\";\n    return (Long) javascriptLibrary.executeScript(driver, script, element);\n  }\n"
  },
  {
    "id": "apache_ant-ivy-48-Associations-FirstSentence",
    "old_comment_raw": "Returns the common base directory between a current base directory and a given file.",
    "new_comment_raw": "Returns the common base directory between the passed file1 and file2.",
    "old_code_raw": "    File getBaseDir(File base, File file) {\n        if (base == null) {\n            return file.getParentFile().getAbsoluteFile();\n        } else {\n            Iterator bases = getParents(base).iterator();\n            Iterator fileParents = getParents(file.getAbsoluteFile()).iterator();\n            File result = null;\n            while (bases.hasNext() && fileParents.hasNext()) {\n                File next = (File) bases.next();\n                if (next.equals(fileParents.next())) {\n                    result = next;\n                } else {\n                    break;\n                }\n            }\n            return result;\n        }\n    }\n",
    "new_code_raw": "    File getBaseDir(final File file1, final File file2) {\n        if (file1 == null || file2 == null) {\n            return null;\n        }\n        final Iterator file1Parents = getParents(file1).iterator();\n        final Iterator file2Parents = getParents(file2.getAbsoluteFile()).iterator();\n        File result = null;\n        while (file1Parents.hasNext() && file2Parents.hasNext()) {\n            File next = (File) file1Parents.next();\n            if (next.equals(file2Parents.next())) {\n                result = next;\n            } else {\n                break;\n            }\n        }\n        return result;\n    }\n\n"
  },
  {
    "id": "apache_drill-1129-FirstSentence-0",
    "old_comment_raw": "expands the selection's folders if metadata cache is found for the selection root.",
    "new_comment_raw": "expands the selection's folders if metadata cache is found for the selection root.",
    "old_code_raw": "  private FileSelection expandIfNecessary(FileSelection selection) throws IOException {\n    if (selection.isExpandedFully()) {\n      return selection;\n    }\n\n    // use the cacheFileRoot if provided (e.g after partition pruning)\n    Path metaFilePath = new Path(cacheFileRoot != null ? cacheFileRoot : selectionRoot, Metadata.METADATA_FILENAME);\n    if (!fs.exists(metaFilePath)) { // no metadata cache\n      return selection;\n    }\n\n    FileSelection expandedSelection = initFromMetadataCache(selection, metaFilePath);\n    return expandedSelection;\n  }\n",
    "new_code_raw": "  private FileSelection expandIfNecessary(FileSelection selection) throws IOException {\n    if (selection.isExpandedFully()) {\n      return selection;\n    }\n\n    // use the cacheFileRoot if provided (e.g after partition pruning)\n    Path metaFilePath = new Path(cacheFileRoot != null ? cacheFileRoot : selectionRoot, Metadata.METADATA_FILENAME);\n    if (!fs.exists(metaFilePath)) { // no metadata cache\n      if (selection.isExpandedPartial()) {\n        logger.error(\"'{}' metadata file does not exist, but metadata directories cache file is present\", metaFilePath);\n        metaContext.setMetadataCacheCorrupted(true);\n      }\n\n      return selection;\n    }\n\n    return expandSelectionFromMetadataCache(selection, metaFilePath);\n  }\n"
  },
  {
    "id": "debezium_debezium-1302-FirstSentence-0",
    "old_comment_raw": "Determine if the supplied value is one of the predefined options.",
    "new_comment_raw": "Determine if the supplied value is one of the predefined options.",
    "old_code_raw": "        public static EventProcessingFailureHandlingMode parse(String value) {\n            if (value == null) {\n                return null;\n            }\n\n            value = value.trim();\n\n            for (EventProcessingFailureHandlingMode option : EventProcessingFailureHandlingMode.values()) {\n                if (option.getValue().equalsIgnoreCase(value)) {\n                    return option;\n                }\n            }\n\n            return null;\n        }\n",
    "new_code_raw": "        public static GtidNewChannelPosition parse(String value, String defaultValue) {\n            GtidNewChannelPosition mode = parse(value);\n            if (mode == null && defaultValue != null) {\n                mode = parse(defaultValue);\n            }\n            return mode;\n        }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-1972-FirstSentence-0",
    "old_comment_raw": "Transforms t if it contains a coordination in a flat structure (CCtransform) and transforms UCP (UCPtransform).",
    "new_comment_raw": "Transforms t if it contains a coordination in a flat structure (CCtransform) and transforms UCP (UCPtransform).",
    "old_code_raw": "  public Tree transformTree(Tree t) {\n    if (VERBOSE) {\n      System.err.println(\"Input to CoordinationTransformer: \" + t);\n    }\n    Tree tx = tn.transformTree(t);\n    if (VERBOSE) {\n      System.err.println(\"After DependencyTreeTransformer:  \" + tx);\n    }\n    if (tx == null) {\n      return tx;\n    }\n    Tree tt = UCPtransform(tx);\n    if (VERBOSE) {\n      System.err.println(\"After UCPTransformer:             \" + tt);\n    }\n    Tree ttt = CCtransform(tt);\n    if (VERBOSE) {\n      System.err.println(\"After CCTransformer:              \" + ttt);\n    }\n    Tree tttt = qp.transformTree(ttt);\n    if (VERBOSE) {\n      System.err.println(\"After QPTreeTransformer:          \" + tttt);\n    }\n    Tree flatSQ = SQflatten(tttt);\n    if (VERBOSE) {\n      System.err.println(\"After SQ flattening:              \" + flatSQ);\n    }\n    Tree fixedDates = dates.transformTree(flatSQ);\n    if (VERBOSE) {\n      System.err.println(\"After DateTreeTransformer:        \" + fixedDates);\n    }\n    Tree ret = removeXOverX(fixedDates);\n    if (VERBOSE) {\n      System.err.println(\"After removeXoverX:               \" + ret);\n    }\n    return ret;\n  }\n",
    "new_code_raw": "  public Tree transformTree(Tree t) {\n    if (VERBOSE) {\n      System.err.println(\"Input to CoordinationTransformer: \" + t);\n    }\n    Tree tx = tn.transformTree(t);\n    if (VERBOSE) {\n      System.err.println(\"After DependencyTreeTransformer:  \" + tx);\n    }\n    if (tx == null) {\n      return tx;\n    }\n    Tree tt = UCPtransform(tx);\n    if (VERBOSE) {\n      System.err.println(\"After UCPTransformer:             \" + tt);\n    }\n    Tree ttt = CCtransform(tt);\n    if (VERBOSE) {\n      System.err.println(\"After CCTransformer:              \" + ttt);\n    }\n    Tree tttt = qp.transformTree(ttt);\n    if (VERBOSE) {\n      System.err.println(\"After QPTreeTransformer:          \" + tttt);\n    }\n    Tree flatSQ = SQflatten(tttt);\n    if (VERBOSE) {\n      System.err.println(\"After SQ flattening:              \" + flatSQ);\n    }\n    Tree fixedDates = dates.transformTree(flatSQ);\n    if (VERBOSE) {\n      System.err.println(\"After DateTreeTransformer:        \" + fixedDates);\n    }\n    Tree removedXX = removeXOverX(fixedDates);\n    if (VERBOSE) {\n      System.err.println(\"After removeXoverX:               \" + removedXX);\n    }\n    Tree conjp = combineConjp(removedXX);\n    if (VERBOSE) {\n      System.err.println(\"After combineConjp:               \" + conjp);\n    }\n    return conjp;\n  }\n"
  },
  {
    "id": "fossasia_phimpme_android-4-FirstSentence-0",
    "old_comment_raw": "This function check if the selected account is already existed.",
    "new_comment_raw": "This function check if the selected account is already existed.",
    "old_code_raw": "    public static boolean checkAlreadyExist(AccountDatabase.AccountName s) {\n        Realm realm = Realm.getDefaultInstance();\n        // Query in the realm database\n        RealmQuery<AccountDatabase> query = realm.where(AccountDatabase.class);\n\n        // Checking if string equals to is exist or not\n        query.equalTo(\"name\", s.toString());\n        RealmResults<AccountDatabase> result1 = query.findAll();\n\n        // Here checking if count of that values is greater than zero\n        return (result1.size() > 0) ? true : false;\n    }\n",
    "new_code_raw": "    public static boolean checkAlreadyExist(AccountDatabase.AccountName s) {\n        Realm realm = Realm.getDefaultInstance();\n        // Query in the realm database\n        RealmQuery<AccountDatabase> query = realm.where(AccountDatabase.class);\n\n        // Checking if string equals to is exist or not\n        query.equalTo(\"name\", s.toString());\n        RealmResults<AccountDatabase> result1 = query.findAll();\n\n        // Here checking if count of that values is greater than zero\n        return (result1.size() > 0);\n    }\n"
  },
  {
    "id": "nelsonsilva_vaadin-160-Associations-FirstSentence",
    "old_comment_raw": "Gets the 'bottom' CSS-attributes value in specified units.",
    "new_comment_raw": "Gets the 'bottom' attributes value using current units.",
    "old_code_raw": "        public float getBottomValue() {\n            return bottomValue == null ? 0 : bottomValue.floatValue();\n        }\n",
    "new_code_raw": "        public Float getBottomValue() {\n            return bottomValue;\n        }\n\n"
  },
  {
    "id": "graphql_java_graphql_java-337-FirstSentence-0",
    "old_comment_raw": "Same effect as the argument(GraphQLArgument).",
    "new_comment_raw": "Same effect as the argument(GraphQLArgument).",
    "old_code_raw": "        public Builder argument(GraphQLArgument.Builder builder) {\n            this.arguments.add(builder.build());\n            return this;\n        }\n",
    "new_code_raw": "        public Builder argument(GraphQLArgument.Builder builder) {\n            return argument(builder.build());\n        }\n"
  },
  {
    "id": "apache_lenya-398-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Get a list of all a href=",
    "old_code_raw": "    public ArrayList getAllAHRefs() {\n        return a_href_all;\n    }\n",
    "new_code_raw": "    public ArrayList getAllAHRefs() {\n        return this.a_href_all;\n    }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-859-FirstSentence-0",
    "old_comment_raw": "Instructs the printer to emit a numeric hourOfDay field.",
    "new_comment_raw": "Instructs the printer to emit a numeric hourOfDay field.",
    "old_code_raw": "    public DateTimeFormatterBuilder appendHourOfDay(final int minDigits) {\n        return appendDecimal(iChronoUTC.hourOfDay(), minDigits, 2);\n    }\n",
    "new_code_raw": "    public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n    }\n"
  },
  {
    "id": "apache_qpid-jms-16-Associations-FirstSentence",
    "old_comment_raw": "Add bean properties to a URI",
    "new_comment_raw": "Enumerate the properties of the target object and add them as additional entries to the query string of the given string URI.",
    "old_code_raw": "    public static String addPropertiesToURIFromBean(String uri, Object bean) throws Exception {\n        Map<String, String> props = PropertyUtil.getProperties(bean);\n        return PropertyUtil.addPropertiesToURI(uri, props);\n    }\n",
    "new_code_raw": "    public static String addPropertiesToURIFromBean(String uri, Object bean) throws Exception {\n        Map<String, String> properties = PropertyUtil.getProperties(bean);\n        return PropertyUtil.addPropertiesToURI(uri, properties);\n    }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-444-FirstSentence-0",
    "old_comment_raw": "Get the human-readable, text value of this field from the milliseconds.",
    "new_comment_raw": "Get the human-readable, text value of this field from the milliseconds.",
    "old_code_raw": "    public String getAsText(long instant, Locale locale) {\n        return Integer.toString(get(instant));\n    }\n",
    "new_code_raw": "    public String getAsText(long instant, Locale locale) {\n        return getAsText(get(instant));\n    }\n"
  },
  {
    "id": "biddyweb_android-rcs-ims-stack-148-Associations-FirstSentence",
    "old_comment_raw": "Build sdp proposal for removeVideo",
    "new_comment_raw": "Build SDP proposal to remove video stream from the session",
    "old_code_raw": "\tprivate String buildRemoveVideoSdpProposal() {\n\t\tif (logger.isActivated()) {\n\t\t\tlogger.info(\"buildRemoveVideoSdpProposal()\");\n\t\t}\n\n\t\t// Build SDP part\n\t\tString sdp = \"\";\n\t\tString ntpTime = SipUtils.constructNTPtime(System.currentTimeMillis());\n\t\tString ipAddress = getDialogPath().getSipStack().getLocalIpAddress();\n\n\t\t\n\t\ttry {\n\t\t\tlogger.warn(\"Build audio sdp\");\n\t\t\tgetAudioPlayer().getLocalRtpPort();\t\t\t\n\t\t\tString audioSdp = AudioSdpBuilder.buildSdp(getAudioPlayer().getSupportedAudioCodecs(), getAudioPlayer().getLocalRtpPort());\n\t\t\t\n\t\t\tsdp = \"v=0\" + SipUtils.CRLF + \"o=- \" + ntpTime + \" \" + ntpTime\n\t\t\t\t\t+ \" \" + SdpUtils.formatAddressType(ipAddress)\n\t\t\t\t\t+ SipUtils.CRLF + \"s=-\" + SipUtils.CRLF + \"c=\"\n\t\t\t\t\t+ SdpUtils.formatAddressType(ipAddress) + SipUtils.CRLF\n\t\t\t\t\t+ \"t=0 0\" + SipUtils.CRLF + audioSdp + \"a=sendrcv\"\n\t\t\t\t\t+ SipUtils.CRLF;\n\t\t} catch (RemoteException e) {\n\t\t\tif (logger.isActivated()) {\n\t\t\t\tlogger.error(\"Remove Video has failed\", e);\n\t\t\t}\n\n\t\t\t// Unexpected error\n\t\t\thandleError(new IPCallError(IPCallError.UNEXPECTED_EXCEPTION,\n\t\t\t\t\te.getMessage()));\n\t\t}\n\t\treturn sdp;\n\t}\n",
    "new_code_raw": "\tprivate String buildRemoveVideoSdpProposal() {\n\t\tif (logger.isActivated()) {\n\t\t\tlogger.debug(\"Build SDP proposal to remove video stream from the session\");\n\t\t}\n\n\t\ttry {\n\t\t\t// Build SDP part\n\t\t\tString ntpTime = SipUtils.constructNTPtime(System.currentTimeMillis());\n\t\t\tString ipAddress = getDialogPath().getSipStack().getLocalIpAddress();\n\n\t\t\tgetAudioPlayer().getLocalRtpPort();\t\t\t\n\t\t\tString audioSdp = AudioSdpBuilder.buildSdpOffer(getAudioPlayer().getSupportedAudioCodecs(), getAudioPlayer().getLocalRtpPort());\n\t\t\t\n\t\t\treturn \"v=0\" + SipUtils.CRLF +\n\t\t\t\t\t\"o=- \" + ntpTime + \" \" + ntpTime + \" \" + SdpUtils.formatAddressType(ipAddress) + SipUtils.CRLF +\n\t\t\t\t\t\"s=-\" + SipUtils.CRLF +\n\t\t\t\t\t\"c=\" + SdpUtils.formatAddressType(ipAddress) + SipUtils.CRLF +\n\t\t\t\t\t\"t=0 0\" + SipUtils.CRLF + audioSdp +\n\t\t\t\t\t\"a=sendrcv\"\t+ SipUtils.CRLF;\n\t\t} catch (RemoteException e) {\n\t\t\tif (logger.isActivated()) {\n\t\t\t\tlogger.error(\"Remove video has failed\", e);\n\t\t\t}\n\n\t\t\t// Unexpected error\n\t\t\thandleError(new IPCallError(IPCallError.UNEXPECTED_EXCEPTION, e.getMessage()));\n\t\t\treturn null;\n\t\t}\n\t}\n\n"
  },
  {
    "id": "jhipster_jhipster_sample_app-40-FirstSentence-0",
    "old_comment_raw": "POST /account/reset_password/finish : Finish to reset the password of the user",
    "new_comment_raw": "POST /account/reset_password/finish : Finish to reset the password of the user",
    "old_code_raw": "    public ResponseEntity<String> finishPasswordReset(@RequestBody KeyAndPasswordVM keyAndPassword) {\n        if (!checkPasswordLength(keyAndPassword.getNewPassword())) {\n            return new ResponseEntity<>(\"Incorrect password\", HttpStatus.BAD_REQUEST);\n        }\n        return userService.completePasswordReset(keyAndPassword.getNewPassword(), keyAndPassword.getKey())\n              .map(user -> new ResponseEntity<String>(HttpStatus.OK))\n              .orElse(new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR));\n    }\n",
    "new_code_raw": "    public ResponseEntity<String> finishPasswordReset(@RequestBody KeyAndPasswordVM keyAndPassword) {\n        if (!checkPasswordLength(keyAndPassword.getNewPassword())) {\n            return new ResponseEntity<>(CHECK_ERROR_MESSAGE, HttpStatus.BAD_REQUEST);\n        }\n        return userService.completePasswordReset(keyAndPassword.getNewPassword(), keyAndPassword.getKey())\n              .map(user -> new ResponseEntity<String>(HttpStatus.OK))\n              .orElse(new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR));\n    }\n"
  },
  {
    "id": "apache_calcite-avatica-18-Associations-FirstSentence",
    "old_comment_raw": "Collects the types of the bound operands into an array.",
    "new_comment_raw": "Collects the types of the bound operands into a list.",
    "old_code_raw": "    public RelDataType [] collectOperandTypes()\n    {\n        RelDataType [] ret = new RelDataType[getOperandCount()];\n        for (int i = 0; i < ret.length; i++) {\n            ret[i] = getOperandType(i);\n        }\n        return ret;\n    }\n",
    "new_code_raw": "    public List<RelDataType> collectOperandTypes()\n    {\n        return new AbstractList<RelDataType>() {\n            public RelDataType get(int index) {\n                return getOperandType(index);\n            }\n            public int size() {\n                return getOperandCount();\n            }\n        };\n    }\n\n"
  },
  {
    "id": "apache_avro-13-FirstSentence-0",
    "old_comment_raw": "Returns the non-terminal that is the start symbol for grammar of the given schema sc.",
    "new_comment_raw": "Returns the non-terminal that is the start symbol for grammar of the given schema sc.",
    "old_code_raw": "  public Symbol generate(Schema sc, Map<LitS, Symbol> seen) {\n    switch (sc.getType()) {\n    case NULL:\n    case BOOLEAN:\n    case INT:\n    case LONG:\n    case FLOAT:\n    case DOUBLE:\n    case STRING:\n    case BYTES:\n    case FIXED:\n    case UNION:\n      return super.generate(sc, seen);\n    case ENUM:\n      return Symbol.seq(new Symbol.EnumLabelsAction(sc.getEnumSymbols()),\n          Symbol.ENUM);\n    case ARRAY:\n      return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END,\n              Symbol.ITEM_END, generate(sc.getElementType(), seen)),\n          Symbol.ARRAY_START);\n    case MAP:\n      return Symbol.seq(Symbol.repeat(Symbol.MAP_END,\n              Symbol.ITEM_END, generate(sc.getValueType(), seen),\n              Symbol.MAP_KEY_MARKER, Symbol.STRING),\n          Symbol.MAP_START);\n    case RECORD: {\n      LitS wsc = new LitS(sc);\n      Symbol rresult = seen.get(wsc);\n      if (rresult == null) {\n        Symbol[] production = new Symbol[sc.getFields().size() * 3 + 2];\n        rresult = Symbol.seq(production);\n        seen.put(wsc, rresult);\n\n        int i = production.length;\n        int n = 0;\n        production[--i] = Symbol.RECORD_START;\n        for (Field f : sc.getFields()) {\n          production[--i] = new Symbol.FieldAdjustAction(n, f.name());\n          production[--i] = generate(f.schema(), seen);\n          production[--i] = Symbol.FIELD_END;\n          n++;\n        }\n        production[--i] = Symbol.RECORD_END;\n      }\n      return rresult;\n    }\n    default:\n      throw new RuntimeException(\"Unexpected schema type\");\n    }\n  }\n",
    "new_code_raw": "  public Symbol generate(Schema sc, Map<LitS, Symbol> seen) {\n    switch (sc.getType()) {\n    case NULL:\n    case BOOLEAN:\n    case INT:\n    case LONG:\n    case FLOAT:\n    case DOUBLE:\n    case STRING:\n    case BYTES:\n    case FIXED:\n    case UNION:\n      return super.generate(sc, seen);\n    case ENUM:\n      return Symbol.seq(Symbol.enumLabelsAction(sc.getEnumSymbols()),\n          Symbol.ENUM);\n    case ARRAY:\n      return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END,\n              Symbol.ITEM_END, generate(sc.getElementType(), seen)),\n          Symbol.ARRAY_START);\n    case MAP:\n      return Symbol.seq(Symbol.repeat(Symbol.MAP_END,\n              Symbol.ITEM_END, generate(sc.getValueType(), seen),\n              Symbol.MAP_KEY_MARKER, Symbol.STRING),\n          Symbol.MAP_START);\n    case RECORD: {\n      LitS wsc = new LitS(sc);\n      Symbol rresult = seen.get(wsc);\n      if (rresult == null) {\n        Symbol[] production = new Symbol[sc.getFields().size() * 3 + 2];\n        rresult = Symbol.seq(production);\n        seen.put(wsc, rresult);\n\n        int i = production.length;\n        int n = 0;\n        production[--i] = Symbol.RECORD_START;\n        for (Field f : sc.getFields()) {\n          production[--i] = Symbol.fieldAdjustAction(n, f.name());\n          production[--i] = generate(f.schema(), seen);\n          production[--i] = Symbol.FIELD_END;\n          n++;\n        }\n        production[--i] = Symbol.RECORD_END;\n      }\n      return rresult;\n    }\n    default:\n      throw new RuntimeException(\"Unexpected schema type\");\n    }\n  }\n"
  },
  {
    "id": "processing_processing-1219-FirstSentence-0",
    "old_comment_raw": "Returns the name of the element.",
    "new_comment_raw": "Returns the full name (i.e.",
    "old_code_raw": "    public String getName() {\n        return this.name;\n    }\n",
    "new_code_raw": "    public String getName() {\n        return this.fullName;\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1919-FirstSentence-0",
    "old_comment_raw": "uploads an image",
    "new_comment_raw": "uploads an image",
    "old_code_raw": "  public ModelApiResponse uploadFile(Long petId, String additionalMetadata, File file) throws ApiException {\n    Object localVarPostBody = null;\n    \n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFile\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/pet/{petId}/uploadImage\"\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString()));\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    if (additionalMetadata != null)\n      localVarFormParams.put(\"additionalMetadata\", additionalMetadata);\nif (file != null)\n      localVarFormParams.put(\"file\", file);\n\n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"multipart/form-data\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"petstore_auth\" };\n\n    GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public ModelApiResponse uploadFile(Long petId, String additionalMetadata, File file) throws ApiException {\n    return uploadFileWithHttpInfo(petId, additionalMetadata, file).getData();\n      }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2559-FirstSentence-0",
    "old_comment_raw": "Remove characters not suitable for variable or method name from the input and camelize it",
    "new_comment_raw": "Remove characters that is not good to be included in method name from the input and camelize it",
    "old_code_raw": "    public String removeNonNameElementToCamelCase(String name) {\n        String nonNameElementPattern = \"[-_:;#]\";\n        name = StringUtils.join(Lists.transform(Lists.newArrayList(name.split(nonNameElementPattern)), new Function<String, String>() { // FIXME: a parameter should not be assigned. Also declare the methods parameters as 'final'.\n            @Nullable\n            @Override\n            public String apply(String input) {\n                return StringUtils.capitalize(input);\n            }\n        }), \"\");\n        if (name.length() > 0) {\n            name = name.substring(0, 1).toLowerCase() + name.substring(1);\n        }\n        return name;\n    }\n",
    "new_code_raw": "    protected String removeNonNameElementToCamelCase(final String name, final String nonNameElementPattern) {\n        String result = StringUtils.join(Lists.transform(Lists.newArrayList(name.split(nonNameElementPattern)), new Function<String, String>() {\n            @Nullable\n            @Override\n            public String apply(String input) {\n                return StringUtils.capitalize(input);\n            }\n        }), \"\");\n        if (result.length() > 0) {\n            result = result.substring(0, 1).toLowerCase() + result.substring(1);\n        }\n        return result;\n    }\n"
  },
  {
    "id": "apache_calcite-716-FirstSentence-0",
    "old_comment_raw": "Creates a project with a dummy column, to protect the parts of the system that cannot handle a relational expression with no columns.",
    "new_comment_raw": "Creates a project with a dummy column, to protect the parts of the system that cannot handle a relational expression with no columns.",
    "old_code_raw": "  private TrimResult dummyProject(int fieldCount, RelNode input) {\n    final RelOptCluster cluster = input.getCluster();\n    final Mapping mapping =\n        Mappings.create(MappingType.INVERSE_SURJECTION, fieldCount, 1);\n    if (input.getRowType().getFieldCount() == 1) {\n      // Input already has one field (and may in fact be a dummy project we\n      // created for the child). We can't do better.\n      return new TrimResult(input, mapping);\n    }\n    final RexLiteral expr =\n        cluster.getRexBuilder().makeExactLiteral(BigDecimal.ZERO);\n    relBuilder.push(input);\n    relBuilder.project(ImmutableList.<RexNode>of(expr), ImmutableList.of(\"DUMMY\"));\n    return new TrimResult(relBuilder.build(), mapping);\n  }\n",
    "new_code_raw": "  private TrimResult dummyProject(int fieldCount, RelNode input) {\n    final RelOptCluster cluster = input.getCluster();\n    final Mapping mapping =\n        Mappings.create(MappingType.INVERSE_SURJECTION, fieldCount, 1);\n    if (input.getRowType().getFieldCount() == 1) {\n      // Input already has one field (and may in fact be a dummy project we\n      // created for the child). We can't do better.\n      return result(input, mapping);\n    }\n    final RexLiteral expr =\n        cluster.getRexBuilder().makeExactLiteral(BigDecimal.ZERO);\n    relBuilder.push(input);\n    relBuilder.project(ImmutableList.<RexNode>of(expr), ImmutableList.of(\"DUMMY\"));\n    return result(relBuilder.build(), mapping);\n  }\n"
  },
  {
    "id": "hazelcast_hazelcast-550-Associations-FirstSentence",
    "old_comment_raw": "Gets the merge policy.",
    "new_comment_raw": "Gets the map merge policy  com.hazelcast.map.merge.MapMergePolicy",
    "old_code_raw": "    public String getMergePolicy() {\n        return mergePolicyConfig.getPolicy();\n    }\n",
    "new_code_raw": "    public String getMergePolicy() {\n        return mergePolicy;\n    }\n\n"
  },
  {
    "id": "apache_avro-15-FirstSentence-0",
    "old_comment_raw": "Gets the configured compression codec from the task context.",
    "new_comment_raw": "Gets the configured compression codec from the task context.",
    "old_code_raw": "  protected static CodecFactory getCompressionCodec(TaskAttemptContext context) {\n    if (FileOutputFormat.getCompressOutput(context)) {\n      // Default to deflate compression.\n      String outputCodec = context.getConfiguration()\n        .get(AvroJob.CONF_OUTPUT_CODEC, DataFileConstants.DEFLATE_CODEC);\n      if (DataFileConstants.DEFLATE_CODEC.equals(outputCodec)) {\n        int compressionLevel = context.getConfiguration().getInt(\n            org.apache.avro.mapred.AvroOutputFormat.DEFLATE_LEVEL_KEY,\n            org.apache.avro.mapred.AvroOutputFormat.DEFAULT_DEFLATE_LEVEL);\n        return CodecFactory.deflateCodec(compressionLevel);\n      } else {\n        return CodecFactory.fromString(outputCodec);\n      }\n    }\n\n    // No compression.\n    return CodecFactory.nullCodec();\n  }\n",
    "new_code_raw": "  protected static CodecFactory getCompressionCodec(TaskAttemptContext context) {\n    if (FileOutputFormat.getCompressOutput(context)) {\n      // Default to deflate compression.\n      int compressionLevel = context.getConfiguration().getInt(\n          org.apache.avro.mapred.AvroOutputFormat.DEFLATE_LEVEL_KEY,\n          org.apache.avro.mapred.AvroOutputFormat.DEFAULT_DEFLATE_LEVEL);\n      \n      String outputCodec = context.getConfiguration()\n        .get(AvroJob.CONF_OUTPUT_CODEC);\n\n      if (outputCodec == null) {\n        String compressionCodec = context.getConfiguration().get(\"mapred.output.compression.codec\");\n        String avroCodecName = HadoopCodecFactory.getAvroCodecName(compressionCodec);\n        if ( avroCodecName != null){\n          context.getConfiguration().set(AvroJob.CONF_OUTPUT_CODEC, avroCodecName);\n          return HadoopCodecFactory.fromHadoopString(compressionCodec);\n        } else {\n          return CodecFactory.deflateCodec(compressionLevel);\n        }\n      } else if (DataFileConstants.DEFLATE_CODEC.equals(outputCodec)) {\n          return CodecFactory.deflateCodec(compressionLevel);\n        } else {\n          return CodecFactory.fromString(outputCodec);\n        }\n      \n      }\n\n    // No compression.\n    return CodecFactory.nullCodec();\n  }\n"
  },
  {
    "id": "cemcatik_jtds-123-Associations-FirstSentence",
    "old_comment_raw": "Returns the  ConnectionJDBC object referenced by the  #statement instance variable.",
    "new_comment_raw": "Returns the  JtdsConnection object referenced by the  #statement instance variable.",
    "old_code_raw": "    private ConnectionJDBC getConnection() throws SQLException {\n        return (ConnectionJDBC) statement.getConnection();\n    }\n",
    "new_code_raw": "    private JtdsConnection getConnection() throws SQLException {\n        return (JtdsConnection) statement.getConnection();\n    }\n\n"
  },
  {
    "id": "SeleniumHQ_selenium-672-FirstSentence-0",
    "old_comment_raw": "Destroy the current command.",
    "new_comment_raw": "Destroy the current command.",
    "old_code_raw": "  public int destroy() {\n    ExecuteWatchdog watchdog = executor.getWatchdog();\n    if (watchdog != null) {\n      watchdog.destroyProcess();\n    }\n\n    // Give the process a chance to die naturally.\n    quiesceFor(3, SECONDS);\n\n    if (!handler.hasResult()) {\n      log.info(\n          \"Command failed to close cleanly. Destroying forcefully. \" + this);\n      ProcessUtils.killProcess(snitch.getProcess());\n      quiesceFor(1, SECONDS);\n    }\n\n    int exitCode;\n    if (!handler.hasResult()) {\n      log.severe(String.format(\n          \"Unable to kill process with PID %s: %s\", snitch.getProcess(), this));\n      exitCode = -1;\n      executor.setExitValue(exitCode);\n    } else {\n      exitCode = getExitCode();\n    }\n\n    postRunCleanup();\n    return exitCode;\n  }\n",
    "new_code_raw": "  public int destroy() {\n    ExecuteWatchdog watchdog = executor.getWatchdog();\n    while (!watchdog.isWatching()){\n      try {\n        Thread.sleep(50);\n      } catch (InterruptedException e) {\n        throw new WebDriverException(e);\n      }\n    }\n    watchdog.destroyProcess();\n    if (handler.hasResult()) {\n       return getExitCode();\n    }\n\n\n    log.info(\"Process destruction entered a last-ditch phase that shouldn't happen. File an issue if you see this message\");\n    // Give the process a chance to die naturally.\n    quiesceFor(3, SECONDS);\n\n    if (!handler.hasResult()) {\n      log.info(\n          \"Command failed to close cleanly. Destroying forcefully. \" + this);\n      ProcessUtils.killProcess(snitch.getProcess());\n      quiesceFor(1, SECONDS);\n    }\n\n    int exitCode;\n    if (!handler.hasResult()) {\n      log.severe(String.format(\n          \"Unable to kill process with PID %s: %s\", snitch.getProcess(), this));\n      exitCode = -1;\n      executor.setExitValue(exitCode);\n    } else {\n      exitCode = getExitCode();\n    }\n\n    postRunCleanup();\n    return exitCode;\n  }\n"
  },
  {
    "id": "apache_drill-689-FirstSentence-0",
    "old_comment_raw": "Return the full location of this partition",
    "new_comment_raw": "Return the full location of this partition",
    "old_code_raw": "  public String getEntirePartitionLocation() {\n    return file;\n  }\n",
    "new_code_raw": "  public Path getEntirePartitionLocation() {\n    return file;\n  }\n"
  },
  {
    "id": "caillette_novelang-7-Associations-FirstSentence",
    "old_comment_raw": "Gobble one item node if possible.",
    "new_comment_raw": "Gobbles one item node if possible.",
    "old_code_raw": "  private static Gobbling gobble( Treepath< SyntacticTree > gobbleStart ) {\n    if( null == gobbleStart ) {\n      return null ;\n    }\n    Preconditions.checkArgument( gobbleStart.getTreeAtEnd().isOneOf( _PLACEHOLDER_ ) ) ;\n    gobbleStart = TreepathTools.getNextSibling( gobbleStart ) ;\n    \n    do {\n      if( isRawItem( gobbleStart ) ) {\n        if( TreepathTools.hasNextSibling( gobbleStart ) ) {\n          final Treepath< SyntacticTree > nextStart = TreepathTools.getNextSibling( gobbleStart ) ;\n          final Treepath< SyntacticTree > nextStartMinusPrevious =\n              TreepathTools.removePreviousSibling( nextStart ) ;\n          return new Gobbling( nextStartMinusPrevious, makeEmbeddedListItem( gobbleStart ), true ) ;\n        } else {\n          final Treepath< SyntacticTree > minusPrevious = TreepathTools.removeEnd( gobbleStart ) ;\n          return new Gobbling( minusPrevious, makeEmbeddedListItem( gobbleStart ), false ) ;\n        }\n      } else if( gobbleStart.getTreeAtEnd().isOneOf( WHITESPACE_, LINE_BREAK_ ) ) {\n        if( TreepathTools.hasNextSibling( gobbleStart ) ) {\n          gobbleStart = TreepathTools.getNextSibling( gobbleStart ) ;\n        }\n      } else {\n        return null ;\n      }\n    } while( true ) ;\n  }\n",
    "new_code_raw": "  private static Gobbling gobble( Treepath< SyntacticTree > gobbleStart, int indentation ) {\n    Preconditions.checkArgument( gobbleStart.getTreeAtEnd().isOneOf( _PLACEHOLDER_ ) ) ;\n    Treepath< SyntacticTree > start = gobbleStart ;\n    \n    do {\n      if( TreepathTools.hasNextSibling( start ) ) {\n        final Treepath< SyntacticTree > next = TreepathTools.getNextSibling( start ) ;\n        if( isRawItem( next ) ) {\n          final Treepath< SyntacticTree > minusNext =\n              TreepathTools.removeNextSibling( start ) ;\n          return new Gobbling( minusNext, makeEmbeddedListItem( next ), indentation ) ;\n        } else {\n          final SyntacticTree nextTree = next.getTreeAtEnd() ;\n          if( nextTree.isOneOf( WHITESPACE_, LINE_BREAK_ ) ) {\n            start = TreepathTools.removeNextSibling( start ) ;\n            if( nextTree.isOneOf( WHITESPACE_ ) ) {\n              indentation = getWhitespaceLength( next ) ;\n            }\n            continue ;\n          }\n        }\n      } \n      // If no next sibling at all, or no useful next sibling, then return.\n      return new Gobbling( start ) ;      \n    } while( true ) ;\n  }\n\n"
  },
  {
    "id": "SeleniumHQ_selenium-342-FirstSentence-0",
    "old_comment_raw": "Returns usual Google Chrome installation location on Windows.",
    "new_comment_raw": "Returns usual Google Chrome installation location on Windows.",
    "old_code_raw": "  protected String[] usualWindowsLauncherLocations() {\n    return new String[] {\n        WindowsUtils.getLocalAppDataPath() + \"\\\\Google\\\\Chrome\\\\Application\"\n    };\n  }\n",
    "new_code_raw": "  protected String[] usualWindowsLauncherLocations() {\n    return new String[] {\n        WindowsUtils.getLocalAppDataPath() + \"\\\\Google\\\\Chrome\\\\Application\",\n        WindowsUtils.getProgramFiles86Path() + \"\\\\Google\\\\Chrome\\\\Application\",\n        WindowsUtils.getProgramFilesPath() + \"\\\\Google\\\\Chrome\\\\Application\"\n    };\n  }\n"
  },
  {
    "id": "apache_giraph-23-Associations-FirstSentence",
    "old_comment_raw": "Check the workers to ensure that a minimum number of good workers exists out of the total that have reported.",
    "new_comment_raw": "Check all the  WorkerInfo objects to ensure that a minimum number of good workers exists out of the total that have reported.",
    "old_code_raw": "    private Map<String, JSONArray> checkWorkers() {\n        boolean failJob = true;\n        int pollAttempt = 0;\n        List<String> healthyWorkerList = new ArrayList<String>();\n        List<String> unhealthyWorkerList = new ArrayList<String>();\n        int totalResponses = -1;\n        while (pollAttempt < maxPollAttempts) {\n            getWorkers(\n                getSuperstep(), healthyWorkerList, unhealthyWorkerList);\n            totalResponses = healthyWorkerList.size() +\n                unhealthyWorkerList.size();\n            if ((totalResponses * 100.0f / maxWorkers) >=\n                    minPercentResponded) {\n                failJob = false;\n                break;\n            }\n            getContext().setStatus(getGraphMapper().getMapFunctions() + \" \" +\n                                   \"checkWorkers: Only found \" +\n                                   totalResponses +\n                                   \" responses of \" + maxWorkers +\n                                   \" needed to start superstep \" +\n                                   getSuperstep());\n            if (getWorkerHealthRegistrationChangedEvent().waitMsecs(\n                    msecsPollPeriod)) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"checkWorkers: Got event that health \" +\n                              \"registration changed, not using poll attempt\");\n                }\n                getWorkerHealthRegistrationChangedEvent().reset();\n                continue;\n            }\n            if (LOG.isInfoEnabled()) {\n                LOG.info(\"checkWorkers: Only found \" + totalResponses +\n                         \" responses of \" + maxWorkers +\n                         \" needed to start superstep \" +\n                         getSuperstep() + \".  Sleeping for \" +\n                         msecsPollPeriod + \" msecs and used \" + pollAttempt +\n                         \" of \" + maxPollAttempts + \" attempts.\");\n                // Find the missing workers if there are only a few\n                if ((maxWorkers - totalResponses) <= partitionLongTailMinPrint) {\n                    Set<Integer> partitionSet = new TreeSet<Integer>();\n                    for (String hostnamePartitionId : healthyWorkerList) {\n                        int lastIndex = hostnamePartitionId.lastIndexOf(\"_\");\n                        Integer partition = Integer.parseInt(\n                            hostnamePartitionId.substring(lastIndex + 1));\n                        partitionSet.add(partition);\n                    }\n                    for (String hostnamePartitionId : unhealthyWorkerList) {\n                        int lastIndex = hostnamePartitionId.lastIndexOf(\"_\");\n                        Integer partition = Integer.parseInt(\n                            hostnamePartitionId.substring(lastIndex + 1));\n                        partitionSet.add(partition);\n                    }\n                    for (int i = 1; i <= maxWorkers; ++i) {\n                        if (partitionSet.contains(new Integer(i))) {\n                            continue;\n                        } else if (i == getTaskPartition()) {\n                            continue;\n                        } else {\n                            LOG.info(\"checkWorkers: No response from \"+\n                                     \"partition \" + i + \" (could be master)\");\n                        }\n                    }\n                }\n            }\n            ++pollAttempt;\n        }\n        if (failJob) {\n            LOG.error(\"checkWorkers: Did not receive enough processes in \" +\n                      \"time (only \" + totalResponses + \" of \" +\n                      minWorkers + \" required).  This occurs if you do not \" +\n                      \"have enough map tasks available simultaneously on \" +\n                      \"your Hadoop instance to fulfill the number of \" +\n                      \"requested workers.\");\n            return null;\n        }\n\n        if (healthyWorkerList.size() < minWorkers) {\n            LOG.error(\"checkWorkers: Only \" + healthyWorkerList.size() +\n                      \" available when \" + minWorkers + \" are required.\");\n            return null;\n        }\n\n        Map<String, JSONArray> workerHostnamePortMap =\n            new HashMap<String, JSONArray>();\n        for (String healthyWorker: healthyWorkerList) {\n            String healthyWorkerPath = null;\n            try {\n                healthyWorkerPath =\n                    getWorkerHealthyPath(getApplicationAttempt(),\n                                         getSuperstep()) + \"/\" +  healthyWorker;\n                JSONArray hostnamePortArray =\n                    new JSONArray(\n                        new String(getZkExt().getData(healthyWorkerPath,\n                                                      false,\n                                                      null)));\n                workerHostnamePortMap.put(healthyWorker, hostnamePortArray);\n            } catch (JSONException e) {\n                throw new RuntimeException(\n                    \"checkWorkers: Problem fetching hostname and port for \" +\n                    healthyWorker + \" in \" + healthyWorkerPath);\n            } catch (KeeperException e) {\n                throw new IllegalStateException(\n                    \"checkWorkers: KeeperException\", e);\n            } catch (InterruptedException e) {\n                throw new IllegalStateException(\n                    \"checkWorkers: IllegalStateException\", e);\n            }\n        }\n\n        return workerHostnamePortMap;\n    }\n",
    "new_code_raw": "    private List<WorkerInfo> checkWorkers() {\n        boolean failJob = true;\n        int pollAttempt = 0;\n        List<WorkerInfo> healthyWorkerInfoList = new ArrayList<WorkerInfo>();\n        List<WorkerInfo> unhealthyWorkerInfoList = new ArrayList<WorkerInfo>();\n        int totalResponses = -1;\n        while (pollAttempt < maxPollAttempts) {\n            getAllWorkerInfos(\n                getSuperstep(), healthyWorkerInfoList, unhealthyWorkerInfoList);\n            totalResponses = healthyWorkerInfoList.size() +\n                unhealthyWorkerInfoList.size();\n            if ((totalResponses * 100.0f / maxWorkers) >=\n                    minPercentResponded) {\n                failJob = false;\n                break;\n            }\n            getContext().setStatus(getGraphMapper().getMapFunctions() + \" \" +\n                                   \"checkWorkers: Only found \" +\n                                   totalResponses +\n                                   \" responses of \" + maxWorkers +\n                                   \" needed to start superstep \" +\n                                   getSuperstep());\n            if (getWorkerHealthRegistrationChangedEvent().waitMsecs(\n                    msecsPollPeriod)) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"checkWorkers: Got event that health \" +\n                              \"registration changed, not using poll attempt\");\n                }\n                getWorkerHealthRegistrationChangedEvent().reset();\n                continue;\n            }\n            if (LOG.isInfoEnabled()) {\n                LOG.info(\"checkWorkers: Only found \" + totalResponses +\n                         \" responses of \" + maxWorkers +\n                         \" needed to start superstep \" +\n                         getSuperstep() + \".  Sleeping for \" +\n                         msecsPollPeriod + \" msecs and used \" + pollAttempt +\n                         \" of \" + maxPollAttempts + \" attempts.\");\n                // Find the missing workers if there are only a few\n                if ((maxWorkers - totalResponses) <=\n                        partitionLongTailMinPrint) {\n                    Set<Integer> partitionSet = new TreeSet<Integer>();\n                    for (WorkerInfo workerInfo : healthyWorkerInfoList) {\n                        partitionSet.add(workerInfo.getPartitionId());\n                    }\n                    for (WorkerInfo workerInfo : unhealthyWorkerInfoList) {\n                        partitionSet.add(workerInfo.getPartitionId());\n                    }\n                    for (int i = 1; i <= maxWorkers; ++i) {\n                        if (partitionSet.contains(new Integer(i))) {\n                            continue;\n                        } else if (i == getTaskPartition()) {\n                            continue;\n                        } else {\n                            LOG.info(\"checkWorkers: No response from \"+\n                                     \"partition \" + i + \" (could be master)\");\n                        }\n                    }\n                }\n            }\n            ++pollAttempt;\n        }\n        if (failJob) {\n            LOG.error(\"checkWorkers: Did not receive enough processes in \" +\n                      \"time (only \" + totalResponses + \" of \" +\n                      minWorkers + \" required).  This occurs if you do not \" +\n                      \"have enough map tasks available simultaneously on \" +\n                      \"your Hadoop instance to fulfill the number of \" +\n                      \"requested workers.\");\n            return null;\n        }\n\n        if (healthyWorkerInfoList.size() < minWorkers) {\n            LOG.error(\"checkWorkers: Only \" + healthyWorkerInfoList.size() +\n                      \" available when \" + minWorkers + \" are required.\");\n            return null;\n        }\n\n        return healthyWorkerInfoList;\n    }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-958-FirstSentence-0",
    "old_comment_raw": "Gets the field for a specific index in the chronology specified.",
    "new_comment_raw": "Gets the field for a specific index in the chronology specified.",
    "old_code_raw": "    protected DateTimeField getField(int index, Chronology chrono) {\n        switch (index) {\n            case YEAR:\n                return chrono.year();\n            case DAY_OF_YEAR:\n                return chrono.dayOfYear();\n            case MILLIS_OF_DAY:\n                return chrono.millisOfDay();\n            default:\n                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n        }\n    }\n",
    "new_code_raw": "    protected DateTimeField getField(int index, Chronology chrono) {\n        switch (index) {\n            case YEAR:\n                return chrono.year();\n            case MONTH_OF_YEAR:\n                return chrono.monthOfYear();\n            case DAY_OF_MONTH:\n                return chrono.dayOfMonth();\n            case MILLIS_OF_DAY:\n                return chrono.millisOfDay();\n            default:\n                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n        }\n    }\n"
  },
  {
    "id": "zaproxy_zaproxy-2185-FirstSentence-0",
    "old_comment_raw": "This method initializes txtProxyIpSSL",
    "new_comment_raw": "This method initializes txtProxyIpSSL",
    "old_code_raw": "\tprivate JTextField getTxtReverseProxyIp() {\n\t\tif (txtReverseProxyIp == null) {\n\t\t\ttxtReverseProxyIp = new JTextField();\n\t\t}\n\t\treturn txtReverseProxyIp;\n\t}\n",
    "new_code_raw": "\tprivate ZapTextField getTxtReverseProxyIp() {\n\t\tif (txtReverseProxyIp == null) {\n\t\t\ttxtReverseProxyIp = new ZapTextField();\n\t\t}\n\t\treturn txtReverseProxyIp;\n\t}\n"
  },
  {
    "id": "apache_lenya-332-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Get the column position",
    "old_code_raw": "    public final int getColumn() {\n        return bufcolumn[bufpos];\n    }\n",
    "new_code_raw": "    public final int getColumn() {\n        return this.bufcolumn[this.bufpos];\n    }\n\n"
  },
  {
    "id": "zaproxy_zaproxy-2187-FirstSentence-0",
    "old_comment_raw": "This method initializes txtProxyPort",
    "new_comment_raw": "This method initializes txtProxyPort",
    "old_code_raw": "\tprivate JTextField getTxtProxyPort() {\n\t\tif (txtProxyPort == null) {\n\t\t\ttxtProxyPort = new JTextField();\n\t\t}\n\t\treturn txtProxyPort;\n\t}\n",
    "new_code_raw": "\tprivate ZapTextField getTxtProxyPort() {\n\t\tif (txtProxyPort == null) {\n\t\t\ttxtProxyPort = new ZapTextField();\n\t\t}\n\t\treturn txtProxyPort;\n\t}\n"
  },
  {
    "id": "apache_calcite-964-FirstSentence-0",
    "old_comment_raw": "Returns a function that checks that a particular MongoDB pipeline is generated to implement a query.",
    "new_comment_raw": "Returns a function that checks that a particular MongoDB query has been called.",
    "old_code_raw": "  private static Consumer<List> mongoChecker(final String... strings) {\n    return actual -> {\n      Object[] actualArray =\n          actual == null || actual.isEmpty()\n              ? null\n              : ((List) actual.get(0)).toArray();\n      CalciteAssert.assertArrayEqual(\"expected MongoDB query not found\",\n          strings, actualArray);\n    };\n  }\n",
    "new_code_raw": "  private static Consumer<List> mongoChecker(final String... expected) {\n    return actual -> {\n      if (expected == null) {\n        Assert.assertThat(\"null mongo Query\", actual, CoreMatchers.nullValue());\n        return;\n      }\n\n      if (expected.length == 0) {\n        CalciteAssert.assertArrayEqual(\"empty Mongo query\", expected,\n            actual.toArray(new Object[0]));\n        return;\n      }\n\n      final BsonDocument expectedBson = BsonDocument.parse(String.join(\",\", expected));\n      final BsonDocument actualBson = BsonDocument.parse(((List<?>) actual.get(0))\n          .stream()\n          .map(Objects::toString)\n          .collect(Collectors.joining(\"\\n\")));\n\n      // compare Bson (not string) representation\n      if (!expectedBson.equals(actualBson)) {\n        final JsonWriterSettings settings = JsonWriterSettings.builder().indent(true).build();\n        // used to pretty print Assertion error\n        Assert.assertEquals(\"expected and actual Mongo queries do not match\",\n            expectedBson.toJson(settings),\n            actualBson.toJson(settings));\n        Assert.fail(\"Should have failed previously because (expected != actual) is already known\");\n      }\n    };\n  }\n"
  },
  {
    "id": "apache_activemq-970-FirstSentence-0",
    "old_comment_raw": "Creates a publisher for the specified topic.",
    "new_comment_raw": "Creates a publisher for the specified topic.",
    "old_code_raw": "    public TopicPublisher createPublisher(Topic topic) throws JMSException {\n        checkClosed();\n        return new ActiveMQTopicPublisher(this, ActiveMQMessageTransformation.transformDestination(topic));\n    }\n",
    "new_code_raw": "    public TopicPublisher createPublisher(Topic topic) throws JMSException {\n        checkClosed();\n        \n        if (topic instanceof CustomDestination)  {\n            CustomDestination customDestination = (CustomDestination) topic;\n            return customDestination.createPublisher(this);\n        }\n        return new ActiveMQTopicPublisher(this, ActiveMQMessageTransformation.transformDestination(topic));\n    }\n"
  },
  {
    "id": "apache_jsecurity-39-Associations-FirstSentence",
    "old_comment_raw": "Performs the multi-realm authentication attempt by calling back to a  ModularAuthenticationStrategy object as each realm is consulted for AuthenticationInfo for the specified token.",
    "new_comment_raw": "Performs the multi-realm authentication attempt by calling back to a  ModularAuthenticationStrategy object as each realm is consulted for Account for the specified token.",
    "old_code_raw": "    protected AuthenticationInfo doMultiRealmAuthentication( Collection<? extends Realm> realms, AuthenticationToken token ) {\n\n        ModularAuthenticationStrategy strategy = getModularAuthenticationStrategy();\n\n        strategy.beforeAllAttempts( realms, token );\n        \n        AuthenticationInfo aggregatedInfo = createAggregatedAuthenticationInfo( token );\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Iterating through [\" + realms.size() + \"] realms for PAM authentication\");\n        }\n\n        for( Realm realm : realms) {\n\n            strategy.beforeAttempt( realm, token );\n\n            if( realm.supports( token.getClass() ) ) {\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Attempting to authenticate token [\" + token + \"] \" +\n                        \"using realm of type [\" + realm.getClass() + \"]\");\n                }\n\n                AuthenticationInfo realmInfo = null;\n                Throwable t = null;\n                try {\n                    realmInfo = realm.getAuthenticationInfo( token );\n                } catch ( Throwable throwable ) {\n                    t = throwable;\n                    if ( log.isTraceEnabled() ) {\n                        String msg = \"Realm [\" + realm + \"] threw an exception during a multi-realm authentication attempt:\";\n                        log.trace( msg, t );\n                    }\n                }\n\n                strategy.afterAttempt( realm, token, realmInfo, t );\n\n                // If non-null info is returned, then the realm was able to authenticate the\n                // user - so merge the info with any accumulated before:\n                if( realmInfo != null ) {\n\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Account successfully authenticated using realm of type [\" +\n                            realm.getClass().getName() + \"]\");\n                    }\n\n                    // Merge the module-returned data with the aggregate data\n                    merge( aggregatedInfo, realmInfo );\n\n                }\n            } else {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Realm of type [\" + realm.getClass().getName() + \"] does not support token \" +\n                            \"of type [\" + token.getClass().getName() + \"].  Skipping realm.\" );\n                }\n            }\n        }\n\n        strategy.afterAllAttempts( token, aggregatedInfo );\n\n        return aggregatedInfo;\n    }\n",
    "new_code_raw": "    protected Account doMultiRealmAuthentication( Collection<? extends Realm> realms, AuthenticationToken token ) {\n\n        ModularAuthenticationStrategy strategy = getModularAuthenticationStrategy();\n\n        strategy.beforeAllAttempts( realms, token );\n        \n        Account aggregatedInfo = createAggregatedAccount( token );\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Iterating through [\" + realms.size() + \"] realms for PAM authentication\");\n        }\n\n        for( Realm realm : realms) {\n\n            strategy.beforeAttempt( realm, token );\n\n            if( realm.supports( token.getClass() ) ) {\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Attempting to authenticate token [\" + token + \"] \" +\n                        \"using realm of type [\" + realm.getClass() + \"]\");\n                }\n\n                Account realmInfo = null;\n                Throwable t = null;\n                try {\n                    realmInfo = realm.getAccount( token );\n                } catch ( Throwable throwable ) {\n                    t = throwable;\n                    if ( log.isTraceEnabled() ) {\n                        String msg = \"Realm [\" + realm + \"] threw an exception during a multi-realm authentication attempt:\";\n                        log.trace( msg, t );\n                    }\n                }\n\n                strategy.afterAttempt( realm, token, realmInfo, t );\n\n                // If non-null account is returned, then the realm was able to authenticate the\n                // user - so merge the account with any accumulated before:\n                if( realmInfo != null ) {\n\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Account successfully authenticated using realm of type [\" +\n                            realm.getClass().getName() + \"]\");\n                    }\n\n                    // Merge the module-returned data with the aggregate data\n                    merge( aggregatedInfo, realmInfo );\n\n                }\n            } else {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Realm of type [\" + realm.getClass().getName() + \"] does not support token \" +\n                            \"of type [\" + token.getClass().getName() + \"].  Skipping realm.\" );\n                }\n            }\n        }\n\n        strategy.afterAllAttempts( token, aggregatedInfo );\n\n        return aggregatedInfo;\n    }\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2439-FirstSentence-0",
    "old_comment_raw": "Get the sentence index of the kth word on the buffer.",
    "new_comment_raw": "Get the sentence index of the kth word on the buffer.",
    "old_code_raw": "  public int getBuffer(int k) {\n    return (k >= 0 && k < getBufferSize()) ? buffer.get(k) : CONST.NONEXIST;\n  }\n",
    "new_code_raw": "  public int getBuffer(int k) {\n    return (k >= 0 && k < getBufferSize()) ? buffer.get(k) : Config.NONEXIST;\n  }\n"
  },
  {
    "id": "mattdesl_slick-sui-4-Associations-FirstSentence",
    "old_comment_raw": "Returns an array of this SuiContainer's children.",
    "new_comment_raw": "Returns an array of this Container's children.",
    "old_code_raw": "    public SuiComponent[] getChildren() {\r\n        ensureZOrder();\r\n        SuiComponent[] c = new SuiComponent[children.size()];\r\n        return (SuiComponent[])children.toArray(c);\r\n    }\r\n",
    "new_code_raw": "    public Component[] getChildren() {\r\n        ensureZOrder();\r\n        Component[] c = new Component[children.size()];\r\n        return (Component[])children.toArray(c);\r\n    }\r\n\n"
  },
  {
    "id": "processing_processing-181-FirstSentence-0",
    "old_comment_raw": "Add a file to the sketch.",
    "new_comment_raw": "Add a file to the sketch.",
    "old_code_raw": "  public boolean addFile(File sourceFile) {\n    String filename = sourceFile.getName();\n    File destFile = null;\n    String codeExtension = null;\n    boolean replacement = false;\n\n    // if the file appears to be code related, drop it\n    // into the code folder, instead of the data folder\n    if (filename.toLowerCase().endsWith(\".class\") ||\n        filename.toLowerCase().endsWith(\".jar\") ||\n        filename.toLowerCase().endsWith(\".dll\") ||\n        filename.toLowerCase().endsWith(\".jnilib\") ||\n        filename.toLowerCase().endsWith(\".so\")) {\n\n      //if (!codeFolder.exists()) codeFolder.mkdirs();\n      prepareCodeFolder();\n      destFile = new File(codeFolder, filename);\n\n    } else {\n      for (String extension : mode.getExtensions()) {\n        String lower = filename.toLowerCase();\n        if (lower.endsWith(\".\" + extension)) {\n          destFile = new File(this.folder, filename);\n          codeExtension = extension;\n        }\n      }\n      if (codeExtension == null) {\n        prepareDataFolder();\n        destFile = new File(dataFolder, filename);\n      }\n    }\n\n    // check whether this file already exists\n    if (destFile.exists()) {\n      Object[] options = { Language.text(\"prompt.ok\"), Language.text(\"prompt.cancel\") };\n      String prompt = \"Replace the existing version of \" + filename + \"?\";\n      int result = JOptionPane.showOptionDialog(editor,\n                                                prompt,\n                                                \"Replace\",\n                                                JOptionPane.YES_NO_OPTION,\n                                                JOptionPane.QUESTION_MESSAGE,\n                                                null,\n                                                options,\n                                                options[0]);\n      if (result == JOptionPane.YES_OPTION) {\n        replacement = true;\n      } else {\n        return false;\n      }\n    }\n\n    // If it's a replacement, delete the old file first,\n    // otherwise case changes will not be preserved.\n    // http://dev.processing.org/bugs/show_bug.cgi?id=969\n    if (replacement) {\n      boolean muchSuccess = destFile.delete();\n      if (!muchSuccess) {\n        Base.showWarning(\"Error adding file\",\n                         \"Could not delete the existing '\" +\n                         filename + \"' file.\", null);\n        return false;\n      }\n    }\n\n    // make sure they aren't the same file\n    if ((codeExtension == null) && sourceFile.equals(destFile)) {\n      Base.showWarning(\"You can't fool me\",\n                       \"This file has already been copied to the\\n\" +\n                       \"location from which where you're trying to add it.\\n\" +\n                       \"I ain't not doin nuthin'.\", null);\n      return false;\n    }\n\n    // in case the user is \"adding\" the code in an attempt\n    // to update the sketch's tabs\n\tif (!sourceFile.equals(destFile)) {\n\t\tfinal File sourceFile2 = sourceFile;\n\t\tfinal File destFile2 = destFile;\n\t    // Create a new event dispatch thread- to display ProgressBar\n\t    // while Saving As\n    javax.swing.SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        new ProgressFrame(sourceFile2, destFile2, editor);\n      }\n    });\n\t}\n\n    if (codeExtension != null) {\n      SketchCode newCode = new SketchCode(destFile, codeExtension);\n\n      if (replacement) {\n        replaceCode(newCode);\n\n      } else {\n        insertCode(newCode);\n        sortCode();\n      }\n      setCurrentCode(filename);\n      editor.header.repaint();\n      if (isUntitled()) {  // TODO probably not necessary? problematic?\n        // Mark the new code as modified so that the sketch is saved\n        current.setModified(true);\n      }\n\n    } else {\n      if (isUntitled()) {  // TODO probably not necessary? problematic?\n        // If a file has been added, mark the main code as modified so\n        // that the sketch is properly saved.\n        code[0].setModified(true);\n      }\n    }\n    return true;\n  }\n",
    "new_code_raw": "  public boolean addFile(File sourceFile) {\n    String filename = sourceFile.getName();\n    File destFile = null;\n    String codeExtension = null;\n    boolean replacement = false;\n\n    // if the file appears to be code related, drop it\n    // into the code folder, instead of the data folder\n    if (filename.toLowerCase().endsWith(\".class\") ||\n        filename.toLowerCase().endsWith(\".jar\") ||\n        filename.toLowerCase().endsWith(\".dll\") ||\n        filename.toLowerCase().endsWith(\".jnilib\") ||\n        filename.toLowerCase().endsWith(\".so\")) {\n\n      //if (!codeFolder.exists()) codeFolder.mkdirs();\n      prepareCodeFolder();\n      destFile = new File(codeFolder, filename);\n\n    } else {\n      for (String extension : mode.getExtensions()) {\n        String lower = filename.toLowerCase();\n        if (lower.endsWith(\".\" + extension)) {\n          destFile = new File(this.folder, filename);\n          codeExtension = extension;\n        }\n      }\n      if (codeExtension == null) {\n        prepareDataFolder();\n        destFile = new File(dataFolder, filename);\n      }\n    }\n\n    // check whether this file already exists\n    if (destFile.exists()) {\n      Object[] options = { Language.text(\"prompt.ok\"), Language.text(\"prompt.cancel\") };\n      String prompt = Language.interpolate(\"add_file.messages.confirm_replace\", \n                                           filename);\n      int result = JOptionPane.showOptionDialog(editor,\n                                                prompt,\n                                                \"Replace\",\n                                                JOptionPane.YES_NO_OPTION,\n                                                JOptionPane.QUESTION_MESSAGE,\n                                                null,\n                                                options,\n                                                options[0]);\n      if (result == JOptionPane.YES_OPTION) {\n        replacement = true;\n      } else {\n        return false;\n      }\n    }\n\n    // If it's a replacement, delete the old file first,\n    // otherwise case changes will not be preserved.\n    // http://dev.processing.org/bugs/show_bug.cgi?id=969\n    if (replacement) {\n      boolean muchSuccess = destFile.delete();\n      if (!muchSuccess) {\n        Base.showWarning(Language.text(\"add_file.messages.error_adding\"),\n                         Language.interpolate(\"add_file.messages.cannot_delete.description\",\n                          filename),\n                         null);\n        return false;\n      }\n    }\n\n    // make sure they aren't the same file\n    if ((codeExtension == null) && sourceFile.equals(destFile)) {\n      Base.showWarning(Language.text(\"add_file.messages.same_file\"),\n                       Language.text(\"add_file.messages.same_file.description\"),\n                       null);\n      return false;\n    }\n\n    // Handles \"Add File\" when a .pde is used. For beta 1, this no longer runs\n    // on a separate thread because it's totally unnecessary (a .pde file is\n    // not going to be so large that it's ever required) and otherwise we have\n    // to introduce a threading block here.\n    // https://github.com/processing/processing/issues/3383\n    if (!sourceFile.equals(destFile)) {\n      try {\n        Base.copyFile(sourceFile, destFile);\n\n      } catch (IOException e) {\n        Base.showWarning(Language.text(\"add_file.messages.error_adding\"),\n                         Language.interpolate(\"add_file.messages.cannot_add.description\",\n                          filename),\n                         e);\n        return false;\n      }\n    }\n\n    if (codeExtension != null) {\n      SketchCode newCode = new SketchCode(destFile, codeExtension);\n\n      if (replacement) {\n        replaceCode(newCode);\n\n      } else {\n        insertCode(newCode);\n        sortCode();\n      }\n      setCurrentCode(filename);\n      editor.header.repaint();\n      if (isUntitled()) {  // TODO probably not necessary? problematic?\n        // Mark the new code as modified so that the sketch is saved\n        current.setModified(true);\n      }\n\n    } else {\n      if (isUntitled()) {  // TODO probably not necessary? problematic?\n        // If a file has been added, mark the main code as modified so\n        // that the sketch is properly saved.\n        code[0].setModified(true);\n      }\n    }\n    return true;\n  }\n"
  },
  {
    "id": "jenkinsci_analysis-core-plugin-20-Associations-FirstSentence",
    "old_comment_raw": "Returns whether we have enough valid results in order to draw a meaningful graph.",
    "new_comment_raw": "Returns whether this project has a valid result action attached.",
    "old_code_raw": "    public final boolean hasValidResults() {\r\n        AbstractBuild<?, ?> build = getLastFinishedBuild();\r\n        if (build != null) {\r\n            BuildHistory history = new BuildHistory(build, resultActionType);\r\n\r\n            return history.hasPreviousResult();\r\n        }\r\n        return false;\r\n    }\r\n",
    "new_code_raw": "    public final boolean hasValidResults() {\r\n        return getLastAction() != null;\r\n    }\r\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-1513-FirstSentence-0",
    "old_comment_raw": "Given a supposed instance of an entity/component, guess its entity mode.",
    "new_comment_raw": "Given a supposed instance of an entity/component, guess its entity mode.",
    "old_code_raw": "\tpublic EntityMode guessEntityMode(Object object) {\n\t\tIterator itr = tuplizers.entrySet().iterator();\n\t\twhile( itr.hasNext() ) {\n\t\t\tMap.Entry entry = ( Map.Entry ) itr.next();\n\t\t\tTuplizer tuplizer = ( Tuplizer ) entry.getValue();\n\t\t\tif ( tuplizer.isInstance( object ) ) {\n\t\t\t\treturn ( EntityMode ) entry.getKey();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "new_code_raw": "\tpublic EntityMode guessEntityMode(Object object) {\n\t\tfor ( Map.Entry<EntityMode, Tuplizer> entityModeTuplizerEntry : tuplizers.entrySet() ) {\n\t\t\tif ( entityModeTuplizerEntry.getValue().isInstance( object ) ) {\n\t\t\t\treturn entityModeTuplizerEntry.getKey();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2573-FirstSentence-0",
    "old_comment_raw": "Get the example string value for the given Property.",
    "new_comment_raw": "Get the example string value for the given schema.",
    "old_code_raw": "    protected String getExample(Property property) {\n        if (property.getExample() != null) {\n            return property.getExample().toString();\n        } else if (property instanceof DateTimeProperty) {\n            return \"2000-01-23T04:56:07.000Z\";\n        } else if (property instanceof DateProperty) {\n            return \"2000-01-23\";\n        } else if (property instanceof BooleanProperty) {\n            return \"true\";\n        } else if (property instanceof LongProperty) {\n            return \"123456789\";\n        } else if (property instanceof DoubleProperty) { // derived from DecimalProperty so make sure this is first\n            return \"3.149\";\n        }  else if (property instanceof DecimalProperty) {\n            return \"1.3579\";\n        } else if (property instanceof PasswordProperty) {\n            return \"********\";\n        } else if (property instanceof UUIDProperty) {\n            return \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\";\n        // do these last in case the specific types above are derived from these classes\n        } else if (property instanceof StringProperty) {\n            return \"aeiou\";\n        } else if (property instanceof BaseIntegerProperty) {\n            return \"123\";\n        } else if (property instanceof AbstractNumericProperty) {\n            return \"1.23\";\n        }\n        LOGGER.warn(\"default example value not implemented for \" + property);\n        return \"\";\n    }\n",
    "new_code_raw": "    protected String getExample(Schema schema) {\n        if (schema.getExample() != null) {\n            return schema.getExample().toString();\n        } else if (ModelUtils.isDateTimeSchema(schema)) {\n            return \"2000-01-23T04:56:07.000Z\";\n        } else if (ModelUtils.isDateSchema(schema)) {\n            return \"2000-01-23\";\n        } else if (ModelUtils.isBooleanSchema(schema)) {\n            return \"true\";\n        } else if (ModelUtils.isNumberSchema(schema)) {\n            if (ModelUtils.isFloatSchema(schema)) { // float\n                return \"1.3579\";\n            } else { // double\n                return \"3.149\";\n            }\n        } else if (ModelUtils.isPasswordSchema(schema)) {\n            return \"********\";\n        } else if (ModelUtils.isUUIDSchema(schema)) {\n            return \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\";\n            // do these last in case the specific types above are derived from these classes\n        } else if (ModelUtils.isStringSchema(schema)) {\n            return \"aeiou\";\n        } else if (ModelUtils.isIntegerSchema(schema)) {\n            if (ModelUtils.isLongSchema(schema)) { // long\n                return \"123456789\";\n            } else { //integer\n                return \"123\";\n            }\n        } else {\n            LOGGER.debug(\"default example value not implemented for {}. Default to UNDEFINED_EXAMPLE_VALUE\", schema);\n            return \"UNDEFINED_EXAMPLE_VALUE\";\n        }\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-1385-FirstSentence-0",
    "old_comment_raw": "Returns a Button which shows a given text.",
    "new_comment_raw": "Returns a Button which shows a given text.",
    "old_code_raw": "\tpublic Button getButton(String text)\n\t{\n\t\treturn viewFetcher.getView(Button.class, text, false);\n\t}\n",
    "new_code_raw": "\tpublic Button getButton(String text)\n\t{\n\t\treturn getter.getView(Button.class, text, false);\n\t}\n"
  },
  {
    "id": "hibernate_hibernate_orm-1922-FirstSentence-0",
    "old_comment_raw": "This methods pre-processes the annotated entities from the index and put them into a structure which can bound to the Hibernate metamodel.",
    "new_comment_raw": "Pre-processes the annotated entities from the index and put them into a structure which can bound to the Hibernate metamodel.",
    "old_code_raw": "\tpublic static Set<ConfiguredClassHierarchy> createEntityHierarchies(Index index, ServiceRegistry serviceRegistry) {\n\t\tClassLoaderService classLoaderService = serviceRegistry.getService( ClassLoaderService.class );\n\t\tMap<ClassInfo, List<ClassInfo>> processedClassInfos = new HashMap<ClassInfo, List<ClassInfo>>();\n\n\t\tfor ( ClassInfo info : index.getKnownClasses() ) {\n\t\t\tif ( !isConfiguredClass( info ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( processedClassInfos.containsKey( info ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tList<ClassInfo> configuredClassList = new ArrayList<ClassInfo>();\n\t\t\tClassInfo tmpClassInfo = info;\n\t\t\tClass<?> clazz = classLoaderService.classForName( tmpClassInfo.toString() );\n\t\t\twhile ( clazz != null && !clazz.equals( Object.class ) ) {\n\t\t\t\ttmpClassInfo = index.getClassByName( DotName.createSimple( clazz.getName() ) );\n\t\t\t\tclazz = clazz.getSuperclass();\n\t\t\t\tif ( tmpClassInfo == null ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( existsHierarchyWithClassInfoAsLeaf( processedClassInfos, tmpClassInfo ) ) {\n\t\t\t\t\tList<ClassInfo> classInfoList = processedClassInfos.get( tmpClassInfo );\n\t\t\t\t\tfor ( ClassInfo tmpInfo : configuredClassList ) {\n\t\t\t\t\t\tclassInfoList.add( tmpInfo );\n\t\t\t\t\t\tprocessedClassInfos.put( tmpInfo, classInfoList );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconfiguredClassList.add( 0, tmpClassInfo );\n\t\t\t\t\tprocessedClassInfos.put( tmpClassInfo, configuredClassList );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tAnnotationBindingContext context = new AnnotationBindingContext( index, serviceRegistry );\n\t\tSet<ConfiguredClassHierarchy> hierarchies = new HashSet<ConfiguredClassHierarchy>();\n\t\tList<List<ClassInfo>> processedList = new ArrayList<List<ClassInfo>>();\n\t\tfor ( List<ClassInfo> classInfoList : processedClassInfos.values() ) {\n\t\t\tif ( !processedList.contains( classInfoList ) ) {\n\t\t\t\thierarchies.add( ConfiguredClassHierarchy.create( classInfoList, context ) );\n\t\t\t\tprocessedList.add( classInfoList );\n\t\t\t}\n\t\t}\n\n\t\treturn hierarchies;\n\t}\n",
    "new_code_raw": "\tpublic static Set<ConfiguredClassHierarchy<EntityClass>> createEntityHierarchies(AnnotationBindingContext context) {\n\t\tClassLoaderService classLoaderService = context.classLoaderService();\n\t\tMap<ClassInfo, List<ClassInfo>> processedClassInfos = new HashMap<ClassInfo, List<ClassInfo>>();\n\n\t\tfor ( ClassInfo info : context.getIndex().getKnownClasses() ) {\n\t\t\tif ( !isEntityClass( info ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( processedClassInfos.containsKey( info ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tList<ClassInfo> configuredClassList = new ArrayList<ClassInfo>();\n\t\t\tClassInfo tmpClassInfo = info;\n\t\t\tClass<?> clazz = classLoaderService.classForName( tmpClassInfo.toString() );\n\t\t\twhile ( clazz != null && !clazz.equals( Object.class ) ) {\n\t\t\t\ttmpClassInfo = context.getIndex().getClassByName( DotName.createSimple( clazz.getName() ) );\n\t\t\t\tclazz = clazz.getSuperclass();\n\t\t\t\tif ( tmpClassInfo == null ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( existsHierarchyWithClassInfoAsLeaf( processedClassInfos, tmpClassInfo ) ) {\n\t\t\t\t\tList<ClassInfo> classInfoList = processedClassInfos.get( tmpClassInfo );\n\t\t\t\t\tfor ( ClassInfo tmpInfo : configuredClassList ) {\n\t\t\t\t\t\tclassInfoList.add( tmpInfo );\n\t\t\t\t\t\tprocessedClassInfos.put( tmpInfo, classInfoList );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconfiguredClassList.add( 0, tmpClassInfo );\n\t\t\t\t\tprocessedClassInfos.put( tmpClassInfo, configuredClassList );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSet<ConfiguredClassHierarchy<EntityClass>> hierarchies = new HashSet<ConfiguredClassHierarchy<EntityClass>>();\n\t\tList<List<ClassInfo>> processedList = new ArrayList<List<ClassInfo>>();\n\t\tfor ( List<ClassInfo> classInfoList : processedClassInfos.values() ) {\n\t\t\tif ( !processedList.contains( classInfoList ) ) {\n\t\t\t\thierarchies.add( ConfiguredClassHierarchy.createEntityClassHierarchy( classInfoList, context ) );\n\t\t\t\tprocessedList.add( classInfoList );\n\t\t\t}\n\t\t}\n\n\t\treturn hierarchies;\n\t}\n"
  },
  {
    "id": "debezium_debezium-783-FirstSentence-0",
    "old_comment_raw": "Obtain a JSON string representation of the specified  Struct.",
    "new_comment_raw": "Obtain a JSON string representation of the specified  Struct.",
    "old_code_raw": "    public static String asString(Struct struct) {\n        StringBuilder sb = new StringBuilder();\n        append(struct, sb);\n        return sb.toString();\n    }\n",
    "new_code_raw": "    public static String asString(Struct struct) {\n        return new RecordWriter().append(struct).toString();\n    }\n"
  },
  {
    "id": "apache_tuscany-sca-1.x-142-Associations-FirstSentence",
    "old_comment_raw": "Searches an array of methods for a match against the given operation",
    "new_comment_raw": "Return the method on the implementation class that matches the operation.",
    "old_code_raw": "    public static Method findMethod(Operation<?> operation, Method[] methods) {\n        for (Method method : methods) {\n            if (match(operation, method)) {\n                return method;\n            }\n        }\n        return null;\n    }\n",
    "new_code_raw": "    public static <T> Method findMethod(Class<?> implClass, Operation<T> operation) throws NoSuchMethodException {\n        String name = operation.getName();\n        Class<?>[] paramTypes = getPhysicalTypes(operation);\n        return implClass.getMethod(name, paramTypes);\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1898-FirstSentence-0",
    "old_comment_raw": "Return the sanitized variable name for enum",
    "new_comment_raw": "Return the sanitized variable name for enum",
    "old_code_raw": "    public String toEnumVarName(String value, String datatype) {\n        String modified;\n        if (value.length() == 0) {\n            modified = \"EMPTY\";\n        } else {\n            modified = value;\n\n            for (Map.Entry<String, String> specialCharacters : specialCharReplacements.entrySet()) {\n                // Underscore is the only special character we'll allow\n                if (!specialCharacters.getKey().equals(\"_\")) {\n                    modified = modified.replaceAll(\"\\\\Q\" + specialCharacters.getKey() + \"\\\\E\", specialCharacters.getValue());\n                }\n            }\n\n            // Fallback, replace unknowns with underscore.\n            modified = modified.replaceAll(\"\\\\W+\", \"_\");\n            if (modified.matches(\"\\\\d.*\")) {\n                modified = \"_\" + modified;\n            }\n\n            // _, __, and ___ are reserved in Kotlin. Treat all names with only underscores consistently, regardless of count.\n            if (modified.matches(\"^_*$\")) {\n                modified = modified.replaceAll(\"\\\\Q_\\\\E\", \"Underscore\");\n            }\n        }\n\n        switch (getEnumPropertyNaming()) {\n            case original:\n                // NOTE: This is provided as a last-case allowance, but will still result in reserved words being escaped.\n                modified =  value;\n                break;\n            case camelCase:\n                // NOTE: Removes hyphens and underscores\n                modified =  camelize(modified, true);\n                break;\n            case PascalCase:\n                // NOTE: Removes hyphens and underscores\n                String result = camelize(modified);\n                modified =  result.substring(0, 1).toUpperCase() + result.substring(1);\n                break;\n            case snake_case:\n                // NOTE: Removes hyphens\n                modified = underscore(modified);\n                break;\n            case UPPERCASE:\n                modified = modified.toUpperCase();\n                break;\n        }\n\n        if (reservedWords.contains(modified)) {\n            // TODO: Allow enum escaping as an option (e.g. backticks vs append/prepend underscore vs match model property escaping).\n            return String.format(\"`%s`\", modified);\n        }\n\n        return modified;\n    }\n",
    "new_code_raw": "    public String toEnumVarName(String value, String datatype) {\n        String modified;\n        if (value.length() == 0) {\n            modified = \"EMPTY\";\n        } else {\n            modified = value;\n            modified = sanitizeKotlinSpecificNames(modified);\n        }\n\n        switch (getEnumPropertyNaming()) {\n            case original:\n                // NOTE: This is provided as a last-case allowance, but will still result in reserved words being escaped.\n                modified =  value;\n                break;\n            case camelCase:\n                // NOTE: Removes hyphens and underscores\n                modified =  camelize(modified, true);\n                break;\n            case PascalCase:\n                // NOTE: Removes hyphens and underscores\n                String result = camelize(modified);\n                modified =  titleCase(result);\n                break;\n            case snake_case:\n                // NOTE: Removes hyphens\n                modified = underscore(modified);\n                break;\n            case UPPERCASE:\n                modified = modified.toUpperCase();\n                break;\n        }\n\n        if (reservedWords.contains(modified)) {\n            return escapeReservedWord(modified);\n        }\n\n        return modified;\n    }\n"
  },
  {
    "id": "apache_activemq-artemis-28-Associations-FirstSentence",
    "old_comment_raw": "Create a HornetQConnectionFactory which creates session factories using a static list of transportConfigurations.",
    "new_comment_raw": "Create a ActiveMQConnectionFactory which creates session factories using a static list of transportConfigurations.",
    "old_code_raw": "   public static HornetQConnectionFactory createConnectionFactoryWithoutHA(JMSFactoryType jmsFactoryType, final TransportConfiguration... transportConfigurations)\n   {\n      HornetQConnectionFactory factory = null;\n      if (jmsFactoryType.equals(JMSFactoryType.CF))\n      {\n         factory = new HornetQJMSConnectionFactory(false, transportConfigurations);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_CF))\n      {\n         factory = new HornetQQueueConnectionFactory(false, transportConfigurations);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_CF))\n      {\n         factory = new HornetQTopicConnectionFactory(false, transportConfigurations);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.XA_CF))\n      {\n         factory = new HornetQXAConnectionFactory(false, transportConfigurations);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_XA_CF))\n      {\n         factory = new HornetQXAQueueConnectionFactory(false, transportConfigurations);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_XA_CF))\n      {\n         factory = new HornetQXATopicConnectionFactory(false, transportConfigurations);\n      }\n\n      return factory;\n   }\n",
    "new_code_raw": "   public static ActiveMQConnectionFactory createConnectionFactoryWithoutHA(JMSFactoryType jmsFactoryType, final TransportConfiguration... transportConfigurations)\n   {\n      ActiveMQConnectionFactory factory = null;\n      if (jmsFactoryType.equals(JMSFactoryType.CF))\n      {\n         factory = new ActiveMQJMSConnectionFactory(false, transportConfigurations);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_CF))\n      {\n         factory = new ActiveMQQueueConnectionFactory(false, transportConfigurations);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_CF))\n      {\n         factory = new ActiveMQTopicConnectionFactory(false, transportConfigurations);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.XA_CF))\n      {\n         factory = new ActiveMQXAConnectionFactory(false, transportConfigurations);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_XA_CF))\n      {\n         factory = new ActiveMQXAQueueConnectionFactory(false, transportConfigurations);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_XA_CF))\n      {\n         factory = new ActiveMQXATopicConnectionFactory(false, transportConfigurations);\n      }\n\n      return factory;\n   }\n\n"
  },
  {
    "id": "apache_kylin-476-FirstSentence-0",
    "old_comment_raw": "Get table extended info.",
    "new_comment_raw": "Get table extended info.",
    "old_code_raw": "    public TableExtDesc getTableExt(String tableName, String prj) {\n        if (tableName.indexOf(\".\") < 0)\n            tableName = \"DEFAULT.\" + tableName;\n\n        TableExtDesc result = srcTableExdMap.get(tableName.toUpperCase());\n\n        // create new\n        if (null == result) {\n            result = new TableExtDesc();\n            result.setName(tableName);\n            result.setUuid(UUID.randomUUID().toString());\n            result.setLastModified(0);\n            result.init();\n            srcTableExdMap.put(result.getName(), result);\n        }\n        return result;\n    }\n",
    "new_code_raw": "    public TableExtDesc getTableExt(String tableName, String prj) {\n        TableDesc t = getTableDesc(tableName, prj);\n        if (t == null)\n            return null;\n        \n        TableExtDesc result = srcTableExtMap.get(mapKey(t.getIdentity(), t.getProject()));\n\n        // avoid returning null, since the TableDesc exists\n        if (null == result) {\n            result = new TableExtDesc();\n            result.setName(t.getIdentity());\n            result.setUuid(UUID.randomUUID().toString());\n            result.setLastModified(0);\n            result.init(t.getProject());\n            srcTableExtMap.put(mapKey(t.getIdentity(), t.getProject()), result);\n        }\n        return result;\n    }\n"
  },
  {
    "id": "sarxos_webcam_capture-14-FirstSentence-0",
    "old_comment_raw": "Check if webcam is locked.",
    "new_comment_raw": "Check if webcam is locked.",
    "old_code_raw": "\tpublic boolean isLocked() {\n\n\t\t// check if locked by current process\n\n\t\tif (locked.get()) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// check if locked by other process\n\n\t\tlong tsp = PREFS.getLong(webcam.getName(), -1);\n\t\tlong now = System.currentTimeMillis();\n\n\t\tLOG.trace(\"Lock timestamp {} now {} for \", tsp, now, webcam);\n\n\t\tif (tsp > now - INTERVAL * 2) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n",
    "new_code_raw": "\tpublic boolean isLocked() {\n\n\t\t// check if locked by current process\n\n\t\tif (locked.get()) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// check if locked by other process\n\n\t\tif (!lock.exists()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlong now = System.currentTimeMillis();\n\t\tlong tsp = read();\n\n\t\tLOG.trace(\"Lock timestamp {} now {} for {}\", tsp, now, webcam);\n\n\t\tif (tsp > now - INTERVAL * 2) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n"
  },
  {
    "id": "apache_wookie-10-Associations-FirstSentence",
    "old_comment_raw": "Marshall JSON metadata into a new Widget instance",
    "new_comment_raw": "Marshall JSON metadata into a new W3CWidget instance",
    "old_code_raw": "\tpublic static Widget getWidget(String metadata, String shindig) throws Exception{\n\t\tJSONObject gadget = null;\n\t\tWidget widget = null;\n\t\tJSONObject response = new JSONObject(metadata);\n\t\tJSONArray gadgets = response.getJSONArray(\"gadgets\");\n\t\tif (gadgets.length() > 0){\n\t\t\tgadget = gadgets.getJSONObject(0);\n\t\t\tif (gadget.has(\"errors\")) throw new Exception(\"Invalid gadget - Shindig error\");\n\t\t\t\n\t\t\twidget = new Widget();\n\t\t\t// Defaults\n\t\t\tString title = \"Untitled Gadget\";\n\t\t\tint height = 200;\n\t\t\tint width = 320;\n\t\t\tString author = \"Unknown Author\";\n\t\t\tString description = \"Google Gadget\";\n\t\t\tString icon = DEFAULT_ICON;\n\n\t\t\tif (!gadget.has(\"url\")) throw new Exception(\"Invalid gadget - URL missing\");\n\t\t\tif (gadget.getString(\"url\") == null || gadget.getString(\"url\").equals(\"\")) throw new Exception(\"Invalid gadget - Invalid URL\");\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"unused\")\n\t\t\t\tURL url = new URL(gadget.getString(\"url\"));\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new Exception(\"Invalid gadget - invalid URL\");\n\t\t\t}\n\n\t\t\t// Use the URL as the GUID\n\t\t\twidget.setGuid(gadget.getString(\"url\"));\n\n\t\t\t// We should be able to use the \"iframeUrl\" property here, but\n\t\t\t// it isn't very reliable at generating a usable value, so we construct\n\t\t\t// a very basic URL instead\n\t\t\tStartFile sf = new StartFile();\n\t\t\tsf.setWidget(widget);\n\t\t\t// FIXME we need to use real locales in these URLs\n\t\t\tsf.setUrl(shindig+\"/gadgets/ifr?url=\"+gadget.getString(\"url\")+\"&amp;lang=en&amp;country=UK\");\n\t\t\t\n\t\t\tif (gadget.has(\"height\")) if (gadget.getInt(\"height\") != 0) height = gadget.getInt(\"height\");\n\t\t\tif (gadget.has(\"width\")) if (gadget.getInt(\"width\") != 0) width = gadget.getInt(\"width\");\n\n\t\t\tif (gadget.has(\"author\")){\n\t\t\t\tif (gadget.getString(\"author\")!=null){\n\t\t\t\t\tif (!(gadget.getString(\"author\").trim()).equals(\"\")){\n\t\t\t\t\t\tauthor = gadget.getString(\"author\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (gadget.has(\"title\")){\n\t\t\t\tif (gadget.getString(\"title\")!=null){\n\t\t\t\t\tif (!(gadget.getString(\"title\").trim()).equals(\"\")){\n\t\t\t\t\t\ttitle = gadget.getString(\"title\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override the title with directory title if present (this is intended for gallery use)\n\t\t\tif (gadget.has(\"directory_title\")){\n\t\t\t\tif (gadget.getString(\"directory_title\")!=null){\n\t\t\t\t\tif (!(gadget.getString(\"directory_title\").trim()).equals(\"\")){\n\t\t\t\t\t\ttitle = gadget.getString(\"directory_title\");\n\t\t\t\t\t}    \t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (gadget.has(\"description\")){\n\t\t\t\tif (gadget.getString(\"description\")!=null){\n\t\t\t\t\tif (!(gadget.getString(\"description\").trim()).equals(\"\")){\n\t\t\t\t\t\ttitle = gadget.getString(\"description\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (gadget.has(\"thumbnail\")){\n\t\t\t\tif (gadget.getString(\"thumbnail\")!=null){\n\t\t\t\t\tif (!(gadget.getString(\"thumbnail\").trim()).equals(\"\")){\n\t\t\t\t\t\ticon = gadget.getString(\"thumbnail\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twidget.setMaximize(false);\n\t\t\twidget.setHeight(height);\n\t\t\twidget.setWidth(width);\n\t\t\tName name = new Name();\n\t\t\tname.setWidget(widget);\n\t\t\tname.setName(title);\n\t\t\tDescription desc = new Description();\n\t\t\tdesc.setWidget(widget);\n\t\t\tdesc.setContent(description);\n\t\t\tWidgetIcon wicon = new WidgetIcon();\n\t\t\twicon.setSrc(icon);\n\t\t\twicon.setWidget(widget);\n\t\t\twidget.setWidgetAuthor(author);\n\t\t\t\n\t\t\twidget.save();\n\t\t\tsf.save();\n\t\t\tname.save();\n\t\t\twicon.save();\n\t\t\tdesc.save();\n\t\t\t\n\t\t}\n\t\treturn widget;\n\t}\n",
    "new_code_raw": "\tpublic static W3CWidget getWidget(String metadata, String shindig) throws Exception{\n\t\tJSONObject gadget = null;\n\t\tJSONObject response = new JSONObject(metadata);\n\t\tJSONArray gadgets = response.getJSONArray(\"gadgets\");\n\t\tif (gadgets.length()==0) return null;\n\t\tgadget = gadgets.getJSONObject(0);\n\t\treturn new GadgetAdapter(gadget, shindig);\n\t}\n\n"
  },
  {
    "id": "zaproxy_zaproxy-2085-FirstSentence-0",
    "old_comment_raw": "Tells whether or not the given  name matches the given  engineName and  engineLanguage.",
    "new_comment_raw": "Tells whether or not the given  name matches the given  engineName and  engineLanguage.",
    "old_code_raw": "\tpublic static boolean isSameScriptEngine(String name, String engineName, String engineLanguage) {\n\t\tif (name == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// In the configs we just use the engine name, in the UI we use the language name as well\n\t\tif (name.indexOf(LANG_ENGINE_SEP) > 0) {\n\t\t\tif (name.equals(engineLanguage + LANG_ENGINE_SEP + engineName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tif (name.equals(engineName)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Nasty, but sometime the engine names are reported differently, eg 'Mozilla Rhino' vs 'Rhino'\n\t\tif (name.endsWith(engineName)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (engineName.endsWith(name)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "new_code_raw": "\tpublic static boolean isSameScriptEngine(String name, String engineName, String engineLanguage) {\n\t\tif (name == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// In the configs we just use the engine name, in the UI we use the language name as well\n\t\tif (name.indexOf(LANG_ENGINE_SEP) > 0) {\n\t\t\tif (name.equals(engineLanguage + LANG_ENGINE_SEP + engineName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\treturn name.equals(engineName);\n\t}\n"
  },
  {
    "id": "apache_drill-1430-FirstSentence-0",
    "old_comment_raw": "Get the precision of given type.",
    "new_comment_raw": "Get the precision of given type.",
    "old_code_raw": "  public static int getPrecision(MajorType majorType) {\n    MinorType type = majorType.getMinorType();\n\n    if (type == MinorType.VARBINARY || type == MinorType.VARCHAR) {\n      return 65536;\n    }\n\n    if (majorType.hasPrecision()) {\n      return majorType.getPrecision();\n    }\n\n    return 0;\n  }\n",
    "new_code_raw": "  public static int getPrecision(MajorType majorType) {\n    if (majorType.hasPrecision()) {\n      return majorType.getPrecision();\n    }\n\n    return isScalarStringType(majorType) ? MAX_VARCHAR_LENGTH : UNDEFINED;\n  }\n"
  },
  {
    "id": "apache_tuscany-sca-1.x-197-Associations-FirstSentence",
    "old_comment_raw": "Creates a new conversational id",
    "new_comment_raw": "Creates a new conversation id",
    "old_code_raw": "    private Object createConversationID() {\n        if (conversationID == null) {\n            return UUID.randomUUID().toString();\n        }\n        return conversationID;\n    }\n",
    "new_code_raw": "    private Object createConversationID() {\n        if (getConversationID() != null) {\n            return getConversationID();\n        } else {\n            return UUID.randomUUID().toString();\n        }\n    }\n\n"
  },
  {
    "id": "andkulikov_Transitions_Everywhere-3-FirstSentence-0",
    "old_comment_raw": "Creates an Animator for ImageViews moving, changing dimensions, and/or changing  android.widget.ImageView.ScaleType.",
    "new_comment_raw": "Creates an Animator for ImageViews moving, changing dimensions, and/or changing  android.widget.ImageView.ScaleType.",
    "old_code_raw": "    private ObjectAnimator createNullAnimator(ImageView imageView) {\n        return AnimatorUtils.ofObject(new ImageAnimator(imageView),\n                new MatrixUtils.NullMatrixEvaluator(),\n                MatrixUtils.IDENTITY_MATRIX, MatrixUtils.IDENTITY_MATRIX);\n    }\n",
    "new_code_raw": "    private ObjectAnimator createNullAnimator(ImageView imageView) {\n        return AnimatorUtils.ofObject(createMatrixProperty(imageView),\n                new MatrixUtils.NullMatrixEvaluator(),\n                MatrixUtils.IDENTITY_MATRIX, MatrixUtils.IDENTITY_MATRIX);\n    }\n"
  },
  {
    "id": "eclipse_rap-20-Associations-FirstSentence",
    "old_comment_raw": "Returns the id of the widget that is used to identify the widget on the client.",
    "new_comment_raw": "Returns the id of the given widget that is used to identify the widget on the client.",
    "old_code_raw": "  public static String getId( final Widget widget ) {\n    return getAdapter( widget ).getId();\n  }\n",
    "new_code_raw": "  public static String getId( final Widget widget ) {\n    // TODO [rh] consider overriding the id when Widget#setData is called\n    //      - safer 1: in case someone tries to obtain id directly from addapter\n    //      - safer 2: changing the id after widget was initialized could be \n    //        detected and prevented\n    //      - less memory: new HashMap created per widget to hold the id\n    //      - illegal id's could be rejected immediately (close to error source)\n    //      - faster (?): only \"return getAdapter( widget ).getId();\" in here \n    String result = ( String )widget.getData( CUSTOM_WIDGET_ID );\n    if( result == null ) {\n      result = getAdapter( widget ).getId();\n    }\n    return result;\n  }\n\n"
  },
  {
    "id": "processing_processing-187-FirstSentence-0",
    "old_comment_raw": "Add a file to the sketch.",
    "new_comment_raw": "Add a file to the sketch.",
    "old_code_raw": "  public boolean addFile(File sourceFile) {\n    String filename = sourceFile.getName();\n    File destFile = null;\n    String codeExtension = null;\n    boolean replacement = false;\n\n    // if the file appears to be code related, drop it\n    // into the code folder, instead of the data folder\n    if (filename.toLowerCase().endsWith(\".class\") ||\n        filename.toLowerCase().endsWith(\".jar\") ||\n        filename.toLowerCase().endsWith(\".dll\") ||\n        filename.toLowerCase().endsWith(\".jnilib\") ||\n        filename.toLowerCase().endsWith(\".so\")) {\n\n      //if (!codeFolder.exists()) codeFolder.mkdirs();\n      prepareCodeFolder();\n      destFile = new File(codeFolder, filename);\n\n    } else {\n      for (String extension : mode.getExtensions()) {\n        String lower = filename.toLowerCase();\n        if (lower.endsWith(\".\" + extension)) {\n          destFile = new File(this.folder, filename);\n          codeExtension = extension;\n        }\n      }\n      if (codeExtension == null) {\n        prepareDataFolder();\n        destFile = new File(dataFolder, filename);\n      }\n    }\n\n    // check whether this file already exists\n    if (destFile.exists()) {\n      Object[] options = { Language.text(\"prompt.ok\"), Language.text(\"prompt.cancel\") };\n      String prompt = \"Replace the existing version of \" + filename + \"?\";\n      int result = JOptionPane.showOptionDialog(editor,\n                                                prompt,\n                                                \"Replace\",\n                                                JOptionPane.YES_NO_OPTION,\n                                                JOptionPane.QUESTION_MESSAGE,\n                                                null,\n                                                options,\n                                                options[0]);\n      if (result == JOptionPane.YES_OPTION) {\n        replacement = true;\n      } else {\n        return false;\n      }\n    }\n\n    // If it's a replacement, delete the old file first,\n    // otherwise case changes will not be preserved.\n    // http://dev.processing.org/bugs/show_bug.cgi?id=969\n    if (replacement) {\n      boolean muchSuccess = destFile.delete();\n      if (!muchSuccess) {\n        Base.showWarning(\"Error adding file\",\n                         \"Could not delete the existing '\" +\n                         filename + \"' file.\", null);\n        return false;\n      }\n    }\n\n    // make sure they aren't the same file\n    if ((codeExtension == null) && sourceFile.equals(destFile)) {\n      Base.showWarning(\"You can't fool me\",\n                       \"This file has already been copied to the\\n\" +\n                       \"location from which where you're trying to add it.\\n\" +\n                       \"I ain't not doin nuthin'.\", null);\n      return false;\n    }\n\n    // in case the user is \"adding\" the code in an attempt\n    // to update the sketch's tabs\n\tif (!sourceFile.equals(destFile)) {\n\t\tfinal File sourceFile2 = sourceFile;\n\t\tfinal File destFile2 = destFile;\n\t    // Create a new event dispatch thread- to display ProgressBar\n\t    // while Saving As\n    javax.swing.SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        new ProgressFrame(sourceFile2, destFile2, editor);\n      }\n    });\n\t}\n\n    if (codeExtension != null) {\n      SketchCode newCode = new SketchCode(destFile, codeExtension);\n\n      if (replacement) {\n        replaceCode(newCode);\n\n      } else {\n        insertCode(newCode);\n        sortCode();\n      }\n      setCurrentCode(filename);\n      editor.header.repaint();\n      if (isUntitled()) {  // TODO probably not necessary? problematic?\n        // Mark the new code as modified so that the sketch is saved\n        current.setModified(true);\n      }\n\n    } else {\n      if (isUntitled()) {  // TODO probably not necessary? problematic?\n        // If a file has been added, mark the main code as modified so\n        // that the sketch is properly saved.\n        code[0].setModified(true);\n      }\n    }\n    return true;\n  }\n",
    "new_code_raw": "  public boolean addFile(File sourceFile) {\n    String filename = sourceFile.getName();\n    File destFile = null;\n    String codeExtension = null;\n    boolean replacement = false;\n\n    // if the file appears to be code related, drop it\n    // into the code folder, instead of the data folder\n    if (filename.toLowerCase().endsWith(\".class\") ||\n        filename.toLowerCase().endsWith(\".jar\") ||\n        filename.toLowerCase().endsWith(\".dll\") ||\n        filename.toLowerCase().endsWith(\".jnilib\") ||\n        filename.toLowerCase().endsWith(\".so\")) {\n\n      //if (!codeFolder.exists()) codeFolder.mkdirs();\n      prepareCodeFolder();\n      destFile = new File(codeFolder, filename);\n\n    } else {\n      for (String extension : mode.getExtensions()) {\n        String lower = filename.toLowerCase();\n        if (lower.endsWith(\".\" + extension)) {\n          destFile = new File(this.folder, filename);\n          codeExtension = extension;\n        }\n      }\n      if (codeExtension == null) {\n        prepareDataFolder();\n        destFile = new File(dataFolder, filename);\n      }\n    }\n\n    // check whether this file already exists\n    if (destFile.exists()) {\n      Object[] options = { Language.text(\"prompt.ok\"), Language.text(\"prompt.cancel\") };\n      String prompt = \"Replace the existing version of \" + filename + \"?\";\n      int result = JOptionPane.showOptionDialog(editor,\n                                                prompt,\n                                                \"Replace\",\n                                                JOptionPane.YES_NO_OPTION,\n                                                JOptionPane.QUESTION_MESSAGE,\n                                                null,\n                                                options,\n                                                options[0]);\n      if (result == JOptionPane.YES_OPTION) {\n        replacement = true;\n      } else {\n        return false;\n      }\n    }\n\n    // If it's a replacement, delete the old file first,\n    // otherwise case changes will not be preserved.\n    // http://dev.processing.org/bugs/show_bug.cgi?id=969\n    if (replacement) {\n      boolean muchSuccess = destFile.delete();\n      if (!muchSuccess) {\n        Base.showWarning(\"Error adding file\",\n                         \"Could not delete the existing '\" +\n                         filename + \"' file.\", null);\n        return false;\n      }\n    }\n\n    // make sure they aren't the same file\n    if ((codeExtension == null) && sourceFile.equals(destFile)) {\n      Base.showWarning(\"You can't fool me\",\n                       \"This file has already been copied to the\\n\" +\n                       \"location from which where you're trying to add it.\\n\" +\n                       \"I ain't not doin nuthin'.\", null);\n      return false;\n    }\n\n    // Handles \"Add File\" when a .pde is used. For beta 1, this no longer runs\n    // on a separate thread because it's totally unnecessary (a .pde file is\n    // not going to be so large that it's ever required) and otherwise we have\n    // to introduce a threading block here.\n    // https://github.com/processing/processing/issues/3383\n    if (!sourceFile.equals(destFile)) {\n      try {\n        Base.copyFile(sourceFile, destFile);\n\n      } catch (IOException e) {\n        Base.showWarning(\"Error adding file\",\n                         \"Could not add '\" + filename + \"' to the sketch.\", e);\n        return false;\n      }\n    }\n\n    if (codeExtension != null) {\n      SketchCode newCode = new SketchCode(destFile, codeExtension);\n\n      if (replacement) {\n        replaceCode(newCode);\n\n      } else {\n        insertCode(newCode);\n        sortCode();\n      }\n      setCurrentCode(filename);\n      editor.header.repaint();\n      if (isUntitled()) {  // TODO probably not necessary? problematic?\n        // Mark the new code as modified so that the sketch is saved\n        current.setModified(true);\n      }\n\n    } else {\n      if (isUntitled()) {  // TODO probably not necessary? problematic?\n        // If a file has been added, mark the main code as modified so\n        // that the sketch is properly saved.\n        code[0].setModified(true);\n      }\n    }\n    return true;\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-1049-FirstSentence-0",
    "old_comment_raw": "Returns a formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, and three digit fraction of second (HH:mm:ss.SSS).",
    "new_comment_raw": "Returns a formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, and three digit fraction of second (HH:mm:ss.SSS).",
    "old_code_raw": "    public static DateTimeFormatter hourMinuteSecondMillis() {\n        if (hmsl == null) {\n            hmsl = new DateTimeFormatterBuilder()\n                .append(hourElement())\n                .append(minuteElement())\n                .append(secondElement())\n                .appendLiteral('.')\n                .appendFractionOfSecond(3, 3)\n                .toFormatter();\n        }\n        return hmsl;\n    }\n",
    "new_code_raw": "    public static DateTimeFormatter hourMinuteSecondMillis() {\n        return Constants.hmsl;\n    }\n"
  },
  {
    "id": "apache_batik-210-Associations-FirstSentence",
    "old_comment_raw": "Parses the given XML string into a DocumentFragment of the given document.",
    "new_comment_raw": "Parses the given XML string into a DocumentFragment of the given document or a new document if 'doc' is null.",
    "old_code_raw": "        public DocumentFragment parseXML(String text, Document doc) {\n            return null;\n        }\n",
    "new_code_raw": "        public Node parseXML(String text, Document doc) {\n            return null;\n        }\n\n"
  },
  {
    "id": "querydsl_querydsl-312-FirstSentence-0",
    "old_comment_raw": "Create a new PathMetadata instance for indexed list access",
    "new_comment_raw": "Create a new PathMetadata instance for indexed list access",
    "old_code_raw": "    public static PathMetadata<Integer> forListAccess(PList<?> parent, int index) {\n        return new PathMetadata<Integer>(parent, factory.createConstant(index), PathType.LISTVALUE_CONSTANT);\n    }\n",
    "new_code_raw": "    public static PathMetadata<Integer> forListAccess(PList<?> parent, int index) {\n        return new PathMetadata<Integer>(parent, EConstant.create(index), PathType.LISTVALUE_CONSTANT);\n    }\n"
  },
  {
    "id": "scribejava_scribejava-3-Associations-FirstSentence",
    "old_comment_raw": "Get a  Map of the query string parameters.",
    "new_comment_raw": "Get a  ParameterList with the query string parameters.",
    "old_code_raw": "  public Map<String, String> getQueryStringParams()\n  {\n    try\n    {\n      Map<String, String> params = new HashMap<String, String>();\n      String queryString = new URL(url).getQuery();\n      params.putAll(MapUtils.queryStringToMap(queryString));\n      params.putAll(this.querystringParams);\n      return params;\n    }\n    catch (MalformedURLException mue)\n    {\n      throw new OAuthException(\"Malformed URL\", mue);\n    }\n  }\n",
    "new_code_raw": "  public ParameterList getQueryStringParams()\n  {\n    try\n    {\n      ParameterList result = new ParameterList();\n      String queryString = new URL(url).getQuery();\n      result.addQuerystring(queryString);\n      result.addAll(querystringParams);\n      return result;\n    }\n    catch (MalformedURLException mue)\n    {\n      throw new OAuthException(\"Malformed URL\", mue);\n    }\n  }\n\n"
  },
  {
    "id": "Atmosphere_atmosphere-608-FirstSentence-0",
    "old_comment_raw": "Create a  ResourceFilter which contains the information about the annotation being processed.",
    "new_comment_raw": "Create a  ResourceFilter which contains the information about the annotation being processed.",
    "old_code_raw": "    public List<ResourceFilter> create(AbstractMethod am) {\n        LinkedList<ResourceFilter> list = new LinkedList<ResourceFilter>();\n\n        if (logger.isLoggable(Level.FINE)) {\n            for (Annotation a : am.getAnnotations()) {\n                logger.log(Level.FINE, \"AtmosphereFilter processing annotation: \" + a);\n            }\n        }\n\n        if (am.isAnnotationPresent(Broadcast.class)) {\n\n            Filter f;\n            int delay = am.getAnnotation(Broadcast.class).delay();\n            Class[] value = am.getAnnotation(Broadcast.class).value();\n\n            if (am.getAnnotation(Broadcast.class).resumeOnBroadcast()) {\n                f = new Filter(Action.RESUME_ON_BROADCAST, delay, 0, Suspend.SCOPE.APPLICATION, true, value);\n            } else {\n                f = new Filter(Action.BROADCAST, delay, 0, Suspend.SCOPE.APPLICATION, true, value);\n            }\n\n            list.addLast((ResourceFilter) f);\n\n            if (am.isAnnotationPresent(Cluster.class)) {\n                value = am.getAnnotation(Cluster.class).value();\n                for (Class<ClusterBroadcastFilter> c : value) {\n                    try {\n                        ClusterBroadcastFilter cbf = c.newInstance();\n                        cbf.setClusterName(am.getAnnotation(Cluster.class).name());\n                        f.addCluster(cbf);\n                    } catch (Throwable t) {\n                        logger.log(Level.WARNING, \"Invalid ClusterBroadcastFilter\", t);\n                    }\n                }\n            }\n        }\n\n        if (am.isAnnotationPresent(Suspend.class)) {\n                      \n            int value = am.getAnnotation(Suspend.class).period();\n            Suspend.SCOPE scope = am.getAnnotation(Suspend.class).scope();\n            boolean outputComments = am.getAnnotation(Suspend.class).outputComments();\n\n            Filter f;\n            if (am.getAnnotation(Suspend.class).resumeOnBroadcast()) {\n                f = new Filter(Action.SUSPEND_RESUME, value, 0, scope, outputComments);\n            } else {\n                f = new Filter(Action.SUSPEND, value, 0, scope,outputComments);\n            }\n            f.setListeners(am.getAnnotation(Suspend.class).listeners());\n\n            list.addFirst((ResourceFilter) f);\n        }\n\n        if (am.isAnnotationPresent(Resume.class)) {\n            int value = am.getAnnotation(Resume.class).value();\n            list.addFirst((ResourceFilter)\n                    new Filter(Action.RESUME, value));\n        }\n\n        if (am.isAnnotationPresent(Schedule.class)) {\n            int period = am.getAnnotation(Schedule.class).period();\n            int waitFor = am.getAnnotation(Schedule.class).waitFor();\n\n            if (am.getAnnotation(Schedule.class).resumeOnBroadcast()) {\n                list.addFirst((ResourceFilter)\n                        new Filter(Action.SCHEDULE_RESUME, period, waitFor));\n            } else {\n                list.addFirst((ResourceFilter)\n                        new Filter(Action.SCHEDULE, period, waitFor));\n            }\n        }\n\n        // Nothing, normal Jersey application.\n        return list.size() > 0 ? list : null;\n    }\n",
    "new_code_raw": "    public List<ResourceFilter> create(AbstractMethod am) {\n        LinkedList<ResourceFilter> list = new LinkedList<ResourceFilter>();\n        Filter f;\n        if (logger.isLoggable(Level.FINE)) {\n            for (Annotation a : am.getAnnotations()) {\n                logger.log(Level.FINE, \"AtmosphereFilter processing annotation: \" + a);\n            }\n        }\n\n        if (SuspendResponse.class.isAssignableFrom(am.getMethod().getReturnType())) {\n            list.addLast(new Filter(Action.SUSPEND_RESPONSE));\n            return list;\n        }\n\n        if (am.isAnnotationPresent(Broadcast.class)) {\n            int delay = am.getAnnotation(Broadcast.class).delay();\n            Class[] suspendTimeout = am.getAnnotation(Broadcast.class).value();\n\n            if (am.getAnnotation(Broadcast.class).resumeOnBroadcast()) {\n                f = new Filter(Action.RESUME_ON_BROADCAST, delay, 0, Suspend.SCOPE.APPLICATION, true, suspendTimeout);\n            } else {\n                f = new Filter(Action.BROADCAST, delay, 0, Suspend.SCOPE.APPLICATION, true, suspendTimeout);\n            }\n\n            list.addLast((ResourceFilter) f);\n\n            if (am.isAnnotationPresent(Cluster.class)) {\n                suspendTimeout = am.getAnnotation(Cluster.class).value();\n                for (Class<ClusterBroadcastFilter> c : suspendTimeout) {\n                    try {\n                        ClusterBroadcastFilter cbf = c.newInstance();\n                        cbf.setClusterName(am.getAnnotation(Cluster.class).name());\n                        f.addCluster(cbf);\n                    } catch (Throwable t) {\n                        logger.log(Level.WARNING, \"Invalid ClusterBroadcastFilter\", t);\n                    }\n                }\n            }\n        }\n\n        if (am.isAnnotationPresent(Suspend.class)) {\n\n            long suspendTimeout = am.getAnnotation(Suspend.class).period();\n            TimeUnit tu = am.getAnnotation(Suspend.class).timeUnit();\n            suspendTimeout = translateTimeUnit(suspendTimeout,tu);\n\n            Suspend.SCOPE scope = am.getAnnotation(Suspend.class).scope();\n            boolean outputComments = am.getAnnotation(Suspend.class).outputComments();\n\n            if (am.getAnnotation(Suspend.class).resumeOnBroadcast()) {\n                f = new Filter(Action.SUSPEND_RESUME, suspendTimeout, 0, scope, outputComments);\n            } else {\n                f = new Filter(Action.SUSPEND, suspendTimeout, 0, scope, outputComments);\n            }\n            f.setListeners(am.getAnnotation(Suspend.class).listeners());\n\n            list.addFirst((ResourceFilter) f);\n        }\n\n        if (am.isAnnotationPresent(Resume.class)) {\n            int suspendTimeout = am.getAnnotation(Resume.class).value();\n            list.addFirst((ResourceFilter)\n                    new Filter(Action.RESUME, suspendTimeout));\n        }\n\n        if (am.isAnnotationPresent(Schedule.class)) {\n            int period = am.getAnnotation(Schedule.class).period();\n            int waitFor = am.getAnnotation(Schedule.class).waitFor();\n\n            if (am.getAnnotation(Schedule.class).resumeOnBroadcast()) {\n                list.addFirst((ResourceFilter)\n                        new Filter(Action.SCHEDULE_RESUME, period, waitFor));\n            } else {\n                list.addFirst((ResourceFilter)\n                        new Filter(Action.SCHEDULE, period, waitFor));\n            }\n        }\n\n        // Nothing, normal Jersey application.\n        return list.size() > 0 ? list : null;\n    }\n"
  },
  {
    "id": "ansell_openrdf-sesame-162-Associations-FirstSentence",
    "old_comment_raw": "Encodes a value for use in a URL.",
    "new_comment_raw": "Encodes a value in a canonical serialized string format, for use in a URL query parameter.",
    "old_code_raw": "\tpublic static String encodeValue(Value value) {\r\n\t\treturn NTriplesUtil.toNTriplesString(value);\r\n\t}\r\n",
    "new_code_raw": "\tpublic static String encodeValue(Value value) {\r\n\t\tif (value instanceof BNode) {\r\n\t\t\t// SES-2129 special treatment of blank node names to avoid problems with round-tripping.\r\n\t\t\treturn ((BNode)value).getID();\r\n\t\t}\r\n\t\t\r\n\t\t// for everything else we just use N-Triples serialization.\r\n\t\treturn NTriplesUtil.toNTriplesString(value);\r\n\t}\r\n\n"
  },
  {
    "id": "JodaOrg_joda_time-513-FirstSentence-0",
    "old_comment_raw": "Instructs the printer to emit a numeric millisOfDay field.",
    "new_comment_raw": "Instructs the printer to emit a numeric millisOfDay field.",
    "old_code_raw": "    public DateTimeFormatterBuilder appendMillisOfDay(final int minDigits) {\n        return appendNumeric(iChronoUTC.millisOfDay(), minDigits, 8);\n    }\n",
    "new_code_raw": "    public DateTimeFormatterBuilder appendMillisOfDay(final int minDigits) {\n        return appendDecimal(iChronoUTC.millisOfDay(), minDigits, 8);\n    }\n"
  },
  {
    "id": "yahoo_elide-1-Associations-FirstSentence",
    "old_comment_raw": "Checks if this persistent resource's underlying entity has the @Shareable annotation.",
    "new_comment_raw": "Checks if this persistent resource's underlying entity is sharable.",
    "old_code_raw": "    private boolean isShareable() {\n        return getRequestScope().getDictionary().getAnnotation(obj.getClass(), Shareable.class) != null;\n    }\n",
    "new_code_raw": "    private boolean isShareable() {\n        return getRequestScope().getDictionary().isSharable(obj.getClass());\n    }\n\n"
  },
  {
    "id": "LawnchairLauncher_Lawnchair-435-FirstSentence-0",
    "old_comment_raw": "This method will extract the preview image specified by the widget developer (if it exists), otherwise, it will try to generate a default image preview with the widget's package icon.",
    "new_comment_raw": "This method will extract the preview image specified by the widget developer (if it exists), otherwise, it will try to generate a default image preview with the widget's package icon.",
    "old_code_raw": "    private FastBitmapDrawable getWidgetPreview(AppWidgetProviderInfo info) {\n        final PackageManager packageManager = mPackageManager;\n        String packageName = info.provider.getPackageName();\n        Drawable drawable = null;\n        FastBitmapDrawable newDrawable = null;\n        if (info.previewImage != 0) {\n            drawable = packageManager.getDrawable(packageName, info.previewImage, null);\n            if (drawable == null) {\n                Log.w(TAG, \"Can't load icon drawable 0x\" + Integer.toHexString(info.icon)\n                        + \" for provider: \" + info.provider);\n            }\n        }\n\n        // If we don't have a preview image, create a default one\n        final int minDim = mWorkspaceWidgetLayout.estimateCellWidth(1);\n        final int maxDim = mWorkspaceWidgetLayout.estimateCellWidth(3);\n        if (drawable == null) {\n            Resources resources = mLauncher.getResources();\n\n            // Create a new bitmap to hold the widget preview\n            int width = (int) (Math.max(minDim, Math.min(maxDim, info.minWidth)) * sScaleFactor);\n            int height = (int) (Math.max(minDim, Math.min(maxDim, info.minHeight)) * sScaleFactor);\n            final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);\n            final Drawable background = resources.getDrawable(R.drawable.default_widget_preview);\n            renderDrawableToBitmap(background, bitmap, 0, 0, width, height, 1.0f, 1.0f);\n\n            // Draw the icon flush left\n            try {\n                Drawable icon = null;\n                if (info.icon > 0) {\n                    icon = packageManager.getDrawable(packageName, info.icon, null);\n                }\n                if (icon == null) {\n                    icon = resources.getDrawable(R.drawable.ic_launcher_application);\n                }\n\n                final int iconSize = minDim / 2;\n                final int offset = iconSize / 4;\n                renderDrawableToBitmap(icon, null, offset, offset, iconSize, iconSize, 1.0f, 1.0f);\n            } catch (Resources.NotFoundException e) {\n                // if we can't find the icon, then just don't draw it\n            }\n\n            newDrawable = new FastBitmapDrawable(bitmap);\n        } else {\n            // Scale down the preview if necessary\n            final float imageWidth = drawable.getIntrinsicWidth();\n            final float imageHeight = drawable.getIntrinsicHeight();\n            final float aspect = (float) imageWidth / imageHeight;\n            final int scaledWidth =\n                (int) (Math.max(minDim, Math.min(maxDim, imageWidth)) * sScaleFactor);\n            final int scaledHeight =\n                (int) (Math.max(minDim, Math.min(maxDim, imageHeight)) * sScaleFactor);\n            int width;\n            int height;\n            if (aspect >= 1.0f) {\n                width = scaledWidth;\n                height = (int) (((float) scaledWidth / imageWidth) * imageHeight);\n            } else {\n                height = scaledHeight;\n                width = (int) (((float) scaledHeight / imageHeight) * imageWidth);\n            }\n\n            final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);\n            renderDrawableToBitmap(drawable, bitmap, 0, 0, width, height, 1.0f, 1.0f);\n\n            newDrawable = new FastBitmapDrawable(bitmap);\n        }\n        newDrawable.setBounds(0, 0, newDrawable.getIntrinsicWidth(),\n                newDrawable.getIntrinsicHeight());\n        return newDrawable;\n    }\n",
    "new_code_raw": "    private Bitmap getWidgetPreview(AppWidgetProviderInfo info) {\n        final PackageManager packageManager = mPackageManager;\n        String packageName = info.provider.getPackageName();\n        Drawable drawable = null;\n        if (info.previewImage != 0) {\n            drawable = packageManager.getDrawable(packageName, info.previewImage, null);\n            if (drawable == null) {\n                Log.w(TAG, \"Can't load icon drawable 0x\" + Integer.toHexString(info.icon)\n                        + \" for provider: \" + info.provider);\n            }\n        }\n\n        // If we don't have a preview image, create a default one\n        if (drawable == null) {\n            Resources resources = mLauncher.getResources();\n\n            // Create a new bitmap to hold the widget preview\n            int width = (int) (Math.max(mMinWidgetPreviewDim,\n                Math.min(mMaxWidgetPreviewDim, info.minWidth)) * sScaleFactor);\n            int height = (int) (Math.max(mMinWidgetPreviewDim,\n                Math.min(mMaxWidgetPreviewDim, info.minHeight)) * sScaleFactor);\n            final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);\n            final Drawable background = resources.getDrawable(R.drawable.default_widget_preview);\n            renderDrawableToBitmap(background, bitmap, 0, 0, width, height, 1.0f, 1.0f);\n\n            // Draw the icon flush left\n            try {\n                Drawable icon = null;\n                if (info.icon > 0) {\n                    icon = packageManager.getDrawable(packageName, info.icon, null);\n                }\n                if (icon == null) {\n                    icon = resources.getDrawable(R.drawable.ic_launcher_application);\n                }\n\n                final int iconSize = mMinWidgetPreviewDim / 2;\n                final int offset = iconSize / 4;\n                renderDrawableToBitmap(icon, null, offset, offset, iconSize, iconSize, 1.0f, 1.0f);\n            } catch (Resources.NotFoundException e) {\n                // if we can't find the icon, then just don't draw it\n            }\n\n            return bitmap;\n        } else {\n            // Scale down the preview if necessary\n            final float imageWidth = drawable.getIntrinsicWidth();\n            final float imageHeight = drawable.getIntrinsicHeight();\n            final float aspect = (float) imageWidth / imageHeight;\n            final int scaledWidth = (int) (Math.max(mMinWidgetPreviewDim,\n                Math.min(mMaxWidgetPreviewDim, imageWidth)) * sScaleFactor);\n            final int scaledHeight = (int) (Math.max(mMinWidgetPreviewDim,\n                Math.min(mMaxWidgetPreviewDim, imageHeight)) * sScaleFactor);\n            int width;\n            int height;\n            if (aspect >= 1.0f) {\n                width = scaledWidth;\n                height = (int) (((float) scaledWidth / imageWidth) * imageHeight);\n            } else {\n                height = scaledHeight;\n                width = (int) (((float) scaledHeight / imageHeight) * imageWidth);\n            }\n\n            final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);\n            renderDrawableToBitmap(drawable, bitmap, 0, 0, width, height, 1.0f, 1.0f);\n\n            return bitmap;\n        }\n    }\n"
  },
  {
    "id": "apache_lenya-336-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Get the column begin",
    "old_code_raw": "    public final int getBeginColumn() {\n        return bufcolumn[tokenBegin];\n    }\n",
    "new_code_raw": "    public final int getBeginColumn() {\n        return this.bufcolumn[this.tokenBegin];\n    }\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-1685-FirstSentence-0",
    "old_comment_raw": "check sub elements-nullability.",
    "new_comment_raw": "check sub elements-nullability.",
    "old_code_raw": "\tprivate String checkSubElementsNullability(Type propertyType, Object value) throws HibernateException {\n\t\t// IMPL NOTE : we currently skip checking \"any\" and \"many to any\" mappings.  This is not the best solution.\n\t\t//\n\t\t// The problem I ran into with performing the checks on \"any\" and \"many to any\" mappings had to do  with\n\t\t// cascaded saves of transient associated entities not yet having assigned the identifier (this was\n\t\t// specifically in the \"many to any\" case).\n\n\t\tif ( propertyType.isAnyType() ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( propertyType.isComponentType() ) {\n\t\t\treturn checkComponentNullability( value, (CompositeType) propertyType );\n\t\t}\n\n\t\tif ( propertyType.isCollectionType() ) {\n\t\t\t//persistent collections may have components\n\t\t\tfinal CollectionType collectionType = (CollectionType) propertyType;\n\t\t\tfinal Type collectionElementType = collectionType.getElementType( session.getFactory() );\n\n\t\t\tif ( collectionElementType.isAnyType() ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( collectionElementType.isComponentType() ) {\n\t\t\t\t//check for all components values in the collection\n\t\t\t\tfinal CompositeType componentType = (CompositeType) collectionElementType;\n\t\t\t\tfinal Iterator itr = CascadingActions.getLoadedElementsIterator( session, collectionType, value );\n\t\t\t\twhile ( itr.hasNext() ) {\n\t\t\t\t\tfinal Object compValue = itr.next();\n\t\t\t\t\tif ( compValue != null ) {\n\t\t\t\t\t\treturn checkComponentNullability( compValue, componentType );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n",
    "new_code_raw": "\tprivate String checkSubElementsNullability(Type propertyType, Object value) throws HibernateException {\n\t\tif ( propertyType.isComponentType() ) {\n\t\t\treturn checkComponentNullability( value, (CompositeType) propertyType );\n\t\t}\n\n\t\tif ( propertyType.isCollectionType() ) {\n\t\t\t// persistent collections may have components\n\t\t\tfinal CollectionType collectionType = (CollectionType) propertyType;\n\t\t\tfinal Type collectionElementType = collectionType.getElementType( session.getFactory() );\n\n\t\t\tif ( collectionElementType.isComponentType() ) {\n\t\t\t\t// check for all components values in the collection\n\t\t\t\tfinal CompositeType componentType = (CompositeType) collectionElementType;\n\t\t\t\tfinal Iterator itr = CascadingActions.getLoadedElementsIterator( session, collectionType, value );\n\t\t\t\twhile ( itr.hasNext() ) {\n\t\t\t\t\tfinal Object compositeElement = itr.next();\n\t\t\t\t\tif ( compositeElement != null ) {\n\t\t\t\t\t\treturn checkComponentNullability( compositeElement, componentType );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n"
  },
  {
    "id": "apache_deltaspike-18-Associations-FirstSentence",
    "old_comment_raw": "Repository access - lookup method information for a specific Repository class.",
    "new_comment_raw": "lookup the  RepositoryMethodMetadata for a specific repository and method.",
    "old_code_raw": "    public RepositoryMethodMetadata lookupMethod(Class<?> repoClass, Method method)\r\n    {\r\n        return lookupComponent(repoClass).getMethodsMetadata().get(method);\r\n    }\r\n",
    "new_code_raw": "    public RepositoryMethodMetadata lookupMethod(RepositoryMetadata repositoryMetadata, Method method)\r\n    {\r\n        return repositoryMetadata.getMethodsMetadata().get(method);\r\n    }\r\n\n"
  },
  {
    "id": "SeleniumHQ_selenium-646-FirstSentence-0",
    "old_comment_raw": "Returns the path to the Windows Program Files.",
    "new_comment_raw": "Returns the path to the Windows Program Files.",
    "old_code_raw": "  public static String getProgramFilesPath() {\n    loadEnvironment();\n    String pf = getEnvVarIgnoreCase(\"ProgramFiles\");\n    if (pf != null) {\n      File ProgramFiles = new File(pf);\n      if (ProgramFiles.exists()) {\n        return ProgramFiles.getAbsolutePath();\n      }\n    }\n    return new File(\"C:\\\\Program Files\").getAbsolutePath();\n  }\n",
    "new_code_raw": "  public static String getProgramFilesPath() {\n    return getEnvVarPath(\"ProgramFiles\", \"C:\\\\Program Files\");\n  }\n"
  },
  {
    "id": "gavioto_portecle-53-Associations-FirstSentence",
    "old_comment_raw": "Gets a string representation of the given object.",
    "new_comment_raw": "Gets a HTML escaped string representation of the given object.",
    "old_code_raw": "\tprivate static String stringify(Object obj)\n\t{\n\t\tif (obj instanceof DERString)\n\t\t{\n\t\t\treturn ((DERString) obj).getString();\n\t\t}\n\t\telse if (obj instanceof DERInteger || obj instanceof byte[])\n\t\t{\n\t\t\treturn convertToHexString(obj);\n\t\t}\n\t\telse if (obj instanceof ASN1TaggedObject)\n\t\t{\n\t\t\tASN1TaggedObject tagObj = (ASN1TaggedObject) obj;\n\t\t\t// Note: \"[\", _not_ '[' ...\n\t\t\treturn \"[\" + tagObj.getTagNo() + \"] \" + stringify(tagObj.getObject());\n\t\t}\n\t\telse if (obj instanceof ASN1Sequence)\n\t\t{\n\t\t\tASN1Sequence aObj = (ASN1Sequence) obj;\n\t\t\tStringBuilder tmp = new StringBuilder(\"[\");\n\t\t\tfor (int i = 0, len = aObj.size(); i < len; i++)\n\t\t\t{\n\t\t\t\ttmp.append(stringify(aObj.getObjectAt(i)));\n\t\t\t\tif (i != len - 1)\n\t\t\t\t{\n\t\t\t\t\ttmp.append(\", \");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tmp.append(\"]\").toString();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tString hex = null;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tMethod method = obj.getClass().getMethod(\"getOctets\", (Class[]) null);\n\t\t\t\thex = convertToHexString(method.invoke(obj, (Object[]) null));\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t\tif (hex == null && obj != null)\n\t\t\t{\n\t\t\t\thex = obj.toString();\n\t\t\t}\n\t\t\treturn hex;\n\t\t}\n\t}\n",
    "new_code_raw": "\tprivate static String stringify(Object obj)\n\t{\n\t\tif (obj instanceof DERString)\n\t\t{\n\t\t\treturn escapeHtml(((DERString) obj).getString());\n\t\t}\n\t\t// TODO: why not DERInteger as number?\n\t\telse if (obj instanceof DERInteger || obj instanceof byte[])\n\t\t{\n\t\t\treturn convertToHexString(obj);\n\t\t}\n\t\telse if (obj instanceof ASN1TaggedObject)\n\t\t{\n\t\t\tASN1TaggedObject tagObj = (ASN1TaggedObject) obj;\n\t\t\t// Note: \"[\", _not_ '[' ...\n\t\t\treturn \"[\" + tagObj.getTagNo() + \"] \" + stringify(tagObj.getObject());\n\t\t}\n\t\telse if (obj instanceof ASN1Sequence)\n\t\t{\n\t\t\tASN1Sequence aObj = (ASN1Sequence) obj;\n\t\t\tStringBuilder tmp = new StringBuilder(\"[\");\n\t\t\tfor (int i = 0, len = aObj.size(); i < len; i++)\n\t\t\t{\n\t\t\t\ttmp.append(stringify(aObj.getObjectAt(i)));\n\t\t\t\tif (i != len - 1)\n\t\t\t\t{\n\t\t\t\t\ttmp.append(\", \");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tmp.append(\"]\").toString();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tString hex = null;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tMethod method = obj.getClass().getMethod(\"getOctets\", (Class[]) null);\n\t\t\t\thex = convertToHexString(method.invoke(obj, (Object[]) null));\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t\tif (hex == null && obj != null)\n\t\t\t{\n\t\t\t\thex = escapeHtml(obj.toString());\n\t\t\t}\n\t\t\treturn hex;\n\t\t}\n\t}\n\n"
  },
  {
    "id": "graphql_java_graphql_java-359-FirstSentence-0",
    "old_comment_raw": "Returns a IDL Document that reprSesents the schema as defined by the introspection result map",
    "new_comment_raw": "Returns a IDL Document that reprSesents the schema as defined by the introspection result map",
    "old_code_raw": "    public Document createSchemaDefinition(Map<String, Object> introspectionResult) {\n        assertTrue(introspectionResult.get(\"__schema\") != null, \"__schema expected\");\n        Map<String, Object> schema = (Map<String, Object>) introspectionResult.get(\"__schema\");\n\n\n        Map<String, Object> queryType = (Map<String, Object>) schema.get(\"queryType\");\n        assertNotNull(queryType, \"queryType expected\");\n        TypeName query = new TypeName((String) queryType.get(\"name\"));\n        boolean nonDefaultQueryName = !\"Query\".equals(query.getName());\n\n        SchemaDefinition schemaDefinition = new SchemaDefinition();\n        schemaDefinition.getOperationTypeDefinitions().add(new OperationTypeDefinition(\"query\", query));\n\n        Map<String, Object> mutationType = (Map<String, Object>) schema.get(\"mutationType\");\n        boolean nonDefaultMutationName = false;\n        if (mutationType != null) {\n            TypeName mutation = new TypeName((String) mutationType.get(\"name\"));\n            nonDefaultMutationName = !\"Mutation\".equals(mutation.getName());\n            schemaDefinition.getOperationTypeDefinitions().add(new OperationTypeDefinition(\"mutation\", mutation));\n        }\n\n        Map<String, Object> subscriptionType = (Map<String, Object>) schema.get(\"subscriptionType\");\n        boolean nonDefaultSubscriptionName = false;\n        if (subscriptionType != null) {\n            TypeName subscription = new TypeName((String) subscriptionType.get(\"name\"));\n            nonDefaultSubscriptionName = !\"Subscription\".equals(subscription.getName());\n            schemaDefinition.getOperationTypeDefinitions().add(new OperationTypeDefinition(\"subscription\", subscription));\n        }\n\n        Document document = new Document();\n        if (nonDefaultQueryName || nonDefaultMutationName || nonDefaultSubscriptionName) {\n            document.getDefinitions().add(schemaDefinition);\n        }\n\n        List<Map<String, Object>> types = (List<Map<String, Object>>) schema.get(\"types\");\n        for (Map<String, Object> type : types) {\n            TypeDefinition typeDefinition = createTypeDefinition(type);\n            if (typeDefinition == null) continue;\n            document.getDefinitions().add(typeDefinition);\n        }\n\n        return document;\n    }\n",
    "new_code_raw": "    public Document createSchemaDefinition(Map<String, Object> introspectionResult) {\n        assertTrue(introspectionResult.get(\"__schema\") != null, \"__schema expected\");\n        Map<String, Object> schema = (Map<String, Object>) introspectionResult.get(\"__schema\");\n\n\n        Map<String, Object> queryType = (Map<String, Object>) schema.get(\"queryType\");\n        assertNotNull(queryType, \"queryType expected\");\n        TypeName query = TypeName.newTypeName().name((String) queryType.get(\"name\")).build();\n        boolean nonDefaultQueryName = !\"Query\".equals(query.getName());\n\n        SchemaDefinition.Builder schemaDefinition = SchemaDefinition.newSchemaDefintion();\n        schemaDefinition.operationTypeDefinition(OperationTypeDefinition.newOperationTypeDefinition().name(\"query\").type(query).build());\n\n        Map<String, Object> mutationType = (Map<String, Object>) schema.get(\"mutationType\");\n        boolean nonDefaultMutationName = false;\n        if (mutationType != null) {\n            TypeName mutation = TypeName.newTypeName().name((String) mutationType.get(\"name\")).build();\n            nonDefaultMutationName = !\"Mutation\".equals(mutation.getName());\n            schemaDefinition.operationTypeDefinition(OperationTypeDefinition.newOperationTypeDefinition().name(\"mutation\").type(mutation).build());\n        }\n\n        Map<String, Object> subscriptionType = (Map<String, Object>) schema.get(\"subscriptionType\");\n        boolean nonDefaultSubscriptionName = false;\n        if (subscriptionType != null) {\n            TypeName subscription = TypeName.newTypeName().name(((String) subscriptionType.get(\"name\"))).build();\n            nonDefaultSubscriptionName = !\"Subscription\".equals(subscription.getName());\n            schemaDefinition.operationTypeDefinition(OperationTypeDefinition.newOperationTypeDefinition().name(\"subscription\").type(subscription).build());\n        }\n\n        Document.Builder document = Document.newDocument();\n        if (nonDefaultQueryName || nonDefaultMutationName || nonDefaultSubscriptionName) {\n            document.definition(schemaDefinition.build());\n        }\n\n        List<Map<String, Object>> types = (List<Map<String, Object>>) schema.get(\"types\");\n        for (Map<String, Object> type : types) {\n            TypeDefinition typeDefinition = createTypeDefinition(type);\n            if (typeDefinition == null) continue;\n            document.definition(typeDefinition);\n        }\n\n        return document.build();\n    }\n"
  },
  {
    "id": "nickman_qreactor-3-Associations-FirstSentence",
    "old_comment_raw": "Returns",
    "new_comment_raw": "Returns the queue wire type",
    "old_code_raw": "\tpublic WireType getWireType() {\n\t\treturn wireType;\n\t}\n",
    "new_code_raw": "\tpublic WireType getWireType() {\n\t\treturn queue.wireType();\n\t}\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-1755-FirstSentence-0",
    "old_comment_raw": "Returns the Thread Context ClassLoader (TCCL).",
    "new_comment_raw": "Returns the Thread Context ClassLoader (TCCL).",
    "old_code_raw": "\tpublic static ClassLoader defaultClassLoader() {\n\t\treturn ClassLoaderHelper.getContextClassLoader();\n\t}\n",
    "new_code_raw": "\tpublic static ClassLoader defaultClassLoader() {\n\t\treturn Thread.currentThread().getContextClassLoader();\n\t}\n"
  },
  {
    "id": "RobotiumTech_robotium-8-Associations-FirstSentence",
    "old_comment_raw": "Searches for a search string in the EditTexts located in the current activity.",
    "new_comment_raw": "Searches for a text string in the edit texts located in the current activity.",
    "old_code_raw": "\t\n\tpublic EditText searchEditText(String search) {\n\t\tArrayList<EditText> editTextList = getCurrentEditTexts();\n\t\tIterator<EditText> iterator = editTextList.iterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tEditText editText = (EditText) iterator.next();\n\t\t\tif (editText.getText().toString().equals(search)) {\n\t\t\t\treturn editText;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t\t\n\t}\n",
    "new_code_raw": "\t\n\tpublic boolean searchEditText(String search) {\n\t\tPattern p = Pattern.compile(search);\n\t\tMatcher matcher;\n\t\tArrayList<EditText> editTextList = getCurrentEditTexts();\n\t\tIterator<EditText> iterator = editTextList.iterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tEditText editText = (EditText) iterator.next();\n\t\t\tmatcher = p.matcher(editText.getText().toString());\n\t\t\tif (matcher.matches()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (scrollDownList())\n\t\t\treturn searchEditText(search);\n\t\telse\n\t\t\treturn false;\n\t}\n\n"
  },
  {
    "id": "JodaOrg_joda_time-553-FirstSentence-0",
    "old_comment_raw": "Undos any changes that were made to this bucket since the given state was saved.",
    "new_comment_raw": "Undos any changes that were made to this bucket since the given state was saved.",
    "old_code_raw": "    public boolean undoChanges(Object savedState) {\n        if (savedState instanceof SavedState) {\n            return ((SavedState)savedState).revertState(this);\n        }\n        return false;\n    }\n",
    "new_code_raw": "    public boolean undoChanges(Object savedState) {\n        if (savedState instanceof SavedState) {\n            if (((SavedState)savedState).revertState(this)) {\n                iSavedState = savedState;\n                return true;\n            }\n        }\n        return false;\n    }\n"
  },
  {
    "id": "jenkinsci_analysis-core-plugin-37-Associations-FirstSentence",
    "old_comment_raw": "Returns the project.",
    "new_comment_raw": "Returns the job.",
    "old_code_raw": "    public AbstractProject<?, ?> getOwner() {\n        return project;\n    }\n",
    "new_code_raw": "    public Job<?, ?> getOwner() {\n        return job;\n    }\n\n"
  },
  {
    "id": "SeleniumHQ_selenium-595-FirstSentence-0",
    "old_comment_raw": "Gets the title of the current page.",
    "new_comment_raw": "Gets the title of the current page.",
    "old_code_raw": "  public String getTitle() {\n    return driver.getTitle();\n  }\n",
    "new_code_raw": "  public String getTitle() {\n    return (String) seleneseMethods.get(\"getTitle\").apply(driver);\n  }\n"
  },
  {
    "id": "svn2github_fleXive-62-Associations-FirstSentence",
    "old_comment_raw": "Get an iterator for all available versions",
    "new_comment_raw": "Get an array for all available versions (sorted)",
    "old_code_raw": "    public Integer[] getVersions() {\n        return versions.keySet().toArray(new Integer[versions.keySet().size()]);\n    }\n",
    "new_code_raw": "    public Integer[] getVersions() {\n        return vers;\n    }\n\n"
  },
  {
    "id": "pwittchen_ReactiveNetwork-17-FirstSentence-0",
    "old_comment_raw": "Filter, which returns true if at least one given type occurred",
    "new_comment_raw": "Filter, which returns true if at least one given type occurred",
    "old_code_raw": "  public static Predicate<Connectivity> hasType(final int... types) {\n    final int[] extendedTypes = appendUnknownNetworkTypeToTypes(types);\n    return new Predicate<Connectivity>() {\n      @Override public boolean test(@NonNull Connectivity connectivity) throws Exception {\n        for (int type : extendedTypes) {\n          if (connectivity.getType() == type) {\n            return true;\n          }\n        }\n        return false;\n      }\n    };\n  }\n",
    "new_code_raw": "  public static Predicate<Connectivity> hasType(final int... types) {\n    final int[] extendedTypes = appendUnknownNetworkTypeToTypes(types);\n    return new Predicate<Connectivity>() {\n      @Override public boolean test(@NonNull Connectivity connectivity) throws Exception {\n        for (int type : extendedTypes) {\n          if (connectivity.type() == type) {\n            return true;\n          }\n        }\n        return false;\n      }\n    };\n  }\n"
  },
  {
    "id": "eclipse_reddeer-109-Associations-FirstSentence",
    "old_comment_raw": "Returns console test.",
    "new_comment_raw": "Gets text from console.",
    "old_code_raw": "\tpublic String getConsoleText() {\n\t\tactivate();\n\t\tnew WaitUntil(new WidgetIsFound<org.eclipse.swt.custom.StyledText>(\n\t\t\t\tnew ClassMatcher(org.eclipse.swt.custom.StyledText.class)));\n\t\t// wait for text to appear\n\t\tnew WaitWhile(new ConsoleHasText(\"\"),TimePeriod.SHORT,false);\n\t\treturn new DefaultStyledText().getText();\n\t}\n",
    "new_code_raw": "\tpublic String getConsoleText() {\n\t\tactivate();\n\t\tWidgetIsFound<org.eclipse.swt.custom.StyledText> widgetIsFound = \n\t\t\t\tnew WidgetIsFound<org.eclipse.swt.custom.StyledText>(\n\t\t\t\tnew ClassMatcher(org.eclipse.swt.custom.StyledText.class));\n\t\tnew WaitUntil(widgetIsFound, TimePeriod.NORMAL, false);\n\t\t// Checck whether there is a console to display or not\n\t\tif (widgetIsFound.getWidget() == null) {\n\t\t\treturn null;\n\t\t}\n\t\t// wait for text to appear\n\t\tnew WaitWhile(new ConsoleHasText(\"\"),TimePeriod.SHORT,false);\n\t\treturn new DefaultStyledText().getText();\n\t}\n\n"
  },
  {
    "id": "querydsl_querydsl-759-FirstSentence-0",
    "old_comment_raw": "Register a table override",
    "new_comment_raw": "Register a table override",
    "old_code_raw": "    public String registerTableOverride(String oldTable, String newTable) {\n        return nameMapping.registerTableOverride(oldTable, newTable);\n    }\n",
    "new_code_raw": "    public String registerTableOverride(String oldTable, String newTable) {\n        return internalNameMapping.registerTableOverride(oldTable, newTable);\n    }\n"
  },
  {
    "id": "apache_axis1-java-117-Associations-FirstSentence",
    "old_comment_raw": "Get a String representation of the identity hashCode for a given",
    "new_comment_raw": "Get an IDKey that represents the unique identity of the object.",
    "old_code_raw": "    private String getIdentityKey(Object value) {\n        return \"\" + System.identityHashCode(value);\n    }\n",
    "new_code_raw": "    private IDKey getIdentityKey(Object value) {\n        return new IDKey(value);\n    }\n\n"
  },
  {
    "id": "apache_avro-0-FirstSentence-0",
    "old_comment_raw": "Returns the non-terminal that is the start symbol for grammar of the given schema sc.",
    "new_comment_raw": "Returns the non-terminal that is the start symbol for grammar of the given schema sc.",
    "old_code_raw": "  public Symbol generate(Schema sc, Map<LitS, Symbol> seen) {\n    switch (sc.getType()) {\n    case NULL:\n    case BOOLEAN:\n    case INT:\n    case LONG:\n    case FLOAT:\n    case DOUBLE:\n    case STRING:\n    case BYTES:\n    case FIXED:\n    case UNION:\n      return super.generate(sc, seen);\n    case ENUM:\n      return Symbol.seq(new Symbol.EnumLabelsAction(sc.getEnumSymbols()),\n          Symbol.ENUM);\n    case ARRAY:\n      return Symbol.seq(Symbol.ARRAY_END,\n          Symbol.repeat(Symbol.ARRAY_END,\n              Symbol.ITEM_END, generate(sc.getElementType(), seen)),\n          Symbol.ARRAY_START);\n    case MAP:\n      return Symbol.seq(Symbol.MAP_END,\n          Symbol.repeat(Symbol.MAP_END,\n              Symbol.ITEM_END, generate(sc.getValueType(), seen),\n              Symbol.MAP_KEY_MARKER, Symbol.STRING),\n          Symbol.MAP_START);\n    case RECORD: {\n      LitS wsc = new LitS(sc);\n      Symbol rresult = seen.get(wsc);\n      if (rresult == null) {\n        Symbol[] production = new Symbol[sc.getFields().size() * 2 + 2];\n        rresult = Symbol.seq(production);\n        seen.put(wsc, rresult);\n\n        int i = production.length;\n        int n = 0;\n        production[--i] = Symbol.RECORD_START;\n        for (Map.Entry<String, Field> f : sc.getFields().entrySet()) {\n          production[--i] = new Symbol.FieldAdjustAction(n, f.getKey());\n          production[--i] = generate(f.getValue().schema(), seen);\n          n++;\n        }\n        production[--i] = Symbol.RECORD_END;\n      }\n      return rresult;\n    }\n    default:\n      throw new RuntimeException(\"Unexpected schema type\");\n    }\n  }\n",
    "new_code_raw": "  public Symbol generate(Schema sc, Map<LitS, Symbol> seen) {\n    switch (sc.getType()) {\n    case NULL:\n    case BOOLEAN:\n    case INT:\n    case LONG:\n    case FLOAT:\n    case DOUBLE:\n    case STRING:\n    case BYTES:\n    case FIXED:\n    case UNION:\n      return super.generate(sc, seen);\n    case ENUM:\n      return Symbol.seq(new Symbol.EnumLabelsAction(sc.getEnumSymbols()),\n          Symbol.ENUM);\n    case ARRAY:\n      return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END,\n              Symbol.ITEM_END, generate(sc.getElementType(), seen)),\n          Symbol.ARRAY_START);\n    case MAP:\n      return Symbol.seq(Symbol.repeat(Symbol.MAP_END,\n              Symbol.ITEM_END, generate(sc.getValueType(), seen),\n              Symbol.MAP_KEY_MARKER, Symbol.STRING),\n          Symbol.MAP_START);\n    case RECORD: {\n      LitS wsc = new LitS(sc);\n      Symbol rresult = seen.get(wsc);\n      if (rresult == null) {\n        Symbol[] production = new Symbol[sc.getFields().size() * 2 + 2];\n        rresult = Symbol.seq(production);\n        seen.put(wsc, rresult);\n\n        int i = production.length;\n        int n = 0;\n        production[--i] = Symbol.RECORD_START;\n        for (Map.Entry<String, Field> f : sc.getFields().entrySet()) {\n          production[--i] = new Symbol.FieldAdjustAction(n, f.getKey());\n          production[--i] = generate(f.getValue().schema(), seen);\n          n++;\n        }\n        production[--i] = Symbol.RECORD_END;\n      }\n      return rresult;\n    }\n    default:\n      throw new RuntimeException(\"Unexpected schema type\");\n    }\n  }\n"
  },
  {
    "id": "mulesoft_google-connectors-suite-6-Associations-FirstSentence",
    "old_comment_raw": "Lists all comments for a file @sample.xml ../../../doc/GoogleDriveConnector.xml.sample google-drive:list-comments",
    "new_comment_raw": "Returns a paged  Iterator with all the  org.mule.module.google.drive.model.Comments for a file @sample.xml ../../../doc/GoogleDriveConnector.xml.sample google-drive:list-comments",
    "old_code_raw": "\t@Processor\n    @OAuthProtected\n\t@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)\n\t@Inject\n\tpublic List<Comment> listComments(\n\t\t\tMuleMessage message,\n\t\t\tString fileId,\n\t\t\t@Optional @Default(\"false\") boolean includeDeleted,\n\t\t\t@Optional @Default(\"100\") int maxResults,\n\t\t\t@Optional @Default(\"#[flowVars['GoogleDrive_NEXT_PAGE_TOKEN']]\") String pageToken,\n\t\t\t@Optional String updatedMin\n\t\t\t) throws IOException {\n\t\t\n\t\tCommentList response = this.client.comments().list(fileId)\n\t\t\t\t\t\t\t\t\t\t.setIncludeDeleted(includeDeleted)\n\t\t\t\t\t\t\t\t\t\t.setMaxResults(maxResults)\n\t\t\t\t\t\t\t\t\t\t.setPageToken(pageToken)\n\t\t\t\t\t\t\t\t\t\t.setUpdatedMin(updatedMin)\n\t\t\t\t\t\t\t\t\t\t.execute();\n\t\t\n\n\t\tPaginationUtils.savePageToken(NEXT_PAGE_TOKEN, response.getNextPageToken(), message);\n\t\treturn Comment.valueOf(response.getItems(), Comment.class);\n\t}\n",
    "new_code_raw": "\t@Processor\n    @OAuthProtected\n\t@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)\n\t@Paged\n\tpublic PagingDelegate<Comment> listComments(\n\t\t\tfinal String fileId,\n\t\t\tfinal @Optional @Default(\"false\") boolean includeDeleted,\n\t\t\tfinal @Optional @Default(\"100\") int maxResults,\n\t\t\tfinal @Optional String updatedMin,\n\t\t\tfinal PagingConfiguration pagingConfiguration\n\t\t\t) throws IOException {\n\t\t\n\t\treturn new TokenBasedPagingDelegate<Comment>() {\n\t\t\t\n\t\t\t@Override\n\t\t\tprotected List<Comment> doGetPage() throws IOException {\n\t\t\t\tCommentList response = client.comments().list(fileId)\n\t\t\t\t\t\t.setIncludeDeleted(includeDeleted)\n\t\t\t\t\t\t.setMaxResults(maxResults)\n\t\t\t\t\t\t.setPageToken(this.getPageToken())\n\t\t\t\t\t\t.setUpdatedMin(updatedMin)\n\t\t\t\t\t\t.execute();\n\t\t\t\t\n\t\t\t\tthis.setPageToken(response.getNextPageToken());\n\t\t\t\treturn Comment.valueOf(response.getItems(), Comment.class);\n\t\t\t}\n\t\t};\n\t\t\n\t}\n\n"
  },
  {
    "id": "dropwizard_dropwizard-6-FirstSentence-0",
    "old_comment_raw": "Returns a  Log instance with the same name as the given slf4j  org.slf4j.Logger instance.",
    "new_comment_raw": "Returns a  Log instance with the same name as the given slf4j  org.slf4j.Logger instance.",
    "old_code_raw": "    public static Log forSlf4jLogger(org.slf4j.Logger logger) {\n        return named(logger.getName());\n    }\n",
    "new_code_raw": "    public static Log forSlf4jLogger(org.slf4j.Logger logger) {\n        return new Log((Logger) logger);\n    }\n"
  },
  {
    "id": "trygvis_jop-162-Associations-FirstSentence",
    "old_comment_raw": "Parse a signature, with or without classname, with or without descriptor.",
    "new_comment_raw": "Parse a member ID, with or without classname, with or without descriptor.",
    "old_code_raw": "    public static MemberID parse(String signature, boolean isClassMember) {\n        return parse(signature, isClassMember, null);\n    }\n",
    "new_code_raw": "    public static MemberID parse(String memberID, boolean isClassMember) {\n        return parse(memberID, isClassMember, null);\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2019-FirstSentence-0",
    "old_comment_raw": "To test \\&quot;client\\&quot; model",
    "new_comment_raw": "To test \\&quot;client\\&quot; model",
    "old_code_raw": "    public ApiResponse<Client> testClientModelWithHttpInfo(Client body) throws ApiException {\n        okhttp3.Call call = testClientModelValidateBeforeCall(body, null, null);\n        Type localVarReturnType = new TypeToken<Client>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n",
    "new_code_raw": "    public ApiResponse<Client> testClientModelWithHttpInfo(Client body) throws ApiException {\n        okhttp3.Call localVarCall = testClientModelValidateBeforeCall(body, null, null);\n        Type localVarReturnType = new TypeToken<Client>(){}.getType();\n        return localVarApiClient.execute(localVarCall, localVarReturnType);\n    }\n"
  },
  {
    "id": "apache_james-project-2-Associations-FirstSentence",
    "old_comment_raw": "Creates a HBaseMessage from a Result object.",
    "new_comment_raw": "Creates a HBaseMailboxMessage from a Result object.",
    "old_code_raw": "    public static Message<HBaseId> messageMetaFromResult(Configuration conf, Result result) {\n        HBaseMessage message = null;\n        Flags flags = new Flags();\n        List<Property> propList = new ArrayList<Property>();\n        KeyValue[] keys = result.raw();\n        String mediaType = null, subType = null;\n        Long modSeq = null, uid, bodyOctets = null, contentOctets = null, textualLineCount = null;\n        Date internalDate = null;\n\n        int i = 0;\n        /** it is VERY IMPORTANT that the byte arrays are kept ascending */\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_BODY_OCTETS)) {\n            bodyOctets = Bytes.toLong(keys[i].getValue());\n            i++;\n        }\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_CONTENT_OCTETS)) {\n            contentOctets = Bytes.toLong(keys[i].getValue());\n            i++;\n        }\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_INTERNALDATE)) {\n            internalDate = new Date(Bytes.toLong(keys[i].getValue()));\n            i++;\n        }\n        // may be null so it will probably skip\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_TEXT_LINE_COUNT)) {\n            textualLineCount = Bytes.toLong(keys[i].getValue());\n            i++;\n        }\n\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_MODSEQ)) {\n            modSeq = Bytes.toLong(keys[i].getValue());\n            i++;\n        }\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_MEDIA_TYPE)) {\n            mediaType = Bytes.toString(keys[i].getValue());\n            i++;\n        }\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_SUB_TYPE)) {\n            subType = Bytes.toString(keys[i].getValue());\n            i++;\n        }\n        // only TEXT_LINE_COUNT can be missing if message is binary\n        if (i < 5) {\n            throw new RuntimeException(\"HBase message column names not sorted.\");\n        }\n        while (i < keys.length) {\n            //get message properties\n            if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_PROP_B)) {\n                propList.add(getProperty(keys[i].getValue()));\n            } else if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_SFLAGS_B)) {\n                // get system flags, stored as qualifiers\n                if (Bytes.equals(MARKER_PRESENT, keys[i].getValue())) {\n                    flags.add(systemFlagFromBytes(keys[i].getQualifier()));\n                }\n            } else if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_UFLAGS_B)) {\n                // get user flags, stored as value qualifier\n                flags.add(userFlagFromBytes(keys[i].getQualifier()));\n            }\n            i++;\n        }\n        HBaseId uuid = HBaseIdFromRowKey(result.getRow());\n        uid = Long.MAX_VALUE - Bytes.toLong(result.getRow(), 16);\n        PropertyBuilder props = new PropertyBuilder(propList);\n        props.setMediaType(mediaType);\n        props.setSubType(subType);\n        message = new HBaseMessage(conf, uuid, internalDate, flags, contentOctets, (int) (contentOctets - bodyOctets), props);\n        message.setUid(uid);\n        message.setModSeq(modSeq);\n        message.setTextualLineCount(textualLineCount);\n        return message;\n    }\n",
    "new_code_raw": "    public static MailboxMessage<HBaseId> messageMetaFromResult(Configuration conf, Result result) {\n        HBaseMailboxMessage message = null;\n        Flags flags = new Flags();\n        List<Property> propList = new ArrayList<Property>();\n        KeyValue[] keys = result.raw();\n        String mediaType = null, subType = null;\n        Long modSeq = null, uid, bodyOctets = null, contentOctets = null, textualLineCount = null;\n        Date internalDate = null;\n\n        int i = 0;\n        /** it is VERY IMPORTANT that the byte arrays are kept ascending */\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_BODY_OCTETS)) {\n            bodyOctets = Bytes.toLong(keys[i].getValue());\n            i++;\n        }\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_CONTENT_OCTETS)) {\n            contentOctets = Bytes.toLong(keys[i].getValue());\n            i++;\n        }\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_INTERNALDATE)) {\n            internalDate = new Date(Bytes.toLong(keys[i].getValue()));\n            i++;\n        }\n        // may be null so it will probably skip\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_TEXT_LINE_COUNT)) {\n            textualLineCount = Bytes.toLong(keys[i].getValue());\n            i++;\n        }\n\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_MODSEQ)) {\n            modSeq = Bytes.toLong(keys[i].getValue());\n            i++;\n        }\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_MEDIA_TYPE)) {\n            mediaType = Bytes.toString(keys[i].getValue());\n            i++;\n        }\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_SUB_TYPE)) {\n            subType = Bytes.toString(keys[i].getValue());\n            i++;\n        }\n        // only TEXT_LINE_COUNT can be missing if message is binary\n        if (i < 5) {\n            throw new RuntimeException(\"HBase message column names not sorted.\");\n        }\n        while (i < keys.length) {\n            //get message properties\n            if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_PROP_B)) {\n                propList.add(getProperty(keys[i].getValue()));\n            } else if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_SFLAGS_B)) {\n                // get system flags, stored as qualifiers\n                if (Bytes.equals(MARKER_PRESENT, keys[i].getValue())) {\n                    flags.add(systemFlagFromBytes(keys[i].getQualifier()));\n                }\n            } else if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_UFLAGS_B)) {\n                // get user flags, stored as value qualifier\n                flags.add(userFlagFromBytes(keys[i].getQualifier()));\n            }\n            i++;\n        }\n        HBaseId uuid = HBaseIdFromRowKey(result.getRow());\n        uid = Long.MAX_VALUE - Bytes.toLong(result.getRow(), 16);\n        PropertyBuilder props = new PropertyBuilder(propList);\n        props.setMediaType(mediaType);\n        props.setSubType(subType);\n        message = new HBaseMailboxMessage(conf, uuid, internalDate, flags, contentOctets, (int) (contentOctets - bodyOctets), props);\n        message.setUid(uid);\n        message.setModSeq(modSeq);\n        message.setTextualLineCount(textualLineCount);\n        return message;\n    }\n\n"
  },
  {
    "id": "apache_activemq-1032-FirstSentence-0",
    "old_comment_raw": "Copies the messages matching the given filter up to the maximum number of matched messages",
    "new_comment_raw": "Copies the messages matching the given filter up to the maximum number of matched messages",
    "old_code_raw": "    public int copyMatchingMessages(ConnectionContext context, MessageReferenceFilter filter, ActiveMQDestination dest, int maximumMessages) throws Exception {\n        pageInMessages();\n        int counter = 0;\n        synchronized (pagedInMessages) {\n            for (Iterator<MessageReference> i = pagedInMessages.iterator(); i.hasNext();) {\n                MessageReference r = i.next();\n                if (filter.evaluate(context, r)) {\n                    r.incrementReferenceCount();\n                    try {\n                        Message m = r.getMessage();\n                        BrokerSupport.resend(context, m, dest);\n                        if (++counter >= maximumMessages && maximumMessages > 0) {\n                            break;\n                        }\n                    } finally {\n                        r.decrementReferenceCount();\n                    }\n                }\n            }\n        }\n        return counter;\n    }\n",
    "new_code_raw": "    public int copyMatchingMessages(ConnectionContext context, MessageReferenceFilter filter, ActiveMQDestination dest, int maximumMessages) throws Exception {\n        int movedCounter = 0;\n        int count = 0;\n        List<MessageReference> list = null;\n        do {\n            pageInMessages();\n            synchronized (pagedInMessages) {\n                list = new ArrayList<MessageReference>(pagedInMessages.values());\n            }\n            for (MessageReference ref : list) {\n                IndirectMessageReference r = (IndirectMessageReference) ref;\n                if (filter.evaluate(context, r)) {\n                    // We should only copy messages that can be locked.\n                    if (lockMessage(r)) {\n                        r.incrementReferenceCount();\n                        try {\n                            Message m = r.getMessage();\n                            BrokerSupport.resend(context, m, dest);\n                            if (++movedCounter >= maximumMessages\n                                    && maximumMessages > 0) {\n                                return movedCounter;\n                            }\n                        } finally {\n                            r.decrementReferenceCount();\n                        }\n                    }\n                }\n                count++;\n            }\n        } while (count < this.destinationStatistics.getMessages().getCount());\n        return movedCounter;\n    }\n"
  },
  {
    "id": "bmatthews68_inmemdb-maven-plugin-1-Associations-FirstSentence",
    "old_comment_raw": "Get the database connection protocol.",
    "new_comment_raw": "Get the database connection protocol used for JDBC connections",
    "old_code_raw": "    protected String getUrlProtocol() {\r\n        return PROTOCOL;\r\n    }\r\n",
    "new_code_raw": "    protected String getUrlProtocol() {\r\n        return \"derby://localhost:\" + (getPort() > 0 ? getPort() : DEFAULT_PORT) + \"/memory:\";\r\n    }\r\n\n"
  },
  {
    "id": "debezium_debezium-1145-FirstSentence-0",
    "old_comment_raw": "Returns a  SchemaBuilder for a  MicroDuration.",
    "new_comment_raw": "Returns a  SchemaBuilder for a  MicroDuration.",
    "old_code_raw": "    public static SchemaBuilder builder() {\n        return SchemaBuilder.float64()\n                            .name(SCHEMA_NAME)\n                            .version(1);\n    }\n",
    "new_code_raw": "    public static SchemaBuilder builder() {\n        return SchemaBuilder.int64()\n                            .name(SCHEMA_NAME)\n                            .version(1);\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-1486-FirstSentence-0",
    "old_comment_raw": "Searches for a toggle button with the given search string and returns true if the searched toggle button is found a given number of times",
    "new_comment_raw": "Searches for a toggle button with the given regex string and returns true if the searched toggle button is found a given number of times",
    "old_code_raw": "\tprivate boolean searchForToggleButton(String search, int matches) {\n\t\tsleeper.sleep();\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(search);\n\t\tMatcher matcher;\n\t\tArrayList<ToggleButton> toggleButtonList = viewFetcher.getCurrentViews(ToggleButton.class);\n\t\tif(matches == 0)\n\t\t\tmatches = 1;\n\t\tfor(ToggleButton toggleButton : toggleButtonList){\n\t\t\tmatcher = p.matcher(toggleButton.getText().toString());\n\t\t\tif(matcher.find()){\t\n\t\t\t\tcountMatches++;\n\t\t\t}\n\t\t\tif (countMatches == matches) {\n\t\t\t\tcountMatches=0;\n\t\t\t\treturn true;\n\t\t\t} \n\t\t}\n\n\t\tif (scroller.scroll(Scroller.Direction.DOWN))\n\t\t{\n\t\t\treturn searchForToggleButton(search, matches);\n\t\t} else {\n\t\t\tif(countMatches > 0)\n\t\t\t\tLog.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + search);\n\t\t\tcountMatches = 0;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t}\n",
    "new_code_raw": "\tprivate boolean searchForToggleButton(String regex, int matches) {\n\t\tsleeper.sleep();\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(regex);\n\t\tMatcher matcher;\n\t\tArrayList<ToggleButton> toggleButtonList = viewFetcher.getCurrentViews(ToggleButton.class);\n\t\tif(matches == 0)\n\t\t\tmatches = 1;\n\t\tfor(ToggleButton toggleButton : toggleButtonList){\n\t\t\tmatcher = p.matcher(toggleButton.getText().toString());\n\t\t\tif(matcher.find()){\t\n\t\t\t\tcountMatches++;\n\t\t\t}\n\t\t\tif (countMatches == matches) {\n\t\t\t\tcountMatches=0;\n\t\t\t\treturn true;\n\t\t\t} \n\t\t}\n\n\t\tif (scroller.scroll(Scroller.Direction.DOWN))\n\t\t{\n\t\t\treturn searchForToggleButton(regex, matches);\n\t\t} else {\n\t\t\tif(countMatches > 0)\n\t\t\t\tLog.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + regex);\n\t\t\tcountMatches = 0;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t}\n"
  },
  {
    "id": "hibernate_hibernate_orm-1556-FirstSentence-0",
    "old_comment_raw": "Parses the given xml configuration files and returns a updated annotation index",
    "new_comment_raw": "Parses the given xml configuration files and returns a updated annotation index",
    "old_code_raw": "\tpublic Index parseAndUpdateIndex(List<JaxbRoot<XMLEntityMappings>> mappings, Index annotationIndex) {\n\t\tList<XMLEntityMappings> list = new ArrayList<XMLEntityMappings>( mappings.size() );\n\t\tfor ( JaxbRoot<XMLEntityMappings> jaxbRoot : mappings ) {\n\t\t\tlist.add( jaxbRoot.getRoot() );\n\t\t}\n\t\treturn new EntityMappingsMocker(\n\t\t\t\tlist, annotationIndex, meta.getServiceRegistry()\n\t\t).mockNewIndex();\n\t}\n",
    "new_code_raw": "\tpublic Index parseAndUpdateIndex(List<JaxbRoot<XMLEntityMappings>> mappings, Index annotationIndex) {\n\t\tList<XMLEntityMappings> list = new ArrayList<XMLEntityMappings>( mappings.size() );\n\t\tfor ( JaxbRoot<XMLEntityMappings> jaxbRoot : mappings ) {\n\t\t\tlist.add( jaxbRoot.getRoot() );\n\t\t}\n\t\treturn new EntityMappingsMocker( list, annotationIndex, metadata.getServiceRegistry() ).mockNewIndex();\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2081-FirstSentence-0",
    "old_comment_raw": "To test special tags",
    "new_comment_raw": "To test special tags",
    "old_code_raw": "  public Client call123testSpecialTags(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling call123testSpecialTags\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/another-fake/dummy\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public Client call123testSpecialTags(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling call123testSpecialTags\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/another-fake/dummy\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, String> localVarCookieParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "cemcatik_jtds-114-Associations-FirstSentence",
    "old_comment_raw": "Helper method to invoke  SharedNamedPipe#calculateBufferSize(int, int) using reflection.",
    "new_comment_raw": "Helper method to invoke  Support#calculateNamedPipeBufferSize(int, int) using reflection.",
    "old_code_raw": "    private int invoke_calculateBufferSize(int tdsVersion, int packetSize) {\n        Class[] classes = new Class[]{int.class, int.class};\n        Object[] objects = new Object[]{new Integer(tdsVersion), new Integer(packetSize)};\n\n        return ((Integer) invokeStaticMethod(SharedNamedPipe.class,\n                \"calculateBufferSize\", classes, objects)).intValue();\n    }\n",
    "new_code_raw": "    private int invoke_calculateBufferSize(int tdsVersion, int packetSize) {\n        Class[] classes = new Class[]{int.class, int.class};\n        Object[] objects = new Object[]{new Integer(tdsVersion), new Integer(packetSize)};\n\n        return ((Integer) invokeStaticMethod(Support.class,\n                \"calculateNamedPipeBufferSize\", classes, objects)).intValue();\n    }\n\n"
  },
  {
    "id": "Netflix_eureka-351-FirstSentence-0",
    "old_comment_raw": "Gets the full registry information from the eureka server and stores it locally.",
    "new_comment_raw": "Gets the full registry information from the eureka server and stores it locally.",
    "old_code_raw": "    private ClientResponse getAndStoreFullRegistry() throws Throwable {\n        long currentUpdateGeneration = fetchRegistryGeneration.get();\n        ClientResponse response = makeRemoteCall(Action.Refresh);\n        logger.info(\"Getting all instance registry info from the eureka server\");\n\n        Applications apps = null;\n        if (response.getStatus() == Status.OK.getStatusCode()) {\n            apps = response.getEntity(Applications.class);\n        }\n\n        if (apps == null) {\n            logger.error(\"The application is null for some reason. Not storing this information\");\n        } else if (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + 1)) {\n            localRegionApps.set(this.filterAndShuffle(apps));\n            logger.debug(\"Got full registry with apps hashcode {}\", apps.getAppsHashCode());\n        } else {\n            logger.warn(\"Not updating applications as another thread is updating it already\");\n        }\n        logger.info(\"The response status is {}\", response.getStatus());\n        return response;\n    }\n",
    "new_code_raw": "    private void getAndStoreFullRegistry() throws Throwable {\n        long currentUpdateGeneration = fetchRegistryGeneration.get();\n\n        logger.info(\"Getting all instance registry info from the eureka server\");\n\n        Applications apps = null;\n        if (shouldUseExperimentalTransport()) {\n            EurekaHttpResponse<Applications> httpResponse = clientConfig.getRegistryRefreshSingleVipAddress() == null\n                    ? eurekaHttpClient.getApplications()\n                    : eurekaHttpClient.getVip(clientConfig.getRegistryRefreshSingleVipAddress());\n            if (httpResponse.getStatusCode() == Status.OK.getStatusCode()) {\n                apps = httpResponse.getEntity();\n            }\n            logger.info(\"The response status is {}\", httpResponse.getStatusCode());\n        } else {\n            ClientResponse response = makeRemoteCall(Action.Refresh);\n            try {\n                if (response.getStatus() == Status.OK.getStatusCode()) {\n                    apps = response.getEntity(Applications.class);\n                }\n                logger.info(\"The response status is {}\", response.getStatus());\n            } finally {\n                closeResponse(response);\n            }\n        }\n\n        if (apps == null) {\n            logger.error(\"The application is null for some reason. Not storing this information\");\n        } else if (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + 1)) {\n            localRegionApps.set(this.filterAndShuffle(apps));\n            logger.debug(\"Got full registry with apps hashcode {}\", apps.getAppsHashCode());\n        } else {\n            logger.warn(\"Not updating applications as another thread is updating it already\");\n        }\n    }\n"
  },
  {
    "id": "Netflix_eureka-333-FirstSentence-0",
    "old_comment_raw": "Checks to see if the eureka client registration is enabled.",
    "new_comment_raw": "Checks to see if the eureka client registration is enabled.",
    "old_code_raw": "    private boolean shouldRegister(InstanceInfo myInfo) {\n        if (!clientConfig.shouldRegisterWithEureka()) {\n            return false;\n        }\n\n        return true;\n    }\n",
    "new_code_raw": "    private boolean shouldRegister(InstanceInfo myInfo) {\n        if (!clientConfig.shouldRegisterWithEureka()) {\n            return false;\n        } else if ((myInfo != null)\n                && (myInfo.getDataCenterInfo()\n                        .equals(DataCenterInfo.Name.Amazon))) {\n            return true;\n        }\n\n        return true;\n    }\n"
  },
  {
    "id": "apache_lenya-283-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Returns the path to the live tree",
    "old_code_raw": "    public String getTreeLivePath() {\n        return treeLivePath;\n    }\n",
    "new_code_raw": "    public String getTreeLivePath() {\n        return this.treeLivePath;\n    }\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-1522-FirstSentence-0",
    "old_comment_raw": "Read mappings from a particular XML file",
    "new_comment_raw": "Read mappings from a particular XML file",
    "old_code_raw": "\tpublic Configuration addFile(final File xmlFile) throws MappingException {\n\t\tlog.info( \"Reading mappings from file: \" + xmlFile.getPath() );\n\n\t\tfinal String name =  xmlFile.getAbsolutePath();\n\t\tfinal InputSource inputSource;\n\t\ttry {\n\t\t\tinputSource = new InputSource( new FileInputStream( xmlFile ) );\n\t\t}\n\t\tcatch ( FileNotFoundException e ) {\n\t\t\tthrow new MappingNotFoundException( \"file\", xmlFile.toString() );\n\t\t}\n\n\t\tadd(\n\t\t\t\tnew XMLHelper.MetadataXmlSource() {\n\t\t\t\t\tprivate final Origin origin = new Origin() {\n\t\t\t\t\t\tpublic String getType() {\n\t\t\t\t\t\t\treturn \"file\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpublic String getName() {\n\t\t\t\t\t\t\treturn name;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tpublic Origin getOrigin() {\n\t\t\t\t\t\treturn origin;\n\t\t\t\t\t}\n\n\t\t\t\t\tpublic InputSource getInputSource() {\n\t\t\t\t\t\treturn inputSource;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn this;\n\t}\n",
    "new_code_raw": "\tpublic Configuration addFile(final File xmlFile) throws MappingException {\n\t\tlog.info( \"Reading mappings from file: \" + xmlFile.getPath() );\n\t\tfinal String name =  xmlFile.getAbsolutePath();\n\t\tfinal InputSource inputSource;\n\t\ttry {\n\t\t\tinputSource = new InputSource( new FileInputStream( xmlFile ) );\n\t\t}\n\t\tcatch ( FileNotFoundException e ) {\n\t\t\tthrow new MappingNotFoundException( \"file\", xmlFile.toString() );\n\t\t}\n\t\tadd( inputSource, \"file\", name );\n\t\treturn this;\n\t}\n"
  },
  {
    "id": "Atmosphere_atmosphere-630-FirstSentence-0",
    "old_comment_raw": "Configure the  AtmosphereResourceEvent state (suspend, resume, broadcast) based on the annotation the web application has used.",
    "new_comment_raw": "Configure the  AtmosphereResourceEvent state (suspend, resume, broadcast) based on the annotation the web application has used.",
    "old_code_raw": "        public ContainerResponse filter(final ContainerRequest request, final ContainerResponse response) {\n            if (response.getMappedThrowable() != null) {\n                return response;\n            }\n\n            AtmosphereResource<HttpServletRequest, HttpServletResponse> r =\n                    (AtmosphereResource<HttpServletRequest, HttpServletResponse>) servletReq\n                            .getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n\n            if (Boolean.parseBoolean((String) servletReq.getAttribute(ApplicationConfig.SUPPORT_LOCATION_HEADER))) {\n                useResumeAnnotation = true;\n            }\n\n            switch (action) {\n                case ASYNCHRONOUS:\n                    // Force the status code to 200 events independently of the value of the entity (null or not)\n                    if (response.getStatus() == 204) {\n                        response.setStatus(200);\n                    }\n\n                    String transport = servletReq.getHeader(X_ATMOSPHERE_TRANSPORT);\n                    if (transport == null) {\n                        throw new WebApplicationException(new IllegalStateException(\"Must specify transport using header value \"\n                                + X_ATMOSPHERE_TRANSPORT));\n                    }\n                    String subProtocol = (String) servletReq.getAttribute(FrameworkConfig.WEBSOCKET_SUBPROTOCOL);\n\n                    String broadcasterName = servletReq.getHeader(topic);\n                    final boolean waitForResource = waitFor == -1 ? true : false;\n                    final Broadcaster bcaster = BroadcasterFactory.getDefault().lookup(broadcasterName, true);\n\n                    if (!transport.startsWith(POLLING_TRANSPORT) && subProtocol == null) {\n                        boolean outputJunk = transport.equalsIgnoreCase(STREAMING_TRANSPORT);\n                        final boolean resumeOnBroadcast = resumeOnBroadcast(false);\n\n                        for (Class<? extends AtmosphereResourceEventListener> listener : listeners) {\n                            try {\n                                AtmosphereResourceEventListener el = listener.newInstance();\n                                InjectorProvider.getInjector().inject(el);\n                                if (r instanceof AtmosphereEventLifecycle) {\n                                    r.addEventListener(el);\n                                }\n                            } catch (Throwable t) {\n                                throw new WebApplicationException(\n                                        new IllegalStateException(\"Invalid AtmosphereResourceEventListener \" + listener));\n                            }\n                        }\n                        final Object entity = response.getEntity();\n\n                        r.addEventListener(new AtmosphereResourceEventListenerAdapter() {\n                            @Override\n                            public void onSuspend(AtmosphereResourceEvent<HttpServletRequest, HttpServletResponse> event) {\n                                try {\n                                    if (entity != null) {\n                                        if (waitForResource) {\n                                            bcaster.awaitAndBroadcast(entity, 30, TimeUnit.SECONDS);\n                                        } else {\n                                            bcaster.broadcast(entity);\n                                        }\n                                    }\n                                } finally {\n                                    event.getResource().removeEventListener(this);\n                                }\n                            }\n                        });\n\n                        if (resumeOnBroadcast) {\n                            servletReq.setAttribute(ApplicationConfig.RESUME_ON_BROADCAST, new Boolean(true));\n                        }\n\n                        r.setBroadcaster(bcaster);\n                        executeSuspend(r, timeout, outputJunk, resumeOnBroadcast, null, request, response, false);\n                    } else {\n                        Object entity = response.getEntity();\n                        if (waitForResource) {\n                            bcaster.awaitAndBroadcast(entity, 30, TimeUnit.SECONDS);\n                        } else {\n                            bcaster.broadcast(entity);\n                        }\n\n                        if (subProtocol == null) {\n                            try {\n                                if (Callable.class.isAssignableFrom(entity.getClass())) {\n                                    entity = Callable.class.cast(entity).call();\n                                }\n                                response.setEntity(entity);\n                                response.write();\n                            } catch (Throwable t) {\n                                logger.debug(\"Error running Callable\", t);\n                                response.setEntity(null);\n                            }\n                        } else {\n                            response.setEntity(null);\n                        }\n                    }\n                    break;\n                case SUSPEND_RESPONSE:\n                    SuspendResponse<?> s = SuspendResponse.class.cast(JResponseAsResponse.class.cast(response.getResponse()).getJResponse());\n\n                    boolean outputJunk = outputJunk(s.outputComments());\n                    boolean resumeOnBroadcast = resumeOnBroadcast(s.resumeOnBroadcast());\n\n                    for (AtmosphereResourceEventListener el : s.listeners()) {\n                        if (r instanceof AtmosphereEventLifecycle) {\n                            r.addEventListener(el);\n                        }\n                    }\n\n                    Broadcaster bc = s.broadcaster();\n                    if (bc == null && s.scope() != Suspend.SCOPE.REQUEST) {\n                        bc = (Broadcaster) servletReq.getAttribute(INJECTED_BROADCASTER);\n                    }\n\n                    boolean supportTrackable = servletReq.getAttribute(ApplicationConfig.SUPPORT_TRACKABLE) != null;\n                    // Register our TrackableResource\n                    boolean isTracked = response.getEntity() != null ? TrackableResource.class.isAssignableFrom(response.getEntity().getClass()) : supportTrackable;\n\n                    TrackableResource<? extends Trackable> trackableResource = null;\n                    if (isTracked) {\n                        trackableResource = preTrack(request, response);\n                    }\n\n                    suspend(resumeOnBroadcast, outputJunk,\n                            translateTimeUnit(s.period().value(), s.period().timeUnit()), request, response, bc, r, s.scope());\n\n                    // Associate the tracked resource.\n                    if (isTracked && trackableResource != null) {\n                        postTrack(trackableResource, r);\n                    }\n\n                    break;\n                case SUBSCRIBE_TRACKABLE:\n                case SUBSCRIBE:\n                case SUSPEND:\n                case SUSPEND_TRACKABLE:\n                case SUSPEND_RESUME:\n                    outputJunk = outputJunk(outputComments);\n                    resumeOnBroadcast = resumeOnBroadcast((action == Action.SUSPEND_RESUME));\n\n                    for (Class<? extends AtmosphereResourceEventListener> listener : listeners) {\n                        try {\n                            AtmosphereResourceEventListener el = listener.newInstance();\n                            InjectorProvider.getInjector().inject(el);\n                            if (r instanceof AtmosphereEventLifecycle) {\n                                ((AtmosphereEventLifecycle) r).addEventListener(el);\n                            }\n                        } catch (Throwable t) {\n                            throw new WebApplicationException(\n                                    new IllegalStateException(\"Invalid AtmosphereResourceEventListener \" + listener, t));\n                        }\n                    }\n\n                    Broadcaster broadcaster = (Broadcaster) servletReq.getAttribute(INJECTED_BROADCASTER);\n                    // @Subscribe\n                    if (action == Action.SUBSCRIBE) {\n                        Class<Broadcaster> c = null;\n                        try {\n                            c = (Class<Broadcaster>) Class.forName((String) servletReq.getAttribute(ApplicationConfig.BROADCASTER_CLASS));\n                        } catch (Throwable e) {\n                            throw new IllegalStateException(e.getMessage());\n                        }\n                        broadcaster = BroadcasterFactory.getDefault().lookup(c, topic, true);\n                    }\n\n                    // Tracking is enabled by default\n                    supportTrackable = servletReq.getAttribute(ApplicationConfig.SUPPORT_TRACKABLE) != null;\n                    // Register our TrackableResource\n                    isTracked = response.getEntity() != null ? TrackableResource.class.isAssignableFrom(response.getEntity().getClass()) : supportTrackable;\n\n                    if (isTracked) {\n                        trackableResource = preTrack(request, response);\n                    } else {\n                        trackableResource = null;\n                    }\n\n                    suspend(resumeOnBroadcast, outputJunk, timeout, request, response,\n                            broadcaster, r, scope);\n\n                    // Associate the tracked resource.\n                    if (isTracked && trackableResource != null) {\n                        postTrack(trackableResource, r);\n                    }\n                    break;\n                case RESUME:\n                    if (response.getEntity() != null) {\n                        try {\n                            response.write();\n                        } catch (IOException ex) {\n                            throw new WebApplicationException(ex);\n                        }\n                    }\n\n                    boolean sessionSupported = (Boolean) servletReq.getAttribute(FrameworkConfig.SUPPORT_SESSION);\n                    if (sessionSupported) {\n                        r = (AtmosphereResource) servletReq.getSession().getAttribute(SUSPENDED_RESOURCE);\n                    } else {\n                        String path = response.getContainerRequest().getPath();\n                        r = resumeCandidates.remove(path.substring(path.lastIndexOf(\"/\") + 1));\n                    }\n\n                    if (r != null) {\n                        resume(r);\n                    } else {\n                        throw new WebApplicationException(\n                                new IllegalStateException(\"Unable to retrieve suspended Response. \" +\n                                        \"Either session-support is not enabled in atmosphere.xml or the\" +\n                                        \"path used to resume is invalid.\"));\n\n                    }\n                    break;\n                case BROADCAST:\n                case PUBLISH:\n                case RESUME_ON_BROADCAST:\n                    AtmosphereResource ar = (AtmosphereResource) servletReq.getAttribute(SUSPENDED_RESOURCE);\n                    if (ar != null) {\n                        r = ar;\n                    }\n\n                    if (action == Action.PUBLISH) {\n                        Class<Broadcaster> c = null;\n                        try {\n                            c = (Class<Broadcaster>) Class.forName((String) servletReq.getAttribute(ApplicationConfig.BROADCASTER_CLASS));\n                        } catch (Throwable e) {\n                            throw new IllegalStateException(e.getMessage());\n                        }\n                        r.setBroadcaster(BroadcasterFactory.getDefault().lookup(c, topic, true));\n                    }\n\n                    broadcast(response, r, timeout);\n                    break;\n                case SCHEDULE:\n                case SCHEDULE_RESUME:\n                    Object o = response.getEntity();\n                    Broadcaster b = r.getBroadcaster();\n                    if (response.getEntity() instanceof Broadcastable) {\n                        b = ((Broadcastable) response.getEntity()).getBroadcaster();\n                        o = ((Broadcastable) response.getEntity()).getMessage();\n                        response.setEntity(((Broadcastable) response.getEntity()).getResponseMessage());\n                    }\n\n                    if (response.getEntity() != null) {\n                        try {\n                            response.write();\n                        } catch (IOException ex) {\n                            throw new WebApplicationException(ex);\n                        }\n                    }\n\n                    if (action == Action.SCHEDULE_RESUME) {\n                        configureResumeOnBroadcast(b);\n                    }\n\n                    b.scheduleFixedBroadcast(o, waitFor, timeout, TimeUnit.SECONDS);\n                    break;\n            }\n\n            return response;\n        }\n",
    "new_code_raw": "        public ContainerResponse filter(final ContainerRequest request, final ContainerResponse response) {\n            if (response.getMappedThrowable() != null) {\n                return response;\n            }\n\n            AtmosphereResource<HttpServletRequest, HttpServletResponse> r =\n                    (AtmosphereResource<HttpServletRequest, HttpServletResponse>) servletReq\n                            .getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n\n            if (Boolean.parseBoolean((String) servletReq.getAttribute(ApplicationConfig.SUPPORT_LOCATION_HEADER))) {\n                useResumeAnnotation = true;\n            }\n\n            switch (action) {\n                case ASYNCHRONOUS:\n                    // Force the status code to 200 events independently of the value of the entity (null or not)\n                    if (response.getStatus() == 204) {\n                        response.setStatus(200);\n                    }\n\n                    String transport = servletReq.getHeader(X_ATMOSPHERE_TRANSPORT);\n                    if (transport == null) {\n                        logger.debug(\"Must specify transport using header value \" + X_ATMOSPHERE_TRANSPORT);\n                        response.setStatus(400);\n                        return response;\n                    }\n                    String subProtocol = (String) servletReq.getAttribute(FrameworkConfig.WEBSOCKET_SUBPROTOCOL);\n\n                    String broadcasterName = servletReq.getHeader(topic);\n                    final boolean waitForResource = waitFor == -1 ? true : false;\n                    final Broadcaster bcaster = BroadcasterFactory.getDefault().lookup(broadcasterName, true);\n\n                    if (!transport.startsWith(POLLING_TRANSPORT) && subProtocol == null) {\n                        boolean outputJunk = transport.equalsIgnoreCase(STREAMING_TRANSPORT);\n                        final boolean resumeOnBroadcast = resumeOnBroadcast(false);\n\n                        for (Class<? extends AtmosphereResourceEventListener> listener : listeners) {\n                            try {\n                                AtmosphereResourceEventListener el = listener.newInstance();\n                                InjectorProvider.getInjector().inject(el);\n                                if (r instanceof AtmosphereEventLifecycle) {\n                                    r.addEventListener(el);\n                                }\n                            } catch (Throwable t) {\n                                throw new WebApplicationException(\n                                        new IllegalStateException(\"Invalid AtmosphereResourceEventListener \" + listener));\n                            }\n                        }\n                        final Object entity = response.getEntity();\n\n                        r.addEventListener(new AtmosphereResourceEventListenerAdapter() {\n                            @Override\n                            public void onSuspend(AtmosphereResourceEvent<HttpServletRequest, HttpServletResponse> event) {\n                                try {\n                                    if (entity != null) {\n                                        if (waitForResource) {\n                                            bcaster.awaitAndBroadcast(entity, 30, TimeUnit.SECONDS);\n                                        } else {\n                                            bcaster.broadcast(entity);\n                                        }\n                                    }\n                                } finally {\n                                    event.getResource().removeEventListener(this);\n                                }\n                            }\n                        });\n\n                        if (resumeOnBroadcast) {\n                            servletReq.setAttribute(ApplicationConfig.RESUME_ON_BROADCAST, new Boolean(true));\n                        }\n\n                        r.setBroadcaster(bcaster);\n                        executeSuspend(r, timeout, outputJunk, resumeOnBroadcast, null, request, response, false);\n                    } else {\n                        Object entity = response.getEntity();\n                        if (waitForResource) {\n                            bcaster.awaitAndBroadcast(entity, 30, TimeUnit.SECONDS);\n                        } else {\n                            bcaster.broadcast(entity);\n                        }\n\n                        if (subProtocol == null) {\n                            try {\n                                if (Callable.class.isAssignableFrom(entity.getClass())) {\n                                    entity = Callable.class.cast(entity).call();\n                                }\n                                response.setEntity(entity);\n                                response.write();\n                            } catch (Throwable t) {\n                                logger.debug(\"Error running Callable\", t);\n                                response.setEntity(null);\n                            }\n                        } else {\n                            response.setEntity(null);\n                        }\n                    }\n                    break;\n                case SUSPEND_RESPONSE:\n                    SuspendResponse<?> s = SuspendResponse.class.cast(JResponseAsResponse.class.cast(response.getResponse()).getJResponse());\n\n                    boolean outputJunk = outputJunk(s.outputComments());\n                    boolean resumeOnBroadcast = resumeOnBroadcast(s.resumeOnBroadcast());\n\n                    for (AtmosphereResourceEventListener el : s.listeners()) {\n                        if (r instanceof AtmosphereEventLifecycle) {\n                            r.addEventListener(el);\n                        }\n                    }\n\n                    Broadcaster bc = s.broadcaster();\n                    if (bc == null && s.scope() != Suspend.SCOPE.REQUEST) {\n                        bc = (Broadcaster) servletReq.getAttribute(INJECTED_BROADCASTER);\n                    }\n\n                    boolean supportTrackable = servletReq.getAttribute(ApplicationConfig.SUPPORT_TRACKABLE) != null;\n                    // Register our TrackableResource\n                    boolean isTracked = response.getEntity() != null ? TrackableResource.class.isAssignableFrom(response.getEntity().getClass()) : supportTrackable;\n\n                    TrackableResource<? extends Trackable> trackableResource = null;\n                    if (isTracked) {\n                        trackableResource = preTrack(request, response);\n                    }\n\n                    suspend(resumeOnBroadcast, outputJunk,\n                            translateTimeUnit(s.period().value(), s.period().timeUnit()), request, response, bc, r, s.scope());\n\n                    // Associate the tracked resource.\n                    if (isTracked && trackableResource != null) {\n                        postTrack(trackableResource, r);\n                    }\n\n                    break;\n                case SUBSCRIBE_TRACKABLE:\n                case SUBSCRIBE:\n                case SUSPEND:\n                case SUSPEND_TRACKABLE:\n                case SUSPEND_RESUME:\n                    outputJunk = outputJunk(outputComments);\n                    resumeOnBroadcast = resumeOnBroadcast((action == Action.SUSPEND_RESUME));\n\n                    for (Class<? extends AtmosphereResourceEventListener> listener : listeners) {\n                        try {\n                            AtmosphereResourceEventListener el = listener.newInstance();\n                            InjectorProvider.getInjector().inject(el);\n                            if (r instanceof AtmosphereEventLifecycle) {\n                                ((AtmosphereEventLifecycle) r).addEventListener(el);\n                            }\n                        } catch (Throwable t) {\n                            throw new WebApplicationException(\n                                    new IllegalStateException(\"Invalid AtmosphereResourceEventListener \" + listener, t));\n                        }\n                    }\n\n                    Broadcaster broadcaster = (Broadcaster) servletReq.getAttribute(INJECTED_BROADCASTER);\n                    // @Subscribe\n                    if (action == Action.SUBSCRIBE) {\n                        Class<Broadcaster> c = null;\n                        try {\n                            c = (Class<Broadcaster>) Class.forName((String) servletReq.getAttribute(ApplicationConfig.BROADCASTER_CLASS));\n                        } catch (Throwable e) {\n                            throw new IllegalStateException(e.getMessage());\n                        }\n                        broadcaster = BroadcasterFactory.getDefault().lookup(c, topic, true);\n                    }\n\n                    // Tracking is enabled by default\n                    supportTrackable = servletReq.getAttribute(ApplicationConfig.SUPPORT_TRACKABLE) != null;\n                    // Register our TrackableResource\n                    isTracked = response.getEntity() != null ? TrackableResource.class.isAssignableFrom(response.getEntity().getClass()) : supportTrackable;\n\n                    if (isTracked) {\n                        trackableResource = preTrack(request, response);\n                    } else {\n                        trackableResource = null;\n                    }\n\n                    suspend(resumeOnBroadcast, outputJunk, timeout, request, response,\n                            broadcaster, r, scope);\n\n                    // Associate the tracked resource.\n                    if (isTracked && trackableResource != null) {\n                        postTrack(trackableResource, r);\n                    }\n                    break;\n                case RESUME:\n                    if (response.getEntity() != null) {\n                        try {\n                            response.write();\n                        } catch (IOException ex) {\n                            throw new WebApplicationException(ex);\n                        }\n                    }\n\n                    boolean sessionSupported = (Boolean) servletReq.getAttribute(FrameworkConfig.SUPPORT_SESSION);\n                    if (sessionSupported) {\n                        r = (AtmosphereResource) servletReq.getSession().getAttribute(SUSPENDED_RESOURCE);\n                    } else {\n                        String path = response.getContainerRequest().getPath();\n                        r = resumeCandidates.remove(path.substring(path.lastIndexOf(\"/\") + 1));\n                    }\n\n                    if (r != null) {\n                        resume(r);\n                    } else {\n                        throw new WebApplicationException(\n                                new IllegalStateException(\"Unable to retrieve suspended Response. \" +\n                                        \"Either session-support is not enabled in atmosphere.xml or the\" +\n                                        \"path used to resume is invalid.\"));\n\n                    }\n                    break;\n                case BROADCAST:\n                case PUBLISH:\n                case RESUME_ON_BROADCAST:\n                    AtmosphereResource ar = (AtmosphereResource) servletReq.getAttribute(SUSPENDED_RESOURCE);\n                    if (ar != null) {\n                        r = ar;\n                    }\n\n                    if (action == Action.PUBLISH) {\n                        Class<Broadcaster> c = null;\n                        try {\n                            c = (Class<Broadcaster>) Class.forName((String) servletReq.getAttribute(ApplicationConfig.BROADCASTER_CLASS));\n                        } catch (Throwable e) {\n                            throw new IllegalStateException(e.getMessage());\n                        }\n                        r.setBroadcaster(BroadcasterFactory.getDefault().lookup(c, topic, true));\n                    }\n\n                    broadcast(response, r, timeout);\n                    break;\n                case SCHEDULE:\n                case SCHEDULE_RESUME:\n                    Object o = response.getEntity();\n                    Broadcaster b = r.getBroadcaster();\n                    if (response.getEntity() instanceof Broadcastable) {\n                        b = ((Broadcastable) response.getEntity()).getBroadcaster();\n                        o = ((Broadcastable) response.getEntity()).getMessage();\n                        response.setEntity(((Broadcastable) response.getEntity()).getResponseMessage());\n                    }\n\n                    if (response.getEntity() != null) {\n                        try {\n                            response.write();\n                        } catch (IOException ex) {\n                            throw new WebApplicationException(ex);\n                        }\n                    }\n\n                    if (action == Action.SCHEDULE_RESUME) {\n                        configureResumeOnBroadcast(b);\n                    }\n\n                    b.scheduleFixedBroadcast(o, waitFor, timeout, TimeUnit.SECONDS);\n                    break;\n            }\n\n            return response;\n        }\n"
  },
  {
    "id": "codehaus_cake-0-Associations-FirstSentence",
    "old_comment_raw": "Analogous to  #get(WithAttributes) except returning a primitive boolean.",
    "new_comment_raw": "Extracts the attribute map from the specified  WithAttributes and returns the value of this attribute from the map.",
    "old_code_raw": "    public boolean get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n",
    "new_code_raw": "    public boolean get(WithAttributes withAttributes) {\r\n        return withAttributes.getAttributes().get(this);\r\n    }\r\n\n"
  },
  {
    "id": "Netflix_eureka-354-FirstSentence-0",
    "old_comment_raw": "Sets the fully qualified hostname of this running instance.This is mostly used in constructing the  java.net.URL for communicating with the instance.",
    "new_comment_raw": "Sets the fully qualified hostname of this running instance.This is mostly used in constructing the  java.net.URL for communicating with the instance.",
    "old_code_raw": "        public Builder setHostName(String hostName) {\n            String existingHostName = result.hostName;\n            result.hostName = hostName;\n            if ((existingHostName != null)\n                    && !(hostName.equals(existingHostName))) {\n                refreshStatusPageUrl().refreshHealthCheckUrl()\n                        .refreshVIPAddress().refreshSecureVIPAddress();\n            }\n            return this;\n        }\n",
    "new_code_raw": "        public Builder setHostName(String hostName) {\n            if (hostName == null || hostName.isEmpty()) {\n                logger.warn(\"Passed in hostname is blank, not setting it\");\n                return this;\n            }\n\n            String existingHostName = result.hostName;\n            result.hostName = hostName;\n            if ((existingHostName != null)\n                    && !(hostName.equals(existingHostName))) {\n                refreshStatusPageUrl().refreshHealthCheckUrl()\n                        .refreshVIPAddress().refreshSecureVIPAddress();\n            }\n            return this;\n        }\n"
  },
  {
    "id": "JodaOrg_joda_time-487-FirstSentence-0",
    "old_comment_raw": "Gets the overlap where this interval and that specified.",
    "new_comment_raw": "Gets the overlap between this interval and another interval.",
    "old_code_raw": "    public Interval overlap(ReadableInterval interval) {\n        interval = DateTimeUtils.getReadableInterval(interval);\n        if (overlaps(interval) == false) {\n            return null;\n        }\n        long start = Math.max(getStartMillis(), interval.getStartMillis());\n        long end = Math.min(getEndMillis(), interval.getEndMillis());\n        return new Interval(start, end);\n    }\n",
    "new_code_raw": "    public Interval overlap(ReadableInterval interval) {\n        interval = DateTimeUtils.getReadableInterval(interval);\n        if (overlaps(interval) == false) {\n            return null;\n        }\n        long start = Math.max(getStartMillis(), interval.getStartMillis());\n        long end = Math.min(getEndMillis(), interval.getEndMillis());\n        return new Interval(start, end, getChronology());\n    }\n"
  },
  {
    "id": "debezium_debezium-1010-FirstSentence-0",
    "old_comment_raw": "Converts a value object for an expected JDBC type of  Types#SMALLINT.",
    "new_comment_raw": "Converts a value object for an expected JDBC type of  Types#SMALLINT.",
    "old_code_raw": "    protected Object convertSmallInt(Column column, Field fieldDefn, Object data) {\n        if (data == null && !fieldDefn.schema().isOptional()) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return SHORT_FALSE;\n        }\n        if (data instanceof Short) return data;\n        if (data instanceof Number) {\n            Number value = (Number) data;\n            return new Short(value.shortValue());\n        }\n        if (data instanceof Boolean) {\n            return NumberConversions.getShort((Boolean) data);\n        }\n        if (data instanceof String) {\n            return Short.parseShort((String) data);\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n",
    "new_code_raw": "    protected Object convertSmallInt(Column column, Field fieldDefn, Object data) {\n        return convertValue(column, fieldDefn, data, SHORT_FALSE, (r) -> {\n            if (data instanceof Short) {\n                r.deliver(data);\n            }\n            else if (data instanceof Number) {\n                Number value = (Number) data;\n                r.deliver(new Short(value.shortValue()));\n            }\n            else if (data instanceof Boolean) {\n                r.deliver(NumberConversions.getShort((Boolean)data));\n            }\n            else if (data instanceof String) {\n                r.deliver(Short.parseShort((String)data));\n            }\n        });\n    }\n"
  },
  {
    "id": "Atmosphere_atmosphere-542-FirstSentence-0",
    "old_comment_raw": "Flush the cached messages.",
    "new_comment_raw": "Flush the cached messages.",
    "old_code_raw": "    protected DefaultMetaBroadcaster flushCache() {\n        if (cache != null) cache.flushCache();\n        return this;\n    }\n",
    "new_code_raw": "    protected MetaBroadcaster flushCache() {\n        if (cache != null) cache.flushCache();\n        return this;\n    }\n"
  },
  {
    "id": "nelsonsilva_vaadin-162-Associations-FirstSentence",
    "old_comment_raw": "Gets the 'left' CSS-attributes value in specified units.",
    "new_comment_raw": "Gets the 'left' attributes value using current units.",
    "old_code_raw": "        public float getLeftValue() {\n            return leftValue == null ? 0 : leftValue.floatValue();\n        }\n",
    "new_code_raw": "        public Float getLeftValue() {\n            return leftValue;\n        }\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2430-FirstSentence-0",
    "old_comment_raw": "Either get a custom annotator which was recently defined, or create it if it has never been defined.",
    "new_comment_raw": "Either get a custom annotator which was recently defined, or create it if it has never been defined.",
    "old_code_raw": "  private synchronized static Supplier<Annotator> getOrCreate(String name, Properties props, Supplier<Annotator> annotator) {\n    StanfordCoreNLP.AnnotatorSignature key = new StanfordCoreNLP.AnnotatorSignature(name, PropertiesUtils.getSignature(name, props));\n    customAnnotators.register(name, props, StanfordCoreNLP.GLOBAL_ANNOTATOR_CACHE.computeIfAbsent(key, (sig) -> Lazy.cache(annotator)));\n    return () -> customAnnotators.get(name);\n  }\n",
    "new_code_raw": "  private synchronized static Supplier<Annotator> getOrCreate(AnnotatorFactory factory) {\n    return () -> {\n      Annotator rtn = customAnnotators.get(factory.signature());\n      if (rtn == null) {\n        // Create the annotator\n        rtn = factory.create();\n        // Register the annotator\n        customAnnotators.put(factory.signature(), factory.create());\n        // Clean up memory if needed\n        while (customAnnotators.size() > 10) {\n          customAnnotators.keySet().iterator().remove();\n        }\n      }\n      return rtn;\n    };\n  }\n"
  },
  {
    "id": "mccraigmccraig_prefuse-11-Associations-FirstSentence",
    "old_comment_raw": "Requests a GraphItem of the specified item class corresponding to a given Entity, optionally creating the GraphItem if it doesn't already exist.",
    "new_comment_raw": "Requests a VisualItem of the specified item class corresponding to a given Entity, optionally creating the VisualItem if it doesn't already exist.",
    "old_code_raw": "\tpublic synchronized GraphItem getItem(String itemClass, Entity entity, boolean create) {\n\t\tItemEntry entry = (ItemEntry)m_entryMap.get(itemClass);\n\t\tif ( entry != null ) {\n\t\t\tGraphItem item = (GraphItem)entry.itemMap.get(entity);\n\t\t\tif ( !create ) {\n\t\t\t\treturn item;\n\t\t\t} else if ( item == null ) {\n\t\t\t\titem = m_ifactory.getItem(itemClass);\n\t\t\t\titem.init(this, itemClass, entity);\n\t\t\t\taddItem(entry, entity, item);\n\t\t\t}\n            if ( item instanceof NodeItem )\n                ((NodeItem)item).removeAllNeighbors();\n            item.setDirty(0);\n            item.setVisible(true);\n\t\t\treturn item;\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"The input string must be a\"\n\t\t\t\t\t\t+ \" recognized item class!\");\n\t\t}\t\t\n\t} //\n",
    "new_code_raw": "\tpublic synchronized VisualItem getItem(String itemClass, Entity entity, boolean create) {\n\t\tItemEntry entry = (ItemEntry)m_entryMap.get(itemClass);\n\t\tif ( entry != null ) {\n\t\t\tVisualItem item = (VisualItem)entry.itemMap.get(entity);\n\t\t\tif ( !create ) {\n\t\t\t\treturn item;\n\t\t\t} else if ( item == null ) {\n\t\t\t\titem = m_ifactory.getItem(itemClass);\n\t\t\t\titem.init(this, itemClass, entity);\n\t\t\t\taddItem(entry, entity, item);\n\t\t\t}\n            if ( item instanceof NodeItem )\n                ((NodeItem)item).removeAllNeighbors();\n            item.setDirty(0);\n            item.setVisible(true);\n\t\t\treturn item;\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"The input string must be a\"\n\t\t\t\t\t\t+ \" recognized item class!\");\n\t\t}\t\t\n\t} //\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-413-FirstSentence-0",
    "old_comment_raw": "Iterate the entity mappings",
    "new_comment_raw": "Iterate the entity mappings",
    "old_code_raw": "\tpublic Iterator getClassMappings() {\n\t\treturn classes.values().iterator();\n\t}\n",
    "new_code_raw": "\tpublic Iterator<PersistentClass> getClassMappings() {\n\t\treturn classes.values().iterator();\n\t}\n"
  },
  {
    "id": "apache_lenya-285-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Returns the path to the export directory",
    "old_code_raw": "    public String getExportDirectory() {\n        return exportDirectory;\n    }\n",
    "new_code_raw": "    public String getExportDirectory() {\n        return this.exportDirectory;\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2558-FirstSentence-0",
    "old_comment_raw": "Get user by user name",
    "new_comment_raw": "Get user by user name",
    "old_code_raw": "  public User getUserByName(String username) throws ApiException {\n    Object localVarPostBody = null;\n    \n    // verify the required parameter 'username' is set\n    if (username == null) {\n      throw new ApiException(400, \"Missing the required parameter 'username' when calling getUserByName\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/user/{username}\".replaceAll(\"\\\\{format\\\\}\",\"json\")\n      .replaceAll(\"\\\\{\" + \"username\" + \"\\\\}\", apiClient.escapeString(username.toString()));\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n    \n\n    \n\n    \n\n    final String[] localVarAccepts = {\n      \"application/json\", \"application/xml\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    \n    GenericType<User> localVarReturnType = new GenericType<User>() {};\n    return apiClient.invokeAPI(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n    \n  }\n",
    "new_code_raw": "  public User getUserByName(String username) throws ApiException {\n    Object postBody = null;\n    \n     // verify the required parameter 'username' is set\n     if (username == null) {\n        throw new ApiException(400, \"Missing the required parameter 'username' when calling getUserByName\");\n     }\n     \n    // create path and map variables\n    String path = \"/user/{username}\".replaceAll(\"\\\\{format\\\\}\",\"json\")\n      .replaceAll(\"\\\\{\" + \"username\" + \"\\\\}\", apiClient.escapeString(username.toString()));\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    Map<String, String> headerParams = new HashMap<String, String>();\n    Map<String, Object> formParams = new HashMap<String, Object>();\n\n    \n\n    \n\n    \n\n    final String[] accepts = {\n      \"application/json\", \"application/xml\"\n    };\n    final String accept = apiClient.selectHeaderAccept(accepts);\n\n    final String[] contentTypes = {\n      \n    };\n    final String contentType = apiClient.selectHeaderContentType(contentTypes);\n\n    String[] authNames = new String[] {  };\n\n    \n    GenericType<User> returnType = new GenericType<User>() {};\n    return apiClient.invokeAPI(path, \"GET\", queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    \n  }\n"
  },
  {
    "id": "apache_jsecurity-11-Associations-FirstSentence",
    "old_comment_raw": "Performs the actual authentication of the user by connecting to the LDAP server, querying it for user information, and returning an  ActiveDirectoryInfo instance containing the results.",
    "new_comment_raw": "Performs the actual authentication of the user by connecting to the LDAP server, querying it for user information, and returning an  LdapDirectoryInfo instance containing the results.",
    "old_code_raw": "    protected ActiveDirectoryInfo performAuthentication(String username, char[] password) {\n\n        if( searchBase == null ) {\n            throw new IllegalStateException( \"A search base must be specified.\" );\n        }\n        if( url == null ) {\n            throw new IllegalStateException( \"An LDAP URL must be specified of the form ldap://<hostname>:<port>\" );\n        }\n\n\n        if( principalSuffix != null ) {\n            username = username + principalSuffix;\n        }\n\n        Hashtable<String, String> env = new Hashtable<String, String>(6);\n\n        env.put(Context.SECURITY_AUTHENTICATION, authentication);\n        env.put(Context.SECURITY_PRINCIPAL, username);\n        env.put(Context.SECURITY_CREDENTIALS, new String( password ));\n        env.put(Context.INITIAL_CONTEXT_FACTORY, contextFactory);\n        env.put(Context.PROVIDER_URL, url);\n        env.put(Context.REFERRAL, refferal);\n\n        if (log.isDebugEnabled()) {\n            log.debug( \"Initializing LDAP context using environment properties [\" + env + \"]\" );\n        }\n\n        LdapContext ctx = null;\n        try {\n            ctx = new InitialLdapContext(env, null);\n\n            return getActiveDirectoryInfo(username, ctx);\n\n\n        } catch (javax.naming.AuthenticationException e) {\n            throw new IncorrectCredentialException( \"User could not be authenticated with LDAP server.\", e );\n\n        } catch (NamingException e) {\n            throw new AuthenticationException( \"LDAP naming error while attempting to authenticate user.\", e );\n\n        } finally {\n            // Always close the LDAP context\n            try {\n                if (ctx != null) {\n                    ctx.close();\n                }\n            } catch (NamingException e) {\n                if( log.isErrorEnabled() ) {\n                    log.error(\"Problem closing Context: \", e);\n                }\n            }\n        }\n    }\n",
    "new_code_raw": "    protected LdapDirectoryInfo performAuthentication(String username, char[] password) {\n\n        if( searchBase == null ) {\n            throw new IllegalStateException( \"A search base must be specified.\" );\n        }\n        if( url == null ) {\n            throw new IllegalStateException( \"An LDAP URL must be specified of the form ldap://<hostname>:<port>\" );\n        }\n\n\n        if( principalSuffix != null ) {\n            username = username + principalSuffix;\n        }\n\n        Hashtable<String, String> env = new Hashtable<String, String>(6);\n\n        env.put(Context.SECURITY_AUTHENTICATION, authentication);\n        env.put(Context.SECURITY_PRINCIPAL, username);\n        env.put(Context.SECURITY_CREDENTIALS, new String( password ));\n        env.put(Context.INITIAL_CONTEXT_FACTORY, contextFactory);\n        env.put(Context.PROVIDER_URL, url);\n        env.put(Context.REFERRAL, refferal);\n\n        if (log.isDebugEnabled()) {\n            log.debug( \"Initializing LDAP context using environment properties [\" + env + \"]\" );\n        }\n\n        LdapContext ctx = null;\n        try {\n            ctx = new InitialLdapContext(env, null);\n\n            return getLdapDirectoryInfo(username, ctx);\n\n\n        } catch (javax.naming.AuthenticationException e) {\n            throw new IncorrectCredentialException( \"User could not be authenticated with LDAP server.\", e );\n\n        } catch (NamingException e) {\n            throw new AuthenticationException( \"LDAP naming error while attempting to authenticate user.\", e );\n\n        } finally {\n            // Always close the LDAP context\n            try {\n                if (ctx != null) {\n                    ctx.close();\n                }\n            } catch (NamingException e) {\n                if( log.isErrorEnabled() ) {\n                    log.error(\"Problem closing Context: \", e);\n                }\n            }\n        }\n    }\n\n"
  },
  {
    "id": "Netflix_eureka-360-FirstSentence-0",
    "old_comment_raw": "Get the  EurekaClient implementation.",
    "new_comment_raw": "Get the  EurekaClient implementation.",
    "old_code_raw": "    public EurekaClient getEurekaClient() {\n        return discoveryClient;\n    }\n",
    "new_code_raw": "    public EurekaClient getEurekaClient() {\n        return eurekaClient;\n    }\n"
  },
  {
    "id": "heuermh_ensembl-rest-client-4-Associations-FirstSentence",
    "old_comment_raw": "C6reate and return a new lookup service with the default server URL.",
    "new_comment_raw": "C6reate and return a new lookup service with the default endpoint URL.",
    "old_code_raw": "    public LookupService createLookupService() {\n        return createLookupService(defaultServerUrl);\n    }\n",
    "new_code_raw": "    public LookupService createLookupService() {\n        return createLookupService(defaultEndpointUrl);\n    }\n\n"
  },
  {
    "id": "apache_activemq-1294-FirstSentence-0",
    "old_comment_raw": "Creates MessageConsumer for the specified destination, using a message selector.",
    "new_comment_raw": "Creates MessageConsumer for the specified destination, using a message selector.",
    "old_code_raw": "    public MessageConsumer createConsumer(Destination destination, String messageSelector, boolean noLocal) throws JMSException {\n        checkClosed();\n\n        if (destination instanceof CustomDestination) {\n            CustomDestination customDestination = (CustomDestination)destination;\n            return customDestination.createConsumer(this, messageSelector, noLocal);\n        }\n\n        ActiveMQPrefetchPolicy prefetchPolicy = connection.getPrefetchPolicy();\n        return new ActiveMQMessageConsumer(this, getNextConsumerId(), ActiveMQMessageTransformation.transformDestination(destination), null, messageSelector, prefetchPolicy\n            .getTopicPrefetch(), prefetchPolicy.getMaximumPendingMessageLimit(), noLocal, false, asyncDispatch);\n    }\n",
    "new_code_raw": "    public MessageConsumer createConsumer(Destination destination, String messageSelector, boolean noLocal, MessageListener messageListener) throws JMSException {\n        checkClosed();\n\n        if (destination instanceof CustomDestination) {\n            CustomDestination customDestination = (CustomDestination)destination;\n            return customDestination.createConsumer(this, messageSelector, noLocal);\n        }\n\n        ActiveMQPrefetchPolicy prefetchPolicy = connection.getPrefetchPolicy();\n        int prefetch = 0;\n        if (destination instanceof Topic) {\n            prefetch = prefetchPolicy.getTopicPrefetch();\n        } else {\n            prefetch = prefetchPolicy.getQueuePrefetch();\n        }\n        ActiveMQDestination activemqDestination = ActiveMQMessageTransformation.transformDestination(destination);\n        return new ActiveMQMessageConsumer(this, getNextConsumerId(), activemqDestination, null, messageSelector,\n                prefetch, prefetchPolicy.getMaximumPendingMessageLimit(), noLocal, false, asyncDispatch, messageListener);\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2417-FirstSentence-0",
    "old_comment_raw": "Takes a double array of weights and creates a 2D array where: the first element is the mapped index of the clique size (e.g., node-0, edge-1) matching featuresIndex i the second element is the number of output classes for that clique size",
    "new_comment_raw": "Takes a double array of weights and populates a 2D array where: the first element is the mapped index of the clique size (e.g., node-0, edge-1) matching featuresIndex i the second element is the number of output classes for that clique size",
    "old_code_raw": "  public static double[][] to2D(double[] weights, List<Index<CRFLabel>> labelIndices, int[] map) {\n    double[][] newWeights = new double[map.length][];\n    int index = 0;\n    for (int i = 0; i < map.length; i++) {\n      int labelSize = labelIndices.get(map[i]).size();\n      newWeights[i] = new double[labelSize];\n      try {\n        System.arraycopy(weights, index, newWeights[i], 0, labelSize);\n      } catch (Exception ex) {\n        log.info(\"weights: \" + Arrays.toString(weights));\n        log.info(\"newWeights[\"+i+\"]: \" + Arrays.toString(newWeights[i]));\n        throw new RuntimeException(ex);\n      }\n      index += labelSize;\n    }\n    return newWeights;\n  }\n",
    "new_code_raw": "  public static void to2D(double[] weights, List<Index<CRFLabel>> labelIndices, int[] map, double[][] newWeights) {\n    int index = 0;\n    for (int i = 0; i < map.length; i++) {\n      int labelSize = labelIndices.get(map[i]).size();\n      System.arraycopy(weights, index, newWeights[i], 0, labelSize);\n      index += labelSize;\n    }\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-452-FirstSentence-0",
    "old_comment_raw": "Create a  SessionFactory using the properties and mappings in this configuration.",
    "new_comment_raw": "Create a  SessionFactory using the properties and mappings in this configuration.",
    "old_code_raw": "\tpublic SessionFactory buildSessionFactory(ServicesRegistry serviceRegistry) throws HibernateException {\n\t\tlog.debug( \"Preparing to build session factory with filters : \" + filterDefinitions );\n\n\t\tsecondPassCompile();\n\t\tif ( ! metadataSourceQueue.isEmpty() ) {\n\t\t\tlog.warn( \"mapping metadata cache was not completely processed\" );\n\t\t}\n\n\t\tenableLegacyHibernateValidator();\n\t\tenableBeanValidation();\n\t\tenableHibernateSearch();\n\n\t\tvalidate();\n\t\tEnvironment.verifyProperties( properties );\n\t\tProperties copy = new Properties();\n\t\tcopy.putAll( properties );\n\t\tConfigurationHelper.resolvePlaceHolders( copy );\n\t\tSettings settings = buildSettings( copy, serviceRegistry.getService( JdbcServices.class ) );\n\n\t\treturn new SessionFactoryImpl(\n\t\t\t\tthis,\n\t\t\t\tmapping,\n\t\t\t\tserviceRegistry,\n\t\t\t\tsettings,\n\t\t\t\tgetInitializedEventListeners(),\n\t\t\t\tsessionFactoryObserver\n\t\t\t);\n\t}\n",
    "new_code_raw": "\tpublic SessionFactory buildSessionFactory() throws HibernateException {\n\t\tlog.debug( \"Preparing to build session factory with filters : \" + filterDefinitions );\n\n\t\tsecondPassCompile();\n\t\tif ( ! metadataSourceQueue.isEmpty() ) {\n\t\t\tlog.warn( \"mapping metadata cache was not completely processed\" );\n\t\t}\n\n\t\tenableLegacyHibernateValidator();\n\t\tenableBeanValidation();\n\t\tenableHibernateSearch();\n\n\t\tvalidate();\n\t\tEnvironment.verifyProperties( properties );\n\t\tProperties copy = new Properties();\n\t\tcopy.putAll( properties );\n\t\tConfigurationHelper.resolvePlaceHolders( copy );\n\t\tSettings settings = buildSettings( copy );\n\n\t\treturn new SessionFactoryImpl(\n\t\t\t\tthis,\n\t\t\t\tmapping,\n\t\t\t\tsettings,\n\t\t\t\tgetInitializedEventListeners(),\n\t\t\t\tsessionFactoryObserver\n\t\t\t);\n\t}\n"
  },
  {
    "id": "hazelcast_hazelcast-494-Associations-FirstSentence",
    "old_comment_raw": "The evaluate method implements the  com.hazelcast.config.EvictionPolicy rule on the given input set of candidates.",
    "new_comment_raw": "Selects the best candidate to be evicted.",
    "old_code_raw": "    @Override\n    public <C extends EvictionCandidate<A, E>> Iterable<C> evaluate(Iterable<C> evictionCandidates) {\n        C selectedEvictionCandidate = null;\n        long now = Clock.currentTimeMillis();\n        for (C currentEvictionCandidate : evictionCandidates) {\n            if (selectedEvictionCandidate == null) {\n                selectedEvictionCandidate = currentEvictionCandidate;\n            } else {\n                E evictable = currentEvictionCandidate.getEvictable();\n\n                if (isExpired(now, evictable)) {\n                    return returnEvictionCandidate(currentEvictionCandidate);\n                }\n\n                int comparisonResult = evictionPolicyComparator.compare(selectedEvictionCandidate, currentEvictionCandidate);\n                if (comparisonResult == EvictionPolicyComparator.SECOND_ENTRY_HAS_HIGHER_PRIORITY_TO_BE_EVICTED) {\n                    selectedEvictionCandidate = currentEvictionCandidate;\n                }\n            }\n        }\n        return returnEvictionCandidate(selectedEvictionCandidate);\n    }\n",
    "new_code_raw": "    public <C extends EvictionCandidate<A, E>> C evaluate(Iterable<C> evictionCandidates) {\n        C selectedEvictionCandidate = null;\n        long now = Clock.currentTimeMillis();\n        for (C currentEvictionCandidate : evictionCandidates) {\n            if (selectedEvictionCandidate == null) {\n                selectedEvictionCandidate = currentEvictionCandidate;\n            } else {\n                E evictable = currentEvictionCandidate.getEvictable();\n                if (isExpired(now, evictable)) {\n                    return currentEvictionCandidate;\n                }\n\n                int comparisonResult = evictionPolicyComparator.compare(selectedEvictionCandidate, currentEvictionCandidate);\n                if (comparisonResult == EvictionPolicyComparator.SECOND_ENTRY_HAS_HIGHER_PRIORITY_TO_BE_EVICTED) {\n                    selectedEvictionCandidate = currentEvictionCandidate;\n                }\n            }\n        }\n        return selectedEvictionCandidate;\n    }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-834-FirstSentence-0",
    "old_comment_raw": "Gets a copy of this datetime with the partial set of fields replacing those from this instance.",
    "new_comment_raw": "Gets a copy of this datetime with the partial set of fields replacing those from this instance.",
    "old_code_raw": "    public DateTime withFields(ReadablePartial partial) {\n        if (partial == null) {\n            return this;\n        }\n        return partial.resolveDateTime(this);\n    }\n",
    "new_code_raw": "    public DateTime withFields(ReadablePartial partial) {\n        if (partial == null) {\n            return this;\n        }\n        return withMillis(getChronology().set(partial, getMillis()));\n    }\n"
  },
  {
    "id": "zjpjohn_idempiere-76-Associations-FirstSentence",
    "old_comment_raw": "Get corresponding Requisition Line for given Order Line",
    "new_comment_raw": "Get corresponding Requisition Line(s) for given Order Line",
    "old_code_raw": "\tpublic static MRequisitionLine forC_OrderLine_ID(Properties ctx, int C_OrderLine_ID, String trxName)\r\n\t{\r\n\t\tfinal String whereClause = COLUMNNAME_C_OrderLine_ID+\"=?\";\r\n\t\treturn new Query(ctx, MRequisitionLine.Table_Name, whereClause, trxName)\r\n\t\t\t.setParameters(new Object[]{C_OrderLine_ID})\r\n\t\t\t.firstOnly();\r\n\t}\r\n",
    "new_code_raw": "\tpublic static MRequisitionLine[] forC_OrderLine_ID(Properties ctx, int C_OrderLine_ID, String trxName)\r\n\t{\r\n\t\tfinal String whereClause = COLUMNNAME_C_OrderLine_ID+\"=?\";\r\n\t\tList<MRequisitionLine> list = new Query(ctx, MRequisitionLine.Table_Name, whereClause, trxName)\r\n\t\t\t.setParameters(new Object[]{C_OrderLine_ID})\r\n\t\t\t.list();\r\n\t\treturn list.toArray(new MRequisitionLine[list.size()]);\r\n\t}\r\n\n"
  },
  {
    "id": "JodaOrg_joda_time-424-FirstSentence-0",
    "old_comment_raw": "Gets the long name of this datetime zone suitable for display using the specified locale.",
    "new_comment_raw": "Gets the long name of this datetime zone suitable for display using the specified locale.",
    "old_code_raw": "    public String getName(long millis, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(millis);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return offsetFormatter().print(millis, this);\n    }\n",
    "new_code_raw": "    public String getName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return offsetFormatter().print(instant, this);\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2038-FirstSentence-0",
    "old_comment_raw": "Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.",
    "new_comment_raw": "Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.",
    "old_code_raw": "  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { String str = yytext();\n          int first = str.charAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n          }\n        case 55: break;\n        case 2: \n          { return getNext(\"<\", yytext());\n          }\n        case 56: break;\n        case 3: \n          { return getNext();\n          }\n        case 57: break;\n        case 4: \n          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n          }\n        case 58: break;\n        case 5: \n          { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n          }\n        case 59: break;\n        case 6: \n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 60: break;\n        case 7: \n          { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n          }\n        case 61: break;\n        case 8: \n          { return handleQuotes(yytext(), false);\n          }\n        case 62: break;\n        case 9: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 63: break;\n        case 10: \n          { return getNext(\">\", yytext());\n          }\n        case 64: break;\n        case 11: \n          { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 65: break;\n        case 12: \n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 66: break;\n        case 13: \n          { return handleEllipsis(yytext());\n          }\n        case 67: break;\n        case 14: \n          { return normalizeFractions(yytext());\n          }\n        case 68: break;\n        case 15: \n          { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 69: break;\n        case 16: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 70: break;\n        case 17: \n          { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 71: break;\n        case 18: \n          { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 72: break;\n        case 19: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 73: break;\n        case 20: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 74: break;\n        case 21: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 75: break;\n        case 22: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 76: break;\n        case 23: \n          { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n          }\n        case 77: break;\n        case 24: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 13;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 78: break;\n        case 25: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext();\n          }\n        case 79: break;\n        case 26: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), true);\n          }\n        case 80: break;\n        case 27: \n          { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n          }\n        case 81: break;\n        case 28: \n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 82: break;\n        case 29: \n          { return getNext(removeSoftHyphens(yytext()), yytext());\n          }\n        case 83: break;\n        case 30: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 3;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 4;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 84: break;\n        case 31: \n          { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 85: break;\n        case 32: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 86: break;\n        case 33: \n          { // this one should only match if we're basically at the end of file\n                          // since the last one matches two things, even newlines\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 87: break;\n        case 34: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 88: break;\n        case 35: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 1;\n          { /* invert quote - often but not always right */\n                  return handleQuotes(yytext(), true);\n          }\n        case 89: break;\n        case 36: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), false);\n          }\n        case 90: break;\n        case 37: \n          { return getNormalizedAmpNext();\n          }\n        case 91: break;\n        case 38: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '/');\n                  }\n                  if (normalizeSpace) {\n                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 92: break;\n        case 39: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '/');\n                  }\n                  if (normalizeSpace) {\n                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 93: break;\n        case 40: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 5;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 6;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n          }\n        case 94: break;\n        case 41: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 16;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 17;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 95: break;\n        case 42: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 15;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 96: break;\n        case 43: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 9;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 10;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { // try to work around an apparent jflex bug where it\n                          // gets a space at the token end by getting\n                          // wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n\t\t\t  return getNext();\n          }\n        case 97: break;\n        case 44: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 98: break;\n        case 45: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                               yytext());\n          }\n        case 99: break;\n        case 46: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 7;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 8;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { // try to work around an apparent jflex bug where it\n                          // gets a space at the token end by getting\n                          // wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n                          String s;\n\t\t\t  if (yylength() == 2) { // \"I.\", etc.\n\t\t\t    yypushback(1); // return a period next time;\n\t\t\t    s = yytext(); // return the word without the final period\n                          } else if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext(); // return the word without the final period\n                          } else {\n                            s = yytext(); // return the word WITH the final period\n                            yypushback(1); // (redpulication:) also return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 100: break;\n        case 47: \n          // lookahead expression with fixed lookahead length\n          yypushback(2);\n          { return getNext();\n          }\n        case 101: break;\n        case 48: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 11;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 12;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 102: break;\n        case 49: \n          { if (splitAssimilations) {\n                            yypushback(3) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 103: break;\n        case 50: \n          { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 104: break;\n        case 51: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNormalizedAmpNext();\n          }\n        case 105: break;\n        case 52: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 106: break;\n        case 53: \n          // lookahead expression with fixed lookahead length\n          yypushback(4);\n          { return getNext();\n          }\n        case 107: break;\n        case 54: \n          { String txt = yytext();\n                          if (normalizeSpace) {\n                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 108: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                if (invertible) {\n            prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n",
    "new_code_raw": "  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { String str = yytext();\n          int first = str.charAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n          }\n        case 55: break;\n        case 2: \n          { return getNext(\"<\", yytext());\n          }\n        case 56: break;\n        case 3: \n          { return getNext();\n          }\n        case 57: break;\n        case 4: \n          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n          }\n        case 58: break;\n        case 5: \n          { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n          }\n        case 59: break;\n        case 6: \n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 60: break;\n        case 7: \n          { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n          }\n        case 61: break;\n        case 8: \n          { return handleQuotes(yytext(), false);\n          }\n        case 62: break;\n        case 9: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 63: break;\n        case 10: \n          { return getNext(\">\", yytext());\n          }\n        case 64: break;\n        case 11: \n          { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 65: break;\n        case 12: \n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 66: break;\n        case 13: \n          { return handleEllipsis(yytext());\n          }\n        case 67: break;\n        case 14: \n          { return normalizeFractions(yytext());\n          }\n        case 68: break;\n        case 15: \n          { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 69: break;\n        case 16: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 70: break;\n        case 17: \n          { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 71: break;\n        case 18: \n          { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 72: break;\n        case 19: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 73: break;\n        case 20: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 74: break;\n        case 21: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 75: break;\n        case 22: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 76: break;\n        case 23: \n          { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n          }\n        case 77: break;\n        case 24: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 13;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 78: break;\n        case 25: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext();\n          }\n        case 79: break;\n        case 26: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), true);\n          }\n        case 80: break;\n        case 27: \n          { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n          }\n        case 81: break;\n        case 28: \n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 82: break;\n        case 29: \n          { return getNext(removeSoftHyphens(yytext()), yytext());\n          }\n        case 83: break;\n        case 30: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 3;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 4;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 84: break;\n        case 31: \n          { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 85: break;\n        case 32: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 86: break;\n        case 33: \n          { // this one should only match if we're basically at the end of file\n                          // since the last one matches two things, even newlines\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 87: break;\n        case 34: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 88: break;\n        case 35: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 1;\n          { /* invert quote - often but not always right */\n                  return handleQuotes(yytext(), true);\n          }\n        case 89: break;\n        case 36: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), false);\n          }\n        case 90: break;\n        case 37: \n          { return getNormalizedAmpNext();\n          }\n        case 91: break;\n        case 38: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '/');\n                  }\n                  if (normalizeSpace) {\n                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 92: break;\n        case 39: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '/');\n                  }\n                  if (normalizeSpace) {\n                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 93: break;\n        case 40: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 5;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 6;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n          }\n        case 94: break;\n        case 41: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 16;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 17;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 95: break;\n        case 42: \n          { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 96: break;\n        case 43: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 15;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 97: break;\n        case 44: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 9;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 10;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { // try to work around an apparent jflex bug where it\n                          // gets a space at the token end by getting\n                          // wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n\t\t\t  return getNext();\n          }\n        case 98: break;\n        case 45: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 99: break;\n        case 46: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                               yytext());\n          }\n        case 100: break;\n        case 47: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 7;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 8;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { // try to work around an apparent jflex bug where it\n                          // gets a space at the token end by getting\n                          // wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n                          String s;\n\t\t\t  if (yylength() == 2) { // \"I.\", etc.\n\t\t\t    yypushback(1); // return a period next time;\n\t\t\t    s = yytext(); // return the word without the final period\n                          } else if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext(); // return the word without the final period\n                          } else {\n                            s = yytext(); // return the word WITH the final period\n                            yypushback(1); // (redpulication:) also return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 101: break;\n        case 48: \n          // lookahead expression with fixed lookahead length\n          yypushback(2);\n          { return getNext();\n          }\n        case 102: break;\n        case 49: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 11;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 12;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 103: break;\n        case 50: \n          { if (splitAssimilations) {\n                            yypushback(3) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 104: break;\n        case 51: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNormalizedAmpNext();\n          }\n        case 105: break;\n        case 52: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 106: break;\n        case 53: \n          // lookahead expression with fixed lookahead length\n          yypushback(4);\n          { return getNext();\n          }\n        case 107: break;\n        case 54: \n          { String txt = yytext();\n                          if (normalizeSpace) {\n                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 108: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                if (invertible) {\n            prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2260-FirstSentence-0",
    "old_comment_raw": "Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.",
    "new_comment_raw": "Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.",
    "old_code_raw": "  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n              {\n                if (invertible) {\n            // prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            // System.err.println(\"At end of text making after: |\" + str + \"|\");\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n            // System.err.println(\"prevWord is |\" + prevWord.get(CoreAnnotations.TextAnnotation.class) + \"|, its after is |\" +\n            //         prevWord.get(CoreAnnotations.AfterAnnotation.class) + \"|\");\n            prevWordAfter.setLength(0);\n          }\n          return null;\n              }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { String str = yytext();\n          int first = str.codePointAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\",\n                          yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n            }\n          case 74: break;\n          case 2: \n            { return getNext(\"<\", yytext());\n            }\n          case 75: break;\n          case 3: \n            { return getNext();\n            }\n          case 76: break;\n          case 4: \n            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n            }\n          case 77: break;\n          case 5: \n            { if (tokenizeNLs) {\n                      return getNext(AbstractTokenizer.NEWLINE_TOKEN, yytext()); // for tokenizing newliens\n                  } else if (invertible) {\n                    // System.err.println(\"Appending newline: |\" + yytext() + \"|\");\n                    prevWordAfter.append(yytext());\n                  }\n            }\n          case 78: break;\n          case 6: \n            { final String origTxt = yytext();\n                          String tok = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} (2) to recognize \" + origTxt + \" as \" + tok +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(tok, origTxt);\n            }\n          case 79: break;\n          case 7: \n            { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n            }\n          case 80: break;\n          case 8: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (3) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 81: break;\n          case 9: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 82: break;\n          case 10: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 83: break;\n          case 11: \n            { return getNext(\">\", yytext());\n            }\n          case 84: break;\n          case 12: \n            { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n            }\n          case 85: break;\n          case 13: \n            { handleHyphenatedNumber(yytext());\n                          if (DEBUG) { logger.info(\"Used {NUMBER} to recognize \" + yytext() + \" as \" + removeFromNumber(yytext())); }\n                          return getNext(removeFromNumber(yytext()), yytext());\n            }\n          case 86: break;\n          case 14: \n            { return handleEllipsis(yytext());\n            }\n          case 87: break;\n          case 15: \n            { // breakByHyphens(yytext()); // this is causing fail of attempted to pushback too much!\n                  String tok = yytext();\n                  /* A THING can contain quote like O'Malley */\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {THING} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 88: break;\n          case 16: \n            { String txt = yytext();\n                  String norm = normalizeFractions(yytext());\n                  if (DEBUG) { logger.info(\"Used {FRAC2} to recognize \" + txt + \" as \" + norm +\n                                       \"; normalizeFractions=\" + normalizeFractions +\n                                       \", escapeForwardSlashAsterisk=\" + escapeForwardSlashAsterisk); }\n                  return getNext(norm, txt);\n            }\n          case 89: break;\n          case 17: \n            { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext());\n                        } else {\n                            return getNext(minimallyNormalizeCurrency(yytext()), yytext());\n                          }\n            }\n          case 90: break;\n          case 18: \n            { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 91: break;\n          case 19: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 92: break;\n          case 20: \n            { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 93: break;\n          case 21: \n            { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 94: break;\n          case 22: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 95: break;\n          case 23: \n            { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 96: break;\n          case 24: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 97: break;\n          case 25: \n            { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n            }\n          case 98: break;\n          case 26: \n            { return getNext(\"\\u2022\", yytext());\n            }\n          case 99: break;\n          case 27: \n            { return getNext(\"\\u2122\", yytext());\n            }\n          case 100: break;\n          case 28: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 15;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 101: break;\n          case 29: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext();\n            }\n          case 102: break;\n          case 30: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {REDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 103: break;\n          case 31: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {APOWORD} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 104: break;\n          case 32: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                                   String norm = handleQuotes(tok, true);\n                                   if (DEBUG) { logger.info(\"Used {DBLQUOT} to recognize \" + tok + \" as \" + norm +\n                                                            \"; probablyLeft=\" + true); }\n                                   return getNext(norm, tok);\n            }\n          case 105: break;\n          case 33: \n            { String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {PROG_LANGS} to recognize \" + tok + \" as \" + tok); }\n                    return getNext(tok, tok);\n            }\n          case 106: break;\n          case 34: \n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 107: break;\n          case 35: \n            { breakByHyphens(yytext());\n                  if (DEBUG) { logger.info(\"Used {HTHING} to recognize \" + yytext() + \" as \" + removeSoftHyphens(yytext())); }\n                  return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 108: break;\n          case 36: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 3;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 4;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tok = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} to recognize \" + origTxt + \" as \" + tok +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(tok, origTxt);\n            }\n          case 109: break;\n          case 37: \n            { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 110: break;\n          case 38: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 111: break;\n          case 39: \n            { // this one should only match if we're basically at the end of file\n                          // since the last one matches two things, even newlines (if not tokenize per line)\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n            }\n          case 112: break;\n          case 40: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 113: break;\n          case 41: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { // Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  // can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  /* invert single quote - often but not always right */\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 114: break;\n          case 42: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {REDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 115: break;\n          case 43: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { // Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  // can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  /* invert single quote - often but not always right */\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 116: break;\n          case 44: \n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 117: break;\n          case 45: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {SREDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 118: break;\n          case 46: \n            { if (splitAssimilations) {\n                      yypushback(2);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 119: break;\n          case 47: \n            { String txt = yytext();\n                  // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...\n                  if (strictTreebank3) {\n                    int spaceIndex = indexOfSpace(txt);\n                    if (spaceIndex >= 0) {\n                      yypushback(txt.length() - spaceIndex);\n                      return getNext();\n                    }\n                  }\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '/');\n                  }\n                  if (normalizeSpace) {\n                    txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n            }\n          case 120: break;\n          case 48: \n            { return getNormalizedAmpNext();\n            }\n          case 121: break;\n          case 49: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 122: break;\n          case 50: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 123: break;\n          case 51: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 5;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 6;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n            }\n          case 124: break;\n          case 52: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 17;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 125: break;\n          case 53: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 126: break;\n          case 54: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 127: break;\n          case 55: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 22;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 128: break;\n          case 56: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 18;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 19;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 129: break;\n          case 57: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 130: break;\n          case 58: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 21;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 131: break;\n          case 59: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 132: break;\n          case 60: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                  breakByHyphens(tok);\n                  tok = yytext();\n                  String norm = removeSoftHyphens(tok);\n                  if (DEBUG) { logger.info(\"Used {HTHING} (2) to recognize \" + tok + \" as \" + norm); }\n                  return getNext(norm, tok);\n            }\n          case 133: break;\n          case 61: \n            { if (splitAssimilations) {\n                      yypushback(3);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 134: break;\n          case 62: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNormalizedAmpNext();\n            }\n          case 135: break;\n          case 63: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 9;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 136: break;\n          case 64: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { return getNext();\n            }\n          case 137: break;\n          case 65: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 14;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 138: break;\n          case 66: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 8;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 139: break;\n          case 67: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 13;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 140: break;\n          case 68: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 141: break;\n          case 69: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);\n            { return getNext();\n            }\n          case 142: break;\n          case 70: \n            // lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { return getNext();\n            }\n          case 143: break;\n          case 71: \n            { String txt = yytext();\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          if (DEBUG) { logger.info(\"Used {PHONE} to recognize \" + yytext() + \" as \" + txt); }\n                          return getNext(txt, yytext());\n            }\n          case 144: break;\n          case 72: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 25;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 145: break;\n          case 73: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 24;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 146: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n",
    "new_code_raw": "  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n              {\n                if (invertible) {\n            // prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            // System.err.println(\"At end of text making after: |\" + str + \"|\");\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n            // System.err.println(\"prevWord is |\" + prevWord.get(CoreAnnotations.TextAnnotation.class) + \"|, its after is |\" +\n            //         prevWord.get(CoreAnnotations.AfterAnnotation.class) + \"|\");\n            prevWordAfter.setLength(0);\n          }\n          return null;\n              }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { String str = yytext();\n          int first = str.codePointAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\",\n                          yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n            }\n          case 75: break;\n          case 2: \n            { return getNext(\"<\", yytext());\n            }\n          case 76: break;\n          case 3: \n            { return getNext();\n            }\n          case 77: break;\n          case 4: \n            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n            }\n          case 78: break;\n          case 5: \n            { if (tokenizeNLs) {\n                      return getNext(AbstractTokenizer.NEWLINE_TOKEN, yytext()); // for tokenizing newliens\n                  } else if (invertible) {\n                    // System.err.println(\"Appending newline: |\" + yytext() + \"|\");\n                    prevWordAfter.append(yytext());\n                  }\n            }\n          case 79: break;\n          case 6: \n            { final String origTxt = yytext();\n                          String tok = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} (2) to recognize \" + origTxt + \" as \" + tok +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(tok, origTxt);\n            }\n          case 80: break;\n          case 7: \n            { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n            }\n          case 81: break;\n          case 8: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (3) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 82: break;\n          case 9: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 83: break;\n          case 10: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 84: break;\n          case 11: \n            { return getNext(\">\", yytext());\n            }\n          case 85: break;\n          case 12: \n            { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n            }\n          case 86: break;\n          case 13: \n            { handleHyphenatedNumber(yytext());\n                          if (DEBUG) { logger.info(\"Used {NUMBER} to recognize \" + yytext() + \" as \" + removeFromNumber(yytext())); }\n                          return getNext(removeFromNumber(yytext()), yytext());\n            }\n          case 87: break;\n          case 14: \n            { return handleEllipsis(yytext());\n            }\n          case 88: break;\n          case 15: \n            { // breakByHyphens(yytext()); // this is causing fail of attempted to pushback too much!\n                  String tok = yytext();\n                  /* A THING can contain quote like O'Malley */\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {THING} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 89: break;\n          case 16: \n            { String txt = yytext();\n                  String norm = normalizeFractions(yytext());\n                  if (DEBUG) { logger.info(\"Used {FRAC2} to recognize \" + txt + \" as \" + norm +\n                                       \"; normalizeFractions=\" + normalizeFractions +\n                                       \", escapeForwardSlashAsterisk=\" + escapeForwardSlashAsterisk); }\n                  return getNext(norm, txt);\n            }\n          case 90: break;\n          case 17: \n            { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext());\n                        } else {\n                            return getNext(minimallyNormalizeCurrency(yytext()), yytext());\n                          }\n            }\n          case 91: break;\n          case 18: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 92: break;\n          case 19: \n            { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 93: break;\n          case 20: \n            { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 94: break;\n          case 21: \n            { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 95: break;\n          case 22: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 96: break;\n          case 23: \n            { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 97: break;\n          case 24: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 98: break;\n          case 25: \n            { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n            }\n          case 99: break;\n          case 26: \n            { return getNext(\"\\u2022\", yytext());\n            }\n          case 100: break;\n          case 27: \n            { return getNext(\"\\u2122\", yytext());\n            }\n          case 101: break;\n          case 28: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 15;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 102: break;\n          case 29: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext();\n            }\n          case 103: break;\n          case 30: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {REDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 104: break;\n          case 31: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {APOWORD} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 105: break;\n          case 32: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                                   String norm = handleQuotes(tok, true);\n                                   if (DEBUG) { logger.info(\"Used {DBLQUOT} to recognize \" + tok + \" as \" + norm +\n                                                            \"; probablyLeft=\" + true); }\n                                   return getNext(norm, tok);\n            }\n          case 106: break;\n          case 33: \n            { String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {PROG_LANGS} to recognize \" + tok + \" as \" + tok); }\n                    return getNext(tok, tok);\n            }\n          case 107: break;\n          case 34: \n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 108: break;\n          case 35: \n            { breakByHyphens(yytext());\n                  if (DEBUG) { logger.info(\"Used {HTHING} to recognize \" + yytext() + \" as \" + removeSoftHyphens(yytext())); }\n                  return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 109: break;\n          case 36: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 3;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 4;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tok = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} to recognize \" + origTxt + \" as \" + tok +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(tok, origTxt);\n            }\n          case 110: break;\n          case 37: \n            { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 111: break;\n          case 38: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 112: break;\n          case 39: \n            { // this one should only match if we're basically at the end of file\n                          // since the last one matches two things, even newlines (if not tokenize per line)\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n                          return getNext(s, yytext());\n            }\n          case 113: break;\n          case 40: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 114: break;\n          case 41: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { // Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  // can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  /* invert single quote - often but not always right */\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 115: break;\n          case 42: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {REDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 116: break;\n          case 43: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { // Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  // can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  /* invert single quote - often but not always right */\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 117: break;\n          case 44: \n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 118: break;\n          case 45: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {SREDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 119: break;\n          case 46: \n            { if (splitAssimilations) {\n                      yypushback(2);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 120: break;\n          case 47: \n            { String txt = yytext();\n                  // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...\n                  if (strictTreebank3) {\n                    int spaceIndex = indexOfSpace(txt);\n                    if (spaceIndex >= 0) {\n                      yypushback(txt.length() - spaceIndex);\n                      return getNext();\n                    }\n                  }\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '/');\n                  }\n                  if (normalizeSpace) {\n                    txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n            }\n          case 121: break;\n          case 48: \n            { return getNormalizedAmpNext();\n            }\n          case 122: break;\n          case 49: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 123: break;\n          case 50: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); // change to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 124: break;\n          case 51: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 5;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 6;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n            }\n          case 125: break;\n          case 52: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 17;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 126: break;\n          case 53: \n            { String txt = yytext();\n                  String normTok = txt;\n                  if (escapeForwardSlashAsterisk) {\n                    normTok = delimit(normTok, '*');\n                  }\n                  if (DEBUG) { logger.info(\"Used {SWEARING} to recognize \" + txt + \" as \" + normTok); }\n                  return getNext(normTok, txt);\n            }\n          case 127: break;\n          case 54: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 128: break;\n          case 55: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 129: break;\n          case 56: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 22;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 130: break;\n          case 57: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 18;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 19;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 131: break;\n          case 58: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 132: break;\n          case 59: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 21;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 133: break;\n          case 60: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 134: break;\n          case 61: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                  breakByHyphens(tok);\n                  tok = yytext();\n                  String norm = removeSoftHyphens(tok);\n                  if (DEBUG) { logger.info(\"Used {HTHING} (2) to recognize \" + tok + \" as \" + norm); }\n                  return getNext(norm, tok);\n            }\n          case 135: break;\n          case 62: \n            { if (splitAssimilations) {\n                      yypushback(3);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 136: break;\n          case 63: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNormalizedAmpNext();\n            }\n          case 137: break;\n          case 64: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 9;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 138: break;\n          case 65: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { return getNext();\n            }\n          case 139: break;\n          case 66: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 14;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 140: break;\n          case 67: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 8;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 141: break;\n          case 68: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 13;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 142: break;\n          case 69: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 143: break;\n          case 70: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);\n            { return getNext();\n            }\n          case 144: break;\n          case 71: \n            // lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { return getNext();\n            }\n          case 145: break;\n          case 72: \n            { String txt = yytext();\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); // change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          if (DEBUG) { logger.info(\"Used {PHONE} to recognize \" + yytext() + \" as \" + txt); }\n                          return getNext(txt, yytext());\n            }\n          case 146: break;\n          case 73: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 25;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 147: break;\n          case 74: \n            // general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 24;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */\n                                    return handleEllipsis(yytext());\n            }\n          case 148: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n"
  },
  {
    "id": "facebook_fresco-242-FirstSentence-0",
    "old_comment_raw": "Performs key-value look up in disk cache.",
    "new_comment_raw": "Performs lookup of a series of disk cache keys in a single thread.",
    "old_code_raw": "  public Task<EncodedImage> get(final CacheKey key, final AtomicBoolean isCancelled) {\n    Preconditions.checkNotNull(key);\n    Preconditions.checkNotNull(isCancelled);\n\n    final EncodedImage pinnedImage = mStagingArea.get(key);\n    if (pinnedImage != null) {\n      FLog.v(TAG, \"Found image for %s in staging area\", key.toString());\n      mImageCacheStatsTracker.onStagingAreaHit();\n      return Task.forResult(pinnedImage);\n    }\n\n    try {\n      return Task.call(\n          new Callable<EncodedImage>() {\n            @Override\n            public EncodedImage call()\n                throws Exception {\n              if (isCancelled.get()) {\n                throw new CancellationException();\n              }\n              EncodedImage result = mStagingArea.get(key);\n              if (result != null) {\n                FLog.v(TAG, \"Found image for %s in staging area\", key.toString());\n                mImageCacheStatsTracker.onStagingAreaHit();\n              } else {\n                FLog.v(TAG, \"Did not find image for %s in staging area\", key.toString());\n                mImageCacheStatsTracker.onStagingAreaMiss();\n\n                try {\n                  final PooledByteBuffer buffer = readFromDiskCache(key);\n                  CloseableReference<PooledByteBuffer> ref = CloseableReference.of(buffer);\n                  try {\n                    result = new EncodedImage(ref);\n                  } finally {\n                    CloseableReference.closeSafely(ref);\n                  }\n                } catch (Exception exception) {\n                  return null;\n                }\n              }\n\n              if (Thread.interrupted()) {\n                FLog.v(TAG, \"Host thread was interrupted, decreasing reference count\");\n                if (result != null) {\n                  result.close();\n                }\n                throw new InterruptedException();\n              } else {\n                return result;\n              }\n            }\n          },\n          mReadExecutor);\n    } catch (Exception exception) {\n      // Log failure\n      // TODO: 3697790\n      FLog.w(\n          TAG,\n          exception,\n          \"Failed to schedule disk-cache read for %s\",\n          key.toString());\n      return Task.forError(exception);\n    }\n  }\n",
    "new_code_raw": "  public Task<EncodedImage> get(List<CacheKey> keys, final AtomicBoolean isCancelled) {\n    Preconditions.checkArgument(!keys.isEmpty());\n\n    for (CacheKey key : keys) {\n      final EncodedImage pinnedImage = mStagingArea.get(key);\n      if (pinnedImage != null) {\n        return foundPinnedImage(key, pinnedImage);\n      }\n    }\n\n    Task<EncodedImage> masterTask = getAsync(keys.get(0), isCancelled);\n    if (keys.size() == 1) {\n      return masterTask;\n    }\n    for (final CacheKey key : keys.subList(1, keys.size())) {\n      masterTask = masterTask.continueWithTask(\n          new Continuation<EncodedImage, Task<EncodedImage>>() {\n            @Override\n            public Task<EncodedImage> then(Task<EncodedImage> previousTask) throws Exception {\n              // If we've got a hit, stop. If this is cancelled, stop. Otherwise, keep going.\n              if (previousTask.isCancelled() || previousTask.getResult() != null) {\n                return previousTask;\n              }\n              return getAsync(key, isCancelled);\n            }\n          },\n          mReadExecutor);\n    }\n    return masterTask;\n  }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2272-FirstSentence-0",
    "old_comment_raw": "Convert a question to a statement, if possible.",
    "new_comment_raw": "Convert a question to a statement, if possible.",
    "old_code_raw": "  public List<List<CoreLabel>> toStatement(List<CoreLabel> question) {\n    TokenSequenceMatcher matcher;\n    if ((matcher = triggerWhatIsThere.matcher(question)).matches()) {  // must come before triggerWhatIs\n      return postProcess(question, processWhatIsThere(matcher));\n    } else if ((matcher = triggerWhNNIs.matcher(question)).matches()) {  // must come before triggerWhatIs\n      return postProcess(question, processWhNNIs(matcher));\n    } else if ((matcher = triggerWhNNHave.matcher(question)).matches()) {  // must come before triggerWhatHave\n      return postProcess(question, processWhNNHaveIs(matcher));\n    } else if ((matcher = triggerWhNNHaveNN.matcher(question)).matches()) {  // must come before triggerWhatHave\n      return postProcess(question, processWhNNHaveNN(matcher));\n    } else if ((matcher = triggerWhatIs.matcher(question)).matches()) {\n      return postProcess(question, processWhatIs(matcher));\n    } else if ((matcher = triggerWhatHave.matcher(question)).matches()) {\n      return postProcess(question, processWhatHave(matcher));\n    } else if ((matcher = triggerWhereDo.matcher(question)).matches()) {\n      return postProcess(question, processWhereDo(matcher, question));\n    } else if ((matcher = triggerWhereIs.matcher(question)).matches()) {\n      return postProcess(question, processWhereIs(matcher));\n    } else if ((matcher = triggerWhoIs.matcher(question)).matches()) {\n      return postProcess(question, processWhoIs(matcher));\n    } else if ((matcher = triggerWhoDid.matcher(question)).matches()) {\n      return postProcess(question, processWhoDid(matcher));\n    } else if ((matcher = triggerWhatDo.matcher(question)).matches()) {\n      return postProcess(question, processWhatDo(matcher));\n    } else if ((matcher = triggerWhenDo.matcher(question)).matches()) {\n      return postProcess(question, processWhenDo(matcher));\n    } else if ((matcher = triggerHow.matcher(question)).matches()) {\n      return postProcess(question, processHow(matcher));\n    } else {\n      return Collections.emptyList();\n    }\n  }\n",
    "new_code_raw": "  public List<List<CoreLabel>> toStatement(List<CoreLabel> question) {\n    TokenSequenceMatcher matcher;\n    if ((matcher = triggerWhatIsThere.matcher(question)).matches()) {  // must come before triggerWhatIs\n      return postProcess(question, processWhatIsThere(matcher));\n    } else if ((matcher = triggerWhNNIs.matcher(question)).matches()) {  // must come before triggerWhatIs\n      return postProcess(question, processWhNNIs(matcher));\n    } else if ((matcher = triggerWhNNHave.matcher(question)).matches()) {  // must come before triggerWhatHave\n      return postProcess(question, processWhNNHaveIs(matcher));\n    } else if ((matcher = triggerWhNNHaveNN.matcher(question)).matches()) {  // must come before triggerWhatHave\n      return postProcess(question, processWhNNHaveNN(matcher));\n    } else if ((matcher = triggerHow.matcher(question)).matches()) {  // must come before triggerWhatIs\n      return postProcess(question, processHow(matcher));\n    } else if ((matcher = triggerHowMuchDo.matcher(question)).matches()) {\n      return postProcess(question, processHowMuchDo(matcher));\n    } else if ((matcher = triggerWhatIs.matcher(question)).matches()) {\n      return postProcess(question, processWhatIs(matcher));\n    } else if ((matcher = triggerWhatHave.matcher(question)).matches()) {\n      return postProcess(question, processWhatHave(matcher));\n    } else if ((matcher = triggerWhereDo.matcher(question)).matches()) {\n      return postProcess(question, processWhereDo(matcher, question));\n    } else if ((matcher = triggerWhereIs.matcher(question)).matches()) {\n      return postProcess(question, processWhereIs(matcher));\n    } else if ((matcher = triggerWhoIs.matcher(question)).matches()) {\n      return postProcess(question, processWhoIs(matcher));\n    } else if ((matcher = triggerWhoDid.matcher(question)).matches()) {\n      return postProcess(question, processWhoDid(matcher));\n    } else if ((matcher = triggerWhatDo.matcher(question)).matches()) {\n      return postProcess(question, processWhatDo(matcher));\n    } else if ((matcher = triggerWhenDo.matcher(question)).matches()) {\n      return postProcess(question, processWhenDo(matcher));\n    } else {\n      return Collections.emptyList();\n    }\n  }\n"
  },
  {
    "id": "Omegaphora_dalvik-3-Associations-FirstSentence",
    "old_comment_raw": "Returns an array containing Constructor objects describing all constructors which are visible from the current execution context.",
    "new_comment_raw": "Returns an array containing  Constructor objects for all public constructors for the class represented by this  Class.",
    "old_code_raw": "    public Constructor<T>[] getConstructors() throws SecurityException {\n        checkPublicMemberAccess();\n        return getDeclaredConstructors(this, true);\n    }\n",
    "new_code_raw": "    public Constructor[] getConstructors() throws SecurityException {\n        // BEGIN android-note\n        // trying to get closer to the RI which returns a raw constructor array.\n        // copied from newer version of harmony\n        // END android-note\n        checkPublicMemberAccess();\n        return getDeclaredConstructors(this, true);\n    }\n\n"
  },
  {
    "id": "fossasia_phimpme_android-6-FirstSentence-0",
    "old_comment_raw": "This function check if the selected account is already existed.",
    "new_comment_raw": "This function check if the selected account is already existed.",
    "old_code_raw": "    public boolean checkAlreadyExist(AccountDatabase.AccountName s) {\n\n        // Query in the realm database\n        RealmQuery<AccountDatabase> query = realm.where(AccountDatabase.class);\n\n        // Checking if string equals to is exist or not\n        query.equalTo(\"name\", s.toString());\n        RealmResults<AccountDatabase> result1 = query.findAll();\n\n        // Here checking if count of that values is greater than zero\n        return (result1.size() > 0) ? true : false;\n    }\n",
    "new_code_raw": "    public boolean checkAlreadyExist(AccountDatabase.AccountName s) {\n\n        // Query in the realm database\n        RealmQuery<AccountDatabase> query = realm.where(AccountDatabase.class);\n\n        // Checking if string equals to is exist or not\n        query.equalTo(\"name\", s.toString());\n        RealmResults<AccountDatabase> result1 = query.findAll();\n\n        // Here checking if count of that values is greater than zero\n        return result1.size() > 0;\n    }\n"
  },
  {
    "id": "byterom_android_external_spongycastle-89-Associations-FirstSentence",
    "old_comment_raw": "Return a DERObject containing the encoded certificate.",
    "new_comment_raw": "Return a ASN1Object containing the encoded certificate.",
    "old_code_raw": "    private DERObject toASN1Object(\n        X509Certificate cert)\n        throws CertificateEncodingException\n    {\n        try\n        {\n            return new ASN1InputStream(cert.getEncoded()).readObject();\n        }\n        catch (Exception e)\n        {\n            throw new CertificateEncodingException(\"Exception while encoding certificate: \" + e.toString());\n        }\n    }\n",
    "new_code_raw": "    private ASN1Object toASN1Object(\n        X509Certificate cert)\n        throws CertificateEncodingException\n    {\n        try\n        {\n            return new ASN1InputStream(cert.getEncoded()).readObject();\n        }\n        catch (Exception e)\n        {\n            throw new CertificateEncodingException(\"Exception while encoding certificate: \" + e.toString());\n        }\n    }\n\n"
  },
  {
    "id": "apache_calcite-588-FirstSentence-0",
    "old_comment_raw": "Translates an expression that is not in the cache.",
    "new_comment_raw": "Translates an expression that is not in the cache.",
    "old_code_raw": "    private Expression translate0(RexNode expr, RexImpTable.NullAs nullAs) {\n        if (expr instanceof RexInputRef) {\n            final int index = ((RexInputRef) expr).getIndex();\n            Expression x = inputGetter.field(list, index);\n            return nullAs.handle(list.append(\"v\", x));\n        }\n        if (expr instanceof RexLocalRef) {\n            return translate(\n                program.getExprList().get(((RexLocalRef) expr).getIndex()),\n                nullAs);\n        }\n        if (expr instanceof RexLiteral) {\n            return translateLiteral(\n                expr,\n                typeFactory.createTypeWithNullability(\n                    expr.getType(),\n                    isNullable(expr)\n                    && nullAs != RexImpTable.NullAs.NOT_POSSIBLE),\n                typeFactory,\n                nullAs);\n        }\n        if (expr instanceof RexCall) {\n            final RexCall call = (RexCall) expr;\n            final SqlOperator operator = call.getOperator();\n            RexImpTable.CallImplementor implementor =\n                RexImpTable.INSTANCE.get(operator);\n            if (implementor != null) {\n                return implementor.implement(this, call, nullAs);\n            }\n        }\n        switch (expr.getKind()) {\n        default:\n            throw new RuntimeException(\n                \"cannot translate expression \" + expr);\n        }\n    }\n",
    "new_code_raw": "    private Expression translate0(RexNode expr, RexImpTable.NullAs nullAs) {\n        if (expr instanceof RexInputRef) {\n            final int index = ((RexInputRef) expr).getIndex();\n            Expression x = inputGetter.field(list, index);\n            return list.append(\n                \"v\",\n                nullAs.handle(\n                    list.append(\"v\", x)));\n        }\n        if (expr instanceof RexLocalRef) {\n            return translate(\n                program.getExprList().get(((RexLocalRef) expr).getIndex()),\n                nullAs);\n        }\n        if (expr instanceof RexLiteral) {\n            return translateLiteral(\n                expr,\n                typeFactory.createTypeWithNullability(\n                    expr.getType(),\n                    isNullable(expr)\n                    && nullAs != RexImpTable.NullAs.NOT_POSSIBLE),\n                typeFactory,\n                nullAs);\n        }\n        if (expr instanceof RexCall) {\n            final RexCall call = (RexCall) expr;\n            final SqlOperator operator = call.getOperator();\n            RexImpTable.CallImplementor implementor =\n                RexImpTable.INSTANCE.get(operator);\n            if (implementor != null) {\n                return implementor.implement(this, call, nullAs);\n            }\n        }\n        switch (expr.getKind()) {\n        default:\n            throw new RuntimeException(\n                \"cannot translate expression \" + expr);\n        }\n    }\n"
  },
  {
    "id": "jenkinsci_openshift-sync-plugin-0-Associations-FirstSentence",
    "old_comment_raw": "Finds the Jenkins job for the given  BuildConfig and defaultNamespace",
    "new_comment_raw": "Finds the Jenkins job name for the given  BuildConfig.",
    "old_code_raw": "  public static String jenkinsJobName(BuildConfig bc, String defaultNamespace) {\n    String namespace = bc.getMetadata().getNamespace();\n    String name = bc.getMetadata().getName();\n    return jenkinsJobName(namespace, name, defaultNamespace);\n  }\n",
    "new_code_raw": "  public static String jenkinsJobName(BuildConfig bc) {\n    String namespace = bc.getMetadata().getNamespace();\n    String name = bc.getMetadata().getName();\n    return jenkinsJobName(namespace, name);\n  }\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2284-FirstSentence-0",
    "old_comment_raw": "Get a  TregexMatcher for this pattern on this tree.",
    "new_comment_raw": "Get a  TregexMatcher for this pattern on this tree.",
    "old_code_raw": "  public TregexMatcher matcher(Tree t, HeadFinder headFinder) {\n    return matcher(t, t, null, ArrayMap.<String, Tree>newArrayMap(), new VariableStrings(), headFinder);\n  }\n",
    "new_code_raw": "  public TregexMatcher matcher(Tree t, HeadFinder headFinder) {\n    return matcher(t, t, null, ArrayMap.newArrayMap(), new VariableStrings(), headFinder);\n  }\n"
  },
  {
    "id": "cemcatik_jtds-121-Associations-FirstSentence",
    "old_comment_raw": "Returns the  ConnectionJDBC2 object referenced by the  #statement instance variable.",
    "new_comment_raw": "Returns the  ConnectionJDBC object referenced by the  #statement instance variable.",
    "old_code_raw": "    private ConnectionJDBC2 getConnection() throws SQLException {\n        return (ConnectionJDBC2) statement.getConnection();\n    }\n",
    "new_code_raw": "    private ConnectionJDBC getConnection() throws SQLException {\n        return (ConnectionJDBC) statement.getConnection();\n    }\n\n"
  },
  {
    "id": "SeleniumHQ_selenium-707-FirstSentence-0",
    "old_comment_raw": "Sets which driver executable the builder will use.",
    "new_comment_raw": "Sets which driver executable the builder will use.",
    "old_code_raw": "    public Builder<DS> usingDriverExecutable(File file) {\n      checkNotNull(file);\n      checkExecutable(file);\n      this.exe = file;\n      return this;\n    }\n",
    "new_code_raw": "    public B usingDriverExecutable(File file) {\n      checkNotNull(file);\n      checkExecutable(file);\n      this.exe = file;\n      return (B) this;\n    }\n"
  },
  {
    "id": "cemcatik_jtds-75-Associations-FirstSentence",
    "old_comment_raw": "Update the SQL string and replace the &#63; markers with parameter names eg @P0, @P1 etc.",
    "new_comment_raw": "Update the SQL string and replace the ? markers with parameter names eg @P0, @P1 etc.",
    "old_code_raw": "    static String substituteParamMarkers(String sql, ParamInfo[] list){\n        StringBuffer buf = new StringBuffer(sql.length() + list.length * 6);\n        int start = 0;\n\n        for (int i = 0; i < list.length; i++) {\n            int pos = list[i].markerPos;\n\n            if (pos > 0) {\n                buf.append(sql.substring(start, list[i].markerPos));\n                start = pos + 1;\n                buf.append(\" @P\").append(i).append(' ');\n            }\n        }\n\n        if (start < sql.length()) {\n            buf.append(sql.substring(start));\n        }\n\n        return buf.toString();\n    }\n",
    "new_code_raw": "    static String substituteParamMarkers(String sql, ParamInfo[] list) {\n        // A parameter can have at most 8 characters: \" @P\" plus at most 4\n        // digits plus \" \". We substract the \"?\" placeholder, that's at most\n        // 7 extra characters needed for each parameter.\n        char[] buf = new char[sql.length() + list.length * 7];\n        int bufferPtr = 0; // Output buffer pointer\n        int start = 0;     // Input string pointer\n\n        for (int i = 0; i < list.length; i++) {\n            int pos = list[i].markerPos;\n\n            if (pos > 0) {\n                sql.getChars(start, pos, buf, bufferPtr);\n                bufferPtr += (pos - start);\n                start = pos + 1;\n\n                // Append \" @P\"\n                buf[bufferPtr++] = ' ';\n                buf[bufferPtr++] = '@';\n                buf[bufferPtr++] = 'P';\n\n                // Append parameter number\n                String number = String.valueOf(i);\n                number.getChars(0, number.length(), buf, bufferPtr);\n                bufferPtr += number.length();\n\n                // Append \" \"\n                buf[bufferPtr++] = ' ';\n            }\n        }\n\n        if (start < sql.length()) {\n            sql.getChars(start, sql.length(), buf, bufferPtr);\n            bufferPtr += (sql.length() - start);\n        }\n\n        return new String(buf, 0, bufferPtr);\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1878-FirstSentence-0",
    "old_comment_raw": "Test serialization of outer string types",
    "new_comment_raw": "Test serialization of outer string types",
    "old_code_raw": "  public String fakeOuterStringSerialize(String body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/string\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<String> localVarReturnType = new GenericType<String>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public String fakeOuterStringSerialize(String body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/string\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<String> localVarReturnType = new GenericType<String>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2271-FirstSentence-0",
    "old_comment_raw": "Convert a question to a statement, if possible.",
    "new_comment_raw": "Convert a question to a statement, if possible.",
    "old_code_raw": "  public List<List<CoreLabel>> toStatement(List<CoreLabel> question) {\n    TokenSequenceMatcher matcher;\n    if ((matcher = triggerWhatIsThere.matcher(question)).matches()) {  // must come before triggerWhatIs\n      return postProcess(question, processWhatIsThere(matcher));\n    } else if ((matcher = triggerWhNNIs.matcher(question)).matches()) {  // must come before triggerWhatIs\n      return postProcess(question, processWhNNIs(matcher));\n    } else if ((matcher = triggerWhNNHave.matcher(question)).matches()) {  // must come before triggerWhatHave\n      return postProcess(question, processWhNNHave(matcher));\n    } else if ((matcher = triggerWhNNHaveNN.matcher(question)).matches()) {  // must come before triggerWhatHave\n      return postProcess(question, processWhNNHaveNN(matcher));\n    } else if ((matcher = triggerWhatIs.matcher(question)).matches()) {\n      return postProcess(question, processWhatIs(matcher));\n    } else if ((matcher = triggerWhatHave.matcher(question)).matches()) {\n      return postProcess(question, processWhatHave(matcher));\n    } else if ((matcher = triggerWhereDo.matcher(question)).matches()) {\n      return postProcess(question, processWhereDo(matcher));\n    } else if ((matcher = triggerWhereIs.matcher(question)).matches()) {\n      return postProcess(question, processWhereIs(matcher));\n    } else if ((matcher = triggerWhoIs.matcher(question)).matches()) {\n      return postProcess(question, processWhoIs(matcher));\n    } else if ((matcher = triggerWhoDid.matcher(question)).matches()) {\n      return postProcess(question, processWhoDid(matcher));\n    } else if ((matcher = triggerWhatDo.matcher(question)).matches()) {\n      return postProcess(question, processWhatDo(matcher));\n    } else if ((matcher = triggerWhenDo.matcher(question)).matches()) {\n      return postProcess(question, processWhenDo(matcher));\n    } else {\n      return Collections.emptyList();\n    }\n  }\n",
    "new_code_raw": "  public List<List<CoreLabel>> toStatement(List<CoreLabel> question) {\n    TokenSequenceMatcher matcher;\n    if ((matcher = triggerWhatIsThere.matcher(question)).matches()) {  // must come before triggerWhatIs\n      return postProcess(question, processWhatIsThere(matcher));\n    } else if ((matcher = triggerWhNNIs.matcher(question)).matches()) {  // must come before triggerWhatIs\n      return postProcess(question, processWhNNIs(matcher));\n    } else if ((matcher = triggerWhNNHave.matcher(question)).matches()) {  // must come before triggerWhatHave\n      return postProcess(question, processWhNNHaveIs(matcher));\n    } else if ((matcher = triggerWhNNHaveNN.matcher(question)).matches()) {  // must come before triggerWhatHave\n      return postProcess(question, processWhNNHaveNN(matcher));\n    } else if ((matcher = triggerWhatIs.matcher(question)).matches()) {\n      return postProcess(question, processWhatIs(matcher));\n    } else if ((matcher = triggerWhatHave.matcher(question)).matches()) {\n      return postProcess(question, processWhatHave(matcher));\n    } else if ((matcher = triggerWhereDo.matcher(question)).matches()) {\n      return postProcess(question, processWhereDo(matcher, question));\n    } else if ((matcher = triggerWhereIs.matcher(question)).matches()) {\n      return postProcess(question, processWhereIs(matcher));\n    } else if ((matcher = triggerWhoIs.matcher(question)).matches()) {\n      return postProcess(question, processWhoIs(matcher));\n    } else if ((matcher = triggerWhoDid.matcher(question)).matches()) {\n      return postProcess(question, processWhoDid(matcher));\n    } else if ((matcher = triggerWhatDo.matcher(question)).matches()) {\n      return postProcess(question, processWhatDo(matcher));\n    } else if ((matcher = triggerWhenDo.matcher(question)).matches()) {\n      return postProcess(question, processWhenDo(matcher));\n    } else if ((matcher = triggerHow.matcher(question)).matches()) {\n      return postProcess(question, processHow(matcher));\n    } else {\n      return Collections.emptyList();\n    }\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2058-FirstSentence-0",
    "old_comment_raw": "Return the default value of the property",
    "new_comment_raw": "Return the default value of the property",
    "old_code_raw": "    public String toDefaultValue(Schema schema) {\n        if (schema.getDefault() != null) {\n            return schema.getDefault().toString();\n        }\n\n        if (ModelUtils.isBooleanSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isDateSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isDateTimeSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isNumberSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isIntegerSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isStringSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isObjectSchema(schema)) {\n            return \"null\";\n        } else {\n            return \"null\";\n        }\n    }\n",
    "new_code_raw": "    public String toDefaultValue(Schema schema) {\n        if (schema.getDefault() != null) {\n            return schema.getDefault().toString();\n        }\n\n        return getPropertyDefaultValue(schema);\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2375-FirstSentence-0",
    "old_comment_raw": "Compiles a sequence of regular expression a TokenSequencePattern using the specified environment.",
    "new_comment_raw": "Compiles a PatternExpr into a TokenSequencePattern.",
    "old_code_raw": "  public static TokenSequencePattern compile(Env env, String... strings)\n  {\n    try {\n      List<SequencePattern.PatternExpr> patterns = new ArrayList<SequencePattern.PatternExpr>();\n      for (String string:strings) {\n        // TODO: Check token sequence parser?\n        SequencePattern.PatternExpr pattern = env.parser.parseSequence(env, string);\n        patterns.add(pattern);\n      }\n      SequencePattern.PatternExpr nodeSequencePattern = new SequencePattern.SequencePatternExpr(patterns);\n      return new TokenSequencePattern(StringUtils.join(strings), nodeSequencePattern);\n    } catch (Exception ex) {\n      throw new RuntimeException(ex);\n    }\n  }\n",
    "new_code_raw": "  public static TokenSequencePattern compile(SequencePattern.PatternExpr nodeSequencePattern)\n  {\n    return new TokenSequencePattern(null, nodeSequencePattern);\n  }\n"
  },
  {
    "id": "zaproxy_zaproxy-1960-FirstSentence-0",
    "old_comment_raw": "Check out if breakpoint should be applied on given  WebSocketMessageDTO#opcode.",
    "new_comment_raw": "Check out if breakpoint should be applied on given  WebSocketMessageDTO#opcode.",
    "old_code_raw": "\tprivate boolean isBreakOnOpcode(Integer opcode) {\n\t\tif (config.isBreakOnPingPong()) {\n\t\t\t// break on every message type\n\t\t\treturn true;\n\t\t} else {\n\t\t\t// break only on non-ping/pong\n\t\t\tboolean isPing = opcode.equals(WebSocketMessage.OPCODE_PING);\n\t\t\tboolean isPong = opcode.equals(WebSocketMessage.OPCODE_PONG);\n\t\t\t\n\t\t\tif (!isPing && !isPong) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "new_code_raw": "\tprivate boolean isBreakOnOpcode(Integer opcode) {\n\t\tboolean shouldBreak = false;\n\t\tif (config.isBreakOnPingPong()) {\n\t\t\t// break on every message type\n\t\t\tshouldBreak = true;\n\t\t} else {\n\t\t\t// break only on non-ping/pong\n\t\t\tboolean isPing = opcode.equals(WebSocketMessage.OPCODE_PING);\n\t\t\tboolean isPong = opcode.equals(WebSocketMessage.OPCODE_PONG);\n\t\t\t\n\t\t\tif (!isPing && !isPong) {\n\t\t\t\tshouldBreak = true;\n\t\t\t}\n\t\t}\n\t\treturn shouldBreak;\n\t}\n"
  },
  {
    "id": "graphql_java_graphql_java-452-FirstSentence-0",
    "old_comment_raw": "Returns a data fetcher associated with a field within a container type",
    "new_comment_raw": "Returns a data fetcher associated with a field located at specified coordinates.",
    "old_code_raw": "    public DataFetcher getDataFetcher(GraphQLFieldsContainer parentType, GraphQLFieldDefinition fieldDefinition) {\n        return getDataFetcherImpl(parentType, fieldDefinition, dataFetcherMap, systemDataFetcherMap);\n    }\n",
    "new_code_raw": "    public DataFetcher getDataFetcher(FieldCoordinates coordinates, GraphQLFieldDefinition fieldDefinition) {\n        return getDataFetcherImpl(coordinates, fieldDefinition, dataFetcherMap, systemDataFetcherMap);\n    }\n"
  },
  {
    "id": "apache_calcite-488-FirstSentence-0",
    "old_comment_raw": "Creates a LogicalAggregate that removes all duplicates from the result of an underlying relational expression.",
    "new_comment_raw": "Creates a LogicalAggregate that removes all duplicates from the result of an underlying relational expression.",
    "old_code_raw": "  public static RelNode createDistinctRel(RelNode rel) {\n    return LogicalAggregate.create(rel,\n        ImmutableBitSet.range(rel.getRowType().getFieldCount()), null,\n        ImmutableList.<AggregateCall>of());\n  }\n",
    "new_code_raw": "  public static RelNode createDistinctRel(RelNode rel) {\n    return LogicalAggregate.create(rel,\n        ImmutableBitSet.range(rel.getRowType().getFieldCount()), null,\n        ImmutableList.of());\n  }\n"
  },
  {
    "id": "byterom_android_external_spongycastle-97-Associations-FirstSentence",
    "old_comment_raw": "Return a DERObject containing the encoded certificate.",
    "new_comment_raw": "Return a ASN1Primitive containing the encoded certificate.",
    "old_code_raw": "    private DERObject toASN1Object(\n        X509Certificate cert )\n        throws CertificateEncodingException\n    {\n        try\n        {\n            return new ASN1InputStream(cert.getEncoded()).readObject();\n        }\n        catch (Exception e)\n        {\n            throw new CertificateEncodingException(\"Exception while encoding certificate: \" + e.toString());\n        }\n    }\n",
    "new_code_raw": "    private ASN1Primitive toASN1Object(\n        X509Certificate cert )\n        throws CertificateEncodingException\n    {\n        try\n        {\n            return new ASN1InputStream(cert.getEncoded()).readObject();\n        }\n        catch (Exception e)\n        {\n            throw new CertificateEncodingException(\"Exception while encoding certificate: \" + e.toString());\n        }\n    }\n\n"
  },
  {
    "id": "lingochamp_FileDownloader-54-FirstSentence-0",
    "old_comment_raw": "Start the download queue by the same listener",
    "new_comment_raw": "Start the download queue by the same listener",
    "old_code_raw": "    public boolean start(final FileDownloadListener listener, final boolean isSerial) {\n\n        if (listener == null) {\n            FileDownloadLog.w(this, \"Tasks with the listener can't start, because the listener \" +\n                    \"provided is null: [null, %B]\", isSerial);\n            return false;\n        }\n\n        final List<BaseDownloadTask> list = FileDownloadList.getImpl().copy(listener);\n\n        if (FileDownloadMonitor.isValid()) {\n            FileDownloadMonitor.getMonitor().onRequestStart(list.size(), isSerial, listener);\n        }\n\n        if (FileDownloadLog.NEED_LOG) {\n            FileDownloadLog.v(this, \"start list size[%d] listener[%s] isSerial[%B]\", list.size(),\n                    listener, isSerial);\n        }\n\n        if (null == list || list.isEmpty()) {\n            FileDownloadLog.w(this, \"Tasks with the listener can't start, because can't find any \" +\n                    \"task with the provided listener: [%s, %B]\", listener, isSerial);\n            return false;\n        }\n\n        if (isSerial) {\n            // serial\n            final Handler serialHandler = createSerialHandler(list);\n            Message msg = serialHandler.obtainMessage();\n            msg.what = WHAT_SERIAL_NEXT;\n            msg.arg1 = 0;\n            serialHandler.sendMessage(msg);\n            synchronized (RUNNING_SERIAL_MAP) {\n                RUNNING_SERIAL_MAP.put(listener, serialHandler);\n            }\n        } else {\n            // parallel\n            for (final BaseDownloadTask downloadTask : list) {\n                downloadTask.start();\n            }\n        }\n\n        return true;\n    }\n",
    "new_code_raw": "    public boolean start(final FileDownloadListener listener, final boolean isSerial) {\n\n        if (listener == null) {\n            FileDownloadLog.w(this, \"Tasks with the listener can't start, because the listener \" +\n                    \"provided is null: [null, %B]\", isSerial);\n            return false;\n        }\n\n\n        return isSerial ? startSerialTasks(listener) : startParallelTasks(listener);\n    }\n"
  },
  {
    "id": "apache_oozie-34-Associations-FirstSentence",
    "old_comment_raw": "Convert a JSONArray into a SLAEvent list.",
    "new_comment_raw": "Convert a JSONArray into a SLARegistrationBean list.",
    "old_code_raw": "    public static List<SLAEvent> fromJSONArray(JSONArray array) {\n        List<SLAEvent> list = new ArrayList<SLAEvent>();\n        for (Object obj : array) {\n            list.add(new JsonSLARegistrationEvent((JSONObject) obj));\n        }\n        return list;\n    }\n",
    "new_code_raw": "    public static List<SLARegistrationBean> fromJSONArray(JSONArray array) {\n        List<SLARegistrationBean> list = new ArrayList<SLARegistrationBean>();\n        for (Object obj : array) {\n            list.add(new SLARegistrationBean((JSONObject) obj));\n        }\n        return list;\n    }\n\n"
  },
  {
    "id": "querydsl_querydsl-256-FirstSentence-0",
    "old_comment_raw": "Expr : left.substring(right)",
    "new_comment_raw": "Expr : left.substring(right)",
    "old_code_raw": "    public static EString substring(Expr<String> left, int right) {\n        return createString(Ops.SUBSTR1ARG, left, createConstant(right));\n    }\n",
    "new_code_raw": "    public static EString substring(Expr<String> left, int right) {\n        return factory.createString(Ops.SUBSTR1ARG, left, factory.createConstant(right));\n    }\n"
  },
  {
    "id": "apache_lenya-369-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Checks if the tag stack is empty",
    "old_code_raw": "        public boolean isEmpty() {\n            return tags.isEmpty();\n        }\n",
    "new_code_raw": "        public boolean isEmpty() {\n            return this.tags.isEmpty();\n        }\n\n"
  },
  {
    "id": "querydsl_querydsl-328-FirstSentence-0",
    "old_comment_raw": "Get an expression representing the current time instant as a EDateTime instance",
    "new_comment_raw": "Get an expression representing the current time instant as a EDateTime instance",
    "old_code_raw": "    public static EDateTime<Date> currentTimestamp() {\n        return ODateTime.create(Date.class, Ops.DateTimeOps.CURRENT_TIMESTAMP);\n    }\n",
    "new_code_raw": "    public static EDateTime<Date> currentTimestamp() {\n        return currentTimestamp(Date.class);\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-550-FirstSentence-0",
    "old_comment_raw": "Get the millis of day property",
    "new_comment_raw": "Get the millis of day property",
    "old_code_raw": "    public MutableDateTimeFieldProperty millisOfDay() {\n        return new MutableDateTimeFieldProperty(this, getChronology().millisOfDay());\n    }\n",
    "new_code_raw": "    public ReadWritableInstantFieldProperty millisOfDay() {\n        return new ReadWritableInstantFieldProperty(this, getChronology().millisOfDay());\n    }\n"
  },
  {
    "id": "LawnchairLauncher_Lawnchair-42-FirstSentence-0",
    "old_comment_raw": "Handles forwarded motion events and determines when to stop forwarding.",
    "new_comment_raw": "Handles forwarded motion events and determines when to stop forwarding.",
    "old_code_raw": "    private boolean onTouchForwarded(MotionEvent srcEvent) {\n        final View src = mSrcIcon;\n\n        final DeepShortcutsContainer dst = mLauncher.getOpenShortcutsContainer();\n        if (dst == null) {\n            return false;\n        }\n\n        // Convert event to destination-local coordinates.\n        final MotionEvent dstEvent = MotionEvent.obtainNoHistory(srcEvent);\n        Utilities.translateEventCoordinates(src, dst, dstEvent);\n\n        // Forward converted event to destination view, then recycle it.\n        // TODO: don't create objects in onForwardedEvent.\n        final boolean handled = dst.onForwardedEvent(dstEvent, mActivePointerId, mTouchDown);\n        dstEvent.recycle();\n\n        // Always cancel forwarding when the touch stream ends.\n        final int action = srcEvent.getActionMasked();\n        final boolean keepForwarding = action != MotionEvent.ACTION_UP\n                && action != MotionEvent.ACTION_CANCEL;\n\n        return handled && keepForwarding;\n    }\n",
    "new_code_raw": "    private boolean onTouchForwarded(MotionEvent srcEvent) {\n        final View src = mSrcIcon;\n\n        final DeepShortcutsContainer dst = mLauncher.getOpenShortcutsContainer();\n        if (dst == null) {\n            return false;\n        }\n        if (!dst.isLaidOut()) {\n            return true;\n        }\n\n        // Convert event to destination-local coordinates.\n        final MotionEvent dstEvent = MotionEvent.obtainNoHistory(srcEvent);\n        Utilities.translateEventCoordinates(src, dst, dstEvent);\n\n        // Convert touch down event to destination-local coordinates.\n        if (!mHasMappedTouchDownToContainerCoord) {\n            mDragLayer.mapCoordInSelfToDescendent(dst, mTouchDown);\n            mHasMappedTouchDownToContainerCoord = true;\n        }\n\n        // Forward converted event to destination view, then recycle it.\n        final boolean handled = dst.onForwardedEvent(dstEvent, mActivePointerId, mTouchDown);\n        dstEvent.recycle();\n\n        // Always cancel forwarding when the touch stream ends.\n        final int action = srcEvent.getActionMasked();\n        final boolean keepForwarding = action != MotionEvent.ACTION_UP\n                && action != MotionEvent.ACTION_CANCEL;\n\n        return handled && keepForwarding;\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-1605-FirstSentence-0",
    "old_comment_raw": "Extract the nominal patterns from this sentence.",
    "new_comment_raw": "Extract the nominal patterns from this sentence.",
    "old_code_raw": "  public List<RelationTriple> extract(SemanticGraph parse, List<CoreLabel> tokens) {\n    List<RelationTriple> extractions = new ArrayList<>();\n    Set<Triple<Span,String,Span>> alreadyExtracted = new HashSet<>();\n\n    //\n    // Run Token Patterns\n    //\n    for (TokenSequencePattern tokenPattern : NOUN_TOKEN_PATTERNS) {\n      TokenSequenceMatcher tokenMatcher = tokenPattern.matcher(tokens);\n      while (tokenMatcher.find()) {\n        boolean missingPrefixBe;\n        boolean missingSuffixOf = false;\n\n        // Create subject\n        List<? extends CoreMap> subject = tokenMatcher.groupNodes(\"$subject\");\n        Span subjectSpan = Util.extractNER(tokens, Span.fromValues(((CoreLabel) subject.get(0)).index() - 1, ((CoreLabel) subject.get(subject.size() - 1)).index()));\n        List<CoreLabel> subjectTokens = new ArrayList<>();\n        for (int i : subjectSpan) {\n          subjectTokens.add(tokens.get(i));\n        }\n\n        // Create object\n        List<? extends CoreMap> object = tokenMatcher.groupNodes(\"$object\");\n        Span objectSpan = Util.extractNER(tokens, Span.fromValues(((CoreLabel) object.get(0)).index() - 1, ((CoreLabel) object.get(object.size() - 1)).index()));\n        if (Span.overlaps(subjectSpan, objectSpan)) {\n          continue;\n        }\n        List<CoreLabel> objectTokens = new ArrayList<>();\n        for (int i : objectSpan) {\n          objectTokens.add(tokens.get(i));\n        }\n\n        // Create relation\n        if (subjectTokens.size() > 0 && objectTokens.size() > 0) {\n          List<CoreLabel> relationTokens = new ArrayList<>();\n          // (add the 'be')\n          missingPrefixBe = true;\n          // (add a complement to the 'be')\n          List<? extends CoreMap> beofComp = tokenMatcher.groupNodes(\"$beof_comp\");\n          if (beofComp != null) {\n            // (add the complement\n            for (CoreMap token : beofComp) {\n              if (token instanceof CoreLabel) {\n                relationTokens.add((CoreLabel) token);\n              } else {\n                relationTokens.add(new CoreLabel(token));\n              }\n            }\n            // (add the 'of')\n            missingSuffixOf = true;\n          }\n          // Add extraction\n          String relationGloss = StringUtils.join(relationTokens.stream().map(CoreLabel::word), \" \");\n          if (!alreadyExtracted.contains(Triple.makeTriple(subjectSpan, relationGloss, objectSpan))) {\n            RelationTriple extraction = new RelationTriple(subjectTokens, relationTokens, objectTokens);\n            //noinspection ConstantConditions\n            extraction.isPrefixBe(missingPrefixBe);\n            extraction.isSuffixOf(missingSuffixOf);\n            extractions.add(extraction);\n            alreadyExtracted.add(Triple.makeTriple(subjectSpan, relationGloss, objectSpan));\n          }\n        }\n      }\n\n      //\n      // Run Semgrex Matches\n      //\n      for (SemgrexPattern semgrex : NOUN_DEPENDENCY_PATTERNS) {\n        SemgrexMatcher matcher = semgrex.matcher(parse);\n        while (matcher.find()) {\n          boolean missingPrefixBe = false;\n          boolean missingSuffixBe = false;\n          boolean istmod = false;\n\n          // Get relaux if applicable\n          String relaux = matcher.getRelnString(\"relaux\");\n          String ignoredArc = relaux;\n          if (ignoredArc == null) {\n            ignoredArc = matcher.getRelnString(\"arc\");\n          }\n\n          // Create subject\n          IndexedWord subject = matcher.getNode(\"subject\");\n          List<IndexedWord> subjectTokens = new ArrayList<>();\n          Span subjectSpan;\n          if (subject.ner() != null && !\"O\".equals(subject.ner())) {\n            subjectSpan = Util.extractNER(tokens, Span.fromValues(subject.index() - 1, subject.index()));\n            for (int i : subjectSpan) {\n              subjectTokens.add(new IndexedWord(tokens.get(i)));\n            }\n          } else {\n            subjectTokens = getValidChunk(parse, subject, VALID_SUBJECT_ARCS, Optional.ofNullable(ignoredArc), true).orElse(Collections.singletonList(subject));\n            subjectSpan = Util.tokensToSpan(subjectTokens);\n          }\n\n          // Create object\n          IndexedWord object = matcher.getNode(\"object\");\n          List<IndexedWord> objectTokens = new ArrayList<>();\n          Span objectSpan;\n          if (object.ner() != null && !\"O\".equals(object.ner())) {\n            objectSpan = Util.extractNER(tokens, Span.fromValues(object.index() - 1, object.index()));\n            for (int i : objectSpan) {\n              objectTokens.add(new IndexedWord(tokens.get(i)));\n            }\n          } else {\n            objectTokens = getValidChunk(parse, object, VALID_OBJECT_ARCS, Optional.ofNullable(ignoredArc), true).orElse(Collections.singletonList(object));\n            objectSpan = Util.tokensToSpan(objectTokens);\n          }\n\n          // Check that the pair is valid\n          if (Span.overlaps(subjectSpan, objectSpan)) {\n            continue;  // We extracted an identity\n          }\n          if (subjectSpan.end() == objectSpan.start() - 1 &&\n              (tokens.get(subjectSpan.end()).word().matches(\"[\\\\.,:;\\\\('\\\"]\") ||\n                  \"CC\".equals(tokens.get(subjectSpan.end()).tag()))) {\n            continue; // We're straddling a clause\n          }\n          if (objectSpan.end() == subjectSpan.start() - 1 &&\n              (tokens.get(objectSpan.end()).word().matches(\"[\\\\.,:;\\\\('\\\"]\") ||\n                  \"CC\".equals(tokens.get(objectSpan.end()).tag()))) {\n            continue; // We're straddling a clause\n          }\n\n          // Get any prepositional edges\n          String expected = relaux == null ? \"\" : relaux.substring(relaux.indexOf(\":\") + 1).replace(\"_\", \" \");\n          IndexedWord prepWord = null;\n          // (these usually come from the object)\n          boolean prepositionIsPrefix = false;\n          for (SemanticGraphEdge edge : parse.outgoingEdgeIterable(object)) {\n            if (edge.getRelation().toString().equals(\"case\")) {\n              prepWord = edge.getDependent();\n            }\n          }\n          // (...but sometimes from the subject)\n          if (prepWord == null) {\n            for (SemanticGraphEdge edge : parse.outgoingEdgeIterable(subject)) {\n              if (edge.getRelation().toString().equals(\"case\")) {\n                prepositionIsPrefix = true;\n                prepWord = edge.getDependent();\n              }\n            }\n          }\n          List<IndexedWord> prepChunk = Collections.EMPTY_LIST;\n          if (prepWord != null && !expected.equals(\"tmod\")) {\n            Optional<List<IndexedWord>> optionalPrepChunk = getValidChunk(parse, prepWord, Collections.singleton(\"mwe\"), Optional.empty(), true);\n            if (!optionalPrepChunk.isPresent()) { continue; }\n            prepChunk = optionalPrepChunk.get();\n            Collections.sort(prepChunk, (a, b) -> {\n              double val = a.pseudoPosition() - b.pseudoPosition();\n              if (val < 0) { return -1; }\n              if (val > 0) { return 1; }\n              else { return 0; }\n            });  // ascending sort\n          }\n\n          // Get the relation\n          if (subjectTokens.size() > 0 && objectTokens.size() > 0) {\n            LinkedList<IndexedWord> relationTokens = new LinkedList<>();\n            IndexedWord relNode = matcher.getNode(\"relation\");\n            if (relNode != null) {\n\n              // Case: we have a grounded relation span\n              // (add the relation)\n              relationTokens.add(relNode);\n              // (add any prepositional case markings)\n              if (prepositionIsPrefix) {\n                missingSuffixBe = true;  // We're almost certainly missing a suffix 'be'\n                for (int i = prepChunk.size() - 1; i >=0; --i) { relationTokens.addFirst(prepChunk.get(i)); }\n              } else {\n                relationTokens.addAll(prepChunk);\n              }\n              if (expected.equalsIgnoreCase(\"tmod\")) {\n                istmod = true;\n              }\n\n            } else {\n\n              // Case: we have a hallucinated relation span\n              // (mark it as missing a preceding 'be'\n              if (!expected.equals(\"poss\")) {\n                missingPrefixBe = true;\n              }\n              // (add any prepositional case markings)\n              if (prepositionIsPrefix) {\n                for (int i = prepChunk.size() - 1; i >=0; --i) { relationTokens.addFirst(prepChunk.get(i)); }\n              } else {\n                relationTokens.addAll(prepChunk);\n              }\n              if (expected.equalsIgnoreCase(\"tmod\")) {\n                istmod = true;\n              }\n              // (some fine-tuning)\n              if (allowNominalsWithoutNER && \"of\".equals(expected)) {\n                continue;  // prohibit things like \"conductor of electricity\" -> \"conductor; be of; electricity\"\n              }\n            }\n\n\n            // Add extraction\n            String relationGloss = StringUtils.join(relationTokens.stream().map(IndexedWord::word), \" \");\n            if (!alreadyExtracted.contains(Triple.makeTriple(subjectSpan, relationGloss, objectSpan))) {\n              RelationTriple extraction = new RelationTriple(\n                  subjectTokens.stream().map(IndexedWord::backingLabel).collect(Collectors.toList()),\n                  relationTokens.stream().map(IndexedWord::backingLabel).collect(Collectors.toList()),\n                  objectTokens.stream().map(IndexedWord::backingLabel).collect(Collectors.toList()));\n              extraction.istmod(istmod);\n              extraction.isPrefixBe(missingPrefixBe);\n              extraction.isSuffixBe(missingSuffixBe);\n              extractions.add(extraction);\n              alreadyExtracted.add(Triple.makeTriple(subjectSpan, relationGloss, objectSpan));\n            }\n          }\n        }\n      }\n    }\n\n    //\n    // Filter downward polarity extractions\n    //\n    Iterator<RelationTriple> iter = extractions.iterator();\n    while (iter.hasNext()) {\n      RelationTriple term = iter.next();\n      boolean shouldRemove = true;\n      for (CoreLabel token : term) {\n        if (token.get(NaturalLogicAnnotations.PolarityAnnotation.class) == null ||\n            !token.get(NaturalLogicAnnotations.PolarityAnnotation.class).isDownwards() ) {\n          shouldRemove = false;\n        }\n      }\n      if (shouldRemove) {\n        iter.remove();   // Don't extract things in downward polarity contexts.\n      }\n    }\n\n    // Return\n    return extractions;\n  }\n",
    "new_code_raw": "  public List<RelationTriple> extract(SemanticGraph parse, List<CoreLabel> tokens) {\n    List<RelationTriple> extractions = new ArrayList<>();\n    Set<Triple<Span,String,Span>> alreadyExtracted = new HashSet<>();\n\n    // Run Token Patterns\n    for (TokenSequencePattern tokenPattern : NOUN_TOKEN_PATTERNS) {\n      TokenSequenceMatcher tokenMatcher = tokenPattern.matcher(tokens);\n      while (tokenMatcher.find()) {\n        // Create subject\n        List<? extends CoreMap> subject = tokenMatcher.groupNodes(\"$subject\");\n        Span subjectSpan = Util.extractNER(tokens, Span.fromValues(((CoreLabel) subject.get(0)).index() - 1, ((CoreLabel) subject.get(subject.size() - 1)).index()));\n        List<CoreLabel> subjectTokens = new ArrayList<>();\n        for (int i : subjectSpan) {\n          subjectTokens.add(tokens.get(i));\n        }\n        // Create object\n        List<? extends CoreMap> object = tokenMatcher.groupNodes(\"$object\");\n        Span objectSpan = Util.extractNER(tokens, Span.fromValues(((CoreLabel) object.get(0)).index() - 1, ((CoreLabel) object.get(object.size() - 1)).index()));\n        if (Span.overlaps(subjectSpan, objectSpan)) {\n          continue;\n        }\n        List<CoreLabel> objectTokens = new ArrayList<>();\n        for (int i : objectSpan) {\n          objectTokens.add(tokens.get(i));\n        }\n        // Create relation\n        if (subjectTokens.size() > 0 && objectTokens.size() > 0) {\n          List<CoreLabel> relationTokens = new ArrayList<>();\n          // (add the 'be')\n          relationTokens.add(new CoreLabel() {{\n            setWord(\"is\");\n            setLemma(\"be\");\n            setTag(\"VBZ\");\n            setNER(\"O\");\n            setBeginPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition());\n            setEndPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition());\n            setSentIndex(subjectTokens.get(subjectTokens.size() - 1).sentIndex());\n            setIndex(-1);\n          }});\n          // (add a complement to the 'be')\n          List<? extends CoreMap> beofComp = tokenMatcher.groupNodes(\"$beof_comp\");\n          if (beofComp != null) {\n            // (add the complement\n            for (CoreMap token : beofComp) {\n              if (token instanceof CoreLabel) {\n                relationTokens.add((CoreLabel) token);\n              } else {\n                relationTokens.add(new CoreLabel(token));\n              }\n            }\n            // (add the 'of')\n            relationTokens.add(new CoreLabel() {{\n              setWord(\"of\");\n              setLemma(\"of\");\n              setTag(\"IN\");\n              setNER(\"O\");\n              setBeginPosition(objectTokens.get(0).beginPosition());\n              setEndPosition(objectTokens.get(0).beginPosition());\n              setSentIndex(objectTokens.get(0).sentIndex());\n              setIndex(-1);\n            }});\n          }\n          // Add extraction\n          String relationGloss = StringUtils.join(relationTokens.stream().map(CoreLabel::word), \" \");\n          if (!alreadyExtracted.contains(Triple.makeTriple(subjectSpan, relationGloss, objectSpan))) {\n            extractions.add(new RelationTriple(subjectTokens, relationTokens, objectTokens));\n            alreadyExtracted.add(Triple.makeTriple(subjectSpan, relationGloss, objectSpan));\n          }\n        }\n      }\n\n      // Run Semgrex Matches\n      for (SemgrexPattern semgrex : NOUN_DEPENDENCY_PATTERNS) {\n        SemgrexMatcher matcher = semgrex.matcher(parse);\n        while (matcher.find()) {\n          // Create subject\n          IndexedWord subject = matcher.getNode(\"subject\");\n          Span subjectSpan = Util.extractNER(tokens, Span.fromValues(subject.index() - 1, subject.index()));\n          List<CoreLabel> subjectTokens = new ArrayList<>();\n          for (int i : subjectSpan) {\n            subjectTokens.add(tokens.get(i));\n          }\n          // Create object\n          IndexedWord object = matcher.getNode(\"object\");\n          Span objectSpan = Util.extractNER(tokens, Span.fromValues(object.index() - 1, object.index()));\n          List<CoreLabel> objectTokens = new ArrayList<>();\n          for (int i : objectSpan) {\n            objectTokens.add(tokens.get(i));\n          }\n          // Check that the pair is valid\n          if (Span.overlaps(subjectSpan, objectSpan)) {\n            continue;  // We extracted an identity\n          }\n          if (subjectSpan.end() == objectSpan.start() - 1 &&\n              (tokens.get(subjectSpan.end()).word().matches(\"[\\\\.,:;\\\\('\\\"]\") ||\n                  \"CC\".equals(tokens.get(subjectSpan.end()).tag()))) {\n            continue; // We're straddling a clause\n          }\n          if (objectSpan.end() == subjectSpan.start() - 1 &&\n              (tokens.get(objectSpan.end()).word().matches(\"[\\\\.,:;\\\\('\\\"]\") ||\n                  \"CC\".equals(tokens.get(objectSpan.end()).tag()))) {\n            continue; // We're straddling a clause\n          }\n          // Get the relation\n          if (subjectTokens.size() > 0 && objectTokens.size() > 0) {\n            LinkedList<CoreLabel> relationTokens = new LinkedList<>();\n            IndexedWord relNode = matcher.getNode(\"relation\");\n            if (relNode != null) {\n              // (add the relation)\n              relationTokens.add(relNode.backingLabel());\n              // (check for aux information)\n              String relaux = matcher.getRelnString(\"relaux\");\n              if (relaux != null && relaux.startsWith(\"nmod:\") && !\"nmod:poss\".equals(relaux)) {\n                relationTokens.add(new CoreLabel() {{\n                  setWord(relaux.substring(\"nmod:\".length()));\n                  setLemma(relaux.substring(\"nmod:\".length()));\n                  setTag(\"PP\");\n                  setNER(\"O\");\n                  setBeginPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition());\n                  setEndPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition());\n                  setSentIndex(subjectTokens.get(subjectTokens.size() - 1).sentIndex());\n                  setIndex(-1);\n                }});\n              } else if (relaux != null && \"nmod:poss\".equals(relaux)) {\n                relationTokens.addFirst(new CoreLabel() {{\n                  setWord(\"'s\");\n                  setLemma(\"'s\");\n                  setTag(\"PP\");\n                  setNER(\"O\");\n                  setBeginPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition());\n                  setEndPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition());\n                  setSentIndex(subjectTokens.get(subjectTokens.size() - 1).sentIndex());\n                  setIndex(-1);\n                }});\n                relationTokens.addLast(new CoreLabel() {{\n                  setWord(\"is\");\n                  setLemma(\"be\");\n                  setTag(\"VBZ\");\n                  setNER(\"O\");\n                  setBeginPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition());\n                  setEndPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition());\n                  setSentIndex(subjectTokens.get(subjectTokens.size() - 1).sentIndex());\n                  setIndex(-1);\n                }});\n              }\n            } else {\n              // (add the 'be')\n              relationTokens.add(new CoreLabel() {{\n                setWord(\"is\");\n                setLemma(\"be\");\n                setTag(\"VBZ\");\n                setNER(\"O\");\n                setBeginPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition());\n                setEndPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition());\n                setSentIndex(subjectTokens.get(subjectTokens.size() - 1).sentIndex());\n                setIndex(-1);\n              }});\n              // (add an optional prep)\n              String rel = matcher.getRelnString(\"relation\");\n              String prep = null;\n              if (rel != null && rel.startsWith(\"nmod:\") && !\"nmod:poss\".equals(rel)) {\n                prep = rel.substring(\"nmod:\".length());\n              } else if (rel != null && (rel.startsWith(\"acl:\") || rel.startsWith(\"advcl:\")) ) {\n                prep = rel.substring(rel.indexOf(\":\"));\n              } else if (rel != null && rel.equals(\"nmod:poss\")) {\n                relationTokens.clear();\n                prep = \"'s\";\n              }\n              if (prep != null) {\n                final String p = prep;\n                relationTokens.add(new CoreLabel() {{\n                  setWord(p);\n                  setLemma(p);\n                  setTag(\"PP\");\n                  setNER(\"O\");\n                  setBeginPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition());\n                  setEndPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition());\n                  setSentIndex(subjectTokens.get(subjectTokens.size() - 1).sentIndex());\n                  setIndex(-1);\n                }});\n              }\n            }\n            // Add extraction\n            String relationGloss = StringUtils.join(relationTokens.stream().map(CoreLabel::word), \" \");\n            if (!alreadyExtracted.contains(Triple.makeTriple(subjectSpan, relationGloss, objectSpan))) {\n              extractions.add(new RelationTriple(subjectTokens, relationTokens, objectTokens));\n              alreadyExtracted.add(Triple.makeTriple(subjectSpan, relationGloss, objectSpan));\n            }\n          }\n        }\n      }\n    }\n\n    // Filter downward polarity extractions\n    Iterator<RelationTriple> iter = extractions.iterator();\n    while (iter.hasNext()) {\n      RelationTriple term = iter.next();\n      boolean shouldRemove = false;\n      for (CoreLabel token : term) {\n        if (token.get(NaturalLogicAnnotations.PolarityAnnotation.class) != null &&\n            token.get(NaturalLogicAnnotations.PolarityAnnotation.class).isDownwards() ) {\n          shouldRemove = true;\n        }\n      }\n      if (shouldRemove) { iter.remove(); }  // Don't extract things in downward polarity contexts.\n    }\n\n    // Return\n    return extractions;\n  }\n"
  },
  {
    "id": "debezium_debezium-35-FirstSentence-0",
    "old_comment_raw": "Get the number of nanoseconds past epoch of the given  java.time.LocalDateTime,  java.time.LocalDate,  java.time.LocalTime,  java.util.Date,  java.sql.Date,  java.sql.Time, or  java.sql.Timestamp.",
    "new_comment_raw": "Get the number of nanoseconds past epoch of the given  LocalDate.",
    "old_code_raw": "    public static long toEpochNanos(Object value, TemporalAdjuster adjuster) {\n        LocalDateTime dateTime = Conversions.toLocalDateTime(value);\n        if ( adjuster != null) {\n            dateTime = dateTime.with(adjuster);\n        }\n        return Conversions.toEpochNanos(dateTime);\n    }\n",
    "new_code_raw": "    private static long toEpochNanos(LocalDate date) {\n        long epochDay = date.toEpochDay();\n        return epochDay * Conversions.NANOSECONDS_PER_DAY;\n    }\n"
  },
  {
    "id": "apache_drill-1159-FirstSentence-0",
    "old_comment_raw": "Return the buffer's byte contents in the form of a hex dump.",
    "new_comment_raw": "Return the buffer's byte contents in the form of a hex dump.",
    "old_code_raw": "  public String toHexString(final int start, final int length) {\n    final int roundedStart = (start / LOG_BYTES_PER_ROW) * LOG_BYTES_PER_ROW;\n\n    final StringBuilder sb = new StringBuilder(\"buffer byte dump\\n\");\n    int index = roundedStart;\n    for (int nLogged = 0; nLogged < length; nLogged += LOG_BYTES_PER_ROW) {\n      sb.append(String.format(\" [%05d-%05d]\", index, index + LOG_BYTES_PER_ROW - 1));\n      for (int i = 0; i < LOG_BYTES_PER_ROW; ++i) {\n        try {\n          final byte b = getByte(index++);\n          sb.append(String.format(\" 0x%02x\", b));\n        } catch (IndexOutOfBoundsException ioob) {\n          sb.append(\" <ioob>\");\n        }\n      }\n      sb.append('\\n');\n    }\n    return sb.toString();\n  }\n",
    "new_code_raw": "  public String toHexString(final int start, final int length) {\n    Preconditions.checkArgument(start >= 0);\n    final StringBuilder sb = new StringBuilder(\"buffer byte dump\");\n    final int end = Math.min(length, this.length - start);\n    for (int i = 0; i < end; i++) {\n      if (i % LOG_BYTES_PER_ROW == 0) {\n        sb.append(String.format(\"%n [%05d-%05d]\", i + start, Math.min(i + LOG_BYTES_PER_ROW - 1, end - 1) + start));\n      }\n      byte b = _getByte(i + start);\n      sb.append(\" 0x\").append(HEX_CHAR[b >> 4]).append(HEX_CHAR[b & 0x0F]);\n    }\n    if (length > end) {\n      sb.append(String.format(\"%n [%05d-%05d] <ioob>\", start + end, start + length));\n    }\n    return sb.append(System.lineSeparator()).toString();\n  }\n"
  },
  {
    "id": "Netflix_eureka-377-FirstSentence-0",
    "old_comment_raw": "Gets the hash code for this applications instance.",
    "new_comment_raw": "Gets the reconciliation hashcode.",
    "old_code_raw": "    public String getReconcileHashCode() {\n        TreeMap<String, AtomicInteger> instanceCountMap = new TreeMap<String, AtomicInteger>();\n        populateInstanceCountMap(instanceCountMap);\n        return getReconcileHashCode(instanceCountMap);\n    }\n",
    "new_code_raw": "    public static String getReconcileHashCode(TreeMap<String, AtomicInteger> instanceCountMap) {\n        String reconcileHashCode = \"\";\n        for (Map.Entry<String, AtomicInteger> mapEntry : instanceCountMap\n                .entrySet()) {\n            reconcileHashCode = reconcileHashCode + mapEntry.getKey()\n                    + STATUS_DELIMITER + mapEntry.getValue().get()\n                    + STATUS_DELIMITER;\n        }\n        return reconcileHashCode;\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2418-FirstSentence-0",
    "old_comment_raw": "Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.",
    "new_comment_raw": "Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.",
    "old_code_raw": "  public int yylex() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          int zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 5: \n          { yybegin(YYINITIAL);\n                     /* System.out.println(\"End of sentence\"); */\n                            return ACCEPT;\n          }\n        case 6: break;\n        case 3: \n          { return ACCEPT;\n          }\n        case 7: break;\n        case 4: \n          { yybegin(SENTENCE);\n\t\t\t  /* System.out.println(\"Beginning of sentence\"); */\n\t\t\t  return ACCEPT;\n          }\n        case 8: break;\n        case 2: \n          { System.out.print(yytext());\n          }\n        case 9: break;\n        case 1: \n          { return IGNORE;\n          }\n        case 10: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            return YYEOF;\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n",
    "new_code_raw": "  public int yylex() throws java.io.IOException {\n    int yy_input;\n    int yy_action;\n\n    // cached fields:\n    int yy_currentPos_l;\n    int yy_startRead_l;\n    int yy_markedPos_l;\n    int yy_endRead_l = yy_endRead;\n    char[] yy_buffer_l = yy_buffer;\n    char[] yycmap_l = yycmap;\n\n    int[] yytrans_l = yytrans;\n    int[] yy_rowMap_l = yy_rowMap;\n    byte[] yy_attr_l = YY_ATTRIBUTE;\n\n    while (true) {\n      yy_markedPos_l = yy_markedPos;\n\n      yy_action = -1;\n\n      yy_startRead_l = yy_currentPos_l = yy_currentPos = yy_startRead = yy_markedPos_l;\n\n      yy_state = yy_lexical_state;\n\n\n      yy_forAction: {\n        while (true) {\n\n          if (yy_currentPos_l < yy_endRead_l) {\n            yy_input = yy_buffer_l[yy_currentPos_l++];\n          } else if (yy_atEOF) {\n            yy_input = YYEOF;\n            break yy_forAction;\n          } else {\n            // store back cached positions\n            yy_currentPos = yy_currentPos_l;\n            yy_markedPos = yy_markedPos_l;\n            boolean eof = yy_refill();\n            // get translated positions and possibly new buffer\n            yy_currentPos_l = yy_currentPos;\n            yy_markedPos_l = yy_markedPos;\n            yy_buffer_l = yy_buffer;\n            yy_endRead_l = yy_endRead;\n            if (eof) {\n              yy_input = YYEOF;\n              break yy_forAction;\n            } else {\n              yy_input = yy_buffer_l[yy_currentPos_l++];\n            }\n          }\n          int yy_next = yytrans_l[yy_rowMap_l[yy_state] + yycmap_l[yy_input]];\n          if (yy_next == -1) {\n            break yy_forAction;\n          }\n          yy_state = yy_next;\n\n          int yy_attributes = yy_attr_l[yy_state];\n          if ((yy_attributes & 1) == 1) {\n            yy_action = yy_state;\n            yy_markedPos_l = yy_currentPos_l;\n            if ((yy_attributes & 8) == 8) {\n              break yy_forAction;\n            }\n          }\n\n        }\n      }\n\n      // store back cached position\n      yy_markedPos = yy_markedPos_l;\n\n      switch (yy_action) {\n\n        case 4:\n        case 9:\n        case 10:\n        case 13:\n          {\n            return ACCEPT;\n          }\n        case 19:\n          break;\n        case 5:\n        case 6:\n        case 7:\n          {\n            return IGNORE;\n          }\n        case 20:\n          break;\n        case 2:\n          {\n            return IGNORE;\n          }\n        case 21:\n          break;\n        case 15:\n          {\n            yybegin(SENTENCE);\n            /* System.out.println(\"Beginning of sentence\"); */\n            return ACCEPT;\n          }\n        case 22:\n          break;\n        case 3:\n          {\n            System.out.print(yytext());\n          }\n        case 23:\n          break;\n        case 16:\n        case 17:\n          {\n            yybegin(YYINITIAL);\n            /* System.out.println(\"End of sentence\"); */\n            return ACCEPT;\n          }\n        case 24:\n          break;\n        default:\n          if (yy_input == YYEOF && yy_startRead == yy_currentPos) {\n            yy_atEOF = true;\n            return YYEOF;\n          } else {\n            yy_ScanError(YY_NO_MATCH);\n          }\n      }\n    }\n  }\n"
  },
  {
    "id": "google_google-oauth-java-client-4-Associations-FirstSentence",
    "old_comment_raw": "Executes the request for a new refresh token from the authorization endpoint from  #refreshToken().",
    "new_comment_raw": "Executes a request for new credentials from the token server.",
    "old_code_raw": "  protected TokenResponse executeRefreshToken() throws IOException {\n    return new RefreshTokenRequest(transport, jsonFactory, new GenericUrl(tokenServerEncodedUrl),\n        refreshToken).setClientAuthentication(clientAuthentication)\n        .setRequestInitializer(requestInitializer).execute();\n  }\n",
    "new_code_raw": "  protected TokenResponse executeRefreshToken() throws IOException {\n    if (refreshToken == null) {\n      return null;\n    }\n    return new RefreshTokenRequest(transport, jsonFactory, new GenericUrl(tokenServerEncodedUrl),\n        refreshToken).setClientAuthentication(clientAuthentication)\n        .setRequestInitializer(requestInitializer).execute();\n  }\n\n"
  },
  {
    "id": "apache_calcite-594-FirstSentence-0",
    "old_comment_raw": "Creates a Pair of appropriate type.",
    "new_comment_raw": "Creates a Pair of appropriate type.",
    "old_code_raw": "    public boolean equals(Object obj)\n    {\n        return (obj instanceof Pair)\n            && Util.equal(this.left, ((Pair) obj).left)\n            && Util.equal(this.right, ((Pair) obj).right);\n    }\n",
    "new_code_raw": "    public boolean equals(Object obj)\n    {\n        return this == obj\n            || (obj instanceof Pair)\n            && Util.equal(this.left, ((Pair) obj).left)\n            && Util.equal(this.right, ((Pair) obj).right);\n    }\n"
  },
  {
    "id": "apache_lenya-375-Associations-FirstSentence",
    "old_comment_raw": "Parse Content.",
    "new_comment_raw": "Return the author",
    "old_code_raw": "    public String getAuthor() {\n        return author;\n    }\n",
    "new_code_raw": "    public String getAuthor() {\n        return this.author;\n    }\n\n"
  },
  {
    "id": "apache_calcite-710-FirstSentence-0",
    "old_comment_raw": "Translates the list of  RexNode, using the default output types.",
    "new_comment_raw": "Translates the list of  RexNode, using the default output types.",
    "old_code_raw": "  public List<Expression> translateList(List<? extends RexNode> operandList) {\n    return translateList(operandList, null);\n  }\n",
    "new_code_raw": "  public List<Expression> translateList(List<? extends RexNode> operandList) {\n    return translateList(operandList, EnumUtils.internalTypes(operandList));\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2028-FirstSentence-0",
    "old_comment_raw": "Finds Pets by tags",
    "new_comment_raw": "Finds Pets by tags",
    "old_code_raw": "    public List<Pet> findPetsByTags(List<String> tags) throws ApiException {\n        ApiResponse<List<Pet>> resp = findPetsByTagsWithHttpInfo(tags);\n        return resp.getData();\n    }\n",
    "new_code_raw": "    public List<Pet> findPetsByTags(List<String> tags) throws ApiException {\n        ApiResponse<List<Pet>> localVarResp = findPetsByTagsWithHttpInfo(tags);\n        return localVarResp.getData();\n    }\n"
  },
  {
    "id": "Omegaphora_dalvik-2-Associations-FirstSentence",
    "old_comment_raw": "Returns the class loader which was used to load the class represented by the receiver.",
    "new_comment_raw": "Returns the class loader which was used to load the class represented by this  Class.",
    "old_code_raw": "    public ClassLoader getClassLoader() {\n        SecurityManager smgr = System.getSecurityManager();\n        if (smgr != null) {\n            ClassLoader calling = VMStack.getCallingClassLoader();\n            ClassLoader current = getClassLoaderImpl();\n\n            if (calling != null && !calling.getClass().isInstance(current)) {\n                smgr.checkPermission(new RuntimePermission(\"getClassLoader\"));\n            }\n        }\n        \n        ClassLoader loader = getClassLoaderImpl();\n        if (loader == null) {\n            loader = BootClassLoader.getInstance();\n        }\n        \n        return loader;\n    }\n",
    "new_code_raw": "    public ClassLoader getClassLoader() {\n        SecurityManager smgr = System.getSecurityManager();\n        ClassLoader loader = getClassLoaderImpl();\n        if (smgr != null && loader != null) {\n            ClassLoader calling = VMStack.getCallingClassLoader();\n\n            if (calling != null && !calling.isAncestorOf(loader)) {\n                smgr.checkPermission(new RuntimePermission(\"getClassLoader\"));\n            }\n        }\n        \n        if (this.isPrimitive()) {\n            return null;\n        }\n        \n        if (loader == null) {\n            loader = BootClassLoader.getInstance();\n        }\n        \n        return loader;\n    }\n\n"
  },
  {
    "id": "debezium_debezium-980-FirstSentence-0",
    "old_comment_raw": "Perform the initial sync of the collections in the replica set.",
    "new_comment_raw": "Perform the initial sync of the collections in the replica set.",
    "old_code_raw": "    protected boolean performInitialSync() {\n        delaySnapshotIfNeeded();\n\n        logger.info(\"Beginning initial sync of '{}' at {}\", rsName, source.lastOffset(rsName));\n        source.startInitialSync(replicaSet.replicaSetName());\n\n        // Set up our recorder to buffer the last record ...\n        try {\n            bufferedRecorder.startBuffering();\n        } catch (InterruptedException e) {\n            // Do nothing so that this thread is terminated ...\n            logger.info(\"Interrupted while waiting to flush the buffer before starting an initial sync of '{}'\", rsName);\n            return false;\n        }\n\n        // Get the current timestamp of this processor ...\n        final long syncStart = clock.currentTimeInMillis();\n\n        // We need to copy each collection, so put the collection IDs into a queue ...\n        final List<CollectionId> collections = primaryClient.collections();\n        final Queue<CollectionId> collectionsToCopy = new ConcurrentLinkedQueue<>(collections);\n        final int numThreads = Math.min(collections.size(), context.getConnectionContext().maxNumberOfCopyThreads());\n        final CountDownLatch latch = new CountDownLatch(numThreads);\n        final AtomicBoolean aborted = new AtomicBoolean(false);\n        final AtomicInteger replicatorThreadCounter = new AtomicInteger(0);\n        final AtomicInteger numCollectionsCopied = new AtomicInteger();\n        final AtomicLong numDocumentsCopied = new AtomicLong();\n\n        // And start threads to pull collection IDs from the queue and perform the copies ...\n        logger.info(\"Preparing to use {} thread(s) to sync {} collection(s): {}\",\n                    numThreads, collections.size(), Strings.join(\", \", collections));\n        for (int i = 0; i != numThreads; ++i) {\n            copyThreads.submit(() -> {\n                context.configureLoggingContext(replicaSet.replicaSetName() + \"-sync\" + replicatorThreadCounter.incrementAndGet());\n                // Continue to pull a collection ID and copy the collection ...\n                try {\n                    CollectionId id = null;\n                    while (!aborted.get() && (id = collectionsToCopy.poll()) != null) {\n                        long start = clock.currentTimeInMillis();\n                        logger.info(\"Starting initial sync of '{}'\", id);\n                        long numDocs = copyCollection(id, syncStart);\n                        numCollectionsCopied.incrementAndGet();\n                        numDocumentsCopied.addAndGet(numDocs);\n                        long duration = clock.currentTimeInMillis() - start;\n                        logger.info(\"Completing initial sync of {} documents from '{}' in {}\", numDocs, id, Strings.duration(duration));\n                    }\n                } catch (InterruptedException e) {\n                    // Do nothing so that this thread is terminated ...\n                    aborted.set(true);\n                } finally {\n                    latch.countDown();\n                }\n            });\n        }\n\n        // Wait for all of the threads to complete ...\n        try {\n            latch.await();\n        } catch (InterruptedException e) {\n            Thread.interrupted();\n            aborted.set(true);\n        }\n        this.copyThreads.shutdown();\n\n        // Stopping the replicator does not interrupt *our* thread but does interrupt the copy threads.\n        // Therefore, check the aborted state here ...\n        long syncDuration = clock.currentTimeInMillis() - syncStart;\n        if (aborted.get()) {\n            int remaining = collections.size() - numCollectionsCopied.get();\n            logger.info(\"Initial sync aborted after {} with {} of {} collections incomplete\",\n                        Strings.duration(syncDuration), remaining, collections.size());\n            return false;\n        }\n\n        // We completed the initial sync, so record this in the source ...\n        source.stopInitialSync(replicaSet.replicaSetName());\n        try {\n            // And immediately flush the last buffered source record with the updated offset ...\n            bufferedRecorder.stopBuffering(source.lastOffset(rsName));\n        } catch (InterruptedException e) {\n            logger.info(\"Interrupted while waiting for last initial sync record from replica set '{}' to be recorded\", rsName);\n            return false;\n        }\n\n        logger.info(\"Initial sync of {} collections with a total of {} documents completed in {}\",\n                    collections.size(), numDocumentsCopied.get(), Strings.duration(syncDuration));\n        return true;\n    }\n",
    "new_code_raw": "    protected boolean performInitialSync() {\n        try {\n            delaySnapshotIfNeeded();\n        }\n        catch (InterruptedException e) {\n            logger.info(\"Interrupted while awaiting initial snapshot delay\");\n            return false;\n        }\n\n        logger.info(\"Beginning initial sync of '{}' at {}\", rsName, source.lastOffset(rsName));\n        source.startInitialSync(replicaSet.replicaSetName());\n\n        // Set up our recorder to buffer the last record ...\n        try {\n            bufferedRecorder.startBuffering();\n        } catch (InterruptedException e) {\n            // Do nothing so that this thread is terminated ...\n            logger.info(\"Interrupted while waiting to flush the buffer before starting an initial sync of '{}'\", rsName);\n            return false;\n        }\n\n        // Get the current timestamp of this processor ...\n        final long syncStart = clock.currentTimeInMillis();\n\n        // We need to copy each collection, so put the collection IDs into a queue ...\n        final List<CollectionId> collections = primaryClient.collections();\n        final Queue<CollectionId> collectionsToCopy = new ConcurrentLinkedQueue<>(collections);\n        final int numThreads = Math.min(collections.size(), context.getConnectionContext().maxNumberOfCopyThreads());\n        final CountDownLatch latch = new CountDownLatch(numThreads);\n        final AtomicBoolean aborted = new AtomicBoolean(false);\n        final AtomicInteger replicatorThreadCounter = new AtomicInteger(0);\n        final AtomicInteger numCollectionsCopied = new AtomicInteger();\n        final AtomicLong numDocumentsCopied = new AtomicLong();\n\n        // And start threads to pull collection IDs from the queue and perform the copies ...\n        logger.info(\"Preparing to use {} thread(s) to sync {} collection(s): {}\",\n                    numThreads, collections.size(), Strings.join(\", \", collections));\n        for (int i = 0; i != numThreads; ++i) {\n            copyThreads.submit(() -> {\n                context.configureLoggingContext(replicaSet.replicaSetName() + \"-sync\" + replicatorThreadCounter.incrementAndGet());\n                // Continue to pull a collection ID and copy the collection ...\n                try {\n                    CollectionId id = null;\n                    while (!aborted.get() && (id = collectionsToCopy.poll()) != null) {\n                        long start = clock.currentTimeInMillis();\n                        logger.info(\"Starting initial sync of '{}'\", id);\n                        long numDocs = copyCollection(id, syncStart);\n                        numCollectionsCopied.incrementAndGet();\n                        numDocumentsCopied.addAndGet(numDocs);\n                        long duration = clock.currentTimeInMillis() - start;\n                        logger.info(\"Completing initial sync of {} documents from '{}' in {}\", numDocs, id, Strings.duration(duration));\n                    }\n                } catch (InterruptedException e) {\n                    // Do nothing so that this thread is terminated ...\n                    aborted.set(true);\n                } finally {\n                    latch.countDown();\n                }\n            });\n        }\n\n        // Wait for all of the threads to complete ...\n        try {\n            latch.await();\n        } catch (InterruptedException e) {\n            Thread.interrupted();\n            aborted.set(true);\n        }\n        this.copyThreads.shutdown();\n\n        // Stopping the replicator does not interrupt *our* thread but does interrupt the copy threads.\n        // Therefore, check the aborted state here ...\n        long syncDuration = clock.currentTimeInMillis() - syncStart;\n        if (aborted.get()) {\n            int remaining = collections.size() - numCollectionsCopied.get();\n            logger.info(\"Initial sync aborted after {} with {} of {} collections incomplete\",\n                        Strings.duration(syncDuration), remaining, collections.size());\n            return false;\n        }\n\n        // We completed the initial sync, so record this in the source ...\n        source.stopInitialSync(replicaSet.replicaSetName());\n        try {\n            // And immediately flush the last buffered source record with the updated offset ...\n            bufferedRecorder.stopBuffering(source.lastOffset(rsName));\n        } catch (InterruptedException e) {\n            logger.info(\"Interrupted while waiting for last initial sync record from replica set '{}' to be recorded\", rsName);\n            return false;\n        }\n\n        logger.info(\"Initial sync of {} collections with a total of {} documents completed in {}\",\n                    collections.size(), numDocumentsCopied.get(), Strings.duration(syncDuration));\n        return true;\n    }\n"
  },
  {
    "id": "justinedelson_felix-193-Associations-FirstSentence",
    "old_comment_raw": "Returns the cause of this exception or null if no cause was specified when this exception was created.",
    "new_comment_raw": "Returns the cause of this exception or null if no cause was set.",
    "old_code_raw": "\tpublic Throwable getCause() {\n\t\treturn cause;\n\t}\n",
    "new_code_raw": "\tpublic Throwable getCause() {\n\t\treturn super.getCause();\n\t}\n\n"
  },
  {
    "id": "querydsl_querydsl-746-FirstSentence-0",
    "old_comment_raw": "Add the fetch group to the set of active fetch groups.",
    "new_comment_raw": "Add the fetch group to the set of active fetch groups.",
    "old_code_raw": "    public Q addFetchGroup(String fetchGroupName) {\n        fetchGroups.add(fetchGroupName);\n        return (Q) this;\n    }\n",
    "new_code_raw": "    public Q addFetchGroup(String fetchGroupName) {\n        fetchGroups.add(fetchGroupName);\n        return queryMixin.getSelf();\n    }\n"
  },
  {
    "id": "zaproxy_zaproxy-2217-FirstSentence-0",
    "old_comment_raw": "Tells whether or not this site has any parameters (cookies, query or form parameters).",
    "new_comment_raw": "Tells whether or not this site has any parameters (cookies, query, form parameters, or response header fields).",
    "old_code_raw": "\tpublic boolean hasParams() {\n\t\treturn !cookieParams.isEmpty() || !urlParams.isEmpty() || !formParams.isEmpty();\n\t}\n",
    "new_code_raw": "\tpublic boolean hasParams() {\n\t\treturn !cookieParams.isEmpty() || !urlParams.isEmpty() || !formParams.isEmpty() || !headerParams.isEmpty();\n\t}\n"
  },
  {
    "id": "JodaOrg_joda_time-954-FirstSentence-0",
    "old_comment_raw": "Converts this object to a LocalDate with the same date and chronology.",
    "new_comment_raw": "Converts this object to a LocalDate with the same date and chronology.",
    "old_code_raw": "    public LocalDate getDate() {\n        return new LocalDate(\n                getYear(), getMonthOfYear(), getDayOfMonth(), getChronology());\n    }\n",
    "new_code_raw": "    public LocalDate getDate() {\n        return new LocalDate(getLocalMillis(), getChronology());\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-1020-FirstSentence-0",
    "old_comment_raw": "Returns a formatter that combines a full date and time without millis, separated by a 'T' (yyyy-MM-dd'T'HH:mm:ssZZ).",
    "new_comment_raw": "Returns a formatter that combines a full date and time without millis, separated by a 'T' (yyyy-MM-dd'T'HH:mm:ssZZ).",
    "old_code_raw": "    public static DateTimeFormatter dateTimeNoMillis() {\n        if (dtx == null) {\n            dtx = new DateTimeFormatterBuilder()\n                .append(date())\n                .append(tTimeNoMillis())\n                .toFormatter();\n        }\n        return dtx;\n    }\n",
    "new_code_raw": "    public static DateTimeFormatter dateTimeNoMillis() {\n        return Constants.dtx;\n    }\n"
  },
  {
    "id": "google_google-http-java-client-93-Associations-FirstSentence",
    "old_comment_raw": "Executes this request asynchronously using  #executeAsync(Executor) in a single separate thread using the supplied Executor.",
    "new_comment_raw": "Executes this request asynchronously in a single separate thread using the supplied executor.",
    "old_code_raw": "  public Future<HttpResponse> executeAsync(Executor exec) {\n    final SettableFuture<HttpResponse> future = SettableFuture.create();\n    exec.execute(new Runnable() {\n      public void run() {\n        try {\n          future.set(execute());\n        } catch (IOException ex) {\n          future.setException(ex);\n        }\n      }\n    });\n    return future;\n  }\n",
    "new_code_raw": "  public Future<HttpResponse> executeAsync(Executor executor) {\n    FutureTask<HttpResponse> future = new FutureTask<HttpResponse>(new Callable<HttpResponse>() {\n\n      public HttpResponse call() throws Exception {\n        return execute();\n      }\n    });\n    executor.execute(future);\n    return future;\n  }\n\n"
  },
  {
    "id": "apache_activemq-961-FirstSentence-0",
    "old_comment_raw": "Reads an object from the stream message.",
    "new_comment_raw": "Reads an object from the stream message.",
    "old_code_raw": "    public Object readObject() throws JMSException {\n        initializeReading();\n        try {\n            this.dataIn.mark(65);\n            int type = this.dataIn.read();\n            if (type == -1) {\n                throw new MessageEOFException(\"reached end of data\");\n            }\n            if (type == MarshallingSupport.NULL) {\n                return null;\n            }\n            if (type == MarshallingSupport.BIG_STRING_TYPE) {\n                return MarshallingSupport.readUTF8(dataIn);\n            }\n            if (type == MarshallingSupport.STRING_TYPE) {\n                return this.dataIn.readUTF();\n            }\n            if (type == MarshallingSupport.LONG_TYPE) {\n                return new Long(this.dataIn.readLong());\n            }\n            if (type == MarshallingSupport.INTEGER_TYPE) {\n                return new Integer(this.dataIn.readInt());\n            }\n            if (type == MarshallingSupport.SHORT_TYPE) {\n                return new Short(this.dataIn.readShort());\n            }\n            if (type == MarshallingSupport.BYTE_TYPE) {\n                return new Byte(this.dataIn.readByte());\n            }\n            if (type == MarshallingSupport.FLOAT_TYPE) {\n                return new Float(this.dataIn.readFloat());\n            }\n            if (type == MarshallingSupport.DOUBLE_TYPE) {\n                return new Double(this.dataIn.readDouble());\n            }\n            if (type == MarshallingSupport.BOOLEAN_TYPE) {\n                return this.dataIn.readBoolean() ? Boolean.TRUE : Boolean.FALSE;\n            }\n            if (type == MarshallingSupport.CHAR_TYPE) {\n                return new Character(this.dataIn.readChar());\n            }\n            if (type == MarshallingSupport.BYTE_ARRAY_TYPE) {\n                int len = this.dataIn.readInt();\n                byte[] value = new byte[len];\n                this.dataIn.readFully(value);\n                return value;\n            } else {\n                this.dataIn.reset();\n                throw new MessageFormatException(\"unknown type\");\n            }\n        } catch (NumberFormatException mfe) {\n            try {\n                this.dataIn.reset();\n            } catch (IOException ioe) {\n                throw JMSExceptionSupport.create(ioe);\n            }\n            throw mfe;\n\n        } catch (EOFException e) {\n            JMSException jmsEx = new MessageEOFException(e.getMessage());\n            jmsEx.setLinkedException(e);\n            throw jmsEx;\n        } catch (IOException e) {\n            JMSException jmsEx = new MessageFormatException(e.getMessage());\n            jmsEx.setLinkedException(e);\n            throw jmsEx;\n        }\n    }\n",
    "new_code_raw": "    public Object readObject() throws JMSException {\n        initializeReading();\n        try {\n            this.dataIn.mark(65);\n            int type = this.dataIn.read();\n            if (type == -1) {\n                throw new MessageEOFException(\"reached end of data\");\n            }\n            if (type == MarshallingSupport.NULL) {\n                return null;\n            }\n            if (type == MarshallingSupport.BIG_STRING_TYPE) {\n                return MarshallingSupport.readUTF8(dataIn);\n            }\n            if (type == MarshallingSupport.STRING_TYPE) {\n                return this.dataIn.readUTF();\n            }\n            if (type == MarshallingSupport.LONG_TYPE) {\n                return Long.valueOf(this.dataIn.readLong());\n            }\n            if (type == MarshallingSupport.INTEGER_TYPE) {\n                return Integer.valueOf(this.dataIn.readInt());\n            }\n            if (type == MarshallingSupport.SHORT_TYPE) {\n                return Short.valueOf(this.dataIn.readShort());\n            }\n            if (type == MarshallingSupport.BYTE_TYPE) {\n                return Byte.valueOf(this.dataIn.readByte());\n            }\n            if (type == MarshallingSupport.FLOAT_TYPE) {\n                return new Float(this.dataIn.readFloat());\n            }\n            if (type == MarshallingSupport.DOUBLE_TYPE) {\n                return new Double(this.dataIn.readDouble());\n            }\n            if (type == MarshallingSupport.BOOLEAN_TYPE) {\n                return this.dataIn.readBoolean() ? Boolean.TRUE : Boolean.FALSE;\n            }\n            if (type == MarshallingSupport.CHAR_TYPE) {\n                return Character.valueOf(this.dataIn.readChar());\n            }\n            if (type == MarshallingSupport.BYTE_ARRAY_TYPE) {\n                int len = this.dataIn.readInt();\n                byte[] value = new byte[len];\n                this.dataIn.readFully(value);\n                return value;\n            } else {\n                this.dataIn.reset();\n                throw new MessageFormatException(\"unknown type\");\n            }\n        } catch (NumberFormatException mfe) {\n            try {\n                this.dataIn.reset();\n            } catch (IOException ioe) {\n                throw JMSExceptionSupport.create(ioe);\n            }\n            throw mfe;\n\n        } catch (EOFException e) {\n            JMSException jmsEx = new MessageEOFException(e.getMessage());\n            jmsEx.setLinkedException(e);\n            throw jmsEx;\n        } catch (IOException e) {\n            JMSException jmsEx = new MessageFormatException(e.getMessage());\n            jmsEx.setLinkedException(e);\n            throw jmsEx;\n        }\n    }\n"
  },
  {
    "id": "mulesoft_google-connectors-suite-5-Associations-FirstSentence",
    "old_comment_raw": "Lists the changes for a user @sample.xml ../../../doc/GoogleDriveConnector.xml.sample google-drive:list-changes",
    "new_comment_raw": "Returns a paginated  Iterator with the  org.mule.module.google.drive.model.Change objects for a user @sample.xml ../../../doc/GoogleDriveConnector.xml.sample google-drive:list-changes",
    "old_code_raw": "\t@Processor\n    @OAuthProtected\n\t@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)\n\t@Inject\n\tpublic List<Change> listChanges(\n\t\t\tMuleMessage message,\n\t\t\t@Optional @Default(\"true\") boolean includeDeleted,\n\t\t\t@Optional @Default(\"true\") boolean includeSubscribed,\n\t\t\t@Optional @Default(\"100\") int maxResults,\n\t\t\t@Optional @Default(\"#[flowVars['GoogleDrive_NEXT_PAGE_TOKEN']]\") String pageToken,\n\t\t\t@Optional Long startChangeId\n\t\t\t) throws IOException {\n\t\t\n\t\tChangeList response = this.client.changes().list()\n\t\t\t\t\t\t\t\t\t.setIncludeDeleted(includeDeleted)\n\t\t\t\t\t\t\t\t\t.setIncludeSubscribed(includeSubscribed)\n\t\t\t\t\t\t\t\t\t.setMaxResults(maxResults)\n\t\t\t\t\t\t\t\t\t.setPageToken(pageToken)\n\t\t\t\t\t\t\t\t\t.setStartChangeId(startChangeId)\n\t\t\t\t\t\t\t\t\t.execute();\n\t\t\n\t\tPaginationUtils.savePageToken(NEXT_PAGE_TOKEN, response.getNextPageToken(), message);\n\t\t\n\t\treturn Change.valueOf(response.getItems(), Change.class);\n\t}\n",
    "new_code_raw": "\t@Processor\n    @OAuthProtected\n\t@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)\n\t@Paged\n\tpublic PagingDelegate<Change> listChanges(\n\t\t\tfinal @Optional @Default(\"true\") boolean includeDeleted,\n\t\t\tfinal @Optional @Default(\"true\") boolean includeSubscribed,\n\t\t\tfinal @Optional @Default(\"100\") int maxResults,\n\t\t\tfinal @Optional Long startChangeId,\n\t\t\tfinal PagingConfiguration pagingConfiguration\n\t\t\t) throws IOException {\n\t\t\n\t\treturn new TokenBasedPagingDelegate<Change>() {\n\t\t\t\n\t\t\t@Override\n\t\t\tprotected List<Change> doGetPage() throws IOException {\n\t\t\t\tChangeList response = client.changes().list()\n\t\t\t\t\t\t.setIncludeDeleted(includeDeleted)\n\t\t\t\t\t\t.setIncludeSubscribed(includeSubscribed)\n\t\t\t\t\t\t.setMaxResults(maxResults)\n\t\t\t\t\t\t.setPageToken(this.getPageToken())\n\t\t\t\t\t\t.setStartChangeId(startChangeId)\n\t\t\t\t\t\t.execute();\n\t\t\t\t\n\t\t\t\tthis.setPageToken(response.getNextPageToken());\n\t\t\t\treturn Change.valueOf(response.getItems(), Change.class);\n\t\t\t}\n\t\t};\n\t}\n\n"
  },
  {
    "id": "RobotiumTech_robotium-1411-FirstSentence-0",
    "old_comment_raw": "Returns a  List of all the opened/active activities.",
    "new_comment_raw": "Returns a  List of all the opened/active activities.",
    "old_code_raw": "\tpublic ArrayList<Activity> getAllOpenedActivities()\n\t{\n\t\treturn new ArrayList<Activity>(activityStack);\n\t}\n",
    "new_code_raw": "\tpublic ArrayList<Activity> getAllOpenedActivities()\n\t{\n\t\tArrayList<Activity> activities = new ArrayList<Activity>();\n\t\tIterator<WeakReference<Activity>> activityStackIterator = activityStack.iterator();\n\n\t\twhile(activityStackIterator.hasNext()){\n\t\t\tActivity  activity = activityStackIterator.next().get();\n\t\t\tif(activity!=null)\n\t\t\t\tactivities.add(activity);\n\t\t}\n\t\treturn activities;\n\t}\n"
  },
  {
    "id": "apache_calcite-913-FirstSentence-0",
    "old_comment_raw": "Creates a SqlParser to parse the given string using",
    "new_comment_raw": "Creates a SqlParser to parse the given string using the parser implementation created from given  SqlParserImplFactory with given quoting syntax and casing policies for identifiers.",
    "old_code_raw": "  public static SqlParser create(String s) {\n    return create(SqlParserImpl.FACTORY, s, Quoting.DOUBLE_QUOTE,\n        Casing.TO_UPPER, Casing.UNCHANGED);\n  }\n",
    "new_code_raw": "  public static SqlParser create(String sql, Config config) {\n    SqlAbstractParserImpl parser =\n        config.parserFactory().getParser(new StringReader(sql));\n\n    return new SqlParser(sql, parser, config);\n  }\n"
  },
  {
    "id": "SeleniumHQ_selenium-834-FirstSentence-0",
    "old_comment_raw": "Sends keys to the active element.",
    "new_comment_raw": "Sends keys to the active element.",
    "old_code_raw": "  public Actions sendKeys(CharSequence... keysToSend) {\n    return this.sendKeys(null, keysToSend);\n  }\n",
    "new_code_raw": "  public Actions sendKeys(CharSequence... keys) {\n    if (isBuildingActions()) {\n      action.addAction(new SendKeysAction(jsonKeyboard, jsonMouse, null, keys));\n      return this;\n    }\n\n    for (CharSequence key : keys) {\n      key.codePoints().forEach(codePoint -> {\n        tick(defaultKeyboard.createKeyDown(codePoint));\n        tick(defaultKeyboard.createKeyUp(codePoint));\n      });\n    }\n\n    return this;\n  }\n"
  },
  {
    "id": "Atmosphere_atmosphere-54-Associations-FirstSentence",
    "old_comment_raw": "Return the associated  HttpServletRequest",
    "new_comment_raw": "Return the associated  AtmosphereRequest",
    "old_code_raw": "    public HttpServletRequest getRequest() {\n        return atmosphereRequest;\n    }\n",
    "new_code_raw": "    public AtmosphereRequest getRequest() {\n        return atmosphereRequest;\n    }\n\n"
  },
  {
    "id": "RobotiumTech_robotium-1329-FirstSentence-0",
    "old_comment_raw": "Returns the active DecorView.",
    "new_comment_raw": "Returns the active DecorView.",
    "old_code_raw": "\tpublic View getActiveDecorView()\n\t{\n\t\tView [] views = getWindowDecorViews();\n\t\tActivity activity = activityUtils.getCurrentActivity(false);\n\t\tif(views !=null && views.length > 0)\n\t\t{\n\t\t\tint length = views.length;\n\t\t\tfor(int i = length - 1; i >= 0; i--){\n\t\t\t\tif(activity.hasWindowFocus() && activity.getWindow().getDecorView().equals(views[i])){\n\t\t\t\t\treturn views[i];\n\t\t\t\t}\n\t\t\t\telse if(!activity.hasWindowFocus() && !activity.getWindow().getDecorView().equals(views[i])){ \n\t\t\t\t\treturn views[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn views[views.length-1];\n\t\t}\n\t\telse\n\t\t\treturn null;\n\t}\n",
    "new_code_raw": "\tpublic View getActiveDecorView()\n\t{\n\t\tfinal View [] views = getWindowDecorViews();\n\t\tfinal Activity activity = activityUtils.getCurrentActivity(false);\n\t\tif(views !=null && views.length > 0)\n\t\t{\n\t\t\tint length = views.length;\n\t\t\tfor(int i = length - 1; i >= 0; i--){\n\t\t\t\n\t\t\t\tif(activity.hasWindowFocus() && getCurrentViews(TextView.class,(ViewGroup) views[i]).size()==1) {\n\t\t\t\t\treturn views[i];\n\t\t\t\t}\t\n\t\t\t\telse if(activity.hasWindowFocus() && activity.getWindow().getDecorView().equals(views[i])){\n\t\t\t\t\treturn views[i];\n\t\t\t\t}\n\t\t\t\telse if(!activity.hasWindowFocus() && !activity.getWindow().getDecorView().equals(views[i])){ \n\t\t\t\t\treturn views[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn views[views.length-1];\n\t\t}\n\t\telse\n\t\t\treturn null;\n\t}\n"
  },
  {
    "id": "alibaba_jstorm-78-FirstSentence-0",
    "old_comment_raw": "get cluster's summary, it will contain SupervisorSummary and",
    "new_comment_raw": "get cluster's summary, it will contain SupervisorSummary and TopologySummary",
    "old_code_raw": "    public ClusterSummary getClusterInfo() throws TException {\n        long start = System.nanoTime();\n        try {\n\n            StormClusterState stormClusterState = data.getStormClusterState();\n\n            Map<String, Assignment> assignments =\n                    new HashMap<String, Assignment>();\n\n            // get TopologySummary\n            List<TopologySummary> topologySummaries =\n                    NimbusUtils.getTopologySummary(stormClusterState,\n                            assignments);\n\n            // all supervisors\n            Map<String, SupervisorInfo> supervisorInfos =\n                    Cluster.get_all_SupervisorInfo(stormClusterState, null);\n\n            // generate SupervisorSummaries\n            List<SupervisorSummary> supervisorSummaries =\n                    NimbusUtils.mkSupervisorSummaries(supervisorInfos,\n                            assignments);\n\n            NimbusSummary nimbusSummary =\n                    NimbusUtils.getNimbusSummary(stormClusterState,\n                            supervisorSummaries, data);\n\n            ClusterSummary ret =\n                    new ClusterSummary(nimbusSummary, supervisorSummaries,\n                            topologySummaries);\n\n            return ret;\n\n        } catch (TException e) {\n            LOG.info(\"Failed to get ClusterSummary \", e);\n            throw e;\n        } catch (Exception e) {\n            LOG.info(\"Failed to get ClusterSummary \", e);\n            throw new TException(e);\n        }finally {\n            double spend = (System.nanoTime() - start)/1000000.0d;\n            SimpleJStormMetric.updateHistorgram(\"getClusterInfo\", spend);\n            LOG.info(\"getClusterInfo spend {}ms\", spend);\n        }\n    }\n",
    "new_code_raw": "    public ClusterSummary getClusterInfo() throws TException {\n        long start = System.nanoTime();\n        try {\n            StormClusterState stormClusterState = data.getStormClusterState();\n\n            Map<String, Assignment> assignments = new HashMap<String, Assignment>();\n\n            // get TopologySummary\n            List<TopologySummary> topologySummaries = NimbusUtils.getTopologySummary(stormClusterState, assignments);\n\n            // all supervisors\n            Map<String, SupervisorInfo> supervisorInfos = Cluster.get_all_SupervisorInfo(stormClusterState, null);\n\n            // generate SupervisorSummaries\n            List<SupervisorSummary> supervisorSummaries = NimbusUtils.mkSupervisorSummaries(supervisorInfos, assignments);\n\n            NimbusSummary nimbusSummary = NimbusUtils.getNimbusSummary(stormClusterState, supervisorSummaries, data);\n\n            return new ClusterSummary(nimbusSummary, supervisorSummaries, topologySummaries);\n        } catch (TException e) {\n            LOG.info(\"Failed to get ClusterSummary \", e);\n            throw e;\n        } catch (Exception e) {\n            LOG.info(\"Failed to get ClusterSummary \", e);\n            throw new TException(e);\n        } finally {\n            long end = System.nanoTime();\n            SimpleJStormMetric.updateNimbusHistogram(\"getClusterInfo\", (end - start) / TimeUtils.NS_PER_US);\n        }\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2150-FirstSentence-0",
    "old_comment_raw": "Test serialization of outer number types 200 - Output number",
    "new_comment_raw": "Test serialization of outer number types 200 - Output number",
    "old_code_raw": "    public Mono<BigDecimal> fakeOuterNumberSerialize(BigDecimal body) throws RestClientException {\n        Object postBody = body;\n        \n        String path = UriComponentsBuilder.fromPath(\"/fake/outer/number\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"*/*\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<BigDecimal> returnType = new ParameterizedTypeReference<BigDecimal>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "new_code_raw": "    public Mono<BigDecimal> fakeOuterNumberSerialize(BigDecimal body) throws RestClientException {\n        Object postBody = body;\n        \n        String path = UriComponentsBuilder.fromPath(\"/fake/outer/number\").build().toUriString();\n\n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"*/*\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<BigDecimal> returnType = new ParameterizedTypeReference<BigDecimal>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType);\n    }\n"
  },
  {
    "id": "codehaus_picocontainer-27-Associations-FirstSentence",
    "old_comment_raw": "Test for dependency resolution of the parameter for the expected type.",
    "new_comment_raw": "Check for a successful dependency resolution of the parameter for the expected type.",
    "old_code_raw": "    public boolean isResolvable(PicoContainer container, ComponentAdapter adapter, Class expectedType) {\n        final Class collectionType = getCollectionType(expectedType);\n        if (collectionType != null) {\n            return emptyCollection\n                    || !getMatchingComponentAdapters(container, adapter, componentKeyType, getValueType(expectedType)).isEmpty();\n        }\n        return false;\n    }\n",
    "new_code_raw": "    public boolean isResolvable(PicoContainer container, ComponentAdapter adapter, Class expectedType) {\n        final Class collectionType = getCollectionType(expectedType);\n        return collectionType != null && (emptyCollection || getResolvingAdapters(container, adapter, expectedType).length > 0);\n    }\n\n"
  },
  {
    "id": "processing_processing-909-FirstSentence-0",
    "old_comment_raw": "Get the list of imported libraries.",
    "new_comment_raw": "Get the list of imported libraries.",
    "old_code_raw": "  public ArrayList<Library> getImportedLibraries() {\n    return importedLibraries;\n  }\n",
    "new_code_raw": "  public List<Library> getImportedLibraries() {\n    return importedLibraries;\n  }\n"
  },
  {
    "id": "querydsl_querydsl-378-FirstSentence-0",
    "old_comment_raw": "Clone the state of this query to a new SQLQueryImpl instance with the given Connection",
    "new_comment_raw": "Clone the state of this query to a new SQLQueryImpl instance with the given Connection",
    "old_code_raw": "    public OracleQuery clone(Connection conn){\n        return new OracleQuery(conn, templates, getMetadata().clone());   \n    }\n",
    "new_code_raw": "    public OracleQuery clone(Connection conn){\n        return new OracleQuery(conn, getTemplates(), getMetadata().clone());   \n    }\n"
  },
  {
    "id": "cemcatik_jtds-0-Associations-FirstSentence",
    "old_comment_raw": "Execute a SQL statement that retruns a single ResultSet",
    "new_comment_raw": "Execute an SQL statement that returns a single ResultSet.",
    "old_code_raw": "   public ResultSet executeQuery(String sql) throws SQLException\n   {\n        if ( type == ResultSet.TYPE_FORWARD_ONLY\n                && concurrency == ResultSet.CONCUR_READ_ONLY ) {\n            return internalExecuteQuery( getTds(sql), sql );\n        }\n        else {\n            return new freetds.CursorResultSet( this, sql );\n        }\n   }\n",
    "new_code_raw": "   public ResultSet executeQuery(String sql) throws SQLException\n   {\n        if( type==ResultSet.TYPE_FORWARD_ONLY &&\n            concurrency==ResultSet.CONCUR_READ_ONLY )\n        {\n            ResultSet rs = internalExecuteQuery( sql );\n\n            if( rs != null )\n                return rs;\n            else\n                throw new SQLException(\"No ResultSet was produced.\");\n        }\n        else\n            return new freetds.CursorResultSet(this, sql);\n   }\n\n"
  },
  {
    "id": "runelite_runelite-155-FirstSentence-0",
    "old_comment_raw": "Removes all tags from the given `str`.",
    "new_comment_raw": "Removes all tags from the given `str`.",
    "old_code_raw": "\tpublic static String removeTags(String str)\n\t{\n\t\tStringBuilder builder = new StringBuilder(str.length());\n\t\tboolean inTag = false;\n\n\t\tfor (int i = 0; i < str.length(); i++)\n\t\t{\n\t\t\tchar currentChar = str.charAt(i);\n\n\t\t\tif (currentChar == '<')\n\t\t\t{\n\t\t\t\tinTag = true;\n\t\t\t}\n\t\t\telse if (currentChar == '>')\n\t\t\t{\n\t\t\t\tinTag = false;\n\t\t\t}\n\t\t\telse if (!inTag)\n\t\t\t{\n\t\t\t\tbuilder.append(currentChar);\n\t\t\t}\n\t\t}\n\n\t\treturn builder.toString();\n\t}\n",
    "new_code_raw": "\tpublic static String removeTags(String str)\n\t{\n\t\treturn TAG_REGEXP.matcher(str).replaceAll(\"\");\n\t}\n"
  },
  {
    "id": "debezium_debezium-22-FirstSentence-0",
    "old_comment_raw": "Convert the a value representing a Unsigned SMALLINT value to the correct Unsigned SMALLINT representation.",
    "new_comment_raw": "Convert the a value representing a Unsigned MEDIUMINT value to the correct Unsigned SMALLINT representation.",
    "old_code_raw": "    protected Object convertUnsignedMediumint(Column column, Field fieldDefn, Object data){\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n\n        if (data instanceof Integer) data = MySqlUnsignedIntegerConverter.convertUnsignedMediumint((int)data);\n        if (data instanceof Number) {\n            Number value = (Number) data;\n            data = MySqlUnsignedIntegerConverter.convertUnsignedMediumint(new Integer(value.intValue()));\n        }\n        //We continue with the original converting method (integer) since we have an unsigned Medium\n        return convertInteger(column, fieldDefn, data);\n    }\n",
    "new_code_raw": "    protected Object convertUnsignedMediumint(Column column, Field fieldDefn, Object data){\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0;\n        }\n\n        if (data instanceof Integer) {\n            return MySqlUnsignedIntegerConverter.convertUnsignedMediumint((int)data);\n        }\n        else if (data instanceof Number) {\n            return MySqlUnsignedIntegerConverter.convertUnsignedMediumint(((Number) data).intValue());\n        }\n        else {\n            //We continue with the original converting method (integer) since we have an unsigned Medium\n            return convertInteger(column, fieldDefn, data);\n        }\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2176-FirstSentence-0",
    "old_comment_raw": "Transforms t if it contains a coordination in a flat structure (CCtransform) and transforms UCP (UCPtransform).",
    "new_comment_raw": "Transforms t if it contains a coordination in a flat structure (CCtransform) and transforms UCP (UCPtransform).",
    "old_code_raw": "  public Tree transformTree(Tree t) {\n    if (VERBOSE) {\n      System.err.println(\"Input to CoordinationTransformer: \" + t);\n    }\n    t = tn.transformTree(t);\n    if (VERBOSE) {\n      System.err.println(\"After DependencyTreeTransformer:  \" + t);\n    }\n    if (t == null) {\n      return t;\n    }\n\n    if (performMWETransformation) {\n      t = MWETransform(t);\n      if (VERBOSE) {\n        System.err.println(\"After MWETransform:               \" + t);\n      }\n\n      t = prepCCTransform(t);\n      if (VERBOSE) {\n        System.err.println(\"After prepCCTransform:               \" + t);\n      }\n    }\n\n    t = UCPtransform(t);\n    if (VERBOSE) {\n      System.err.println(\"After UCPTransformer:             \" + t);\n    }\n    t = CCtransform(t);\n    if (VERBOSE) {\n      System.err.println(\"After CCTransformer:              \" + t);\n    }\n    t = qp.transformTree(t);\n    if (VERBOSE) {\n      System.err.println(\"After QPTreeTransformer:          \" + t);\n    }\n    t = SQflatten(t);\n    if (VERBOSE) {\n      System.err.println(\"After SQ flattening:              \" + t);\n    }\n    t = dates.transformTree(t);\n    if (VERBOSE) {\n      System.err.println(\"After DateTreeTransformer:        \" + t);\n    }\n    t = removeXOverX(t);\n    if (VERBOSE) {\n      System.err.println(\"After removeXoverX:               \" + t);\n    }\n    t = combineConjp(t);\n    if (VERBOSE) {\n      System.err.println(\"After combineConjp:               \" + t);\n    }\n    t = moveRB(t);\n    if (VERBOSE) {\n      System.err.println(\"After moveRB:                     \" + t);\n    }\n    t = changeSbarToPP(t);\n    if (VERBOSE) {\n      System.err.println(\"After changeSbarToPP:             \" + t);\n    }\n    t = rearrangeNowThat(t);\n    if (VERBOSE) {\n      System.err.println(\"After rearrangeNowThat:           \" + t);\n    }\n\n    return t;\n  }\n",
    "new_code_raw": "  public Tree transformTree(Tree t) {\n    if (VERBOSE) {\n      System.err.println(\"Input to CoordinationTransformer: \" + t);\n    }\n    Tree tx = tn.transformTree(t);\n    if (VERBOSE) {\n      System.err.println(\"After DependencyTreeTransformer:  \" + tx);\n    }\n    if (tx == null) {\n      return tx;\n    }\n    Tree tt = UCPtransform(tx);\n    if (VERBOSE) {\n      System.err.println(\"After UCPTransformer:             \" + t);\n    }\n    Tree ttt = CCtransform(tt);\n    if (VERBOSE) {\n      System.err.println(\"After CCTransformer:              \" + t);\n    }\n    Tree tttt = qp.transformTree(ttt);\n    if (VERBOSE) {\n      System.err.println(\"After QPTreeTransformer:          \" + t);\n    }\n    Tree ret = dates.transformTree(tttt);\n    if (VERBOSE) {\n      System.err.println(\"After DateTreeTransformer:        \" + t);\n    }\n    return ret;\n  }\n"
  },
  {
    "id": "kevinsawicki_http-request-12-Associations-FirstSentence",
    "old_comment_raw": "Append given parameters to base URL",
    "new_comment_raw": "Append given query parameters to base URL",
    "old_code_raw": "\t@SuppressWarnings(\"unchecked\")\n\tpublic static String append(String url, final Map<String, ?> params) {\n\t\tif (params == null || params.isEmpty())\n\t\t\treturn url;\n\n\t\tStringBuilder result = new StringBuilder();\n\t\tif (!url.endsWith(\"/\"))\n\t\t\turl += \"/\";\n\n\t\tEntry<String, ?> entry;\n\t\tObject value;\n\t\tIterator<?> iterator = params.entrySet().iterator();\n\t\tentry = (Entry<String, ?>) iterator.next();\n\t\tresult.append(entry.getKey());\n\t\tresult.append('=');\n\t\tvalue = entry.getValue();\n\t\tif (value != null)\n\t\t\tresult.append(value);\n\n\t\twhile (iterator.hasNext()) {\n\t\t\tresult.append('&');\n\t\t\tentry = (Entry<String, ?>) iterator.next();\n\t\t\tresult.append(entry.getKey());\n\t\t\tresult.append('=');\n\t\t\tvalue = entry.getValue();\n\t\t\tif (value != null)\n\t\t\t\tresult.append(value);\n\t\t}\n\n\t\treturn url + '?' + result.toString();\n\t}\n",
    "new_code_raw": "\t@SuppressWarnings(\"unchecked\")\n\tpublic static String append(final String url, final Map<String, ?> params) {\n\t\tif (params == null || params.isEmpty())\n\t\t\treturn url;\n\n\t\tfinal StringBuilder result = new StringBuilder(url);\n\n\t\t// Add trailing slash if the base URL doesn't have any path segments.\n\t\t// The following test is checking for the last slash not being part of\n\t\t// the protocol to host separator '://'.\n\t\tint firstColon = url.indexOf(':');\n\t\tint lastSlash = url.lastIndexOf('/');\n\t\tif (firstColon + 2 == lastSlash)\n\t\t\tresult.append('/');\n\t\tresult.append('?');\n\n\t\tEntry<String, ?> entry;\n\t\tObject value;\n\t\tIterator<?> iterator = params.entrySet().iterator();\n\t\tentry = (Entry<String, ?>) iterator.next();\n\t\tresult.append(entry.getKey());\n\t\tresult.append('=');\n\t\tvalue = entry.getValue();\n\t\tif (value != null)\n\t\t\tresult.append(value);\n\n\t\twhile (iterator.hasNext()) {\n\t\t\tresult.append('&');\n\t\t\tentry = (Entry<String, ?>) iterator.next();\n\t\t\tresult.append(entry.getKey());\n\t\t\tresult.append('=');\n\t\t\tvalue = entry.getValue();\n\t\t\tif (value != null)\n\t\t\t\tresult.append(value);\n\t\t}\n\n\t\treturn result.toString();\n\t}\n\n"
  },
  {
    "id": "cymcsg_UltimateRecyclerView-29-FirstSentence-0",
    "old_comment_raw": "the layout id for the normal data",
    "new_comment_raw": "the layout id for the normal data",
    "old_code_raw": "    protected int getNormalLayoutResId() {\n        return R.layout.grid_item;\n    }\n",
    "new_code_raw": "    protected int getNormalLayoutResId() {\n        return itemGridCellBinder.layout;\n    }\n"
  },
  {
    "id": "nelsonsilva_vaadin-144-Associations-FirstSentence",
    "old_comment_raw": "Gets the component container iterator for going trough all the components in the container.",
    "new_comment_raw": "Gets the component container iterator for going through all the components (tab contents).",
    "old_code_raw": "    public Iterator<Component> getComponentIterator() {\n        return java.util.Collections.unmodifiableList(components).iterator();\n    }\n",
    "new_code_raw": "    public Iterator<Component> getComponentIterator() {\n        return Collections.unmodifiableList(components).iterator();\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2051-FirstSentence-0",
    "old_comment_raw": "Logs out current logged in user session",
    "new_comment_raw": "Logs out current logged in user session",
    "old_code_raw": "    public ApiResponse<Void> logoutUserWithHttpInfo() throws ApiException {\n        okhttp3.Call call = logoutUserValidateBeforeCall(null, null);\n        return apiClient.execute(call);\n    }\n",
    "new_code_raw": "    public ApiResponse<Void> logoutUserWithHttpInfo() throws ApiException {\n        okhttp3.Call localVarCall = logoutUserValidateBeforeCall(null, null);\n        return localVarApiClient.execute(localVarCall);\n    }\n"
  },
  {
    "id": "eclipse_rt.equinox.bundles-62-Associations-FirstSentence",
    "old_comment_raw": "Obtains a ISTextExpert instance for processing structured text with the specified type handler and the specified environment.",
    "new_comment_raw": "Obtains a IStructuredTextExpert instance for processing structured text with the specified type handler and the specified environment.",
    "old_code_raw": "\tstatic public ISTextExpert getStatefulExpert(String type, STextEnvironment environment) {\n\t\tSTextTypeHandler handler = STextTypeHandlerFactory.getHandler(type);\n\t\tif (handler == null)\n\t\t\tthrow new IllegalArgumentException(\"Invalid type argument\"); //$NON-NLS-1$\n\t\treturn getStatefulExpert(handler, environment);\n\t}\n",
    "new_code_raw": "\tstatic public IStructuredTextExpert getStatefulExpert(String type, StructuredTextEnvironment environment) {\n\t\tStructuredTextTypeHandler handler = StructuredTextTypeHandlerFactory.getHandler(type);\n\t\tif (handler == null)\n\t\t\tthrow new IllegalArgumentException(\"Invalid type argument\"); //$NON-NLS-1$\n\t\treturn getStatefulExpert(handler, environment);\n\t}\n\n"
  },
  {
    "id": "apache_drill-1072-FirstSentence-0",
    "old_comment_raw": "generates the message that will be displayed to the client.",
    "new_comment_raw": "generates the message that will be displayed to the client.",
    "old_code_raw": "  public String getVerboseMessage() {\n    return generateMessage() + \"\\n\\n\" + ErrorHelper.buildCausesMessage(getCause());\n  }\n",
    "new_code_raw": "  public String getVerboseMessage() {\n    return getVerboseMessage(true);\n  }\n"
  },
  {
    "id": "RSB4760_apq8016_external_conscrypt-32-Associations-FirstSentence",
    "old_comment_raw": "Finds the first  X509TrustManager element in the provided array.",
    "new_comment_raw": "Finds the first  X509ExtendedTrustManager or  X509TrustManager element in the provided array.",
    "old_code_raw": "    private static X509TrustManager findFirstX509TrustManager(TrustManager[] tms) {\n        for (TrustManager tm : tms) {\n            if (tm instanceof X509TrustManager) {\n                return (X509TrustManager)tm;\n            }\n        }\n        return null;\n    }\n",
    "new_code_raw": "    private static X509ExtendedTrustManager findFirstX509TrustManager(TrustManager[] tms)\n            throws KeyManagementException {\n        for (TrustManager tm : tms) {\n            if (tm instanceof X509ExtendedTrustManager) {\n                return (X509ExtendedTrustManager) tm;\n            }\n            if (tm instanceof X509TrustManager) {\n                return new X509ExtendedTrustManagerWrapper((X509TrustManager) tm);\n            }\n        }\n        return null;\n    }\n\n"
  },
  {
    "id": "apache_kylin-414-FirstSentence-0",
    "old_comment_raw": "Update a cube status from disable to ready.",
    "new_comment_raw": "Update a cube status from disable to ready.",
    "old_code_raw": "    @PreAuthorize(Constant.ACCESS_HAS_ROLE_ADMIN + \" or hasPermission(#cube, 'ADMINISTRATION') or hasPermission(#cube, 'OPERATION')  or hasPermission(#cube, 'MANAGEMENT')\")\n    public CubeInstance enableCube(CubeInstance cube) throws IOException, JobException {\n        String cubeName = cube.getName();\n\n        RealizationStatusEnum ostatus = cube.getStatus();\n        if (!cube.getStatus().equals(RealizationStatusEnum.DISABLED)) {\n            throw new InternalErrorException(\"Only disabled cube can be enabled, status of \" + cubeName + \" is \" + ostatus);\n        }\n\n        if (cube.getSegments(SegmentStatusEnum.READY).size() == 0) {\n            throw new InternalErrorException(\"Cube \" + cubeName + \" dosen't contain any READY segment\");\n        }\n\n        final List<CubingJob> cubingJobs = listAllCubingJobs(cube.getName(), null, EnumSet.of(ExecutableState.READY, ExecutableState.RUNNING));\n        if (!cubingJobs.isEmpty()) {\n            throw new JobException(\"Enable is not allowed with a running job.\");\n        }\n        if (!cube.getDescriptor().calculateSignature().equals(cube.getDescriptor().getSignature())) {\n            cube = this.releaseAllSegments(cube);\n        }\n\n        try {\n            return getCubeManager().updateCube(cube, null, null, null, RealizationStatusEnum.READY, true);\n        } catch (IOException e) {\n            cube.setStatus(ostatus);\n            throw e;\n        }\n    }\n",
    "new_code_raw": "    @PreAuthorize(Constant.ACCESS_HAS_ROLE_ADMIN + \" or hasPermission(#cube, 'ADMINISTRATION') or hasPermission(#cube, 'OPERATION')  or hasPermission(#cube, 'MANAGEMENT')\")\n    public CubeInstance enableCube(CubeInstance cube) throws IOException, JobException {\n        String cubeName = cube.getName();\n\n        RealizationStatusEnum ostatus = cube.getStatus();\n        if (!cube.getStatus().equals(RealizationStatusEnum.DISABLED)) {\n            throw new InternalErrorException(\"Only disabled cube can be enabled, status of \" + cubeName + \" is \" + ostatus);\n        }\n\n        if (cube.getSegments(SegmentStatusEnum.READY).size() == 0) {\n            throw new InternalErrorException(\"Cube \" + cubeName + \" dosen't contain any READY segment\");\n        }\n\n        final List<CubingJob> cubingJobs = listAllCubingJobs(cube.getName(), null, EnumSet.of(ExecutableState.READY, ExecutableState.RUNNING));\n        if (!cubingJobs.isEmpty()) {\n            throw new JobException(\"Enable is not allowed with a running job.\");\n        }\n        if (!cube.getDescriptor().calculateSignature().equals(cube.getDescriptor().getSignature())) {\n            cube = this.releaseAllSegments(cube);\n        }\n\n        try {\n            return getCubeManager().updateCube(cube, null, null, null, RealizationStatusEnum.READY);\n        } catch (IOException e) {\n            cube.setStatus(ostatus);\n            throw e;\n        }\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1875-FirstSentence-0",
    "old_comment_raw": "Test serialization of outer boolean types",
    "new_comment_raw": "Test serialization of outer boolean types",
    "old_code_raw": "  public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/boolean\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/boolean\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "JodaOrg_joda_time-488-FirstSentence-0",
    "old_comment_raw": "Gets the gap between this interval and that specified.",
    "new_comment_raw": "Gets the gap between this interval and another interval.",
    "old_code_raw": "    public Interval gap(ReadableInterval interval) {\n        interval = DateTimeUtils.getReadableInterval(interval);\n        if (overlaps(interval) || abuts(interval)) {\n            return null;\n        }\n        long otherStart = interval.getStartMillis();\n        long otherEnd = interval.getEndMillis();\n        long thisStart = getStartMillis();\n        long thisEnd = getEndMillis();\n        if (thisStart >= otherEnd) {\n            return new Interval(otherEnd, thisStart);\n        } else {\n            return new Interval(thisEnd, otherStart);\n        }\n    }\n",
    "new_code_raw": "    public Interval gap(ReadableInterval interval) {\n        interval = DateTimeUtils.getReadableInterval(interval);\n        if (overlaps(interval) || abuts(interval)) {\n            return null;\n        }\n        long otherStart = interval.getStartMillis();\n        long otherEnd = interval.getEndMillis();\n        long thisStart = getStartMillis();\n        long thisEnd = getEndMillis();\n        if (thisStart >= otherEnd) {\n            return new Interval(otherEnd, thisStart, getChronology());\n        } else {\n            return new Interval(thisEnd, otherStart, getChronology());\n        }\n    }\n"
  },
  {
    "id": "runelite_runelite-139-FirstSentence-0",
    "old_comment_raw": "Look up an item's price synchronously",
    "new_comment_raw": "Look up an item's price synchronously",
    "old_code_raw": "\tpublic ItemPrice getItemPrice(int itemId) throws IOException\n\t{\n\t\tItemPrice itemPrice = itemPrices.getIfPresent(itemId);\n\t\tif (itemPrice != null && itemPrice != EMPTY)\n\t\t{\n\t\t\treturn itemPrice == NONE ? null : itemPrice;\n\t\t}\n\n\t\titemPrice = itemClient.lookupItemPrice(itemId);\n\t\titemPrices.put(itemId, itemPrice);\n\t\treturn itemPrice;\n\t}\n",
    "new_code_raw": "\tpublic ItemPrice getItemPrice(int itemId) throws IOException\n\t{\n\t\tItemPrice itemPrice = itemPrices.getIfPresent(itemId);\n\t\tif (itemPrice != null && itemPrice != EMPTY)\n\t\t{\n\t\t\treturn itemPrice == NONE ? null : itemPrice;\n\t\t}\n\n\t\titemPrice = itemClient.lookupItemPrice(itemId);\n\t\tif (itemPrice == null)\n\t\t{\n\t\t\titemPrices.put(itemId, NONE);\n\t\t\treturn null;\n\t\t}\n\n\t\titemPrices.put(itemId, itemPrice);\n\t\treturn itemPrice;\n\t}\n"
  },
  {
    "id": "yanzhenjie_NoHttp-143-FirstSentence-0",
    "old_comment_raw": "Create a new request queue, using NoHttp default request executor  HttpRestConnection and default response parser  HttpRestParser.",
    "new_comment_raw": "Create a new request queue, using NoHttp default request executor  RestProtocol and default response parser  RestParser.",
    "old_code_raw": "    public static RequestQueue newRequestQueue(ImplRestConnection implRestConnection, int threadPoolSize) {\n        return newRequestQueue(HttpRestParser.getInstance(implRestConnection), threadPoolSize);\n    }\n",
    "new_code_raw": "    public static RequestQueue newRequestQueue(IRestProtocol implRestConnection, int threadPoolSize) {\n        return newRequestQueue(RestParser.getInstance(implRestConnection), threadPoolSize);\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1757-FirstSentence-0",
    "old_comment_raw": "Get a batch of uninitialized collection keys for a given role",
    "new_comment_raw": "Get a batch of uninitialized collection keys for a given role",
    "old_code_raw": "\tprivate boolean isCached(Serializable collectionKey, CollectionPersister persister) {\n\t\tif ( context.getSession().getCacheMode().isGetEnabled() && persister.hasCache() ) {\n\t\t\tCacheKey cacheKey = context.getSession().generateCacheKey(\n\t\t\t\t\tcollectionKey,\n\t\t\t\t\tpersister.getKeyType(),\n\t\t\t\t\tpersister.getRole()\n\t\t\t);\n\t\t\treturn CacheHelper.fromSharedCache( context.getSession(), cacheKey, persister.getCacheAccessStrategy() ) != null;\n\t\t}\n\t\treturn false;\n\t}\n",
    "new_code_raw": "\tprivate boolean isCached(Serializable collectionKey, CollectionPersister persister) {\n\t\tSessionImplementor session = context.getSession();\n\t\tif ( session.getCacheMode().isGetEnabled() && persister.hasCache() ) {\n\t\t\tCollectionRegionAccessStrategy cache = persister.getCacheAccessStrategy();\n\t\t\tCollectionCacheKey cacheKey = cache.generateCacheKey(\n\t\t\t\t\tcollectionKey,\n\t\t\t\t\tpersister,\n\t\t\t\t\tsession.getFactory(),\n\t\t\t\t\tsession.getTenantIdentifier()\n\t\t\t);\n\t\t\treturn CacheHelper.fromSharedCache( session, cacheKey, cache ) != null;\n\t\t}\n\t\treturn false;\n\t}\n"
  },
  {
    "id": "eclipse_rt.equinox.bundles-54-Associations-FirstSentence",
    "old_comment_raw": "Remove directional formatting characters in the given string that were inserted by the  #processTyped processTyped method.",
    "new_comment_raw": "Removes directional formatting characters in the given string.",
    "old_code_raw": "\tpublic static String deprocess(String str, STextProcessor processor) {\n\t\tif ((str == null) || (str.length() <= 1) || !isProcessingNeeded())\n\t\t\treturn str;\n\n\t\t// make sure that LRE/PDF are added around the string\n\t\tSTextEnvironment env = new STextEnvironment(null, false, STextEnvironment.ORIENT_UNKNOWN);\n\t\treturn STextEngine.fullToLeanText(processor, env, str, null);\n\t}\n",
    "new_code_raw": "\tpublic static String deprocess(String str, STextProcessor processor) {\n\t\tif ((str == null) || (str.length() <= 1))\n\t\t\treturn str;\n\n\t\t// make sure that LRE/PDF are added around the string\n\t\tSTextEnvironment env = new STextEnvironment(null, false, STextEnvironment.ORIENT_UNKNOWN);\n\t\tif (!env.isProcessingNeeded())\n\t\t\treturn str;\n\t\treturn STextEngine.fullToLeanText(processor, env, str, null);\n\t}\n\n"
  },
  {
    "id": "apache_calcite-655-FirstSentence-0",
    "old_comment_raw": "Returns statistics for a relational expression.",
    "new_comment_raw": "Returns statistics for a relational expression.",
    "old_code_raw": "  public static RelStatSource getStatistics(RelNode rel) {\n    RelStatSource result =\n        (RelStatSource) rel.getCluster().getMetadataProvider()\n            .getRelMetadata(rel, \"getStatistics\", null);\n    return result;\n  }\n",
    "new_code_raw": "  public static RelStatSource getStatistics(RelNode rel) {\n    throw new UnsupportedOperationException();\n  }\n"
  },
  {
    "id": "MarkBennett_dart-31-Associations-FirstSentence",
    "old_comment_raw": "Return the key with which the value will be associated.",
    "new_comment_raw": "Return the expression computing the key with which the value will be associated.",
    "old_code_raw": "  public StringLiteral getKey() {\n    return key;\n  }\n",
    "new_code_raw": "  public Expression getKey() {\n    return key;\n  }\n\n"
  },
  {
    "id": "processing_processing-1249-FirstSentence-0",
    "old_comment_raw": "Get the JSONObject value associated with a key.",
    "new_comment_raw": "Get the JSONObject value associated with a key.",
    "old_code_raw": "  public JSONObject getJSONObject(String key) {\n    Object object = this.get(key);\n    if (object instanceof JSONObject) {\n      return (JSONObject)object;\n    }\n    throw new RuntimeException(\"JSONObject[\" + quote(key) + \"] is not a JSONObject.\");\n  }\n",
    "new_code_raw": "  public JSONObject getJSONObject(String key) {\n    Object object = this.get(key);\n    if (object == null) {\n      return null;\n    }\n    if (object instanceof JSONObject) {\n      return (JSONObject)object;\n    }\n    throw new RuntimeException(\"JSONObject[\" + quote(key) + \"] is not a JSONObject.\");\n  }\n"
  },
  {
    "id": "apache_calcite-860-FirstSentence-0",
    "old_comment_raw": "Parses the connect string into a Properties object.",
    "new_comment_raw": "Parses the connect string into an existing Properties object.",
    "old_code_raw": "    Properties parse(Properties props)\n        throws SQLException\n    {\n        if (props == null) {\n            props = new Properties();\n        }\n        while (i < n) {\n            parsePair(props);\n        }\n        return props;\n    }\n",
    "new_code_raw": "    public static Properties parse(String s, Properties props)\n        throws SQLException\n    {\n        return new ConnectStringParser(s).parse_(props);\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1488-FirstSentence-0",
    "old_comment_raw": "Return a representation of the given name ensuring quoting (wrapped with '`' characters).",
    "new_comment_raw": "Return a representation of the given name ensuring quoting (wrapped with '`' characters).",
    "old_code_raw": "\tpublic static String quote(String name) {\n\t\tif ( name == null || name.length() == 0 || isQuoted( name ) ) {\n\t\t\treturn name;\n\t\t}\n\t\telse {\n\t\t\treturn new StringBuilder( name.length() + 2 ).append('`').append( name ).append( '`' ).toString();\n\t\t}\n\t}\n",
    "new_code_raw": "\tpublic static String quote(String name) {\n\t\tif ( name == null || name.length() == 0 || isQuoted( name ) ) {\n\t\t\treturn name;\n\t\t}\n\t\telse {\n\t\t\treturn new StringBuffer( name.length() + 2 ).append('`').append( name ).append( '`' ).toString();\n\t\t}\n\t}\n"
  },
  {
    "id": "codehaus_cake-12-Associations-FirstSentence",
    "old_comment_raw": "Analogous to  #get(WithAttributes) except returning a primitive long.",
    "new_comment_raw": "Extracts the attribute map from the specified  WithAttributes and returns the value of this attribute from the map.",
    "old_code_raw": "    public long get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n",
    "new_code_raw": "    public long get(WithAttributes withAttributes) {\r\n        return withAttributes.getAttributes().get(this);\r\n    }\r\n\n"
  },
  {
    "id": "querydsl_querydsl-294-FirstSentence-0",
    "old_comment_raw": "Expr : left.substring(beginIndex, endIndex)",
    "new_comment_raw": "Expr : left.substring(beginIndex, endIndex)",
    "old_code_raw": "    public static EString substring(Expr<String> left, int beginIndex, int endIndex) {\n        return factory.createString(Ops.SUBSTR2ARGS, left, factory.createConstant(beginIndex), factory.createConstant(endIndex));\n    }\n",
    "new_code_raw": "    public static EString substring(Expr<String> left, int beginIndex, int endIndex) {\n        return operationFactory.createString(Ops.SUBSTR2ARGS, left, exprFactory.createConstant(beginIndex), exprFactory.createConstant(endIndex));\n    }\n"
  },
  {
    "id": "apache_geronimo-90-Associations-FirstSentence",
    "old_comment_raw": "Gets the package names that will be searched for property editors.",
    "new_comment_raw": "Get a list containing all of the packages in the editor search path.",
    "old_code_raw": "    public static List getEditorSearchPath()\n    {\n        String[] path = PropertyEditorManager.getEditorSearchPath();\n\n        List list = new ArrayList(path.length);\n        for (int i=0; i<path.length; i++) {\n            list.add(path[i]);\n        }\n\n        return list;\n    }\n",
    "new_code_raw": "    public static List getEditorSearchPath() {\n        // grrrr, Arrays.asList() returns a readonly List item, which makes it difficult\n        // to append additional items.  This means we have to do this manually.\n\n        // start by getting the list from the editor manager, which is returned as an\n        // array of Strings.\n        String[] paths = PropertyEditorManager.getEditorSearchPath();\n\n        // get a list matching the initial size...we don't always request this with the intend to append.\n        List pathList = new ArrayList(paths.length);\n\n        // now MANUALLY add each of the items in the array.\n        for (int i = 0; i < paths.length; i++) {\n            pathList.add(paths[i]);\n        }\n\n        return pathList;\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2584-FirstSentence-0",
    "old_comment_raw": "POST /fake/outer/number",
    "new_comment_raw": "POST /fake/outer/number",
    "old_code_raw": "        public BigDecimal executeAs(Function<Response, Response> handler) {\n            Type type = new TypeToken<BigDecimal>(){}.getType();\n            return getJSON().deserialize(execute(handler).asString(), type);\n        }\n",
    "new_code_raw": "        public BigDecimal executeAs(Function<Response, Response> handler) {\n            Type type = new TypeToken<BigDecimal>(){}.getType();\n            return execute(handler).as(type);\n        }\n"
  },
  {
    "id": "nuxeo_h2database-8-Associations-FirstSentence",
    "old_comment_raw": "[Not supported] Gets the result set metadata of the query returned when the statement is executed.",
    "new_comment_raw": "Gets the result set metadata of the query returned when the statement is executed.",
    "old_code_raw": "    public ResultSetMetaData getMetaData() throws SQLException {\r\n        try {\r\n            debugCodeCall(\"getMetaData\");\r\n            checkClosed();\r\n            return null;\r\n        } catch(Throwable e) {\r\n            throw logAndConvert(e);\r\n        }\r\n    }\r\n",
    "new_code_raw": "    public ResultSetMetaData getMetaData() throws SQLException {\r\n        try {\r\n            debugCodeCall(\"getMetaData\");\r\n            checkClosed();\r\n            ResultInterface result = command.getMetaData();\r\n            if(result == null) {\r\n                return null;\r\n            }\r\n            int id = getNextId(TraceObject.RESULT_SET_META_DATA);\r\n            if(debug()) {\r\n                debugCodeAssign(\"ResultSetMetaData\", TraceObject.RESULT_SET_META_DATA, id);\r\n                debugCodeCall(\"getMetaData\");\r\n            }\r\n            JdbcResultSetMetaData meta = new JdbcResultSetMetaData(null, this, result, session.getTrace(), id);\r\n            return meta;\r\n        } catch(Throwable e) {\r\n            throw logAndConvert(e);\r\n        }\r\n    }\r\n\n"
  },
  {
    "id": "JodaOrg_joda_time-706-FirstSentence-0",
    "old_comment_raw": "Get the era property.",
    "new_comment_raw": "Get the era property.",
    "old_code_raw": "    public ReadWritableInstantFieldProperty era() {\n        return new ReadWritableInstantFieldProperty(this, getChronology().era());\n    }\n",
    "new_code_raw": "    public Property era() {\n        return new Property(this, getChronology().era());\n    }\n"
  },
  {
    "id": "apache_calcite-864-FirstSentence-0",
    "old_comment_raw": "Determines the set of unique minimal keys for this expression, optionally ignoring nulls in the columns in the expression.",
    "new_comment_raw": "Returns the  BuiltInMetadata.UniqueKeys#getUniqueKeys(boolean) statistic.",
    "old_code_raw": "  public static Set<BitSet> getUniqueKeys(RelNode rel, boolean ignoreNulls) {\n    return (Set<BitSet>) rel.getCluster().getMetadataProvider()\n        .getRelMetadata(\n            rel,\n            \"getUniqueKeys\",\n            new Object[]{ignoreNulls});\n  }\n",
    "new_code_raw": "  public static Set<BitSet> getUniqueKeys(RelNode rel, boolean ignoreNulls) {\n    final BuiltInMetadata.UniqueKeys metadata =\n        rel.metadata(BuiltInMetadata.UniqueKeys.class);\n    return metadata.getUniqueKeys(ignoreNulls);\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-571-FirstSentence-0",
    "old_comment_raw": "Rounds to the nearest whole unit of this field on a copy of this DateTime.",
    "new_comment_raw": "Rounds to the nearest whole unit of this field on a copy of this DateTime.",
    "old_code_raw": "    public DateTime roundHalfEvenCopy() {\n        DateTime instant = iInstant;\n        return (DateTime)instant.toCopy(iField.roundHalfEven(instant.getMillis()));\n    }\n",
    "new_code_raw": "    public DateTime roundHalfEvenCopy() {\n        DateTime instant = iInstant;\n        return (DateTime)instant.withMillis(iField.roundHalfEven(instant.getMillis()));\n    }\n"
  },
  {
    "id": "google_certificate-transparency-java-3-Associations-FirstSentence",
    "old_comment_raw": "Parses a  Ct.MerkleTreeLeaf from binary encoding.",
    "new_comment_raw": "Parses a  MerkleTreeLeaf from binary encoding.",
    "old_code_raw": "  public static Ct.MerkleTreeLeaf parseMerkleTreeLeaf(InputStream in) {\n    Ct.MerkleTreeLeaf.Builder merkleTreeLeafBuilder = Ct.MerkleTreeLeaf.newBuilder();\n\n    int version = (int) readNumber(in, CTConstants.VERSION_LENGTH);\n    if (version != Ct.Version.V1.getNumber()) {\n      throw new SerializationException(String.format(\"Unknown version: %d\", version));\n    }\n    merkleTreeLeafBuilder.setVersion(Ct.Version.valueOf(version));\n\n    int leafType = (int) readNumber(in, 1);\n    if (leafType != Ct.MerkleLeafType.TIMESTAMPED_ENTRY_VALUE) {\n      throw new SerializationException(String.format(\"Unknown entry type: %d\", leafType));\n    }\n    merkleTreeLeafBuilder.setType(Ct.MerkleLeafType.valueOf(leafType));\n    merkleTreeLeafBuilder.setTimestampedEntry((parseTimestampedEntry(in)));\n\n    return merkleTreeLeafBuilder.build();\n  }\n",
    "new_code_raw": "  public static MerkleTreeLeaf parseMerkleTreeLeaf(InputStream in) {\n    int version = (int) readNumber(in, CTConstants.VERSION_LENGTH);\n    if (version != Ct.Version.V1.getNumber()) {\n      throw new SerializationException(String.format(\"Unknown version: %d\", version));\n    }\n\n    int leafType = (int) readNumber(in, 1);\n    if (leafType != Ct.MerkleLeafType.TIMESTAMPED_ENTRY_VALUE) {\n      throw new SerializationException(String.format(\"Unknown entry type: %d\", leafType));\n    }\n\n    return new MerkleTreeLeaf(Ct.Version.valueOf(version), Ct.MerkleLeafType.valueOf(leafType), parseTimestampedEntry(in));\n  }\n\n"
  },
  {
    "id": "docker_java_docker_java-7-FirstSentence-0",
    "old_comment_raw": "This will set all fields in the builder to those contained in the Properties object.",
    "new_comment_raw": "This will set all fields in the builder to those contained in the Properties object.",
    "old_code_raw": "        public DockerClientConfigBuilder withProperties(Properties p) {\n            return withUri(p.getProperty(\"docker.io.url\"))\n                    .withVersion(p.getProperty(\"docker.io.version\"))\n                    .withUsername(p.getProperty(\"docker.io.username\"))\n                    .withPassword(p.getProperty(\"docker.io.password\"))\n                    .withEmail(p.getProperty(\"docker.io.email\"))\n                    .withReadTimeout(Integer.valueOf(p.getProperty(\"docker.io.readTimeout\", \"0\")))\n                    .withLoggingFilter(Boolean.valueOf(p.getProperty(\"docker.io.enableLoggingFilter\", \"true\")));\n        }\n",
    "new_code_raw": "        public DockerClientConfigBuilder withProperties(Properties p) {\n            return withUri(p.getProperty(\"docker.io.url\"))\n                    .withVersion(p.getProperty(\"docker.io.version\"))\n                    .withUsername(p.getProperty(\"docker.io.username\"))\n                    .withPassword(p.getProperty(\"docker.io.password\"))\n                    .withEmail(p.getProperty(\"docker.io.email\"))\n                    .withReadTimeout(Integer.valueOf(p.getProperty(\"docker.io.readTimeout\", \"0\")))\n                    .withLoggingFilter(Boolean.valueOf(p.getProperty(\"docker.io.enableLoggingFilter\", \"true\")))\n                    .withKeystore(p.getProperty(\"docker.io.keystore\"))\n                    .withKeystorePassword(p.getProperty(\"docker.io.keystorePassword\"))\n                    .withTruststore(p.getProperty(\"docker.io.truststore\"))\n                    .withTruststorePassword(p.getProperty(\"docker.io.truststorePassword\"));\n        }\n"
  },
  {
    "id": "frohoff_jdk6-75-Associations-FirstSentence",
    "old_comment_raw": "Reinitializes the insets parameter with this Border's current Insets.",
    "new_comment_raw": "This default implementation returns a new Insets instance where the top, left, bottom, and right fields are set to 0.",
    "old_code_raw": "    public Insets getBorderInsets(Component c, Insets insets) {\n        if (this.insets != null) {\n            if (insets == null) {\n                insets = new Insets(this.insets.top, this.insets.left,\n                                  this.insets.bottom, this.insets.right);\n            }\n            else {\n                insets.top    = this.insets.top;\n                insets.bottom = this.insets.bottom;\n                insets.left   = this.insets.left;\n                insets.right  = this.insets.right;\n            }\n        }\n        else if (insets == null) {\n            insets = new Insets(0, 0, 0, 0);\n        }\n        else {\n            insets.top = insets.bottom = insets.left = insets.right = 0;\n        }\n        if (c instanceof JComponent) {\n            Region region = Region.getRegion((JComponent)c);\n            Insets margin = null;\n            if ((region == Region.ARROW_BUTTON || region == Region.BUTTON ||\n                 region == Region.CHECK_BOX ||\n                 region == Region.CHECK_BOX_MENU_ITEM ||\n                 region == Region.MENU || region == Region.MENU_ITEM ||\n                 region == Region.RADIO_BUTTON ||\n                 region == Region.RADIO_BUTTON_MENU_ITEM ||\n                 region == Region.TOGGLE_BUTTON) &&\n                       (c instanceof AbstractButton)) {\n                margin = ((AbstractButton)c).getMargin();\n            }\n            else if ((region == Region.EDITOR_PANE ||\n                      region == Region.FORMATTED_TEXT_FIELD ||\n                      region == Region.PASSWORD_FIELD ||\n                      region == Region.TEXT_AREA ||\n                      region == Region.TEXT_FIELD ||\n                      region == Region.TEXT_PANE) &&\n                        (c instanceof JTextComponent)) {\n                margin = ((JTextComponent)c).getMargin();\n            }\n            else if (region == Region.TOOL_BAR && (c instanceof JToolBar)) {\n                margin = ((JToolBar)c).getMargin();\n            }\n            else if (region == Region.MENU_BAR && (c instanceof JMenuBar)) {\n                margin = ((JMenuBar)c).getMargin();\n            }\n            if (margin != null) {\n                insets.top += margin.top;\n                insets.bottom += margin.bottom;\n                insets.left += margin.left;\n                insets.right += margin.right;\n            }\n        }\n        return insets;\n    }\n",
    "new_code_raw": "    public Insets getBorderInsets(Component c) { \n        return getBorderInsets(c, null);\n    }\n\n"
  },
  {
    "id": "RobotiumTech_robotium-1417-FirstSentence-0",
    "old_comment_raw": "Scrolls up a list with a given index.",
    "new_comment_raw": "Scrolls up a list with a given index.",
    "old_code_raw": "\tpublic boolean scrollUpList(int index) {\n\t\treturn scroller.scrollList(waiter.waitForAndGetView(index, ListView.class), Scroller.UP);\n\t}\n",
    "new_code_raw": "\tpublic boolean scrollUpList(int index) {\n\t\treturn scroller.scrollList(waiter.waitForAndGetView(index, ListView.class), Scroller.UP, false);\n\t}\n"
  },
  {
    "id": "macalinao_ModTheModAPI-1-Associations-FirstSentence",
    "old_comment_raw": "Returns a  Type from its name.",
    "new_comment_raw": "Gets a  Type from its name.",
    "old_code_raw": "\tpublic static Type valueOf(String name) {\n\t\treturn null; // TODO\n\t}\n",
    "new_code_raw": "\tpublic static Type<?> valueOf(String name) {\n\t\treturn ModTheMod.getGame().getTypeManager().getType(name);\n\t}\n\n"
  },
  {
    "id": "apache_avro-173-FirstSentence-0",
    "old_comment_raw": "Gets the default value of the given field, if any.",
    "new_comment_raw": "Gets the default value of the given field, if any.",
    "old_code_raw": "  protected Object defaultValue(Field field) throws IOException {\n    return data.deepCopy(field.schema(), data.getDefaultValue(field));\n  }\n",
    "new_code_raw": "  protected Object defaultValue(Field field, Conversion<?> conversion) throws IOException {\n    Schema schema = field.schema();\n    LogicalType logicalType = schema.getLogicalType();\n    Object rawDefaultValue = data.deepCopy(schema, data.getDefaultValue(field));\n    if (conversion == null || logicalType == null) {\n      return rawDefaultValue;\n    } else {\n      return Conversions.convertToLogicalType(rawDefaultValue, schema,\n          logicalType, conversion);\n    }\n  }\n"
  },
  {
    "id": "MarkBennett_dart-13-Associations-FirstSentence",
    "old_comment_raw": "Return the value of the source attribute if it exists.",
    "new_comment_raw": "Return the first source attribute for the given tag node, or  null if it does not exist.",
    "old_code_raw": "  private String getScriptSourcePath(XmlTagNode node) {\n    for (XmlAttributeNode attribute : node.getAttributes()) {\n      if (attribute.getName().getLexeme().equals(SRC)) {\n        String text = attribute.getText();\n        return text != null && text.length() > 0 ? text : null;\n      }\n    }\n    return null;\n  }\n",
    "new_code_raw": "  private XmlAttributeNode getScriptSourcePath(XmlTagNode node) {\n    for (XmlAttributeNode attribute : node.getAttributes()) {\n      if (attribute.getName().getLexeme().equals(SRC)) {\n        return attribute;\n      }\n    }\n    return null;\n  }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2608-FirstSentence-0",
    "old_comment_raw": "Get the actual schema from aliases.",
    "new_comment_raw": "Get the actual schema from aliases.",
    "old_code_raw": "    public static Schema unaliasSchema(Map<String, Schema> allSchemas, Schema schema) {\n        if (allSchemas == null || allSchemas.isEmpty()) {\n            // skip the warning as the spec can have no model defined\n            //LOGGER.warn(\"allSchemas cannot be null/empty in unaliasSchema. Returned 'schema'\");\n            return schema;\n        }\n\n        if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) {\n            Schema ref = allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()));\n            if (ref == null) {\n                LOGGER.warn(\"{} is not defined\", schema.get$ref());\n                return schema;\n            } else if (ref.getEnum() != null && !ref.getEnum().isEmpty()) {\n                // top-level enum class\n                return schema;\n            } else if (isArraySchema(ref)) {\n                if (generateAliasAsModel) {\n                    return schema; // generate a model extending array\n                } else {\n                    return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n                }\n            } else if (isComposedSchema(ref)) {\n                return schema;\n            } else if (isMapSchema(ref)) {\n                if (ref.getProperties() != null && !ref.getProperties().isEmpty()) // has at least one property\n                    return schema; // treat it as model\n                else {\n                    if (generateAliasAsModel) {\n                        return schema; // generate a model extending map\n                    } else {\n                        // treat it as a typical map\n                        return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n                    }\n                }\n            } else if (isObjectSchema(ref)) { // model\n                if (ref.getProperties() != null && !ref.getProperties().isEmpty()) { // has at least one property\n                    return schema;\n                } else { // free form object (type: object)\n                    return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n                }\n            } else {\n                return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n            }\n        }\n        return schema;\n    }\n",
    "new_code_raw": "    public static Schema unaliasSchema(OpenAPI openAPI, Schema schema) {\n        Map<String, Schema> allSchemas = getSchemas(openAPI);\n        if (allSchemas == null || allSchemas.isEmpty()) {\n            // skip the warning as the spec can have no model defined\n            //LOGGER.warn(\"allSchemas cannot be null/empty in unaliasSchema. Returned 'schema'\");\n            return schema;\n        }\n\n        if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) {\n            Schema ref = allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()));\n            if (ref == null) {\n                LOGGER.warn(\"{} is not defined\", schema.get$ref());\n                return schema;\n            } else if (ref.getEnum() != null && !ref.getEnum().isEmpty()) {\n                // top-level enum class\n                return schema;\n            } else if (isArraySchema(ref)) {\n                if (generateAliasAsModel) {\n                    return schema; // generate a model extending array\n                } else {\n                    return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n                }\n            } else if (isComposedSchema(ref)) {\n                return schema;\n            } else if (isMapSchema(ref)) {\n                if (ref.getProperties() != null && !ref.getProperties().isEmpty()) // has at least one property\n                    return schema; // treat it as model\n                else {\n                    if (generateAliasAsModel) {\n                        return schema; // generate a model extending map\n                    } else {\n                        // treat it as a typical map\n                        return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n                    }\n                }\n            } else if (isObjectSchema(ref)) { // model\n                if (ref.getProperties() != null && !ref.getProperties().isEmpty()) { // has at least one property\n                    return schema;\n                } else { // free form object (type: object)\n                    return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n                }\n            } else {\n                return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n            }\n        }\n        return schema;\n    }\n"
  },
  {
    "id": "processing_processing-205-FirstSentence-0",
    "old_comment_raw": "Any modes that extend JavaMode can override this method to add additional jars to be included in the classpath for code completion and error checking",
    "new_comment_raw": "Any modes that extend JavaMode can override this method to add additional",
    "old_code_raw": "  public String getSearchPath() {\n    // Java Mode doesn't need any default external jars at the moment.\n    return \"\";\n  }\n",
    "new_code_raw": "  public String getSearchPath() {\n    // Java Mode doesn't need any default external jars at the moment.\n    // This is here for Android Mode so that it can add its android.jar file.\n    return null;\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-1018-FirstSentence-0",
    "old_comment_raw": "Returns a formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, and time zone offset prefixed by 'T' ('T'HH:mm:ssZZ).",
    "new_comment_raw": "Returns a formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, and time zone offset prefixed by 'T' ('T'HH:mm:ssZZ).",
    "old_code_raw": "    public static DateTimeFormatter tTimeNoMillis() {\n        if (ttx == null) {\n            ttx = new DateTimeFormatterBuilder()\n                .append(literalTElement())\n                .append(timeNoMillis())\n                .toFormatter();\n        }\n        return ttx;\n    }\n",
    "new_code_raw": "    public static DateTimeFormatter tTimeNoMillis() {\n        return Constants.ttx;\n    }\n"
  },
  {
    "id": "albfan_sqlworkbenchj-72-Associations-FirstSentence",
    "old_comment_raw": "Return the columns for the given table",
    "new_comment_raw": "Return the columns for the given table.",
    "old_code_raw": "\tpublic List<ColumnIdentifier> getColumns(TableIdentifier tbl)\n\t{\n\t\tString schema = getSchemaToUse(tbl.getSchema());\n\n\t\tif (this.objects.size() == 0 || !schemasInCache.contains(schema == null ? NULL_SCHEMA : schema))\n\t\t{\n\t\t\tthis.getTables(schema);\n\t\t}\n\n\t\tTableIdentifier toSearch = tbl.createCopy();\n\t\ttoSearch.adjustCase(dbConnection);\n\t\tif (toSearch.getSchema() == null)\n\t\t{\n\t\t\ttoSearch.setSchema(schema);\n\t\t}\n\n\t\tList<ColumnIdentifier> cols = this.objects.get(toSearch);\n\n\t\t// To support Oracle public synonyms, try to find a table with that name but without a schema\n\t\tif (retrieveOraclePublicSynonyms && toSearch.getSchema() != null && cols == null)\n\t\t{\n\t\t\ttoSearch.setSchema(null);\n\t\t\ttoSearch.setType(null);\n\t\t\tcols = this.objects.get(toSearch);\n\t\t\tif (cols == null)\n\t\t\t{\n\t\t\t\t// retrieve Oracle PUBLIC synonyms\n\t\t\t\tthis.getTables(\"PUBLIC\");\n\t\t\t\tcols = this.objects.get(toSearch);\n\t\t\t}\n\t\t}\n\n\t\tif (CollectionUtil.isEmpty(cols))\n\t\t{\n\t\t\tTableIdentifier tblToUse = null;\n\n\t\t\t// use the stored key because that might carry the correct type attribute\n\t\t\t// TabelIdentifier.equals() doesn't compare the type, only the expression\n\t\t\t// so we'll get a containsKey() == true even if the type is different\n\t\t\t// (which is necessary because the TableIdentifier passed to this\n\t\t\t// method will never contain a type!)\n\t\t\t// only using objects.get() would not return anything!\n\t\t\tif (objects.containsKey(toSearch))\n\t\t\t{\n\t\t\t\t// we have already retrieved the list of tables, but not the columns for this table\n\t\t\t\t// the table identifier in the object map contains correct type and schema information, so we need\n\t\t\t\t// to use that\n\t\t\t\ttblToUse = findEntry(toSearch);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// retrieve the real table identifier based on the table name\n\t\t\t\ttblToUse = this.dbConnection.getMetadata().findObject(toSearch);\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tcols = this.dbConnection.getMetadata().getTableColumns(tblToUse);\n\t\t\t}\n\t\t\tcatch (Throwable e)\n\t\t\t{\n\t\t\t\tLogMgr.logError(\"DbObjectCache.getColumns\", \"Error retrieving columns for \" + tblToUse, e);\n\t\t\t\tcols = null;\n\t\t\t}\n\n\t\t\tif (tblToUse != null && CollectionUtil.isNonEmpty(cols))\n\t\t\t{\n\t\t\t\tthis.objects.put(tblToUse, cols);\n\t\t\t}\n\n\t\t}\n\t\treturn Collections.unmodifiableList(cols);\n\t}\n",
    "new_code_raw": "\tpublic synchronized List<ColumnIdentifier> getColumns(TableIdentifier tbl)\n\t{\n\t\tString schema = getSchemaToUse(tbl.getSchema());\n\n\t\tTableIdentifier toSearch = tbl.createCopy();\n\t\ttoSearch.adjustCase(dbConnection);\n\t\tif (toSearch.getSchema() == null)\n\t\t{\n\t\t\ttoSearch.setSchema(schema);\n\t\t}\n\n\t\tList<ColumnIdentifier> cols = this.objects.get(toSearch);\n\t\tif (cols == null)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tTableDefinition def = dbConnection.getMetadata().getTableDefinition(toSearch);\n\t\t\t\taddTable(def);\n\t\t\t}\n\t\t\tcatch (SQLException sql)\n\t\t\t{\n\t\t\t\tLogMgr.logWarning(\"DbObjectCache.getColumns()\", \"Error retrieving table definition\", sql);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// To support Oracle public synonyms, try to find a table with that name but without a schema\n\t\tif (retrieveOraclePublicSynonyms && toSearch.getSchema() != null && cols == null)\n\t\t{\n\t\t\ttoSearch.setSchema(null);\n\t\t\ttoSearch.setType(null);\n\t\t\tcols = this.objects.get(toSearch);\n\t\t\tif (cols == null)\n\t\t\t{\n\t\t\t\t// retrieve Oracle PUBLIC synonyms\n\t\t\t\tthis.getTables(\"PUBLIC\");\n\t\t\t\tcols = this.objects.get(toSearch);\n\t\t\t}\n\t\t}\n\n\t\tif (CollectionUtil.isEmpty(cols))\n\t\t{\n\t\t\tTableIdentifier tblToUse = null;\n\n\t\t\t// use the stored key because that might carry the correct type attribute\n\t\t\t// TabelIdentifier.equals() doesn't compare the type, only the expression\n\t\t\t// so we'll get a containsKey() == true even if the type is different\n\t\t\t// (which is necessary because the TableIdentifier passed to this\n\t\t\t// method will never contain a type!)\n\t\t\t// only using objects.get() would not return anything!\n\t\t\tif (objects.containsKey(toSearch))\n\t\t\t{\n\t\t\t\t// we have already retrieved the list of tables, but not the columns for this table\n\t\t\t\t// the table identifier in the object map contains correct type and schema information, so we need\n\t\t\t\t// to use that\n\t\t\t\ttblToUse = findEntry(toSearch);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// retrieve the real table identifier based on the table name\n\t\t\t\ttblToUse = this.dbConnection.getMetadata().findObject(toSearch);\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tcols = this.dbConnection.getMetadata().getTableColumns(tblToUse);\n\t\t\t}\n\t\t\tcatch (Throwable e)\n\t\t\t{\n\t\t\t\tLogMgr.logError(\"DbObjectCache.getColumns\", \"Error retrieving columns for \" + tblToUse, e);\n\t\t\t\tcols = null;\n\t\t\t}\n\n\t\t\tif (tblToUse != null && CollectionUtil.isNonEmpty(cols))\n\t\t\t{\n\t\t\t\tthis.objects.put(tblToUse, cols);\n\t\t\t}\n\n\t\t}\n\t\treturn Collections.unmodifiableList(cols);\n\t}\n\n"
  },
  {
    "id": "avast_android_butterknife_zelezny-9-FirstSentence-0",
    "old_comment_raw": "Try to find layout XML file in selected element",
    "new_comment_raw": "Try to find layout XML file in selected element",
    "old_code_raw": "    public static PsiFile findLayoutResource(PsiElement element) {\n        if (element == null) {\n            return null; // nothing to be used\n        }\n        if (!(element instanceof PsiIdentifier)) {\n            return null; // nothing to be used\n        }\n\n        PsiElement layout = element.getParent().getFirstChild();\n        if (layout == null) {\n            return null; // no file to process\n        }\n        if (!\"R.layout\".equals(layout.getText())) {\n            return null; // not layout file\n        }\n\n        Project project = element.getProject();\n        String name = String.format(\"%s.xml\", element.getText());\n\n        // restricting the search to the current module - searching the whole project could return wrong layouts\n        GlobalSearchScope moduleScope = ModuleUtil.findModuleForPsiElement(element).getModuleWithDependenciesAndLibrariesScope(false);\n        PsiFile[] files = FilenameIndex.getFilesByName(project, name, moduleScope);\n        if (files.length <= 0) {\n            return null; //no matching files\n        }\n\n        // TODO - we have a problem here - we still can have multiple layouts (some coming from a dependency)\n        // we need to resolve R class properly and find the proper layout for the R class\n        return files[0];\n    }\n",
    "new_code_raw": "    public static PsiFile findLayoutResource(PsiElement element) {\n        if (element == null) {\n            return null; // nothing to be used\n        }\n        if (!(element instanceof PsiIdentifier)) {\n            return null; // nothing to be used\n        }\n\n        PsiElement layout = element.getParent().getFirstChild();\n        if (layout == null) {\n            return null; // no file to process\n        }\n        if (!\"R.layout\".equals(layout.getText())) {\n            return null; // not layout file\n        }\n\n        Project project = element.getProject();\n        String name = String.format(\"%s.xml\", element.getText());\n        return resolveLayoutResourceFile(element, project, name);\n\n\n    }\n"
  },
  {
    "id": "iluwatar_java-design-patterns-4-Associations-FirstSentence",
    "old_comment_raw": "Returns the next element of the iteration.",
    "new_comment_raw": "Returns the next element of the Iterable.",
    "old_code_raw": "    @Override\n    public final TYPE next() {\n        TYPE result = next;\n        next = null;\n        result = (result == null ? fromIterator.next() : result);\n        return result;\n    }\n",
    "new_code_raw": "    @Override\n    public final TYPE next() {\n        if (next == null) {\n            return fromIterator.next();\n        } else {\n            final TYPE result = next;\n            next = null;\n            return result;\n        }\n    }\n\n"
  },
  {
    "id": "apache_activemq-1106-FirstSentence-0",
    "old_comment_raw": "Returns the value of the object with the specified name.",
    "new_comment_raw": "Returns the value of the object with the specified name.",
    "old_code_raw": "    public Object getObject(String name) throws JMSException {\n        initializeReading();\n        return map.get(name);\n    }\n",
    "new_code_raw": "    public Object getObject(String name) throws JMSException {\n        initializeReading();\n        Object result = map.get(name);\n        if (result instanceof UTF8Buffer) {\n            result = result.toString();\n        }\n\n        return result;\n    }\n"
  },
  {
    "id": "biddyweb_android-rcs-ims-stack-11-Associations-FirstSentence",
    "old_comment_raw": "Utility to find the RCS rawContactId for a specific phone number.",
    "new_comment_raw": "Utility to find the RCS rawContactIds for a specific phone number.",
    "old_code_raw": "    private long getRcsRawContactIdFromPhoneNumber(String phoneNumber) {\n        String[] projection = { Data.RAW_CONTACT_ID };\n        String selection = Data.MIMETYPE + \"=? AND PHONE_NUMBERS_EQUAL(\" + Phone.NUMBER + \", ?)\";\n        String[] selectionArgs = { MIMETYPE_NUMBER, phoneNumber };\n        String sortOrder = Data.RAW_CONTACT_ID;\n\n        Cursor cur = ctx.getContentResolver().query(Data.CONTENT_URI, \n        \t\tprojection, \n        \t\tselection, \n        \t\tselectionArgs,\n                sortOrder);\n        if (cur != null) {\n            while (cur.moveToNext()) {\n            \tlong rcsRawContactId = cur.getLong(cur.getColumnIndex(Data.RAW_CONTACT_ID));\n            \tcur.close();\n            \treturn rcsRawContactId;\n            }\n            cur.close();\n        }\n\n        return INVALID_ID;\n    }\n",
    "new_code_raw": "    private List<Long> getRcsRawContactIdFromPhoneNumber(String phoneNumber) {\n    \tList<Long> contactsIds = new ArrayList<Long>();\n    \t\n        String[] projection = { Data.RAW_CONTACT_ID };\n        String selection = Data.MIMETYPE + \"=? AND PHONE_NUMBERS_EQUAL(\" + Phone.NUMBER + \", ?)\";\n        String[] selectionArgs = { MIMETYPE_NUMBER, phoneNumber };\n        String sortOrder = Data.RAW_CONTACT_ID;\n\n        Cursor cur = ctx.getContentResolver().query(Data.CONTENT_URI, \n        \t\tprojection, \n        \t\tselection, \n        \t\tselectionArgs,\n                sortOrder);\n        if (cur != null) {\n            while (cur.moveToNext()) {\n            \tlong rcsRawContactId = cur.getLong(cur.getColumnIndex(Data.RAW_CONTACT_ID));\n            \tcontactsIds.add(rcsRawContactId);\n            }\n            cur.close();\n        }\n\n        return contactsIds;\n    }\n\n"
  },
  {
    "id": "apache_calcite-684-FirstSentence-0",
    "old_comment_raw": "Creates a connection with a given query provider.",
    "new_comment_raw": "Creates a connection with a given query provider.",
    "old_code_raw": "  static OptiqConnection getConnection(SchemaSpec schemaSpec)\n      throws ClassNotFoundException, SQLException {\n    Class.forName(\"net.hydromatic.optiq.jdbc.Driver\");\n    Connection connection = DriverManager.getConnection(\"jdbc:calcite:\");\n    OptiqConnection optiqConnection =\n        connection.unwrap(OptiqConnection.class);\n    final SchemaPlus rootSchema = optiqConnection.getRootSchema();\n    switch (schemaSpec) {\n    case JDBC_FOODMART:\n      addSchema(rootSchema, schemaSpec);\n      break;\n    case CLONE_FOODMART:\n    case JDBC_FOODMART_WITH_LATTICE:\n      addSchema(rootSchema, SchemaSpec.JDBC_FOODMART);\n      addSchema(rootSchema, schemaSpec);\n      break;\n    default:\n      throw new AssertionError(\"unknown schema \" + schemaSpec);\n    }\n    optiqConnection.setSchema(\"foodmart2\");\n    return optiqConnection;\n  }\n",
    "new_code_raw": "  static CalciteConnection getConnection(SchemaSpec schemaSpec)\n      throws ClassNotFoundException, SQLException {\n    Connection connection = DriverManager.getConnection(\"jdbc:calcite:\");\n    CalciteConnection calciteConnection =\n        connection.unwrap(CalciteConnection.class);\n    final SchemaPlus rootSchema = calciteConnection.getRootSchema();\n    switch (schemaSpec) {\n    case JDBC_FOODMART:\n      addSchema(rootSchema, schemaSpec);\n      break;\n    case CLONE_FOODMART:\n    case JDBC_FOODMART_WITH_LATTICE:\n      addSchema(rootSchema, SchemaSpec.JDBC_FOODMART);\n      addSchema(rootSchema, schemaSpec);\n      break;\n    default:\n      throw new AssertionError(\"unknown schema \" + schemaSpec);\n    }\n    calciteConnection.setSchema(\"foodmart2\");\n    return calciteConnection;\n  }\n"
  },
  {
    "id": "rstudio_rstudio-137-FirstSentence-0",
    "old_comment_raw": "Adds a menu item to the bar, that will fire the given command when it is selected.",
    "new_comment_raw": "Adds a menu item to the bar containing SafeHtml, that will fire the given command when it is selected.",
    "old_code_raw": "  public MenuItem addItem(String text, boolean asHTML, Command cmd) {\n    return addItem(new MenuItem(text, asHTML, cmd));\n  }\n",
    "new_code_raw": "  public MenuItem addItem(SafeHtml html, ScheduledCommand cmd) {\n    return addItem(new MenuItem(html, cmd));\n  }\n"
  },
  {
    "id": "apache_kylin-482-FirstSentence-0",
    "old_comment_raw": "Calculate size of each region for given table and other info of the table.",
    "new_comment_raw": "Calculate size of each region for given table and other info of the table.",
    "old_code_raw": "    public HBaseResponse getHTableInfo(String tableName) throws IOException {\n        if (htableInfoCache.containsKey(tableName)) {\n            return htableInfoCache.get(tableName);\n        }\n\n        HBaseResponse hr = new HBaseResponse();\n        if (\"hbase\".equals(getConfig().getMetadataUrl().getScheme())) {\n            try {\n                // use reflection to isolate NoClassDef errors when HBase is not available\n                hr = (HBaseResponse) Class.forName(\"org.apache.kylin.rest.service.HBaseInfoUtil\")//\n                        .getMethod(\"getHBaseInfo\", new Class[] { String.class, String.class })//\n                        .invoke(null, new Object[] { tableName, this.getConfig().getStorageUrl() });\n            } catch (Throwable e) {\n                throw new IOException(e);\n            }\n        }\n\n        htableInfoCache.put(tableName, hr);\n        return hr;\n    }\n",
    "new_code_raw": "    public HBaseResponse getHTableInfo(String tableName) throws IOException, ExecutionException {\n        return htableInfoCache.get(tableName);\n    }\n"
  },
  {
    "id": "codehaus_picocontainer-10-Associations-FirstSentence",
    "old_comment_raw": "Ensures that the given key is converted to a JMX ObjectName",
    "new_comment_raw": "Ensures that the given componentKey is converted to a JMX ObjectName",
    "old_code_raw": "    public static ObjectName asObjectName(Object key) throws MalformedObjectNameException {\n        if (key == null) {\n            throw new NullPointerException(\"key cannot be null\");\n        }\n        if (key instanceof ObjectName) {\n            return (ObjectName) key;\n        }\n        if (key instanceof Class) {\n            Class clazz = (Class) key;\n            return new ObjectName(\"nanomx:type=\" + clazz.getName());\n        } else {\n            String text = key.toString();\n            // Fix, so it works under WebSphere ver. 5\n            if (text.indexOf(':') == -1) {\n                text = \"nanomx:type=\" + text;\n            }\n            return new ObjectName(text);\n        }\n    }\n",
    "new_code_raw": "    private static ObjectName asObjectName(Object componentKey) throws MalformedObjectNameException {\n        if (componentKey == null) {\n            throw new NullPointerException(\"componentKey cannot be null\");\n        }\n        if (componentKey instanceof ObjectName) {\n            return (ObjectName) componentKey;\n        }\n        if (componentKey instanceof Class) {\n            Class clazz = (Class) componentKey;\n            return new ObjectName(\"picomx:type=\" + clazz.getName());\n        } else {\n            String text = componentKey.toString();\n            // Fix, so it works under WebSphere ver. 5\n            if (text.indexOf(':') == -1) {\n                text = \"picomx:type=\" + text;\n            }\n            return new ObjectName(text);\n        }\n    }\n\n"
  },
  {
    "id": "RobotiumTech_robotium-1445-FirstSentence-0",
    "old_comment_raw": "Checks if a View matches a certain string and returns the amount of total matches.",
    "new_comment_raw": "Checks if a View matches a certain string and returns the amount of total matches.",
    "old_code_raw": "\tpublic static int getNumberOfMatches(String regex, TextView view, Set<TextView> uniqueTextViews){\n\t\tPattern pattern = null;\n\t\ttry{\n\t\t\tpattern = Pattern.compile(regex);\n\t\t}catch(PatternSyntaxException e){\n\t\t\tpattern = Pattern.compile(regex, Pattern.LITERAL);\n\t\t}\n\t\tMatcher matcher = pattern.matcher(view.getText().toString());\n\t\tif (matcher.find()){\n\t\t\tuniqueTextViews.add(view);\n\t\t}\n\t\tif (view.getError() != null){\n\t\t\tmatcher = pattern.matcher(view.getError().toString());\n\t\t\tif (matcher.find()){\n\t\t\t\tuniqueTextViews.add(view);\n\t\t\t}\n\t\t}\t\n\t\tif (view.getText().toString().equals(\"\") && view.getHint() != null){\n\t\t\tmatcher = pattern.matcher(view.getHint().toString());\n\t\t\tif (matcher.find()){\n\t\t\t\tuniqueTextViews.add(view);\n\t\t\t}\n\t\t}\t\n\t\treturn uniqueTextViews.size();\t\t\n\t}\n",
    "new_code_raw": "\tpublic static int getNumberOfMatches(String regex, TextView view, Set<TextView> uniqueTextViews){\n\t\tif(view == null) {\n\t\t\treturn uniqueTextViews.size();\n\t\t}\n\n\t\tPattern pattern = null;\n\t\ttry{\n\t\t\tpattern = Pattern.compile(regex);\n\t\t}catch(PatternSyntaxException e){\n\t\t\tpattern = Pattern.compile(regex, Pattern.LITERAL);\n\t\t}\n\t\tString viewText = view.getText().toString();\n\t\tviewText = viewText.replaceAll(\"[\\n\\r]\", \" \");\n\t\tMatcher matcher = pattern.matcher(viewText);\n\n\t\tif (matcher.find()){\n\t\t\tuniqueTextViews.add(view);\n\t\t}\n\t\tif (view.getError() != null){\n\t\t\tmatcher = pattern.matcher(view.getError().toString());\n\t\t\tif (matcher.find()){\n\t\t\t\tuniqueTextViews.add(view);\n\t\t\t}\n\t\t}\t\n\t\tif (view.getText().toString().equals(\"\") && view.getHint() != null){\n\t\t\tmatcher = pattern.matcher(view.getHint().toString());\n\t\t\tif (matcher.find()){\n\t\t\t\tuniqueTextViews.add(view);\n\t\t\t}\n\t\t}\t\n\t\treturn uniqueTextViews.size();\t\t\n\t}\n"
  },
  {
    "id": "hibernate_hibernate_orm-1208-FirstSentence-0",
    "old_comment_raw": "find entity statistics per name",
    "new_comment_raw": "find entity statistics per name",
    "old_code_raw": "\tpublic EntityStatistics getEntityStatistics(String entityName) {\n\t\tConcurrentEntityStatisticsImpl es = (ConcurrentEntityStatisticsImpl) entityStatistics.get( entityName );\n\t\tif ( es == null ) {\n\t\t\tes = new ConcurrentEntityStatisticsImpl( entityName );\n\t\t\tConcurrentEntityStatisticsImpl previous;\n\t\t\tif ( ( previous = (ConcurrentEntityStatisticsImpl) entityStatistics.putIfAbsent(\n\t\t\t\t\tentityName, es\n\t\t\t) ) != null ) {\n\t\t\t\tes = previous;\n\t\t\t}\n\t\t}\n\t\treturn es;\n\t}\n",
    "new_code_raw": "\tpublic ConcurrentEntityStatisticsImpl getEntityStatistics(String entityName) {\n\t\tConcurrentEntityStatisticsImpl es = entityStatistics.get( entityName );\n\t\tif ( es == null ) {\n\t\t\tes = new ConcurrentEntityStatisticsImpl( entityName );\n\t\t\tConcurrentEntityStatisticsImpl previous;\n\t\t\tif ( ( previous = entityStatistics.putIfAbsent( entityName, es ) ) != null ) {\n\t\t\t\tes = previous;\n\t\t\t}\n\t\t}\n\t\treturn es;\n\t}\n"
  },
  {
    "id": "briancavalier_iterate-3-Associations-FirstSentence",
    "old_comment_raw": "Applies  predicate to each item",
    "new_comment_raw": "Applies  visitor to each item",
    "old_code_raw": "    public <P extends Visitor<? super X>> P visit(P predicate)\n    {\n        for (X x : this) {\n            predicate.visit(x);\n        }\n\n        return predicate;\n    }\n",
    "new_code_raw": "    public <V extends Visitor<? super X>> V visit(V visitor)\n    {\n        for (X x : this) {\n            visitor.visit(x);\n        }\n\n        return visitor;\n    }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-456-FirstSentence-0",
    "old_comment_raw": "Gets the value as a String in the ISO8601 duration format.",
    "new_comment_raw": "Gets the value as a String in the ISO8601 duration format.",
    "old_code_raw": "    public String toString() {\n        return ISODurationFormat.getInstance().standard().print(this);\n    }\n",
    "new_code_raw": "    public String toString() {\n        return ISOTimePeriodFormat.getInstance().standard().print(toTimePeriod());\n    }\n"
  },
  {
    "id": "apache_deltaspike-17-Associations-FirstSentence",
    "old_comment_raw": "Repository access - lookup the Repository component meta data for a specific Repository class.",
    "new_comment_raw": "Lookup the  RepositoryMetadata for a specific Repository class.",
    "old_code_raw": "    public RepositoryMetadata lookupComponent(Class<?> repoClass)\r\n    {\r\n        if (repositoriesMetadata.containsKey(repoClass))\r\n        {\r\n            return repositoriesMetadata.get(repoClass);\r\n        }\r\n        throw new RuntimeException(\"Unknown Repository class \" + repoClass.getName());\r\n    }\r\n",
    "new_code_raw": "    public RepositoryMetadata lookupComponent(Class<?> repositoryClass)\r\n    {\r\n        if (repositoriesMetadata.containsKey(repositoryClass))\r\n        {\r\n            return repositoriesMetadata.get(repositoryClass);\r\n        }\r\n        throw new RuntimeException(\"Unknown Repository class \" + repositoryClass.getName());\r\n    }\r\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2514-FirstSentence-0",
    "old_comment_raw": "Serialize the given Java object into request body string, according to the request Content-Type.",
    "new_comment_raw": "Serialize the given Java object into request body according to the object's class and the request Content-Type.",
    "old_code_raw": "  public String serialize(Object obj, String contentType) throws ApiException {\n    if (isJsonMime(contentType)) {\n      if (obj != null)\n        return json.serialize(obj);\n      else\n        return null;\n    } else {\n      throw new ApiException(\"Content type \\\"\" + contentType + \"\\\" is not supported\");\n    }\n  }\n",
    "new_code_raw": "  public RequestBody serialize(Object obj, String contentType) throws ApiException {\n    if (obj instanceof byte[]) {\n      // Binary (byte array) body parameter support.\n      return RequestBody.create(MediaType.parse(contentType), (byte[]) obj);\n    } else if (obj instanceof File) {\n      // File body parameter support.\n      return RequestBody.create(MediaType.parse(contentType), (File) obj);\n    } else if (isJsonMime(contentType)) {\n      String content;\n      if (obj != null) {\n        content = json.serialize(obj);\n      } else {\n        content = null;\n      }\n      return RequestBody.create(MediaType.parse(contentType), content);\n    } else {\n      throw new ApiException(\"Content type \\\"\" + contentType + \"\\\" is not supported\");\n    }\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-2128-FirstSentence-0",
    "old_comment_raw": "Sets a value in the milliseconds supplied from a human-readable, text value.",
    "new_comment_raw": "Sets a value using the specified partial instant.",
    "old_code_raw": "    public long set(long instant, String text, Locale locale) {\n        try {\n            return set(instant, Integer.parseInt(text));\n        } catch (NumberFormatException ex) {\n            throw new IllegalArgumentException(\"Invalid \" + getName() + \" text: \" + text);\n        }\n    }\n",
    "new_code_raw": "    public int[] set(PartialInstant instant, int fieldIndex, int[] values, int newValue) {\n        FieldUtils.verifyValueBounds(this, newValue, getMinimumValue(instant), getMaximumValue(instant));\n        values[fieldIndex] = newValue;\n        return values;\n    }\n"
  },
  {
    "id": "sudosurootdev_frameworks_opt_telephony-37-Associations-FirstSentence",
    "old_comment_raw": "Returns the  ConnectionService.VideoCallProvider for the connection.",
    "new_comment_raw": "Returns the  VideoCallProvider for the connection.",
    "old_code_raw": "    public ConnectionService.VideoCallProvider getVideoCallProvider() {\n        return mVideoCallProvider;\n    }\n",
    "new_code_raw": "    public VideoCallProvider getVideoCallProvider() {\n        return mVideoCallProvider;\n    }\n\n"
  },
  {
    "id": "webdizz_sonarqube-spellcheck-2-Associations-FirstSentence",
    "old_comment_raw": "Spell checks all words in the input string and returns an array of misspelt words.",
    "new_comment_raw": "Spell checks all words in the input string and returns an array of misspelled words.",
    "old_code_raw": "    public String[] checkAllWords(String words) {\n        List<String> misspeltWords = new ArrayList<String>();\n        StringWordTokenizer tokenizer = new StringWordTokenizer(words);\n\n        while (tokenizer.hasMoreWords()) {\n            String word = tokenizer.nextWord();\n            if (!isWordCorrect(word, tokenizer.isNewSentence())) {\n                misspeltWords.add(word);\n            }\n        }\n        return misspeltWords.toArray(new String[0]);\n    }\n",
    "new_code_raw": "    public String[] checkAllWords(String words) {\n        List<String> misspelledWords = new ArrayList<String>();\n        StringWordTokenizer tokenizer = new StringWordTokenizer(words);\n\n        while (tokenizer.hasMoreWords()) {\n            String word = tokenizer.nextWord();\n            if (!isWordCorrect(word, tokenizer.isNewSentence())) {\n                misspelledWords.add(word);\n            }\n        }\n        return misspelledWords.toArray(new String[0]);\n    }\n\n"
  },
  {
    "id": "biddyweb_android-rcs-ims-stack-43-Associations-FirstSentence",
    "old_comment_raw": "Returns the message id header value of a SIP request",
    "new_comment_raw": "Returns the message ID from a SIP request",
    "old_code_raw": "\tpublic static String getMessageId(SipRequest request) {\r\n\t\t// Read ID from Message-Id header\r\n\t\tExtensionHeader messageIdHeader = (ExtensionHeader)request.getHeader(ImdnUtils.HEADER_IMDN_MSG_ID);\r\n\t\tif (messageIdHeader != null) {\r\n\t\t\treturn messageIdHeader.getValue();\r\n\t\t} \r\n\t\t\r\n\t\t// Read ID from multipart content\r\n\t\ttry {\r\n\t\t    String content = request.getContent();\r\n\t\t\tint index = content.indexOf(ImdnUtils.HEADER_IMDN_MSG_ID);\r\n\t\t\tif (index != -1) {\r\n\t\t\t\tindex = index+ImdnUtils.HEADER_IMDN_MSG_ID.length()+1;\r\n\t\t\t\tString part = content.substring(index);\r\n\t\t\t\tString msgId = part.substring(0, part.indexOf(SipUtils.CRLF));\r\n\t\t\t\treturn msgId.trim();\r\n\t\t\t}\r\n\t\t} catch(Exception e) {\r\n\t\t}\r\n\t\t\r\n\t\t// No message id\r\n\t\treturn null;\r\n\t}\r\n",
    "new_code_raw": "\tpublic static String getMessageId(SipRequest request) {\r\n\t\tString result = null;\r\n\t\ttry {\r\n\t\t\t// Read ID from multipart content\r\n\t\t    String content = request.getContent();\r\n\t\t\tint index = content.indexOf(ImdnUtils.HEADER_IMDN_MSG_ID);\r\n\t\t\tif (index != -1) {\r\n\t\t\t\tindex = index+ImdnUtils.HEADER_IMDN_MSG_ID.length()+1;\r\n\t\t\t\tString part = content.substring(index);\r\n\t\t\t\tString msgId = part.substring(0, part.indexOf(CRLF));\r\n\t\t\t\tresult = msgId.trim();\r\n\t\t\t}\r\n\t\t} catch(Exception e) {\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\n"
  },
  {
    "id": "apache_kylin-527-FirstSentence-0",
    "old_comment_raw": "flatten to OR-AND filter, (A AND B AND ..) OR (C AND D AND ..) OR ..",
    "new_comment_raw": "throws IllegalStateException when the flat children exceed the maxFlatChildrenSize",
    "old_code_raw": "    public TupleFilter flatFilter() {\n        return flattenInternal(this);\n    }\n",
    "new_code_raw": "    public TupleFilter flatFilter(int maxFlatChildrenSize) {\n        return flattenInternal(this, maxFlatChildrenSize);\n    }\n"
  },
  {
    "id": "magro_memcached-session-manager-11-Associations-FirstSentence",
    "old_comment_raw": "Store the provided session in memcached.",
    "new_comment_raw": "Store the provided session in memcached if the session was modified or if the session needs to be relocated.",
    "old_code_raw": "    public BackupResult backupSession( final Session session ) {\n        if ( _log.isInfoEnabled() ) {\n            _log.debug( \"Trying to store session in memcached: \" + session.getId() );\n        }\n\n        final BackupSessionTask task = getOrCreateBackupSessionTask( (MemcachedBackupSession) session );\n        return task.backupSession();\n    }\n",
    "new_code_raw": "    public BackupResultStatus backupSession( final Session session ) {\n        if ( _log.isInfoEnabled() ) {\n            _log.debug( \"Trying to store session in memcached: \" + session.getId() );\n        }\n\n        final MemcachedBackupSession backupSession = (MemcachedBackupSession) session;\n\n        final BackupSessionTask task = getOrCreateBackupSessionTask( backupSession );\n\n        final Map<String, Object> attributes = backupSession.getAttributesInternal();\n\n        final byte[] attributesData = _transcoderService.serializeAttributes( backupSession, attributes );\n        final int hashCode = Arrays.hashCode( attributesData );\n        if ( backupSession.getDataHashCode() != hashCode\n                || task.sessionCookieWasRelocated() ) {\n            final byte[] data = _transcoderService.serialize( backupSession, attributesData );\n\n            final BackupResult result = task.backupSession( data, attributesData );\n            if ( result.getAttributesData() != null ) {\n                backupSession.setDataHashCode( Arrays.hashCode( result.getAttributesData() ) );\n            }\n\n            return result.getStatus();\n        } else {\n            return BackupResultStatus.SKIPPED;\n        }\n    }\n\n"
  },
  {
    "id": "cemcatik_jtds-113-Associations-FirstSentence",
    "old_comment_raw": "Construct a test suite for this library.",
    "new_comment_raw": "Provides a null test suite so that JUnit will not try to instantiate this class directly.",
    "old_code_raw": "        public static Test suite(String name) {\n            return new TestSuite(\n                    JtdsDataSourceUnitTest.Test_JtdsDataSource_getConnection.class, name);\n        }\n",
    "new_code_raw": "        public static final Test suite() {\n            return null;\n        }\n\n"
  },
  {
    "id": "apache_lenya-333-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Get the line number",
    "old_code_raw": "    public final int getLine() {\n        return bufline[bufpos];\n    }\n",
    "new_code_raw": "    public final int getLine() {\n        return this.bufline[this.bufpos];\n    }\n\n"
  },
  {
    "id": "querydsl_querydsl-1437-FirstSentence-0",
    "old_comment_raw": "Expr : left.startsWith(right) (ignore case)",
    "new_comment_raw": "Expr : left.startsWith(right)",
    "old_code_raw": "    public static EBoolean startsWith(Expr<String> left, Expr<String> right, boolean caseSensitive) {\n        if (caseSensitive){\n            return startsWith(left, right);            \n        }else{\n            return operationFactory.createBoolean(Ops.STARTSWITH_IC, left, right);\n        }\n    }\n",
    "new_code_raw": "    public static EBoolean startsWith(Expr<String> left, Expr<String> right) {\n        return operationFactory.createBoolean(Ops.STARTSWITH, left, right);\n    }\n"
  },
  {
    "id": "LawnchairLauncher_Lawnchair-421-FirstSentence-0",
    "old_comment_raw": "Finds the upper-left coordinate of the first rectangle in the grid that can hold a cell of the specified dimensions.",
    "new_comment_raw": "This method can be called only once! Calling #findVacantCellsFromOccupied will restore the ability to call this method.",
    "old_code_raw": "        boolean findCellForSpan(int[] cellXY, int spanX, int spanY) {\n            // return the span represented by the CellInfo only there is no view there\n            //   (this.cell == null) and there is enough space\n\n            if (this.cell == null && this.spanX >= spanX && this.spanY >= spanY) {\n                if (cellXY != null) {\n                    cellXY[0] = cellX;\n                    cellXY[1] = cellY;\n                }\n                return true;\n            }\n\n            int startX = 0;\n            if (intersectX >= 0) {\n                startX = Math.max(startX, intersectX - (spanX - 1));\n            }\n            int endX = mCountX - (spanX - 1);\n            if (intersectX >= 0) {\n                endX = Math.min(endX, intersectX + (spanX - 1));\n            }\n            int startY = 0;\n            if (intersectY >= 0) {\n                startY = Math.max(startY, intersectY - (spanY - 1));\n            }\n            int endY = mCountY - (spanY - 1);\n            if (intersectY >= 0) {\n                endY = Math.min(endY, intersectY + (spanY - 1));\n            }\n\n            for (int x = startX; x < endX; x++) {\n                inner:\n                for (int y = startY; y < endY; y++) {\n                    for (int i = 0; i < spanX; i++) {\n                        for (int j = 0; j < spanY; j++) {\n                            if (mOccupied[x + i][y + j]) {\n                                // small optimization: we can skip to below the row we just found\n                                // an occupied cell\n                                y += j;\n                                continue inner;\n                            }\n                        }\n                    }\n                    if (cellXY != null) {\n                        cellXY[0] = x;\n                        cellXY[1] = y;\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n",
    "new_code_raw": "        boolean findCellForSpan(int[] cellXY, int spanX, int spanY) {\n            return findCellForSpan(cellXY, spanX, spanY, true);\n        }\n"
  },
  {
    "id": "apache_lenya-655-Associations-FirstSentence",
    "old_comment_raw": "Creates a document identity map.",
    "new_comment_raw": "Creates a document factory.",
    "old_code_raw": "    public static DocumentFactory createDocumentFactory(ServiceManager manager, Session session) {\n        DocumentFactory map;\n        DocumentManager docManager = null;\n        try {\n            docManager = (DocumentManager) manager.lookup(DocumentManager.ROLE);\n            map = docManager.createDocumentIdentityMap(session);\n        } catch (ServiceException e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (docManager != null) {\n                manager.release(docManager);\n            }\n        }\n        return map;\n    }\n",
    "new_code_raw": "    public static DocumentFactory createDocumentFactory(ServiceManager manager, Session session) {\n        DocumentFactory factory;\n        DocumentManager docManager = null;\n        try {\n            docManager = (DocumentManager) manager.lookup(DocumentManager.ROLE);\n            factory = docManager.createDocumentIdentityMap(session);\n        } catch (ServiceException e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (docManager != null) {\n                manager.release(docManager);\n            }\n        }\n        return factory;\n    }\n\n"
  },
  {
    "id": "svn2github_fleXive-34-Associations-FirstSentence",
    "old_comment_raw": "Return a  FilteredEnvironment for the calling user.",
    "new_comment_raw": "Return a  com.flexive.shared.structure.FxFilteredEnvironment for the calling user.",
    "old_code_raw": "    public static FxEnvironment getFilteredEnvironment() {\n        return new FilteredEnvironment(getEnvironment());\n    }\n",
    "new_code_raw": "    public static FxEnvironment getFilteredEnvironment() {\n        return new FxFilteredEnvironment(getEnvironment());\n    }\n\n"
  },
  {
    "id": "mukteshkrmishra_javasimon-45-Associations-FirstSentence",
    "old_comment_raw": "If given location is monitored, then a Stopwatch is started and Split returned - otherwise  null is returned.",
    "new_comment_raw": "If given location is monitored, then a  Stopwatch is started and  Split returned - otherwise disabled Split is returned.",
    "old_code_raw": "\tpublic Split start(L location) {\r\n\t\tif (stopwatchSource.isMonitored(location)) {\r\n\t\t\treturn stopwatchSource.getMonitor(location).start();\r\n\t\t} else {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n",
    "new_code_raw": "\tpublic Split start(L location) {\r\n\t\tif (stopwatchSource.isMonitored(location)) {\r\n\t\t\treturn stopwatchSource.getMonitor(location).start();\r\n\t\t} else {\r\n\t\t\treturn Split.DISABLED;\r\n\t\t}\r\n\t}\r\n\n"
  },
  {
    "id": "eclipse_reddeer-137-Associations-FirstSentence",
    "old_comment_raw": "Gets Menu of specified control.",
    "new_comment_raw": "Returns menu of given control",
    "old_code_raw": "\tpublic Menu getControlMenu(final Control c) {\n\n\t\tMenu menu = Display.syncExec(new ResultRunnable<Menu>() {\n\n\t\t\t@Override\n\t\t\tpublic Menu run() {\n\t\t\t\tMenu m = c.getMenu();\n\t\t\t\treturn m;\n\t\t\t}\n\t\t});\n\n\t\tif (menu == null) {\n\t\t\tthrow new CoreLayerException(\n\t\t\t\t\tc.getClass() +\" Has no menu\");\n\t\t}\n\n\t\treturn menu;\t\n\t}\n",
    "new_code_raw": "\tpublic Menu getControlMenu(final Control c) {\n\t\tMenu controlMenu = ControlHandler.getInstance().getMenu(c);\n\t\tif(controlMenu == null) {\n\t\t\tthrow new CoreLayerException(c.getClass() +\" Has no menu\");\n\t\t}\n\t\treturn controlMenu;\n\t}\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2532-FirstSentence-0",
    "old_comment_raw": "Return the default value of the property",
    "new_comment_raw": "Return the default value of the schema",
    "old_code_raw": "    public String toDefaultValue(Property p) {\n        if (p instanceof StringProperty) {\n            StringProperty dp = (StringProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\\\"\" + dp.getDefault() + \"\\\"\";\n            }\n        } else if (p instanceof BooleanProperty) {\n            BooleanProperty dp = (BooleanProperty) p;\n            if (dp.getDefault() != null) {\n                if (dp.getDefault().toString().equalsIgnoreCase(\"false\"))\n                    return \"@(NO)\";\n                else\n                    return \"@(YES)\";\n            }\n        } else if (p instanceof DateProperty) {\n            // TODO\n        } else if (p instanceof DateTimeProperty) {\n            // TODO\n        } else if (p instanceof DoubleProperty) {\n            DoubleProperty dp = (DoubleProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof FloatProperty) {\n            FloatProperty dp = (FloatProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof IntegerProperty) {\n            IntegerProperty dp = (IntegerProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof LongProperty) {\n            LongProperty dp = (LongProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        }\n\n        return null;\n    }\n",
    "new_code_raw": "    public String toDefaultValue(Schema p) {\n        if (p instanceof StringSchema) {\n            StringSchema dp = (StringSchema) p;\n            if (dp.getDefault() != null) {\n                return \"@\\\"\" + dp.getDefault() + \"\\\"\";\n            }\n        } else if (p instanceof BooleanSchema) {\n            BooleanSchema dp = (BooleanSchema) p;\n            if (dp.getDefault() != null) {\n                if (dp.getDefault().toString().equalsIgnoreCase(\"false\"))\n                    return \"@(NO)\";\n                else\n                    return \"@(YES)\";\n            }\n        } else if (p instanceof DateSchema) {\n            // TODO\n        } else if (p instanceof DateTimeSchema) {\n            // TODO\n        } else if (p instanceof NumberSchema) {\n            NumberSchema dp = (NumberSchema) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof IntegerSchema) {\n            IntegerSchema dp = (IntegerSchema) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        }\n\n        return null;\n    }\n"
  },
  {
    "id": "nickman_qreactor-4-Associations-FirstSentence",
    "old_comment_raw": "Returns",
    "new_comment_raw": "Indicates if the queue is buffered",
    "old_code_raw": "\tpublic boolean isBuffered() {\n\t\treturn buffered;\n\t}\n",
    "new_code_raw": "\tpublic boolean isBuffered() {\n\t\treturn queue.buffered();\n\t}\n\n"
  },
  {
    "id": "JodaOrg_joda_time-442-FirstSentence-0",
    "old_comment_raw": "Gets a copy of this instant with a different time zone.",
    "new_comment_raw": "Gets a copy of this instant with a different time zone, preserving the millisecond instant.",
    "old_code_raw": "    public ReadableInstant withDateTimeZone(DateTimeZone newDateTimeZone) {\n        Chronology newChronology = getChronology();\n        newChronology = newChronology == null ? ISOChronology.getInstance(newDateTimeZone)\n            : newChronology.withDateTimeZone(newDateTimeZone);\n        return withChronology(newChronology);\n    }\n",
    "new_code_raw": "    public ReadableInstant withDateTimeZone(DateTimeZone newDateTimeZone) {\n        final Chronology originalChrono = getChronology();\n        if (originalChrono == null) {\n            // Without an original chronology, no new time zone can be\n            // set. Call withMillis to allow subclass to decide if a clone\n            // should be made or not.\n            return withMillis(getMillis());\n        }\n        return withChronology(originalChrono.withDateTimeZone(newDateTimeZone));\n    }\n"
  },
  {
    "id": "hoecake_ephesoft-38-Associations-FirstSentence",
    "old_comment_raw": "An api to return total count of batches in the batch instance table.",
    "new_comment_raw": "An api to return total count of batches from the batch instance table having access by the user roles on the basis of ephesoft user.",
    "old_code_raw": "\t@Transactional(readOnly = true)\n\t@Override\n\tpublic int getAllCount(final String currentUser, final Set<String> currentRole) {\n\t\treturn batchInstanceDao.getAllCount(currentUser, currentRole);\n\t}\n",
    "new_code_raw": "\t@Transactional(readOnly = true)\n\t@Override\n\tpublic int getAllCount(final String currentUser, final Set<String> userRoles, EphesoftUser ephesoftUser) {\n\t\treturn batchInstanceDao.getAllCount(currentUser, userRoles, ephesoftUser);\n\t}\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2533-FirstSentence-0",
    "old_comment_raw": "Return the default value of the property",
    "new_comment_raw": "Return the default value of the schema",
    "old_code_raw": "    public String toDefaultValue(Property p) {\n        if (p instanceof StringProperty) {\n            StringProperty dp = (StringProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\\\"\" + dp.getDefault() + \"\\\"\";\n            }\n        } else if (p instanceof BooleanProperty) {\n            BooleanProperty dp = (BooleanProperty) p;\n            if (dp.getDefault() != null) {\n                if (dp.getDefault().toString().equalsIgnoreCase(\"false\"))\n                    return \"@(NO)\";\n                else\n                    return \"@(YES)\";\n            }\n        } else if (p instanceof DateProperty) {\n            // TODO\n        } else if (p instanceof DateTimeProperty) {\n            // TODO\n        } else if (p instanceof DoubleProperty) {\n            DoubleProperty dp = (DoubleProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof FloatProperty) {\n            FloatProperty dp = (FloatProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof IntegerProperty) {\n            IntegerProperty dp = (IntegerProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof LongProperty) {\n            LongProperty dp = (LongProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        }\n\n        return null;\n    }\n",
    "new_code_raw": "    public String toDefaultValue(Schema p) {\n        if (ModelUtils.isDateSchema(p)) {\n            // TODO\n        } else if (ModelUtils.isDateTimeSchema(p)) {\n            // TODO\n        } else if (ModelUtils.isNumberSchema(p)) {\n            if (p.getDefault() != null) {\n                return \"@\" + p.getDefault().toString();\n            }\n        } else if (ModelUtils.isIntegerSchema(p)) {\n            if (p.getDefault() != null) {\n                return \"@\" + p.getDefault().toString();\n            }\n        } else if (ModelUtils.isStringSchema(p)) {\n            if (p.getDefault() != null) {\n                return \"@\\\"\" + (String) p.getDefault() + \"\\\"\";\n            }\n        } else if (ModelUtils.isBooleanSchema(p)) {\n            if (p.getDefault() != null) {\n                if (p.getDefault().toString().equalsIgnoreCase(\"false\"))\n                    return \"@(NO)\";\n                else\n                    return \"@(YES)\";\n            }\n        }\n\n        return null;\n    }\n"
  },
  {
    "id": "graphql_java_graphql_java-450-FirstSentence-0",
    "old_comment_raw": "Visits the Document in pre-order and allows to transform it using  graphql.language.AstTransformerUtil methods.",
    "new_comment_raw": "Visits the Document in pre-order and allows to transform it using  graphql.util.TreeTransformerUtil methods.",
    "old_code_raw": "    public Node transform(QueryVisitor queryVisitor) {\n        NodeVisitorImpl nodeVisitor = new NodeVisitorImpl(queryVisitor, new QueryVisitorStub());\n        Map<Class<?>, Object> rootVars = new LinkedHashMap<>();\n        rootVars.put(QueryTraversalContext.class, new QueryTraversalContext(rootParentType, rootParentType, null, null));\n\n        Node root = roots.stream().findFirst()\n                .orElseThrow(() -> new IllegalArgumentException(\"Single root node is required for transformation.\"));\n        return new AstTransformer().transform(root, nodeVisitor, rootVars);\n    }\n",
    "new_code_raw": "    public Node transform(QueryVisitor queryVisitor) {\n        NodeVisitorImpl nodeVisitor = new NodeVisitorImpl(queryVisitor, new QueryVisitorStub());\n        Map<Class<?>, Object> rootVars = new LinkedHashMap<>();\n        rootVars.put(QueryTraversalContext.class, new QueryTraversalContext(rootParentType, rootParentType, null, null));\n\n        Node root = roots.stream().findFirst()\n                .orElseThrow(() -> new IllegalArgumentException(\"Single root node is required for transformation.\"));\n        TraverserVisitor<Node> nodeTraverserVisitor = new TraverserVisitor<Node>() {\n\n            @Override\n            public TraversalControl enter(TraverserContext<Node> context) {\n                context.setVar(LeaveOrEnter.class, LeaveOrEnter.ENTER);\n                return context.thisNode().accept(context, nodeVisitor);\n            }\n\n            @Override\n            public TraversalControl leave(TraverserContext<Node> context) {\n                context.setVar(LeaveOrEnter.class, LeaveOrEnter.LEAVE);\n                return  context.thisNode().accept(context, nodeVisitor);\n            }\n        };\n        return new TreeTransformer<>(AST_NODE_ADAPTER).transform(root, nodeTraverserVisitor, rootVars);\n    }\n"
  },
  {
    "id": "apache_lenya-331-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Read the next character",
    "old_code_raw": "    public final char readChar() throws java.io.IOException {\n        if (inBuf > 0) {\n            --inBuf;\n\n            if (++bufpos == bufsize) {\n                bufpos = 0;\n            }\n\n            return buffer[bufpos];\n        }\n\n        if (++bufpos >= maxNextCharInd) {\n            FillBuff();\n        }\n\n        char c = buffer[bufpos];\n\n        UpdateLineColumn(c);\n\n        return (c);\n    }\n",
    "new_code_raw": "    public final char readChar() throws IOException {\n        if (this.inBuf > 0) {\n            --this.inBuf;\n\n            if (++this.bufpos == this.bufsize) {\n                this.bufpos = 0;\n            }\n\n            return this.buffer[this.bufpos];\n        }\n\n        if (++this.bufpos >= this.maxNextCharInd) {\n            fillBuff();\n        }\n\n        char c = this.buffer[this.bufpos];\n\n        updateLineColumn(c);\n\n        return (c);\n    }\n\n"
  },
  {
    "id": "yahoo_fili-1-Associations-FirstSentence",
    "old_comment_raw": "Exports current thread's request log object as a JSON string without resetting it.",
    "new_comment_raw": "Exports current thread's request log object as a formatted string without resetting it.",
    "old_code_raw": "    public static String export() {\n        RequestLog current = RLOG.get();\n        record(new Durations(current.aggregateDurations()));\n        record(new Threads(current.threadIds));\n        try {\n            return current.mapper.writeValueAsString(current.info);\n        } catch (JsonProcessingException jpe) {\n            String msg = String.format(\"Exporting mega log line with id: '%s' to JSON failed.\", current.logId);\n            LOG.warn(msg, jpe);\n            return msg;\n        }\n    }\n",
    "new_code_raw": "    public static String export() {\n        RequestLog current = RLOG.get();\n        record(new Durations(current.aggregateDurations()));\n        record(new Threads(current.threadIds));\n        return LogFormatterProvider.getInstance().format(current.info);\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2599-FirstSentence-0",
    "old_comment_raw": "If a Parameter contains a reference to an other Parameter with '$ref', returns the referenced Parameter or the actual Parameter in the other cases.",
    "new_comment_raw": "If a Parameter contains a reference to an other Parameter with '$ref', returns the referenced Parameter if it is found or the actual Parameter in the other cases.",
    "old_code_raw": "    public static Parameter getReferencedParameter(OpenAPI openAPI, Parameter parameter) {\n        if (parameter != null && StringUtils.isNotEmpty(parameter.get$ref())) {\n            String name = getSimpleRef(parameter.get$ref());\n            return getParameter(openAPI, name);\n        }\n        return parameter;\n    }\n",
    "new_code_raw": "    public static Parameter getReferencedParameter(OpenAPI openAPI, Parameter parameter) {\n        if (parameter != null && StringUtils.isNotEmpty(parameter.get$ref())) {\n            String name = getSimpleRef(parameter.get$ref());\n            Parameter referencedParameter = getParameter(openAPI, name);\n            if(referencedParameter != null) {\n                return referencedParameter;\n            }\n        }\n        return parameter;\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-331-FirstSentence-0",
    "old_comment_raw": "DB2 allows NULLS LAST only if the order is ASC, and NULLS FIRST only if the order is DESC.",
    "new_comment_raw": "Handle DB2 \"support\" for null precedence...",
    "old_code_raw": "\tpublic String renderOrderByElement(String expression, String collation, String order, NullPrecedence nullPrecedence) {\n\t\t// DB2 FTW!\n\t\tif ( nullPrecedence == null || nullPrecedence == NullPrecedence.NONE ) {\n\t\t\treturn super.renderOrderByElement( expression, collation, order, NullPrecedence.NONE );\n\t\t}\n\n\t\tif ( nullPrecedence == NullPrecedence.FIRST ) {\n\t\t\t// an explicit NullPrecedence request for NULLS FIRST\n\t\t\tif ( order == null || \"asc\".equals( order ) ) {\n\t\t\t\t// ASC + NULLS FIRST is ok, but unnecessary\n\t\t\t\treturn super.renderOrderByElement( expression, collation, order, NullPrecedence.NONE );\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// DESC + NULLS FIRST is not supported, so hack it\n\t\t\t\treturn \"order by case when \" + expression + \" is null then 0 else 1 end, \" + expression + \" desc\";\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// an explicit NullPrecedence request for NULLS LAST\n\t\t\tif ( order == null || \"asc\".equals( order ) ) {\n\t\t\t\t// ASC + NULLS LAST is not supported, so hack it\n\t\t\t\treturn \"order by case when \" + expression + \" is null then 1 else 0 end, \" + expression + \" asc\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// DESC + NULLS LAST is ok, but unnecessary\n\t\t\t\treturn super.renderOrderByElement( expression, collation, order, NullPrecedence.NONE );\n\t\t\t}\n\t\t}\n\t}\n",
    "new_code_raw": "\tpublic String renderOrderByElement(String expression, String collation, String order, NullPrecedence nullPrecedence) {\n\t\tif ( nullPrecedence == null || nullPrecedence == NullPrecedence.NONE ) {\n\t\t\treturn super.renderOrderByElement( expression, collation, order, NullPrecedence.NONE );\n\t\t}\n\n\t\t// DB2 FTW!  A null precedence was explicitly requested, but DB2 \"support\" for null precedence\n\t\t// is a joke.  Basically it supports combos that align with what it does anyway.  Here is the\n\t\t// support matrix:\n\t\t//\t\t* ASC + NULLS FIRST -> case statement\n\t\t//\t\t* ASC + NULLS LAST -> just drop the NULLS LAST from sql fragment\n\t\t//\t\t* DESC + NULLS FIRST -> just drop the NULLS FIRST from sql fragment\n\t\t//\t\t* DESC + NULLS LAST -> case statement\n\n\t\tif ( ( nullPrecedence == NullPrecedence.FIRST  && \"desc\".equalsIgnoreCase( order ) )\n\t\t\t\t|| ( nullPrecedence == NullPrecedence.LAST && \"asc\".equalsIgnoreCase( order ) ) ) {\n\t\t\t// we have one of:\n\t\t\t//\t\t* ASC + NULLS LAST\n\t\t\t//\t\t* DESC + NULLS FIRST\n\t\t\t// so just drop the null precedence.  *NOTE: we could pass along the null precedence here,\n\t\t\t// but only DB2 9.7 or greater understand it; dropping it is more portable across DB2 versions\n\t\t\treturn super.renderOrderByElement( expression, collation, order, NullPrecedence.NONE );\n\t\t}\n\n\t\treturn String.format(\n\t\t\t\tLocale.ENGLISH,\n\t\t\t\t\"case when %s is null then %s else %s end, %s %s\",\n\t\t\t\texpression,\n\t\t\t\tnullPrecedence == NullPrecedence.FIRST ? \"0\" : \"1\",\n\t\t\t\tnullPrecedence == NullPrecedence.FIRST ? \"1\" : \"0\",\n\t\t\t\texpression,\n\t\t\t\torder\n\t\t);\n\t}\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2359-FirstSentence-0",
    "old_comment_raw": "Given a  Tree node  t, attempts to return a list of nodes to which node  t has this grammatical relation, with  t as the governor.",
    "new_comment_raw": "Given a Tree node t, attempts to return a list of nodes to which node t has this grammatical relation.",
    "old_code_raw": "  public Collection<TreeGraphNode> getRelatedNodes(TreeGraphNode t, TreeGraphNode root, HeadFinder headFinder) {\n    Set<TreeGraphNode> nodeList = new ArraySet<TreeGraphNode>();\n    for (TregexPattern p : targetPatterns) {    // cdm: I deleted: && nodeList.isEmpty()\n      // Initialize the TregexMatcher with the HeadFinder so that we\n      // can use the same HeadFinder through the entire process of\n      // building the dependencies\n      TregexMatcher m = p.matcher(root, headFinder);\n      while (m.findAt(t)) {\n        TreeGraphNode target = (TreeGraphNode) m.getNode(\"target\");\n        if (target == null) {\n          throw new AssertionError(\"Expression has no target: \" + p);\n        }\n        nodeList.add(target);\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \"-\" + t.headWordNode() + \", \" + m.getNode(\"target\") + \"-\" + ((TreeGraphNode) m.getNode(\"target\")).headWordNode() + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\"))\n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n",
    "new_code_raw": "  public Collection<Tree> getRelatedNodes(Tree t, Tree root) {\n    if (root.value() == null) {\n      root.setValue(\"ROOT\");  // todo: cdm: it doesn't seem like this line should be here\n    }\n    Set<Tree> nodeList = new LinkedHashSet<Tree>();\n    for (TregexPattern p : targetPatterns) {    // cdm: I deleted: && nodeList.isEmpty()\n      TregexMatcher m = p.matcher(root);\n      while (m.findAt(t)) {\n        nodeList.add(m.getNode(\"target\"));\n        //System.out.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p);\n      }\n    }\n    return nodeList;\n  }\n"
  },
  {
    "id": "trygvis_jop-160-Associations-FirstSentence",
    "old_comment_raw": "Parse a signature, with or without classname, with or without descriptor.",
    "new_comment_raw": "Parse a member ID, with or without classname, with or without descriptor.",
    "old_code_raw": "    public static String getClassName(String signature, boolean isClassMember) {\n        int pos = signature.indexOf(ALT_MEMBER_SEPARATOR);\n        // uses alternative separator, easy\n        if (pos != -1) return signature.substring(0, pos);\n\n        pos = signature.indexOf('(');\n        if ( pos != -1 ) {\n            // has a descriptor, is a method signature, strip last member part\n            pos = signature.lastIndexOf('.', pos);\n            return pos != -1 ? signature.substring(0, pos) : \"\";\n        }\n\n        if (isClassMember) {\n            // field or class name, cannot decide, assume it is a field\n            pos = signature.lastIndexOf('.');\n            return pos != -1 ? signature.substring(0, pos) : \"\";\n        } else {\n            // assume it is a class name\n            return signature;\n        }\n    }\n",
    "new_code_raw": "    public static String getClassName(String memberID, boolean isClassMember) {\n        int pos = memberID.indexOf(ALT_MEMBER_SEPARATOR);\n        // uses alternative separator, easy\n        if (pos != -1) return memberID.substring(0, pos);\n\n        pos = memberID.indexOf('(');\n        if ( pos != -1 ) {\n            // has a descriptor, is a method ID, strip last member part\n            pos = memberID.lastIndexOf('.', pos);\n            return pos != -1 ? memberID.substring(0, pos) : \"\";\n        }\n\n        if (isClassMember) {\n            // field or class name, cannot decide, assume it is a field\n            pos = memberID.lastIndexOf('.');\n            return pos != -1 ? memberID.substring(0, pos) : \"\";\n        } else {\n            // assume it is a class name\n            return memberID;\n        }\n    }\n\n"
  },
  {
    "id": "facebook_facebook-android-sdk-20-Associations-FirstSentence",
    "old_comment_raw": "Returns information about any errors that may have occurred during the request.",
    "new_comment_raw": "Returns the error returned for this request, if any.",
    "old_code_raw": "    public final FacebookRequestError getError() {\n        return error;\n    }\n",
    "new_code_raw": "    public final FacebookException getError() {\n        return error;\n    }\n\n"
  },
  {
    "id": "rstudio_rstudio-130-FirstSentence-0",
    "old_comment_raw": "Index of terminal to show after closing indicated terminal index",
    "new_comment_raw": "Handle of terminal to show after closing indicated terminal.",
    "old_code_raw": "   private int terminalToShowWhenClosing(int terminalClosing)\n   {\n      if (terminalClosing > 0)\n         return terminalClosing - 1;\n      else if (terminalClosing + 1 < getTerminalCount())\n         return terminalClosing + 1;\n      else\n         return -1;\n   }\n",
    "new_code_raw": "   private String terminalToShowWhenClosing(String handle)\n   {\n      int terminalClosing = terminals_.indexOfTerminal(handle);\n      if (terminalClosing > 0)\n         return terminals_.terminalHandleAtIndex(terminalClosing - 1);\n      else if (terminalClosing + 1 < terminals_.terminalCount())\n         return terminals_.terminalHandleAtIndex(terminalClosing + 1);\n      else\n         return null;\n   }\n"
  },
  {
    "id": "ushahidi_Ushahidi_Java-10-Associations-FirstSentence",
    "old_comment_raw": "Create report task object",
    "new_comment_raw": "Create incidents task object",
    "old_code_raw": "\tpublic ReportsTask createReportsTask() {\n\t\treturn new ReportsTask(url);\n\t}\n",
    "new_code_raw": "\tpublic IncidentsTask createReportsTask() {\n\t\treturn new IncidentsTask(url);\n\t}\n\n"
  },
  {
    "id": "nickman_HeliosStreams-32-Associations-FirstSentence",
    "old_comment_raw": "Resets the count to zero",
    "new_comment_raw": "Resets the count to zero and sets the time window according to the passed ms timestamp",
    "old_code_raw": "\tpublic long reset() {\n\t\tfinal long priorCount = count;\n\t\tcount = 0;\n\t\treturn priorCount;\n\t}\n",
    "new_code_raw": "\tpublic NVP<Long, Double> reset(final long newStartMs, final long newCount) {\n\t\tfinal long[] priorWindow = TIME_WINDOW_UPDATER.getAndSet(this, windowRangeFromMs(newStartMs, windowWidth));\n\t\tfinal long priorCount = count;\n\t\tcount = newCount;\n\t\treturn new NVP<Long, Double>(priorWindow[1], calcRate(priorCount, windowWidth));\n\t}\n\n"
  },
  {
    "id": "wdullaer_MaterialDateTimePicker-40-FirstSentence-0",
    "old_comment_raw": "Get the currently-entered time, as integer values of the hours and minutes typed.",
    "new_comment_raw": "Get the currently-entered time, as integer values of the hours, minutes and seconds typed.",
    "old_code_raw": "    private int[] getEnteredTime(Boolean[] enteredZeros) {\n        int amOrPm = -1;\n        int startIndex = 1;\n        if (!mIs24HourMode && isTypedTimeFullyLegal()) {\n            int keyCode = mTypedTimes.get(mTypedTimes.size() - 1);\n            if (keyCode == getAmOrPmKeyCode(AM)) {\n                amOrPm = AM;\n            } else if (keyCode == getAmOrPmKeyCode(PM)){\n                amOrPm = PM;\n            }\n            startIndex = 2;\n        }\n        int minute = -1;\n        int hour = -1;\n        for (int i = startIndex; i <= mTypedTimes.size(); i++) {\n            int val = getValFromKeyCode(mTypedTimes.get(mTypedTimes.size() - i));\n            if (i == startIndex) {\n                minute = val;\n            } else if (i == startIndex+1) {\n                minute += 10*val;\n                if (enteredZeros != null && val == 0) {\n                    enteredZeros[1] = true;\n                }\n            } else if (i == startIndex+2) {\n                hour = val;\n            } else if (i == startIndex+3) {\n                hour += 10*val;\n                if (enteredZeros != null && val == 0) {\n                    enteredZeros[0] = true;\n                }\n            }\n        }\n\n        return new int[] {hour, minute, amOrPm};\n    }\n",
    "new_code_raw": "    private int[] getEnteredTime(Boolean[] enteredZeros) {\n        int amOrPm = -1;\n        int startIndex = 1;\n        if (!mIs24HourMode && isTypedTimeFullyLegal()) {\n            int keyCode = mTypedTimes.get(mTypedTimes.size() - 1);\n            if (keyCode == getAmOrPmKeyCode(AM)) {\n                amOrPm = AM;\n            } else if (keyCode == getAmOrPmKeyCode(PM)){\n                amOrPm = PM;\n            }\n            startIndex = 2;\n        }\n        int minute = -1;\n        int hour = -1;\n        int second = 0;\n        int shift = mEnableSeconds ? 2 : 0;\n        for (int i = startIndex; i <= mTypedTimes.size(); i++) {\n            int val = getValFromKeyCode(mTypedTimes.get(mTypedTimes.size() - i));\n            if (mEnableSeconds) {\n                if (i == startIndex) {\n                    second = val;\n                } else if (i == startIndex + 1) {\n                    second += 10*val;\n                    if (enteredZeros != null && val == 0) {\n                        enteredZeros[2] = true;\n                    }\n                }\n            }\n            if (i == startIndex + shift) {\n                minute = val;\n            } else if (i == startIndex + shift + 1) {\n                minute += 10*val;\n                if (enteredZeros != null && val == 0) {\n                    enteredZeros[1] = true;\n                }\n            } else if (i == startIndex + shift + 2) {\n                hour = val;\n            } else if (i == startIndex + shift + 3) {\n                hour += 10*val;\n                if (enteredZeros != null && val == 0) {\n                    enteredZeros[0] = true;\n                }\n            }\n        }\n\n        return new int[] {hour, minute, second, amOrPm};\n    }\n"
  },
  {
    "id": "codehaus_cake-10-Associations-FirstSentence",
    "old_comment_raw": "Analogous to  #get(WithAttributes) except returning a primitive int.",
    "new_comment_raw": "Extracts the attribute map from the specified  WithAttributes and returns the value of this attribute from the map.",
    "old_code_raw": "    public int get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n",
    "new_code_raw": "    public int get(WithAttributes withAttributes) {\r\n        return withAttributes.getAttributes().get(this);\r\n    }\r\n\n"
  },
  {
    "id": "idega_is.idega.idegaweb.marathon-0-Associations-FirstSentence",
    "old_comment_raw": "Gets a Map of distances for a specific run and year.",
    "new_comment_raw": "Gets a Collection of distances for a specific run and year.",
    "old_code_raw": "\tpublic Map getDistancesMap(Group run, String year) {\n\t\tIWContext iwc = IWContext.getInstance();\n\t\tMap disMap = new LinkedHashMap();\n\t\tCollection distances = null;\n\t\tCollection type = new ArrayList();\n\t\ttype.add(IWMarathonConstants.GROUP_TYPE_RUN_DISTANCE);\n\t\tIterator yearsIter = getYears(run).iterator();\n\t\twhile (yearsIter.hasNext()) {\n\t\t\tGroup y = (Group) yearsIter.next();\n\t\t\tif (y.getName().equals(year)) {\n\t\t\t\ttry {\n\t\t\t\t\tdistances = getGroupBiz(iwc).getChildGroupsRecursiveResultFiltered(y, type, true);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tdistances = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdistances = null;\n\t\t\t}\n\t\t}\n\t\tif (distances != null) {\n\t\t\tIterator disIter = distances.iterator();\n\t\t\twhile (disIter.hasNext()) {\n\t\t\t\tGroup dis = (Group) disIter.next();\n\t\t\t\tdisMap.put(dis.getPrimaryKey().toString(), dis.getName());\n\t\t\t}\n\t\t}\n\t\treturn disMap;\n\t}\n",
    "new_code_raw": "\tpublic Collection getDistancesMap(Group run, String year) {\n\t\tIWContext iwc = IWContext.getInstance();\n\t\tMap disMap = new LinkedHashMap();\n\t\tCollection distances = null;\n\t\tCollection type = new ArrayList();\n\t\ttype.add(IWMarathonConstants.GROUP_TYPE_RUN_DISTANCE);\n\t\tIterator yearsIter = getYears(run).iterator();\n\t\twhile (yearsIter.hasNext()) {\n\t\t\tGroup y = (Group) yearsIter.next();\n\t\t\tif (y.getName().equals(year)) {\n\t\t\t\ttry {\n\t\t\t\t\tdistances = getGroupBiz(iwc).getChildGroupsRecursiveResultFiltered(y, type, true);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tdistances = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn distances;\n\t}\n\n"
  },
  {
    "id": "apache_lenya-321-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Get the next token",
    "old_code_raw": "    final public Token getNextToken() {\n        if (token.next != null) {\n            token = token.next;\n        } else {\n            token = token.next = token_source.getNextToken();\n        }\n\n        jj_ntk = -1;\n        jj_gen++;\n\n        return token;\n    }\n",
    "new_code_raw": "    final public Token getNextToken() {\n        if (this.token.next != null) {\n            this.token = this.token.next;\n        } else {\n            this.token = this.token.next = this.token_source.getNextToken();\n        }\n\n        this.jj_ntk = -1;\n        this.jj_gen++;\n\n        return this.token;\n    }\n\n"
  },
  {
    "id": "orfjackal_ikayaki-46-Associations-FirstSentence",
    "old_comment_raw": "checks if connection is ok.",
    "new_comment_raw": "Checks if the serial communication channel is open.",
    "old_code_raw": "    public boolean isOK() {\n        if (serialIO != null) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n",
    "new_code_raw": "    public boolean isOK() {\n        return (serialIO != null);\n    }\n\n"
  },
  {
    "id": "eclipse_rt.equinox.bundles-53-Associations-FirstSentence",
    "old_comment_raw": "Remove directional formatting characters in the given string that were inserted by one of the  #process process methods.",
    "new_comment_raw": "Removes directional formatting characters in the given string.",
    "old_code_raw": "\tpublic static String deprocess(String str) {\n\t\tif ((str == null) || (str.length() <= 1) || !isProcessingNeeded())\n\t\t\treturn str;\n\n\t\tStringBuffer buf = new StringBuffer();\n\t\tint strLen = str.length();\n\t\tfor (int i = 0; i < strLen; i++) {\n\t\t\tchar c = str.charAt(i);\n\t\t\tswitch (c) {\n\t\t\t\tcase LRM :\n\t\t\t\t\tcontinue;\n\t\t\t\tcase LRE :\n\t\t\t\t\tcontinue;\n\t\t\t\tcase PDF :\n\t\t\t\t\tcontinue;\n\t\t\t\tdefault :\n\t\t\t\t\tbuf.append(c);\n\t\t\t}\n\t\t}\n\t\treturn buf.toString();\n\t}\n",
    "new_code_raw": "\tpublic static String deprocess(String str) {\n\t\tif ((str == null) || (str.length() <= 1))\n\t\t\treturn str;\n\t\tSTextEnvironment env = new STextEnvironment(null, false, STextEnvironment.ORIENT_UNKNOWN);\n\t\tif (!env.isProcessingNeeded())\n\t\t\treturn str;\n\n\t\tStringBuffer buf = new StringBuffer();\n\t\tint strLen = str.length();\n\t\tfor (int i = 0; i < strLen; i++) {\n\t\t\tchar c = str.charAt(i);\n\t\t\tswitch (c) {\n\t\t\t\tcase LRM :\n\t\t\t\t\tcontinue;\n\t\t\t\tcase LRE :\n\t\t\t\t\tcontinue;\n\t\t\t\tcase PDF :\n\t\t\t\t\tcontinue;\n\t\t\t\tdefault :\n\t\t\t\t\tbuf.append(c);\n\t\t\t}\n\t\t}\n\t\treturn buf.toString();\n\t}\n\n"
  },
  {
    "id": "macalinao_albkit-16-Associations-FirstSentence",
    "old_comment_raw": "Checks whether this ChatSection's argument can be parsed as a boolean",
    "new_comment_raw": "Checks whether this ChatSection's value can be parsed as a boolean",
    "old_code_raw": "    public boolean isBoolean() {\n        return arg.equals(\"true\") || arg.equals(\"false\");\n    }\n",
    "new_code_raw": "    public boolean isBoolean() {\n        return raw.equals(\"true\") || raw.equals(\"false\");\n    }\n\n"
  },
  {
    "id": "macalinao_albkit-15-Associations-FirstSentence",
    "old_comment_raw": "Gets the material whose name is the same as the raw arg (ignores case)",
    "new_comment_raw": "Gets the material whose name is the same as the raw value (ignores case)",
    "old_code_raw": "    public Material asMaterialFromName() {\n        return Material.getMaterial(arg.toUpperCase());\n    }\n",
    "new_code_raw": "    public Material asMaterialFromName() {\n        return Material.getMaterial(raw.toUpperCase());\n    }\n\n"
  },
  {
    "id": "apache_lenya-394-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Get the list of src attributes for all images",
    "old_code_raw": "    public ArrayList getAllImageSrcs() {\n        return img_src_all;\n    }\n",
    "new_code_raw": "    public ArrayList getAllImageSrcs() {\n        return this.img_src_all;\n    }\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2428-FirstSentence-0",
    "old_comment_raw": "Select the most common element of the given type in the given span.",
    "new_comment_raw": "Find the dependency path between two words in a sentence.",
    "old_code_raw": "  public List<String> dependencyPathBetween(int start, int end, Function<Sentence, List<String>> selector) {\n    // Get paths from a node to the root of the sentence\n    LinkedList<Integer> rootToStart = new LinkedList<>();\n    LinkedList<Integer> rootToEnd = new LinkedList<>();\n    int startAncestor = start;\n    List<Optional<Integer>> governors = sentence.governors();\n    Set<Integer> seenVertices = new HashSet<>();\n    while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) {\n      if (seenVertices.contains(startAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(startAncestor);\n      rootToStart.addFirst(startAncestor);\n      startAncestor = governors.get(startAncestor).get();\n    }\n    if (startAncestor == -1) {\n      rootToStart.addFirst(-1);\n    }\n    int endAncestor = end;\n    seenVertices.clear();\n    while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) {\n      if (seenVertices.contains(endAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(endAncestor);\n      rootToEnd.addFirst(endAncestor);\n      endAncestor = governors.get(endAncestor).get();\n    }\n    if (endAncestor == -1) {\n      rootToEnd.addFirst(-1);\n    }\n\n    // Get least common node\n    int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0;\n    for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) {\n      if (rootToStart.get(i).equals(rootToEnd.get(i))) {\n        leastCommonNodeIndex = i;\n      }\n    }\n\n    // Construct the path\n    if (leastCommonNodeIndex < 0) {\n      return Collections.EMPTY_LIST;\n    }\n    List<String> path = new ArrayList<>();\n    for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) {\n      path.add(selector.apply(sentence).get(rootToStart.get(i)));\n      path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\");\n    }\n    path.add(selector.apply(sentence).get(rootToStart.get(leastCommonNodeIndex)));\n    for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) {\n      path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\");\n      path.add(selector.apply(sentence).get(rootToEnd.get(i)));\n    }\n    return path;\n  }\n",
    "new_code_raw": "  public List<String> dependencyPathBetween(int start, int end, Optional<Function<Sentence, List<String>>> selector) {\n    // Get paths from a node to the root of the sentence\n    LinkedList<Integer> rootToStart = new LinkedList<>();\n    LinkedList<Integer> rootToEnd = new LinkedList<>();\n    int startAncestor = start;\n    List<Optional<Integer>> governors = sentence.governors();\n    Set<Integer> seenVertices = new HashSet<>();\n    while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) {\n      if (seenVertices.contains(startAncestor)) {\n        // Found loopiness -- revert to BFS\n        return loopyDependencyPathBetween(start, end, selector);\n      }\n      seenVertices.add(startAncestor);\n      rootToStart.addFirst(startAncestor);\n      startAncestor = governors.get(startAncestor).get();\n    }\n    if (startAncestor == -1) {\n      rootToStart.addFirst(-1);\n    }\n    int endAncestor = end;\n    seenVertices.clear();\n    while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) {\n      if (seenVertices.contains(endAncestor)) {\n        // Found loopiness -- revert to BFS\n        return loopyDependencyPathBetween(start, end, selector);\n      }\n      seenVertices.add(endAncestor);\n      rootToEnd.addFirst(endAncestor);\n      endAncestor = governors.get(endAncestor).get();\n    }\n    if (endAncestor == -1) {\n      rootToEnd.addFirst(-1);\n    }\n\n    // Get least common node\n    int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0;\n    for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) {\n      if (rootToStart.get(i).equals(rootToEnd.get(i))) {\n        leastCommonNodeIndex = i;\n      }\n    }\n\n    // Construct the path\n    if (leastCommonNodeIndex < 0) {\n      return Collections.emptyList();\n    }\n    List<String> path = new ArrayList<>();\n    Optional<List<String>> words = selector.map(x -> x.apply(sentence));\n    for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) {\n      final int index = i;\n      words.ifPresent(x -> path.add(x.get(rootToStart.get(index))));\n      path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\");\n    }\n    if (words.isPresent()) {\n      path.add(words.get().get(rootToStart.get(leastCommonNodeIndex)));\n    }\n    for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) {\n      final int index = i;\n      path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\");\n      words.ifPresent(x -> path.add(x.get(rootToEnd.get(index))));\n    }\n    return path;\n  }\n"
  },
  {
    "id": "udayinfy_owasp-esapi-java-45-Associations-FirstSentence",
    "old_comment_raw": "Union two character arrays.",
    "new_comment_raw": "Union multiple character arrays.",
    "old_code_raw": "    public static char[] union(char[] c1, char[] c2) {\r\n    \tStringBuilder sb = new StringBuilder();\r\n        for (int i = 0; i < c1.length; i++) {\r\n            if (!contains(sb, c1[i]))\r\n                sb.append(c1[i]);\r\n        }\r\n        for (int i = 0; i < c2.length; i++) {\r\n            if (!contains(sb, c2[i]))\r\n                sb.append(c2[i]);\r\n        }\r\n        char[] c3 = new char[sb.length()];\r\n        sb.getChars(0, sb.length(), c3, 0);\r\n        Arrays.sort(c3);\r\n        return c3;\r\n    }\r\n",
    "new_code_raw": "    public static char[] union(char[]... list) {\r\n    \tStringBuilder sb = new StringBuilder();\r\n    \t\r\n    \tfor (char[] characters : list) {\r\n\t        for (int i = 0; i < list.length; i++) {\r\n\t            if (!contains(sb, characters[i]))\r\n\t                sb.append(list[i]);\r\n\t        }\r\n    \t}\r\n\r\n        char[] toReturn = new char[sb.length()];\r\n        sb.getChars(0, sb.length(), toReturn, 0);\r\n        Arrays.sort(toReturn);\r\n        return toReturn;\r\n    }\r\n\n"
  },
  {
    "id": "apache_derby-12-Associations-FirstSentence",
    "old_comment_raw": "Get the name of the table this column comes from.",
    "new_comment_raw": "Get the name of the underlying(base) table this column comes from, if any.",
    "old_code_raw": "\n\tpublic String getSourceTableName()\n\t{\n\t\treturn ( ( tableName != null) ? tableName.getTableName() : \n\t\t\t\t\t((source != null) ? source.getTableName() : null));\n\t}\n",
    "new_code_raw": "\n\tpublic String getSourceTableName()\n\t{\n\t\treturn ((source != null) ? source.getTableName() : null);\n\t}\n\n"
  },
  {
    "id": "apache_drill-1517-FirstSentence-0",
    "old_comment_raw": "First attempts to finds the Drill function implementation that matches the name, arg types and return type.",
    "new_comment_raw": "First attempts to find the Drill function implementation that matches the name, arg types and return type.",
    "old_code_raw": "  public DrillFuncHolder findDrillFunction(FunctionResolver functionResolver, FunctionCall functionCall) {\n    AtomicLong version = new AtomicLong();\n    String newFunctionName = functionReplacement(functionCall);\n    List<DrillFuncHolder> functions = localFunctionRegistry.getMethods(newFunctionName, version);\n    FunctionResolver exactResolver = FunctionResolverFactory.getExactResolver(functionCall);\n    DrillFuncHolder holder = exactResolver.getBestMatch(functions, functionCall);\n\n    if (holder == null) {\n      syncWithRemoteRegistry(version.get());\n      List<DrillFuncHolder> updatedFunctions = localFunctionRegistry.getMethods(newFunctionName, version);\n      holder = functionResolver.getBestMatch(updatedFunctions, functionCall);\n    }\n\n    return holder;\n  }\n",
    "new_code_raw": "  public DrillFuncHolder findDrillFunction(FunctionResolver functionResolver, FunctionCall functionCall) {\n    AtomicLong version = new AtomicLong();\n    String newFunctionName = functionReplacement(functionCall);\n\n    // Dynamic UDFS: First try with exact match. If not found, we may need to\n    // update the registry, so sync with remote.\n\n    if (useDynamicUdfs) {\n      List<DrillFuncHolder> functions = localFunctionRegistry.getMethods(newFunctionName, version);\n      FunctionResolver exactResolver = FunctionResolverFactory.getExactResolver(functionCall);\n      DrillFuncHolder holder = exactResolver.getBestMatch(functions, functionCall);\n      if (holder != null) {\n        return holder;\n      }\n      syncWithRemoteRegistry(version.get());\n    }\n\n    // Whether Dynamic UDFs or not: look in the registry for\n    // an inexact match.\n\n    List<DrillFuncHolder> functions = localFunctionRegistry.getMethods(newFunctionName, version);\n    return functionResolver.getBestMatch(functions, functionCall);\n  }\n"
  },
  {
    "id": "apache_giraph-77-Associations-FirstSentence",
    "old_comment_raw": "Creates a new  com.yammer.metrics.core.Timer and registers it under the given group and name, measuring elapsed time in milliseconds and invocations per second.",
    "new_comment_raw": "Create a new  Timer from the description and registers it under the given group and name.",
    "old_code_raw": "  public Timer getTimer(String name) {\n    return getTimer(name, TimeUnit.MILLISECONDS, TimeUnit.SECONDS);\n  }\n",
    "new_code_raw": "  public Timer getTimer(TimerDesc timerDesc) {\n    return getTimer(timerDesc.getName(), timerDesc.getDurationUnit(),\n        timerDesc.getTimeUnit());\n  }\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-1973-FirstSentence-0",
    "old_comment_raw": "Get a batch of unloaded identifiers for this class, using a slightly complex algorithm that tries to grab keys registered immediately after the given key.",
    "new_comment_raw": "Get a batch of uninitialized collection keys for a given role",
    "old_code_raw": "\tprivate boolean isCached(EntityKey entityKey, EntityPersister persister) {\n\t\tif ( persister.hasCache() ) {\n\t\t\tCacheKey key = context.getSession().generateCacheKey(\n\t\t\t\t\tentityKey.getIdentifier(),\n\t\t\t\t\tpersister.getIdentifierType(),\n\t\t\t\t\tentityKey.getEntityName()\n\t\t\t);\n\t\t\treturn persister.getCacheAccessStrategy().get( key, context.getSession().getTimestamp() ) != null;\n\t\t}\n\t\treturn false;\n\t}\n",
    "new_code_raw": "\tprivate boolean isCached(Serializable collectionKey, CollectionPersister persister) {\n\t\tif ( persister.hasCache() ) {\n\t\t\tCacheKey cacheKey = context.getSession().generateCacheKey(\n\t\t\t\t\tcollectionKey,\n\t\t\t        persister.getKeyType(),\n\t\t\t        persister.getRole()\n\t\t\t);\n\t\t\treturn persister.getCacheAccessStrategy().get( cacheKey, context.getSession().getTimestamp() ) != null;\n\t\t}\n\t\treturn false;\n\t}\n"
  },
  {
    "id": "davidB_metrics-influxdb-1-Associations-FirstSentence",
    "old_comment_raw": "Builds a  InfluxdbReporter with the given properties, sending metrics using the given  Influxdb client.",
    "new_comment_raw": "Builds a  ScheduledReporter with the given properties, sending metrics using the given InfluxDB.",
    "old_code_raw": "\t\tpublic ScheduledReporter build(Influxdb influxdb) {\n\t\t\treturn executor == null\n\t\t\t\t\t? new ReporterV08(registry, influxdb, clock, prefix, rateUnit, durationUnit, filter, skipIdleMetrics)\n\t\t\t\t\t: new ReporterV08(registry, influxdb, clock, prefix, rateUnit, durationUnit, filter, skipIdleMetrics, executor)\n\t\t\t\t\t;\n\t\t}\n",
    "new_code_raw": "\t\tpublic ScheduledReporter build() {\n\t\t\tScheduledReporter reporter;\n\n\t\t\tswitch (influxdbVersion) {\n\t\t\tcase V08:\n\t\t\t\tInfluxdb influxdb = buildInfluxdb();\n\t\t\t\treporter = (executor == null)\n\t\t\t\t\t\t? new ReporterV08(registry, influxdb, clock, prefix, rateUnit, durationUnit, filter, skipIdleMetrics)\n\t\t\t\t\t\t: new ReporterV08(registry, influxdb, clock, prefix, rateUnit, durationUnit, filter, skipIdleMetrics, executor)\n\t\t\t\t\t\t;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tSender s = buildSender();\n\t\t\t\treporter = executor == null\n\t\t\t\t\t\t? new MeasurementReporter(s, registry, filter, rateUnit, durationUnit, clock, tags, transformer)\n\t\t\t\t\t\t: new MeasurementReporter(s, registry, filter, rateUnit, durationUnit, clock, tags, transformer, executor)\n\t\t\t\t\t\t;\n\t\t\t}\n\t\t\treturn reporter;\n\t\t}\n\n"
  },
  {
    "id": "apache_jsecurity-33-Associations-FirstSentence",
    "old_comment_raw": "Returns the time in seconds the specified session may remain idle before expiring.",
    "new_comment_raw": "Subclass template hook in case per-session timeout is not based on  org.jsecurity.session.Session#getTimeout().",
    "old_code_raw": "    protected int getTimeout( Session session ) {\n        return getGlobalSessionTimeout();\n    }\n",
    "new_code_raw": "    protected long getTimeout( Session session ) {\n        return session.getTimeout();\n    }\n\n"
  },
  {
    "id": "apache_lenya-286-Associations-FirstSentence",
    "old_comment_raw": "DOCUMENT ME!",
    "new_comment_raw": "Returns the substitution regular expression used in the export",
    "old_code_raw": "    public String getSubstituteExpression() {\n        return substituteExpression;\n    }\n",
    "new_code_raw": "    public String getSubstituteExpression() {\n        return this.substituteExpression;\n    }\n\n"
  },
  {
    "id": "codehaus_loom-10-Associations-FirstSentence",
    "old_comment_raw": "Create a  PartitionMetaData object based on specified name and assembly configuration.",
    "new_comment_raw": "Create a  PartitionTemplate object based on specified name and assembly configuration.",
    "old_code_raw": "    private PartitionMetaData assembleSar( final String name,\n                                           final Configuration config,\n                                           final Configuration assembly )\n        throws LoomException\n    {\n        final Configuration[] blockConfig = assembly.getChildren( \"block\" );\n        final ComponentMetaData[] blocks = buildBlocks( blockConfig, config );\n        final PartitionMetaData blockPartition =\n            new PartitionMetaData( ContainerConstants.BLOCK_PARTITION,\n                                   new String[]{ContainerConstants.LISTENER_PARTITION},\n                                   PartitionMetaData.EMPTY_SET,\n                                   blocks );\n\n        final Configuration[] listenerConfig = assembly.getChildren( \"listener\" );\n        final ComponentMetaData[] listeners = buildBlockListeners( listenerConfig, config );\n        final PartitionMetaData listenerPartition =\n            new PartitionMetaData( ContainerConstants.LISTENER_PARTITION,\n                                   new String[ 0 ],\n                                   PartitionMetaData.EMPTY_SET,\n                                   listeners );\n\n        final PartitionMetaData[] partitions =\n            new PartitionMetaData[]{blockPartition, listenerPartition};\n\n        return new PartitionMetaData( name,\n                                      new String[ 0 ],\n                                      partitions,\n                                      ComponentMetaData.EMPTY_SET );\n    }\n",
    "new_code_raw": "    private PartitionTemplate assembleSar( final String name,\n                                           final Configuration config,\n                                           final Configuration assembly )\n        throws LoomException\n    {\n        final Configuration[] blockConfig = assembly.getChildren( \"block\" );\n        final ComponentTemplate[] blocks = buildBlocks( blockConfig, config );\n        final PartitionTemplate blockPartition =\n            new PartitionTemplate( ContainerConstants.BLOCK_PARTITION,\n                                   new String[]{ContainerConstants.LISTENER_PARTITION},\n                                   PartitionTemplate.EMPTY_SET,\n                                   blocks );\n\n        final Configuration[] listenerConfig = assembly.getChildren( \"listener\" );\n        final ComponentTemplate[] listeners = buildBlockListeners( listenerConfig, config );\n        final PartitionTemplate listenerPartition =\n            new PartitionTemplate( ContainerConstants.LISTENER_PARTITION,\n                                   new String[ 0 ],\n                                   PartitionTemplate.EMPTY_SET,\n                                   listeners );\n\n        final PartitionTemplate[] partitions =\n            new PartitionTemplate[]{blockPartition, listenerPartition};\n\n        return new PartitionTemplate( name,\n                                      new String[ 0 ],\n                                      partitions,\n                                      ComponentTemplate.EMPTY_SET );\n    }\n\n"
  },
  {
    "id": "apache_axis1-java-145-Associations-FirstSentence",
    "old_comment_raw": "Return XML schema for the specified type, suitable for insertion into the  element of a WSDL document.",
    "new_comment_raw": "Return XML schema for the specified type, suitable for insertion into the &lt;types&gt; element of a WSDL document, or underneath an &lt;element&gt; or &lt;attribute&gt; declaration.",
    "old_code_raw": "    public boolean writeSchema(Types types) throws Exception {\n        return false;\n    }\n",
    "new_code_raw": "    public Element writeSchema(Class javaType, Types types) throws Exception {\n        // If an array the component type should be processed first\n        String componentTypeName = null;\n        Class componentType = null;\n        if (javaType.isArray()) {\n            String dimString = \"[]\";\n            componentType = javaType.getComponentType();\n            if (componentType.isArray()) {\n                while (componentType.isArray()) {\n                    dimString += \"[]\";\n                    componentType = componentType.getComponentType();\n                }\n            }\n            componentTypeName =\n                    types.getQNameString(types.getTypeQName(componentType)) +\n                    dimString;\n        }\n\n        // Use Types helper method to actually create the complexType\n        return types.createArrayElement(componentTypeName);\n    }\n\n"
  },
  {
    "id": "apache_roller-156-Associations-FirstSentence",
    "old_comment_raw": "Accessor to the Roller Weblogger business tier.",
    "new_comment_raw": "Accessor to the Weblogger Weblogger business tier.",
    "old_code_raw": "    public static final Roller getRoller() {\n        if (rollerInstance == null) {\n            throw new IllegalStateException(\"Roller Weblogger has not been bootstrapped yet\");\n        }\n        \n        return rollerInstance;\n    }\n",
    "new_code_raw": "    public static final Weblogger getRoller() {\n        if (rollerInstance == null) {\n            throw new IllegalStateException(\"Roller Weblogger has not been bootstrapped yet\");\n        }\n        \n        return rollerInstance;\n    }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-472-FirstSentence-0",
    "old_comment_raw": "Gets the chronology, which is the GJChronology if a GregorianCalendar is used,",
    "new_comment_raw": "Gets the chronology.",
    "old_code_raw": "    public Chronology getChronology(Object object) {\n        Calendar cal = (Calendar) object;\n        DateTimeZone zone = null;\n        try {\n            zone = DateTimeZone.getInstance(cal.getTimeZone());\n            \n        } catch (IllegalArgumentException ex) {\n            zone = DateTimeZone.getDefault();\n        }\n        return getChronology(cal, zone);\n    }\n",
    "new_code_raw": "    public Chronology getChronology(Object object, Chronology chrono) {\n        if (chrono != null) {\n            return chrono;\n        }\n        Calendar cal = (Calendar) object;\n        DateTimeZone zone = null;\n        try {\n            zone = DateTimeZone.getInstance(cal.getTimeZone());\n            \n        } catch (IllegalArgumentException ex) {\n            zone = DateTimeZone.getDefault();\n        }\n        return getChronology(cal, zone);\n    }\n"
  },
  {
    "id": "querydsl_querydsl-1434-FirstSentence-0",
    "old_comment_raw": "Expr : left.endsWith(right) (ignore case)",
    "new_comment_raw": "Expr : left.endsWith(right)",
    "old_code_raw": "    public static EBoolean endsWith(Expr<String> left, Expr<String> right, boolean caseSensitive) {\n        if (caseSensitive){\n            return endsWith(left, right);            \n        }else{\n            return operationFactory.createBoolean(Ops.ENDSWITH_IC, left, right);\n        }\n    }\n",
    "new_code_raw": "    public static EBoolean endsWith(Expr<String> left, Expr<String> right) {\n        return operationFactory.createBoolean(Ops.ENDSWITH, left, right);\n    }\n"
  },
  {
    "id": "zaproxy_zaproxy-2207-FirstSentence-0",
    "old_comment_raw": "Gets an unmodifiable  List containing all the  Vulnerability loaded from the path  Constant.VULNS_CONFIG.",
    "new_comment_raw": "Gets an unmodifiable  List containing all the  Vulnerability for the current active Locale.",
    "old_code_raw": "\tpublic static List<Vulnerability> getAllVulnerabilities() {\n\t\tif (vulns == null) {\n\t\t\tinit();\n\t\t}\n\t\treturn vulns;\n\t}\n",
    "new_code_raw": "\tpublic static List<Vulnerability> getAllVulnerabilities() {\n\t\tinitializeIfEmpty();\n\t\treturn Collections.unmodifiableList(vulnerabilitiesI18NMap.getVulnerabilityList(Constant.getLocale().toString()));\n\t}\n"
  }
]