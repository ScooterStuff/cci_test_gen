[
  {
    "id": "OpenAPITools_openapi_generator-1692-Param-1",
    "old_comment_raw": "@param file file to upload (required)",
    "old_code_raw": "  public ApiResponse<ModelApiResponse> uploadFileWithRequiredFileWithHttpInfo(Long petId, File file, String additionalMetadata) throws ApiException {\n    Object localVarPostBody = new Object();\n    \n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n    }\n    \n    // verify the required parameter 'file' is set\n    if (file == null) {\n      throw new ApiException(400, \"Missing the required parameter 'file' when calling uploadFileWithRequiredFile\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake/{petId}/uploadImageWithRequiredFile\"\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString()));\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    if (additionalMetadata != null)\n      localVarFormParams.put(\"additionalMetadata\", additionalMetadata);\nif (file != null)\n      localVarFormParams.put(\"file\", file);\n\n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"multipart/form-data\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"petstore_auth\" };\n\n    GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public ApiResponse<ModelApiResponse> uploadFileWithRequiredFileWithHttpInfo(Long petId, File requiredFile, String additionalMetadata) throws ApiException {\n    Object localVarPostBody = new Object();\n    \n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n    }\n    \n    // verify the required parameter 'requiredFile' is set\n    if (requiredFile == null) {\n      throw new ApiException(400, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake/{petId}/uploadImageWithRequiredFile\"\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString()));\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    if (additionalMetadata != null)\n      localVarFormParams.put(\"additionalMetadata\", additionalMetadata);\nif (requiredFile != null)\n      localVarFormParams.put(\"requiredFile\", requiredFile);\n\n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"multipart/form-data\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"petstore_auth\" };\n\n    GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1200-Param-0",
    "old_comment_raw": "@param resultSet The result set from which to do the load.",
    "old_code_raw": "\tprivate static EntityKey getOptionalObjectKey(QueryParameters queryParameters, SessionImplementor session) {\n\t\tfinal Object optionalObject = queryParameters.getOptionalObject();\n\t\tfinal Serializable optionalId = queryParameters.getOptionalId();\n\t\tfinal String optionalEntityName = queryParameters.getOptionalEntityName();\n\n\t\tif ( optionalObject != null && optionalEntityName != null ) {\n\t\t\treturn session.generateEntityKey(\n\t\t\t\t\toptionalId, session.getEntityPersister(\n\t\t\t\t\t\t\toptionalEntityName,\n\t\t\t\t\t\t\toptionalObject\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\n\t}\n",
    "new_code_raw": "\tprivate static EntityKey getOptionalObjectKey(QueryParameters queryParameters, SharedSessionContractImplementor session) {\n\t\tfinal Object optionalObject = queryParameters.getOptionalObject();\n\t\tfinal Serializable optionalId = queryParameters.getOptionalId();\n\t\tfinal String optionalEntityName = queryParameters.getOptionalEntityName();\n\n\t\tif ( optionalObject != null && optionalEntityName != null ) {\n\t\t\treturn session.generateEntityKey(\n\t\t\t\t\toptionalId, session.getEntityPersister(\n\t\t\t\t\t\t\toptionalEntityName,\n\t\t\t\t\t\t\toptionalObject\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\n\t}\n"
  },
  {
    "id": "Rajawali_Rajawali-33-Associations-Param0",
    "old_comment_raw": "@param float x The point x coordinate.",
    "old_code_raw": "\tpublic float distanceTo(float x, float y, float z) {\n\t\tfinal float a = this.x - x;\n\t\tfinal float b = this.y - y;\n\t\tfinal float c = this.z - z;\n\t\treturn (float) Math.sqrt(a * a + b * b + c * c);\n\t}\n",
    "new_code_raw": "\tpublic double distanceTo(double x, double y, double z) {\n\t\tfinal double a = this.x - x;\n\t\tfinal double b = this.y - y;\n\t\tfinal double c = this.z - z;\n\t\treturn Math.sqrt(a * a + b * b + c * c);\n\t}\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-411-Param-0",
    "old_comment_raw": "@param petId ID of pet that needs to be updated",
    "old_code_raw": "  public void  updatePetWithForm (String petId, String name, String status) throws ApiException {\n    Object postBody = null;\n    \n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n       throw new ApiException(400, \"Missing the required parameter 'petId' when calling updatePetWithForm\");\n    }\n    \n\n    // create path and map variables\n    String path = \"/pet/{petId}\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString()));\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n\n    \n\n    \n\n    String[] contentTypes = {\n      \"application/x-www-form-urlencoded\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder builder = MultipartEntityBuilder.create();\n      \n      if (name != null) {\n        builder.addTextBody(\"name\", ApiInvoker.parameterToString(name), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      \n      if (status != null) {\n        builder.addTextBody(\"status\", ApiInvoker.parameterToString(status), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      \n\n      HttpEntity httpEntity = builder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n      formParams.put(\"name\", ApiInvoker.parameterToString(name));\n      formParams.put(\"status\", ApiInvoker.parameterToString(status));\n      \n    }\n\n    try {\n      String response = apiInvoker.invokeAPI(basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType);\n      if(response != null){\n        return ;\n      }\n      else {\n        return ;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n",
    "new_code_raw": "  public void  updatePetWithForm (Long petId, String name, String status) throws ApiException {\n    Object postBody = null;\n    \n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n       throw new ApiException(400, \"Missing the required parameter 'petId' when calling updatePetWithForm\");\n    }\n    \n\n    // create path and map variables\n    String path = \"/pet/{petId}\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString()));\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n\n    \n\n    \n\n    String[] contentTypes = {\n      \"application/x-www-form-urlencoded\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder builder = MultipartEntityBuilder.create();\n      \n      if (name != null) {\n        builder.addTextBody(\"name\", ApiInvoker.parameterToString(name), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      \n      if (status != null) {\n        builder.addTextBody(\"status\", ApiInvoker.parameterToString(status), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      \n\n      HttpEntity httpEntity = builder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n      formParams.put(\"name\", ApiInvoker.parameterToString(name));\n      formParams.put(\"status\", ApiInvoker.parameterToString(status));\n      \n    }\n\n    try {\n      String response = apiInvoker.invokeAPI(basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType);\n      if(response != null){\n        return ;\n      }\n      else {\n        return ;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n"
  },
  {
    "id": "runelite_runelite-122-Param-4",
    "old_comment_raw": "@param tileY the y-axis coordinate of the tile",
    "old_code_raw": "\tpublic static Area getClickbox(@Nonnull Client client, Model model, int orientation, int tileX, int tileY)\n\t{\n\t\tif (model == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tList<Triangle> triangles = model.getTriangles().stream()\n\t\t\t.map(triangle -> triangle.rotate(orientation))\n\t\t\t.collect(Collectors.toList());\n\n\t\tList<Vertex> vertices = model.getVertices().stream()\n\t\t\t\t.map(v -> v.rotate(orientation))\n\t\t\t\t.collect(Collectors.toList());\n\n\t\tArea clickBox = get2DGeometry(client, triangles, orientation, tileX, tileY);\n\t\tArea visibleAABB = getAABB(client, vertices, orientation, tileX, tileY);\n\n\t\tif (visibleAABB == null || clickBox == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tclickBox.intersect(visibleAABB);\n\t\treturn clickBox;\n\t}\n",
    "new_code_raw": "\tpublic static Area getClickbox(@Nonnull Client client, Model model, int orientation, int localX, int localY)\n\t{\n\t\tif (model == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tList<Triangle> triangles = model.getTriangles().stream()\n\t\t\t.map(triangle -> triangle.rotate(orientation))\n\t\t\t.collect(Collectors.toList());\n\n\t\tList<Vertex> vertices = model.getVertices().stream()\n\t\t\t\t.map(v -> v.rotate(orientation))\n\t\t\t\t.collect(Collectors.toList());\n\n\t\tArea clickBox = get2DGeometry(client, triangles, orientation, localX, localY);\n\t\tArea visibleAABB = getAABB(client, vertices, orientation, localX, localY);\n\n\t\tif (visibleAABB == null || clickBox == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tclickBox.intersect(visibleAABB);\n\t\treturn clickBox;\n\t}\n"
  },
  {
    "id": "graphql_java_graphql_java-362-Param-0",
    "old_comment_raw": "@param definition the definition to add",
    "old_code_raw": "    public Optional<GraphQLError> add(SDLDefinition definition) {\n        // extensions\n        if (definition instanceof ObjectTypeExtensionDefinition) {\n            ObjectTypeExtensionDefinition newEntry = (ObjectTypeExtensionDefinition) definition;\n            return defineExt(typeExtensions, newEntry, ObjectTypeExtensionDefinition::getName);\n        } else if (definition instanceof InterfaceTypeExtensionDefinition) {\n            InterfaceTypeExtensionDefinition newEntry = (InterfaceTypeExtensionDefinition) definition;\n            return defineExt(interfaceTypeExtensions, newEntry, InterfaceTypeExtensionDefinition::getName);\n        } else if (definition instanceof UnionTypeExtensionDefinition) {\n            UnionTypeExtensionDefinition newEntry = (UnionTypeExtensionDefinition) definition;\n            return defineExt(unionTypeExtensions, newEntry, UnionTypeExtensionDefinition::getName);\n        } else if (definition instanceof EnumTypeExtensionDefinition) {\n            EnumTypeExtensionDefinition newEntry = (EnumTypeExtensionDefinition) definition;\n            return defineExt(enumTypeExtensions, newEntry, EnumTypeExtensionDefinition::getName);\n        } else if (definition instanceof ScalarTypeExtensionDefinition) {\n            ScalarTypeExtensionDefinition newEntry = (ScalarTypeExtensionDefinition) definition;\n            return defineExt(scalarTypeExtensions, newEntry, ScalarTypeExtensionDefinition::getName);\n        } else if (definition instanceof InputObjectTypeExtensionDefinition) {\n            InputObjectTypeExtensionDefinition newEntry = (InputObjectTypeExtensionDefinition) definition;\n            return defineExt(inputObjectTypeExtensions, newEntry, InputObjectTypeExtensionDefinition::getName);\n            //\n            // normal\n        } else if (definition instanceof ScalarTypeDefinition) {\n            ScalarTypeDefinition newEntry = (ScalarTypeDefinition) definition;\n            return define(scalarTypes, scalarTypes, newEntry);\n        } else if (definition instanceof TypeDefinition) {\n            TypeDefinition newEntry = (TypeDefinition) definition;\n            return define(types, types, newEntry);\n        } else if (definition instanceof DirectiveDefinition) {\n            DirectiveDefinition newEntry = (DirectiveDefinition) definition;\n            return define(directiveDefinitions, directiveDefinitions, newEntry);\n        } else if (definition instanceof SchemaDefinition) {\n            SchemaDefinition newSchema = (SchemaDefinition) definition;\n            if (schema != null) {\n                return Optional.of(new SchemaRedefinitionError(this.schema, newSchema));\n            } else {\n                schema = newSchema;\n            }\n        } else {\n            return Assert.assertShouldNeverHappen();\n        }\n        return Optional.empty();\n    }\n",
    "new_code_raw": "    public Optional<GraphQLError> add(Definition definition) {\n        // extensions\n        if (definition instanceof ObjectTypeExtensionDefinition) {\n            ObjectTypeExtensionDefinition newEntry = (ObjectTypeExtensionDefinition) definition;\n            return defineExt(objectTypeExtensions, newEntry, ObjectTypeExtensionDefinition::getName);\n        } else if (definition instanceof InterfaceTypeExtensionDefinition) {\n            InterfaceTypeExtensionDefinition newEntry = (InterfaceTypeExtensionDefinition) definition;\n            return defineExt(interfaceTypeExtensions, newEntry, InterfaceTypeExtensionDefinition::getName);\n        } else if (definition instanceof UnionTypeExtensionDefinition) {\n            UnionTypeExtensionDefinition newEntry = (UnionTypeExtensionDefinition) definition;\n            return defineExt(unionTypeExtensions, newEntry, UnionTypeExtensionDefinition::getName);\n        } else if (definition instanceof EnumTypeExtensionDefinition) {\n            EnumTypeExtensionDefinition newEntry = (EnumTypeExtensionDefinition) definition;\n            return defineExt(enumTypeExtensions, newEntry, EnumTypeExtensionDefinition::getName);\n        } else if (definition instanceof ScalarTypeExtensionDefinition) {\n            ScalarTypeExtensionDefinition newEntry = (ScalarTypeExtensionDefinition) definition;\n            return defineExt(scalarTypeExtensions, newEntry, ScalarTypeExtensionDefinition::getName);\n        } else if (definition instanceof InputObjectTypeExtensionDefinition) {\n            InputObjectTypeExtensionDefinition newEntry = (InputObjectTypeExtensionDefinition) definition;\n            return defineExt(inputObjectTypeExtensions, newEntry, InputObjectTypeExtensionDefinition::getName);\n            //\n            // normal\n        } else if (definition instanceof ScalarTypeDefinition) {\n            ScalarTypeDefinition newEntry = (ScalarTypeDefinition) definition;\n            return define(scalarTypes, scalarTypes, newEntry);\n        } else if (definition instanceof TypeDefinition) {\n            TypeDefinition newEntry = (TypeDefinition) definition;\n            return define(types, types, newEntry);\n        } else if (definition instanceof DirectiveDefinition) {\n            DirectiveDefinition newEntry = (DirectiveDefinition) definition;\n            return define(directiveDefinitions, directiveDefinitions, newEntry);\n        } else if (definition instanceof SchemaDefinition) {\n            SchemaDefinition newSchema = (SchemaDefinition) definition;\n            if (schema != null) {\n                return Optional.of(new SchemaRedefinitionError(this.schema, newSchema));\n            } else {\n                schema = newSchema;\n            }\n        }\n        return Optional.empty();\n    }\n"
  },
  {
    "id": "querydsl_querydsl-1417-Param-0",
    "old_comment_raw": "@param iteratorFactory",
    "old_code_raw": "    public MultiIterator init(IteratorFactory iteratorFactory){\n        this.iteratorFactory = iteratorFactory;\n        this.iterators = new Iterator<?>[sources.size()];\n        this.lastEntry = new boolean[iterators.length];\n        this.values = new Object[iterators.length];\n        return this;\n    }\n",
    "new_code_raw": "    public MultiIterator init(IndexSupport indexSupport){\n        this.indexSupport = indexSupport;\n        this.iterators = new Iterator<?>[sources.size()];\n        this.lastEntry = new boolean[iterators.length];\n        this.values = new Object[iterators.length];\n        return this;\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-286-Param-2",
    "old_comment_raw": "@param queryParams The query parameters",
    "old_code_raw": "  public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n",
    "new_code_raw": "  public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n"
  },
  {
    "id": "apache_calcite-876-Param-0",
    "old_comment_raw": "@param fail Whether to fail",
    "old_code_raw": "  public boolean isValid(boolean fail) {\n    if (inputRowType == null) {\n      assert !fail;\n      return false;\n    }\n    if (exprs == null) {\n      assert !fail;\n      return false;\n    }\n    if (projects == null) {\n      assert !fail;\n      return false;\n    }\n    if (outputRowType == null) {\n      assert !fail;\n      return false;\n    }\n\n    // If the input row type is a struct (contains fields) then the leading\n    // expressions must be references to those fields. But we don't require\n    // this if the input row type is, say, a java class.\n    if (inputRowType.isStruct()) {\n      if (!RexUtil.containIdentity(exprs, inputRowType, fail)) {\n        assert !fail;\n        return false;\n      }\n\n      // None of the other fields should be inputRefs.\n      for (int i = inputRowType.getFieldCount(); i < exprs.size(); i++) {\n        RexNode expr = exprs.get(i);\n        if (expr instanceof RexInputRef) {\n          assert !fail;\n          return false;\n        }\n      }\n    }\n    // todo: enable\n    // CHECKSTYLE: IGNORE 1\n    if (false && RexUtil.containCommonExprs(exprs, fail)) {\n      assert !fail;\n      return false;\n    }\n    if (RexUtil.containForwardRefs(exprs, inputRowType, fail)) {\n      assert !fail;\n      return false;\n    }\n    if (RexUtil.containNonTrivialAggs(exprs, fail)) {\n      assert !fail;\n      return false;\n    }\n    final Checker checker =\n        new Checker(\n            fail,\n            inputRowType,\n            new AbstractList<RelDataType>() {\n              public RelDataType get(int index) {\n                return exprs.get(index).getType();\n              }\n\n              @Override public int size() {\n                return exprs.size();\n              }\n              // CHECKSTYLE: IGNORE 1\n            });\n    if (condition != null) {\n      if (!SqlTypeUtil.inBooleanFamily(condition.getType())) {\n        assert !fail : \"condition must be boolean\";\n        return false;\n      }\n      condition.accept(checker);\n      if (checker.failCount > 0) {\n        assert !fail;\n        return false;\n      }\n    }\n    for (int i = 0; i < projects.size(); i++) {\n      projects.get(i).accept(checker);\n      if (checker.failCount > 0) {\n        assert !fail;\n        return false;\n      }\n    }\n    for (int i = 0; i < exprs.size(); i++) {\n      exprs.get(i).accept(checker);\n      if (checker.failCount > 0) {\n        assert !fail;\n        return false;\n      }\n    }\n    return true;\n  }\n",
    "new_code_raw": "  public boolean isValid(Litmus litmus) {\n    if (inputRowType == null) {\n      return litmus.fail(null);\n    }\n    if (exprs == null) {\n      return litmus.fail(null);\n    }\n    if (projects == null) {\n      return litmus.fail(null);\n    }\n    if (outputRowType == null) {\n      return litmus.fail(null);\n    }\n\n    // If the input row type is a struct (contains fields) then the leading\n    // expressions must be references to those fields. But we don't require\n    // this if the input row type is, say, a java class.\n    if (inputRowType.isStruct()) {\n      if (!RexUtil.containIdentity(exprs, inputRowType, litmus)) {\n        return litmus.fail(null);\n      }\n\n      // None of the other fields should be inputRefs.\n      for (int i = inputRowType.getFieldCount(); i < exprs.size(); i++) {\n        RexNode expr = exprs.get(i);\n        if (expr instanceof RexInputRef) {\n          return litmus.fail(null);\n        }\n      }\n    }\n    // todo: enable\n    // CHECKSTYLE: IGNORE 1\n    if (false && RexUtil.containNoCommonExprs(exprs, litmus)) {\n      return litmus.fail(null);\n    }\n    if (!RexUtil.containNoForwardRefs(exprs, inputRowType, litmus)) {\n      return litmus.fail(null);\n    }\n    if (!RexUtil.containNoNonTrivialAggs(exprs, litmus)) {\n      return litmus.fail(null);\n    }\n    final Checker checker =\n        new Checker(\n            litmus,\n            inputRowType,\n            new AbstractList<RelDataType>() {\n              public RelDataType get(int index) {\n                return exprs.get(index).getType();\n              }\n\n              @Override public int size() {\n                return exprs.size();\n              }\n              // CHECKSTYLE: IGNORE 1\n            });\n    if (condition != null) {\n      if (!SqlTypeUtil.inBooleanFamily(condition.getType())) {\n        return litmus.fail(\"condition must be boolean\");\n      }\n      condition.accept(checker);\n      if (checker.failCount > 0) {\n        return litmus.fail(null);\n      }\n    }\n    for (int i = 0; i < projects.size(); i++) {\n      projects.get(i).accept(checker);\n      if (checker.failCount > 0) {\n        return litmus.fail(null);\n      }\n    }\n    for (int i = 0; i < exprs.size(); i++) {\n      exprs.get(i).accept(checker);\n      if (checker.failCount > 0) {\n        return litmus.fail(null);\n      }\n    }\n    return litmus.succeed();\n  }\n"
  },
  {
    "id": "runelite_runelite-131-Param-1",
    "old_comment_raw": "@param percentage The ratio to modify the image's alpha component with. Values above 1 will increase transparency, and values below 1 will decrease transparency.",
    "old_code_raw": "\tpublic static BufferedImage alphaOffset(final BufferedImage image, final float percentage)\n\t{\n\t\tfinal int numComponents = image.getColorModel().getNumComponents();\n\t\tfinal float[] scales = new float[numComponents];\n\t\tfinal float[] offsets = new float[numComponents];\n\n\t\tArrays.fill(scales, 1f);\n\t\tArrays.fill(offsets, 0f);\n\t\tscales[numComponents - 1] = percentage;\n\t\treturn offset(image, scales, offsets);\n\t}\n",
    "new_code_raw": "\tpublic static BufferedImage alphaOffset(final Image rawImg, final float percentage)\n\t{\n\t\tBufferedImage image = toARGB(rawImg);\n\t\tfinal int numComponents = image.getColorModel().getNumComponents();\n\t\tfinal float[] scales = new float[numComponents];\n\t\tfinal float[] offsets = new float[numComponents];\n\n\t\tArrays.fill(scales, 1f);\n\t\tArrays.fill(offsets, 0f);\n\t\tscales[numComponents - 1] = percentage;\n\t\treturn offset(image, scales, offsets);\n\t}\n"
  },
  {
    "id": "apache_clerezza-24-Associations-Param1",
    "old_comment_raw": "@param defaultGraph the default ImmutableGraph against which to execute the query if not FROM clause is present",
    "old_code_raw": "    @Deprecated\n    public ImmutableGraph executeSparqlQuery(ConstructQuery query,\n            Graph defaultGraph) {\n        return (ImmutableGraph) executeSparqlQuery((Query) query, defaultGraph);\n    }\n",
    "new_code_raw": "    @Deprecated\n    public Graph executeSparqlQuery(ConstructQuery query,\n            TripleCollection defaultGraph) {\n        return (Graph) executeSparqlQuery((Query) query, defaultGraph);\n    }\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-1350-Param-1",
    "old_comment_raw": "@param extraSep boolean indicating whether the extra dependencies have to be printed separately, after the basic ones",
    "old_code_raw": "  private static String toString(Collection<TypedDependency> dependencies, boolean extraSep, boolean includeTags) {\n    CoreLabel.OutputFormat labelFormat = (includeTags) ? CoreLabel.OutputFormat.VALUE_TAG_INDEX : CoreLabel.OutputFormat.VALUE_INDEX;\n    StringBuilder buf = new StringBuilder();\n    if (extraSep) {\n      List<TypedDependency> extraDeps = new ArrayList<>();\n      for (TypedDependency td : dependencies) {\n        if (td.extra()) {\n          extraDeps.add(td);\n        } else {\n          buf.append(td.toString(labelFormat)).append('\\n');\n        }\n      }\n      // now we print the separator for extra dependencies, and print these if there are some\n      if (!extraDeps.isEmpty()) {\n        buf.append(\"======\\n\");\n        for (TypedDependency td : extraDeps) {\n          buf.append(td.toString(labelFormat)).append('\\n');\n        }\n      }\n    } else {\n      for (TypedDependency td : dependencies) {\n        buf.append(td.toString(labelFormat)).append('\\n');\n      }\n    }\n    return buf.toString();\n  }\n",
    "new_code_raw": "  private static String toString(Collection<TypedDependency> dependencies, boolean extraSep) {\n    StringBuilder buf = new StringBuilder();\n    if (extraSep) {\n      List<TypedDependency> extraDeps =  new ArrayList<TypedDependency>();\n      for (TypedDependency td : dependencies) {\n        if (td.extra()) {\n          extraDeps.add(td);\n        }\n        else {\n          buf.append(td.toString()).append('\\n');\n        }\n      }\n      // now we print the separator for extra dependencies, and print these if there are some\n      if (!extraDeps.isEmpty()) {\n        buf.append(\"======\\n\");\n        for (TypedDependency td : extraDeps) {\n          buf.append(td.toString()).append('\\n');\n        }\n      }\n    } else {\n      for (TypedDependency td : dependencies) {\n        buf.append(td.toString()).append('\\n');\n      }\n    }\n    return buf.toString();\n  }\n"
  },
  {
    "id": "Atmosphere_atmosphere-826-Param-0",
    "old_comment_raw": "@param request the  HttpServletRequest",
    "old_code_raw": "    public Action timedout(HttpServletRequest request, HttpServletResponse response)\n            throws IOException, ServletException {\n\n        AtmosphereResourceImpl r = null;\n        try {\n            if (trackActiveRequest) {\n                long l = (Long) request.getAttribute(MAX_INACTIVE);\n                if (l == -1) {\n                    // The closedDetector closed the connection.\n                    return timedoutAction;\n                }\n                request.setAttribute(MAX_INACTIVE, (long) -1);\n            }\n\n            logger.debug(\"Timing out the connection for request {}\", request);\n\n            // Something went wrong.\n            if (request == null || response == null) {\n                logger.warn(\"Invalid Request/Response: {}/{}\", request, response);\n                return timedoutAction;\n            }\n\n            r = (AtmosphereResourceImpl) request.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n\n            if (r != null && r.getAtmosphereResourceEvent().isSuspended()) {\n                r.getAtmosphereResourceEvent().setIsResumedOnTimeout(true);\n\n                Broadcaster b = r.getBroadcaster();\n                if (b instanceof DefaultBroadcaster) {\n                    ((DefaultBroadcaster) b).broadcastOnResume(r);\n                }\n\n                if (request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT) != null) {\n                    r.getAtmosphereResourceEvent().setIsResumedOnTimeout(\n                            (Boolean) request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT));\n                }\n\n                invokeAtmosphereHandler(r);\n            }\n        } catch (Throwable t) {\n            logger.error(\"failed to timeout resource {}\", r, t);\n        } finally {\n            try {\n                if (r != null) {\n                    r.notifyListeners();\n                    r.setIsInScope(false);\n                    r.cancel();\n                }\n            } catch (Throwable t) {\n                logger.trace(\"timedout\", t);\n            } finally {\n\n                try {\n                    response.getOutputStream().close();\n                } catch (Throwable t) {\n                    try {\n                        response.getWriter().close();\n                    } catch (Throwable t2) {\n                    }\n                }\n\n                if (r != null) {\n                    destroyResource(r);\n                }\n            }\n        }\n\n        return timedoutAction;\n    }\n",
    "new_code_raw": "    public Action timedout(AtmosphereRequest request, AtmosphereResponse response)\n            throws IOException, ServletException {\n\n        AtmosphereResourceImpl r = null;\n        try {\n            if (trackActiveRequest) {\n                long l = (Long) request.getAttribute(MAX_INACTIVE);\n                if (l == -1) {\n                    // The closedDetector closed the connection.\n                    return timedoutAction;\n                }\n                request.setAttribute(MAX_INACTIVE, (long) -1);\n            }\n\n            logger.debug(\"Timing out the connection for request {}\", request);\n\n            // Something went wrong.\n            if (request == null || response == null) {\n                logger.warn(\"Invalid Request/Response: {}/{}\", request, response);\n                return timedoutAction;\n            }\n\n            r = (AtmosphereResourceImpl) request.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n\n            if (r != null && r.getAtmosphereResourceEvent().isSuspended()) {\n                r.getAtmosphereResourceEvent().setIsResumedOnTimeout(true);\n\n                Broadcaster b = r.getBroadcaster();\n                if (b instanceof DefaultBroadcaster) {\n                    ((DefaultBroadcaster) b).broadcastOnResume(r);\n                }\n\n                if (request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT) != null) {\n                    r.getAtmosphereResourceEvent().setIsResumedOnTimeout(\n                            (Boolean) request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT));\n                }\n\n                invokeAtmosphereHandler(r);\n            }\n        } catch (Throwable t) {\n            logger.error(\"failed to timeout resource {}\", r, t);\n        } finally {\n            try {\n                if (r != null) {\n                    r.notifyListeners();\n                    r.setIsInScope(false);\n                    r.cancel();\n                }\n            } catch (Throwable t) {\n                logger.trace(\"timedout\", t);\n            } finally {\n\n                try {\n                    response.getOutputStream().close();\n                } catch (Throwable t) {\n                    try {\n                        response.getWriter().close();\n                    } catch (Throwable t2) {\n                    }\n                }\n\n                if (r != null) {\n                    destroyResource(r);\n                }\n            }\n        }\n\n        return timedoutAction;\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-305-Param-0",
    "old_comment_raw": "@param other the other period, must not be null",
    "old_code_raw": "    public int compareTo(Object other) {\n        if (other.getClass() != getClass()) {\n            throw new ClassCastException(getClass() + \" cannot be compared to \" + other.getClass());\n        }\n        int otherValue = ((BaseSingleFieldPeriod) other).getValue();\n        int thisValue = getValue();\n        if (thisValue > otherValue) {\n            return 1;\n        }\n        if (thisValue < otherValue) {\n            return -1;\n        }\n        return 0;\n    }\n",
    "new_code_raw": "    public int compareTo(BaseSingleFieldPeriod other) {\n        if (other.getClass() != getClass()) {\n            throw new ClassCastException(getClass() + \" cannot be compared to \" + other.getClass());\n        }\n        int otherValue = other.getValue();\n        int thisValue = getValue();\n        if (thisValue > otherValue) {\n            return 1;\n        }\n        if (thisValue < otherValue) {\n            return -1;\n        }\n        return 0;\n    }\n"
  },
  {
    "id": "apache_jsecurity-43-Associations-Param0",
    "old_comment_raw": "@param tokenClass the class of the authenticationToken being submitted for authentication.",
    "old_code_raw": "    public boolean supports(Class tokenClass) {\n        return getAuthenticationTokenClass().isAssignableFrom( tokenClass );\n    }\n",
    "new_code_raw": "    public boolean supports(AuthenticationToken token) {\n        if ( log.isInfoEnabled() ) {\n            log.info( \"Received null AuthenticationToken.  Returning false for supports(token) implementation (can't \" +\n                \"process null tokens).\" );\n        }\n        return token != null && getAuthenticationTokenClass().isAssignableFrom(token.getClass());\n    }\n\n"
  },
  {
    "id": "LawnchairLauncher_Lawnchair-258-Param-3",
    "old_comment_raw": "@param preview bitmap that can be recycled",
    "old_code_raw": "    private RectF drawBoxWithShadow(Canvas c, Paint p, int width, int height) {\n        Resources res = mContext.getResources();\n        float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);\n        float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);\n        float corner = res.getDimension(R.dimen.widget_preview_corner_radius);\n\n        RectF bounds = new RectF(shadowBlur, shadowBlur,\n                width - shadowBlur, height - shadowBlur - keyShadowDistance);\n        p.setColor(Color.WHITE);\n\n        // Key shadow\n        p.setShadowLayer(shadowBlur, 0, keyShadowDistance,\n                ShadowGenerator.KEY_SHADOW_ALPHA << 24);\n        c.drawRoundRect(bounds, corner, corner, p);\n\n        // Ambient shadow\n        p.setShadowLayer(shadowBlur, 0, 0,\n                ColorUtils.setAlphaComponent(Color.BLACK, ShadowGenerator.AMBIENT_SHADOW_ALPHA));\n        c.drawRoundRect(bounds, corner, corner, p);\n\n        p.clearShadowLayer();\n        return bounds;\n    }\n",
    "new_code_raw": "    private RectF drawBoxWithShadow(Canvas c, int width, int height) {\n        Resources res = mContext.getResources();\n        float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);\n        float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);\n        float corner = res.getDimension(R.dimen.widget_preview_corner_radius);\n\n        RectF bounds = new RectF(shadowBlur, shadowBlur,\n                width - shadowBlur, height - shadowBlur - keyShadowDistance);\n        ShadowGenerator.drawShadow(c, bounds, Color.WHITE, shadowBlur, keyShadowDistance, corner);\n        return bounds;\n    }\n"
  },
  {
    "id": "dropwizard_dropwizard-39-Associations-Param1",
    "old_comment_raw": "@param urlPattern the URL pattern for requests that should be handled by instances of  klass",
    "old_code_raw": "    public ServletBuilder addServlet(Class<? extends Servlet> klass,\n                                     String urlPattern) {\n        final ServletHolder holder = new ServletHolder(checkNotNull(klass));\n        final ServletBuilder builder = new ServletBuilder(holder, handler);\n        builder.addUrlPattern(checkNotNull(urlPattern));\n        return builder;\n    }\n",
    "new_code_raw": "    public ServletRegistration.Dynamic addServlet(String name, Class<? extends Servlet> klass) {\n        final ServletHolder holder = new ServletHolder(checkNotNull(klass));\n        holder.setName(name);\n        handler.getServletHandler().addServlet(holder);\n        return holder.getRegistration();\n    }\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-514-Param-0",
    "old_comment_raw": "@param dependencies The TypedDependencies to print",
    "old_code_raw": "  private static String toString(Collection<TypedDependency> dependencies, boolean extraSep) {\n    StringBuilder buf = new StringBuilder();\n    if (extraSep) {\n      List<TypedDependency> extraDeps =  new ArrayList<TypedDependency>();\n      for (TypedDependency td : dependencies) {\n        if (td.extra()) {\n          extraDeps.add(td);\n        } else {\n          buf.append(td.toString(\"value-tag-index\")).append('\\n');\n        }\n      }\n      // now we print the separator for extra dependencies, and print these if there are some\n      if (!extraDeps.isEmpty()) {\n        buf.append(\"======\\n\");\n        for (TypedDependency td : extraDeps) {\n          buf.append(td.toString(\"value-tag-index\")).append('\\n');\n        }\n      }\n    } else {\n      for (TypedDependency td : dependencies) {\n        buf.append(td.toString(\"value-tag-index\")).append('\\n');\n      }\n    }\n    return buf.toString();\n  }\n",
    "new_code_raw": "  private static String toString(Collection<TypedDependency> dependencies, boolean extraSep, boolean includeTags) {\n    String labelFormat = (includeTags) ? \"value-tag-index\" : \"value-index\";\n    StringBuilder buf = new StringBuilder();\n    if (extraSep) {\n      List<TypedDependency> extraDeps =  new ArrayList<TypedDependency>();\n      for (TypedDependency td : dependencies) {\n        if (td.extra()) {\n          extraDeps.add(td);\n        } else {\n          buf.append(td.toString(labelFormat)).append('\\n');\n        }\n      }\n      // now we print the separator for extra dependencies, and print these if there are some\n      if (!extraDeps.isEmpty()) {\n        buf.append(\"======\\n\");\n        for (TypedDependency td : extraDeps) {\n          buf.append(td.toString(labelFormat)).append('\\n');\n        }\n      }\n    } else {\n      for (TypedDependency td : dependencies) {\n        buf.append(td.toString(labelFormat)).append('\\n');\n      }\n    }\n    return buf.toString();\n  }\n"
  },
  {
    "id": "dropwizard_dropwizard-41-Associations-Param1",
    "old_comment_raw": "@param urlPattern the URL pattern for requests that should be handled by instances of  klass",
    "old_code_raw": "    public FilterBuilder addFilter(Class<? extends Filter> klass,\n                                   String urlPattern) {\n        final FilterHolder holder = new FilterHolder(checkNotNull(klass));\n        final FilterBuilder filterConfig = new FilterBuilder(holder, handler);\n        filterConfig.addUrlPattern(checkNotNull(urlPattern));\n        return filterConfig;\n    }\n",
    "new_code_raw": "    public FilterRegistration.Dynamic addFilter(String name, Class<? extends Filter> klass) {\n        final FilterHolder holder = new FilterHolder(checkNotNull(klass));\n        holder.setName(name);\n        handler.getServletHandler().addFilter(holder);\n        return holder.getRegistration();\n    }\n\n"
  },
  {
    "id": "zaproxy_zaproxy-928-Param-1",
    "old_comment_raw": "@param name Null = not to append parameter.",
    "old_code_raw": "    private boolean paramAppend(StringBuilder sb, String name, String value) {\n        boolean isEdited = false;\n        \n        if (name != null) {\n            sb.append(name);\n            isEdited = true;\n        }\n        \n        if (value != null) {\n            sb.append('=');\n            sb.append(value);\n            isEdited = true;\n        }\n        \n        return isEdited;\n    }\n",
    "new_code_raw": "    private boolean paramAppend(StringBuilder sb, String name, String value, ParameterParser parser) {\n        boolean isEdited = false;\n        \n        if (name != null) {\n            sb.append(name);\n            isEdited = true;\n        }\n        \n        if (value != null) {\n            sb.append(parser.getDefaultKeyValueSeparator());\n            sb.append(value);\n            isEdited = true;\n        }\n        \n        return isEdited;\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2600-Param-1",
    "old_comment_raw": "@param file file to upload (required)",
    "old_code_raw": "  public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws ApiException {\n    return uploadFileWithRequiredFileWithHttpInfo(petId, file, additionalMetadata).getData();\n      }\n",
    "new_code_raw": "  public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException {\n    return uploadFileWithRequiredFileWithHttpInfo(petId, requiredFile, additionalMetadata).getData();\n      }\n"
  },
  {
    "id": "graphql_java_graphql_java-361-Param-0",
    "old_comment_raw": "@param definition the definition to add",
    "old_code_raw": "    public Optional<GraphQLError> add(Definition definition) {\n        // extensions\n        if (definition instanceof ObjectTypeExtensionDefinition) {\n            ObjectTypeExtensionDefinition newEntry = (ObjectTypeExtensionDefinition) definition;\n            return defineExt(typeExtensions, newEntry, ObjectTypeExtensionDefinition::getName);\n        } else if (definition instanceof InterfaceTypeExtensionDefinition) {\n            InterfaceTypeExtensionDefinition newEntry = (InterfaceTypeExtensionDefinition) definition;\n            return defineExt(interfaceTypeExtensions, newEntry, InterfaceTypeExtensionDefinition::getName);\n        } else if (definition instanceof UnionTypeExtensionDefinition) {\n            UnionTypeExtensionDefinition newEntry = (UnionTypeExtensionDefinition) definition;\n            return defineExt(unionTypeExtensions, newEntry, UnionTypeExtensionDefinition::getName);\n        } else if (definition instanceof EnumTypeExtensionDefinition) {\n            EnumTypeExtensionDefinition newEntry = (EnumTypeExtensionDefinition) definition;\n            return defineExt(enumTypeExtensions, newEntry, EnumTypeExtensionDefinition::getName);\n        } else if (definition instanceof ScalarTypeExtensionDefinition) {\n            ScalarTypeExtensionDefinition newEntry = (ScalarTypeExtensionDefinition) definition;\n            return defineExt(scalarTypeExtensions, newEntry, ScalarTypeExtensionDefinition::getName);\n        } else if (definition instanceof InputObjectTypeExtensionDefinition) {\n            InputObjectTypeExtensionDefinition newEntry = (InputObjectTypeExtensionDefinition) definition;\n            return defineExt(inputObjectTypeExtensions, newEntry, InputObjectTypeExtensionDefinition::getName);\n            //\n            // normal\n        } else if (definition instanceof ScalarTypeDefinition) {\n            ScalarTypeDefinition newEntry = (ScalarTypeDefinition) definition;\n            return define(scalarTypes, scalarTypes, newEntry);\n        } else if (definition instanceof TypeDefinition) {\n            TypeDefinition newEntry = (TypeDefinition) definition;\n            return define(types, types, newEntry);\n        } else if (definition instanceof DirectiveDefinition) {\n            DirectiveDefinition newEntry = (DirectiveDefinition) definition;\n            return define(directiveDefinitions, directiveDefinitions, newEntry);\n        } else if (definition instanceof SchemaDefinition) {\n            SchemaDefinition newSchema = (SchemaDefinition) definition;\n            if (schema != null) {\n                return Optional.of(new SchemaRedefinitionError(this.schema, newSchema));\n            } else {\n                schema = newSchema;\n            }\n        }\n        return Optional.empty();\n    }\n",
    "new_code_raw": "    public Optional<GraphQLError> add(SDLDefinition definition) {\n        // extensions\n        if (definition instanceof ObjectTypeExtensionDefinition) {\n            ObjectTypeExtensionDefinition newEntry = (ObjectTypeExtensionDefinition) definition;\n            return defineExt(typeExtensions, newEntry, ObjectTypeExtensionDefinition::getName);\n        } else if (definition instanceof InterfaceTypeExtensionDefinition) {\n            InterfaceTypeExtensionDefinition newEntry = (InterfaceTypeExtensionDefinition) definition;\n            return defineExt(interfaceTypeExtensions, newEntry, InterfaceTypeExtensionDefinition::getName);\n        } else if (definition instanceof UnionTypeExtensionDefinition) {\n            UnionTypeExtensionDefinition newEntry = (UnionTypeExtensionDefinition) definition;\n            return defineExt(unionTypeExtensions, newEntry, UnionTypeExtensionDefinition::getName);\n        } else if (definition instanceof EnumTypeExtensionDefinition) {\n            EnumTypeExtensionDefinition newEntry = (EnumTypeExtensionDefinition) definition;\n            return defineExt(enumTypeExtensions, newEntry, EnumTypeExtensionDefinition::getName);\n        } else if (definition instanceof ScalarTypeExtensionDefinition) {\n            ScalarTypeExtensionDefinition newEntry = (ScalarTypeExtensionDefinition) definition;\n            return defineExt(scalarTypeExtensions, newEntry, ScalarTypeExtensionDefinition::getName);\n        } else if (definition instanceof InputObjectTypeExtensionDefinition) {\n            InputObjectTypeExtensionDefinition newEntry = (InputObjectTypeExtensionDefinition) definition;\n            return defineExt(inputObjectTypeExtensions, newEntry, InputObjectTypeExtensionDefinition::getName);\n            //\n            // normal\n        } else if (definition instanceof ScalarTypeDefinition) {\n            ScalarTypeDefinition newEntry = (ScalarTypeDefinition) definition;\n            return define(scalarTypes, scalarTypes, newEntry);\n        } else if (definition instanceof TypeDefinition) {\n            TypeDefinition newEntry = (TypeDefinition) definition;\n            return define(types, types, newEntry);\n        } else if (definition instanceof DirectiveDefinition) {\n            DirectiveDefinition newEntry = (DirectiveDefinition) definition;\n            return define(directiveDefinitions, directiveDefinitions, newEntry);\n        } else if (definition instanceof SchemaDefinition) {\n            SchemaDefinition newSchema = (SchemaDefinition) definition;\n            if (schema != null) {\n                return Optional.of(new SchemaRedefinitionError(this.schema, newSchema));\n            } else {\n                schema = newSchema;\n            }\n        } else {\n            return Assert.assertShouldNeverHappen();\n        }\n        return Optional.empty();\n    }\n"
  },
  {
    "id": "Atmosphere_atmosphere-819-Param-1",
    "old_comment_raw": "@param res the  HttpServletResponse",
    "old_code_raw": "    public Action timedout(HttpServletRequest req, HttpServletResponse res)\n            throws IOException, ServletException {\n\n        AtmosphereResourceImpl re;\n        long l = (Long) req.getAttribute(MAX_INACTIVE);\n        if (l == -1) {\n            // The closedDetector closed the connection.\n            return timedoutAction;            \n        }\n        req.setAttribute(MAX_INACTIVE, (long)-1);\n\n        // Something went wrong.\n        if (req == null || res == null) {\n            logger.warning(\"Invalid Request/Response: \" + req + \"/\" + res);\n            return timedoutAction;\n        }\n\n        re = (AtmosphereResourceImpl) req.getAttribute(AtmosphereServlet.ATMOSPHERE_RESOURCE);\n\n        if (re != null) {\n            re.getAtmosphereResourceEvent().setIsResumedOnTimeout(true);\n\n            Broadcaster b = re.getBroadcaster();\n            if (b instanceof DefaultBroadcaster) {\n                ((DefaultBroadcaster)b).broadcastOnResume(re);\n            }\n\n            if (re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT) != null) {\n                re.getAtmosphereResourceEvent().setIsResumedOnTimeout(\n                        (Boolean) re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT));\n            }\n            invokeAtmosphereHandler(re);\n        }\n\n        return timedoutAction;\n    }\n",
    "new_code_raw": "    public Action timedout(HttpServletRequest request, HttpServletResponse response)\n            throws IOException, ServletException {\n\n        AtmosphereResourceImpl re;\n        long l = (Long) request.getAttribute(MAX_INACTIVE);\n        if (l == -1) {\n            // The closedDetector closed the connection.\n            return timedoutAction;            \n        }\n        request.setAttribute(MAX_INACTIVE, (long) -1);\n\n        // Something went wrong.\n        if (request == null || response == null) {\n            logger.warn(\"Invalid Request/Response: {}/{}\", request, response);\n            return timedoutAction;\n        }\n\n        re = (AtmosphereResourceImpl) request.getAttribute(AtmosphereServlet.ATMOSPHERE_RESOURCE);\n\n        if (re != null) {\n            re.getAtmosphereResourceEvent().setIsResumedOnTimeout(true);\n\n            Broadcaster b = re.getBroadcaster();\n            if (b instanceof DefaultBroadcaster) {\n                ((DefaultBroadcaster)b).broadcastOnResume(re);\n            }\n\n            if (re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT) != null) {\n                re.getAtmosphereResourceEvent().setIsResumedOnTimeout(\n                        (Boolean) re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT));\n            }\n            invokeAtmosphereHandler(re);\n        }\n\n        return timedoutAction;\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-233-Param-0",
    "old_comment_raw": "@param viewClass what kind of  View to search for, e.g.  Button.class or  TextView.class",
    "old_code_raw": "\tpublic boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll) {\n\t\tfinal long endTime = System.currentTimeMillis() + TIMEOUT;\n\n\t\twhile (System.currentTimeMillis() < endTime) {\n\t\t\tsleeper.sleep();\n\t\t\tfinal boolean foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, scroll);\n\t\t\tif (foundAnyMatchingView){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n",
    "new_code_raw": "\tpublic boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll, boolean visible) {\n\t\tfinal long endTime = System.currentTimeMillis() + TIMEOUT;\n\n\t\twhile (System.currentTimeMillis() < endTime) {\n\t\t\tsleeper.sleep();\n\t\t\tfinal boolean foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, scroll, visible);\n\t\t\tif (foundAnyMatchingView){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n"
  },
  {
    "id": "alibaba_jstorm-119-Param-0",
    "old_comment_raw": "@param prefered",
    "old_code_raw": "    public static int availablePort(int prefered) {\n        int rtn = -1;\n        try {\n            rtn = tryPort(prefered);\n        } catch (IOException e) {\n\n        }\n        return rtn;\n    }\n",
    "new_code_raw": "    public static int availablePort(int preferred) {\n        int rtn = -1;\n        try {\n            rtn = tryPort(preferred);\n        } catch (IOException ignored) {\n        }\n        return rtn;\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2365-Param-1",
    "old_comment_raw": "@param root The root of the Tree",
    "old_code_raw": "  public Collection<TreeGraphNode> getRelatedNodes(TreeGraphNode t, TreeGraphNode root, HeadFinder headFinder) {\n    Set<TreeGraphNode> nodeList = new ArraySet<>();\n    for (TregexPattern p : targetPatterns) {    // cdm: I deleted: && nodeList.isEmpty()\n      // Initialize the TregexMatcher with the HeadFinder so that we\n      // can use the same HeadFinder through the entire process of\n      // building the dependencies\n      TregexMatcher m = p.matcher(root, headFinder);\n      while (m.findAt(t)) {\n        TreeGraphNode target = (TreeGraphNode) m.getNode(\"target\");\n        if (target == null) {\n          throw new AssertionError(\"Expression has no target: \" + p);\n        }\n        nodeList.add(target);\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \"-\" + t.headWordNode() + \", \" + m.getNode(\"target\") + \"-\" + ((TreeGraphNode) m.getNode(\"target\")).headWordNode() + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\"))\n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n",
    "new_code_raw": "  public Collection<Tree> getRelatedNodes(Tree t, Tree root) {\n    if (root.value() == null) {\n      root.setValue(\"ROOT\");  // todo: cdm: it doesn't seem like this line should be here\n    }\n    Set<Tree> nodeList = new LinkedHashSet<Tree>();\n    for (TregexPattern p : targetPatterns) {    // cdm: I deleted: && nodeList.isEmpty()\n      TregexMatcher m = p.matcher(root);\n      while (m.findAt(t)) {\n        nodeList.add(m.getNode(\"target\"));\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\")) \n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n"
  },
  {
    "id": "galderz_rhq-131-Associations-Param0",
    "old_comment_raw": "@param pluginKey",
    "old_code_raw": "    public synchronized <T extends AbstractTypeServerPluginContainer> T getPluginContainerByPlugin(PluginKey pluginKey) {\n        for (AbstractTypeServerPluginContainer pc : this.pluginContainers.values()) {\n            try {\n                if (pc.getSupportedServerPluginType().equals(new ServerPluginType(pluginKey.getPluginType()))) {\n                    if (null != pc.getPluginManager().getPluginEnvironment(pluginKey.getPluginName())) {\n                        return (T) pc;\n                    }\n                }\n            } catch (Exception skip) {\n                // should never really happen\n                log.error(\"Bad plugin key: \" + pluginKey);\n            }\n        }\n        return null;\n    }\n",
    "new_code_raw": "    public synchronized <T extends AbstractTypeServerPluginContainer> T getPluginContainerByPlugin(String pluginName) {\n        for (AbstractTypeServerPluginContainer pc : this.pluginContainers.values()) {\n            if (null != pc.getPluginManager().getPluginEnvironment(pluginName)) {\n                return (T) pc;\n            }\n        }\n        return null;\n    }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-54-Param-3",
    "old_comment_raw": "@param newValue the value to set, in the units of the field",
    "old_code_raw": "    public int[] set(PartialInstant instant, int fieldIndex, int[] values, int newValue) {\n        FieldUtils.verifyValueBounds(this, newValue, getMinimumValue(instant, values), getMaximumValue(instant, values));\n        values[fieldIndex] = newValue;\n        \n        // may need to adjust smaller fields\n        if (fieldIndex < instant.getFieldSize()) {\n            for (int i = fieldIndex + 1; i < instant.getFieldSize(); i++) {\n                DateTimeField field = instant.getField(i);\n                if (values[i] > field.getMaximumValue(instant, values)) {\n                    values[i] = field.getMaximumValue(instant, values);\n                }\n                if (values[i] < field.getMinimumValue(instant, values)) {\n                    values[i] = field.getMinimumValue(instant, values);\n                }\n            }\n        }\n        return values;\n    }\n",
    "new_code_raw": "    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, int newValue) {\n        FieldUtils.verifyValueBounds(this, newValue, getMinimumValue(instant, values), getMaximumValue(instant, values));\n        values[fieldIndex] = newValue;\n        \n        // may need to adjust smaller fields\n        if (fieldIndex < instant.getFieldSize()) {\n            for (int i = fieldIndex + 1; i < instant.getFieldSize(); i++) {\n                DateTimeField field = instant.getField(i);\n                if (values[i] > field.getMaximumValue(instant, values)) {\n                    values[i] = field.getMaximumValue(instant, values);\n                }\n                if (values[i] < field.getMinimumValue(instant, values)) {\n                    values[i] = field.getMinimumValue(instant, values);\n                }\n            }\n        }\n        return values;\n    }\n"
  },
  {
    "id": "yahoo_gondola-0-Associations-Param0",
    "old_comment_raw": "@param entryId",
    "old_code_raw": "    public String getValue(String entryId) throws RecordNotFoundException {\n        if (!entries.containsKey(entryId)) {\n            throw new RecordNotFoundException();\n        }\n        return entries.get(entryId);\n    }\n",
    "new_code_raw": "    public String getValue(String key) throws NotFoundException, NotLeaderException {\n        if (cluster.getLocalRole() != Role.LEADER) {\n            throw new NotLeaderException();\n        }\n        if (!entries.containsKey(key)) {\n            throw new NotFoundException();\n        }\n        String value = entries.get(key);\n        logger.info(String.format(\"Get key %s: %s\", key, value));\n        return value;\n    }\n\n"
  },
  {
    "id": "zaproxy_zaproxy-2116-Param-0",
    "old_comment_raw": "@param sb",
    "old_code_raw": "    private boolean paramAppend(StringBuffer sb, String name, String value) {\n        boolean isEdited = false;\n        if (name != null) {\n            sb.append(name);\n            isEdited = true;\n        }\n        if (value != null) {\n            sb.append('=');\n            sb.append(value);\n            isEdited = true;\n        }\n        return isEdited;\n    }\n",
    "new_code_raw": "    private boolean paramAppend(StringBuilder sb, String name, String value) {\n        boolean isEdited = false;\n        if (name != null) {\n            sb.append(name);\n            isEdited = true;\n        }\n        if (value != null) {\n            sb.append('=');\n            sb.append(value);\n            isEdited = true;\n        }\n        return isEdited;\n    }\n"
  },
  {
    "id": "eclipse_rt.equinox.bundles-62-Associations-Param0",
    "old_comment_raw": "@param type the identifier for the required type handler. This identifier may be one of those listed in  STextTypeHandlerFactory or it may be have been registered by a plug-in.",
    "old_code_raw": "\tstatic public ISTextExpert getStatefulExpert(String type, STextEnvironment environment) {\n\t\tSTextTypeHandler handler = STextTypeHandlerFactory.getHandler(type);\n\t\tif (handler == null)\n\t\t\tthrow new IllegalArgumentException(\"Invalid type argument\"); //$NON-NLS-1$\n\t\treturn getStatefulExpert(handler, environment);\n\t}\n",
    "new_code_raw": "\tstatic public IStructuredTextExpert getStatefulExpert(String type, StructuredTextEnvironment environment) {\n\t\tStructuredTextTypeHandler handler = StructuredTextTypeHandlerFactory.getHandler(type);\n\t\tif (handler == null)\n\t\t\tthrow new IllegalArgumentException(\"Invalid type argument\"); //$NON-NLS-1$\n\t\treturn getStatefulExpert(handler, environment);\n\t}\n\n"
  },
  {
    "id": "zaproxy_zaproxy-2007-Param-0",
    "old_comment_raw": "@param plugin",
    "old_code_raw": "    private boolean scanSingleNode(Plugin plugin, SiteNode node) {\n        Thread thread;\n        Plugin test;\n        HttpMessage msg;\n        \n        log.debug(\"scanSingleNode node plugin=\" + plugin.getName() + \" node=\" + node);\n\n        // do not poll for isStop here to allow every plugin to run but terminate immediately.\n        //if (isStop()) return;\n\n        try {\n            if (node == null || node.getHistoryReference() == null) {\n                log.debug(\"scanSingleNode node or href null, returning: node=\" + node);\n                return false;\n            }\n            \n            if (HistoryReference.TYPE_SCANNER == node.getHistoryReference().getHistoryType()) {\n                log.debug(\"Ignoring \\\"scanner\\\" type href\");\n                return false;\n            }\n\n            if (!nodeInScope(node)) {\n                log.debug(\"scanSingleNode node not in scope\");\n                return false;\n            }\n            \n            msg = node.getHistoryReference().getHttpMessage();\n\n            if (msg == null) {\n                // Likely to be a temporary node\n                log.debug(\"scanSingleNode msg null\");\n                return false;\n            }\n\n            test = plugin.getClass().newInstance();\n            test.setConfig(plugin.getConfig());\n            test.setDelayInMs(plugin.getDelayInMs());\n            test.setDefaultAlertThreshold(plugin.getAlertThreshold());\n            test.setDefaultAttackStrength(plugin.getAttackStrength());\n            test.setTechSet(getTechSet());\n            test.init(msg, this);\n            notifyHostProgress(plugin.getName() + \": \" + msg.getRequestHeader().getURI().toString());\n\n        } catch (Exception e) {\n            if (node != null) {\n                log.error(e.getMessage() + \" \" + node.getNodeName(), e);\n                \n            } else {\n                log.error(e.getMessage(), e);\n            }\n            \n            return false;\n        }\n\n        do {\n            thread = threadPool.getFreeThreadAndRun(test);\n            if (thread == null) {\n                Util.sleep(200);\n            }\n            \n        } while (thread == null);\n\n        return true;\n    }\n",
    "new_code_raw": "    private boolean scanSingleNode(Plugin plugin, StructuralNode node) {\n        Thread thread;\n        Plugin test;\n        HttpMessage msg;\n        \n        log.debug(\"scanSingleNode node plugin=\" + plugin.getName() + \" node=\" + node.getName());\n\n        // do not poll for isStop here to allow every plugin to run but terminate immediately.\n        //if (isStop()) return;\n\n        try {\n            if (node == null || node.getHistoryReference() == null) {\n                log.debug(\"scanSingleNode node or href null, returning: node=\" + node);\n                return false;\n            }\n            \n            if (HistoryReference.TYPE_SCANNER == node.getHistoryReference().getHistoryType()) {\n                log.debug(\"Ignoring \\\"scanner\\\" type href\");\n                return false;\n            }\n\n            if (!nodeInScope(node.getName())) {\n                log.debug(\"scanSingleNode node not in scope\");\n                return false;\n            }\n            \n            msg = node.getHistoryReference().getHttpMessage();\n\n            if (msg == null) {\n                // Likely to be a temporary node\n                log.debug(\"scanSingleNode msg null\");\n                return false;\n            }\n\n            test = plugin.getClass().newInstance();\n            test.setConfig(plugin.getConfig());\n            test.setDelayInMs(plugin.getDelayInMs());\n            test.setDefaultAlertThreshold(plugin.getAlertThreshold());\n            test.setDefaultAttackStrength(plugin.getAttackStrength());\n            test.setTechSet(getTechSet());\n            test.init(msg, this);\n            notifyHostProgress(plugin.getName() + \": \" + msg.getRequestHeader().getURI().toString());\n\n        } catch (Exception e) {\n            log.error(e.getMessage() + \" \" + node.getName(), e);\n            return false;\n        }\n\n        do {\n\t\t\tif (this.isStop()) {\n\t\t\t\treturn false;\n\t\t\t}\n            thread = threadPool.getFreeThreadAndRun(test);\n            if (thread == null) {\n                Util.sleep(200);\n            }\n            \n        } while (thread == null);\n\n        return true;\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1664-Param-0",
    "old_comment_raw": "@param body order placed for purchasing the pet (required)",
    "old_code_raw": "    public Order placeOrder(Order body) throws ApiException {\n        ApiResponse<Order> resp = placeOrderWithHttpInfo(body);\n        return resp.getData();\n    }\n",
    "new_code_raw": "    public Order placeOrder(Order order) throws ApiException {\n        ApiResponse<Order> resp = placeOrderWithHttpInfo(order);\n        return resp.getData();\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-649-Param-1",
    "old_comment_raw": "@param associationType The type representing the thing to be joined into.",
    "old_code_raw": "\tpublic JoinSequence createJoinSequence(boolean implicit, AssociationType associationType, String tableAlias, int joinType, String[] columns) {\n\t\tJoinSequence joinSequence = createJoinSequence();\n\t\tjoinSequence.setUseThetaStyle( implicit );\t// Implicit joins use theta style (WHERE pk = fk), explicit joins use JOIN (after from)\n\t\tjoinSequence.addJoin( associationType, tableAlias, joinType, columns );\n\t\treturn joinSequence;\n\t}\n",
    "new_code_raw": "\tpublic JoinSequence createJoinSequence(boolean implicit, AssociationType associationType, String tableAlias, JoinType joinType, String[] columns) {\n\t\tJoinSequence joinSequence = createJoinSequence();\n\t\tjoinSequence.setUseThetaStyle( implicit );\t// Implicit joins use theta style (WHERE pk = fk), explicit joins use JOIN (after from)\n\t\tjoinSequence.addJoin( associationType, tableAlias, joinType, columns );\n\t\treturn joinSequence;\n\t}\n"
  },
  {
    "id": "dropwizard_dropwizard-37-Associations-Param0",
    "old_comment_raw": "@param name the filter's name",
    "old_code_raw": "    public FilterRegistration.Dynamic addFilter(String name, Class<? extends Filter> klass) {\n        final FilterHolder holder = new FilterHolder(checkNotNull(klass));\n        holder.setName(name);\n        handler.getServletHandler().addFilter(holder);\n        return holder.getRegistration();\n    }\n",
    "new_code_raw": "    public FilterBuilder addFilter(Class<? extends Filter> klass,\n                                   String urlPattern) {\n        final FilterHolder holder = new FilterHolder(checkNotNull(klass));\n        final FilterBuilder filterConfig = new FilterBuilder(holder, handler);\n        filterConfig.addUrlPattern(checkNotNull(urlPattern));\n        return filterConfig;\n    }\n\n"
  },
  {
    "id": "querydsl_querydsl-569-Param-1",
    "old_comment_raw": "@param ex",
    "old_code_raw": "    public RuntimeException translate(String sql, SQLException ex) {\n        return exceptionTranslator.translate(sql, ex);\n    }\n",
    "new_code_raw": "    public RuntimeException translate(String sql, List<Object> bindings, SQLException ex) {\n        return exceptionTranslator.translate(sql, bindings, ex);\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-321-Param-1",
    "old_comment_raw": "@param methodName The method name.",
    "old_code_raw": "\tprivate static Method getMethod(Class<?> clazz, String methodName) {\n\t\ttry {\n\t\t\tchar string[] = methodName.toCharArray();\n\t\t\tstring[0] = Character.toUpperCase( string[0] );\n\t\t\tmethodName = new String( string );\n\t\t\ttry {\n\t\t\t\treturn clazz.getDeclaredMethod( \"get\" + methodName );\n\t\t\t}\n\t\t\tcatch ( NoSuchMethodException e ) {\n\t\t\t\treturn clazz.getDeclaredMethod( \"is\" + methodName );\n\t\t\t}\n\t\t}\n\t\tcatch ( NoSuchMethodException e ) {\n\t\t\treturn null;\n\t\t}\n\t}\n",
    "new_code_raw": "\tprivate static Method getMethod(Class<?> clazz, String attributeName) {\n\t\ttry {\n\t\t\tchar string[] = attributeName.toCharArray();\n\t\t\tstring[0] = Character.toUpperCase( string[0] );\n\t\t\tString casedAttributeName = new String( string );\n\t\t\ttry {\n\t\t\t\treturn clazz.getDeclaredMethod( \"get\" + casedAttributeName );\n\t\t\t}\n\t\t\tcatch ( NoSuchMethodException e ) {\n\t\t\t\treturn clazz.getDeclaredMethod( \"is\" + casedAttributeName );\n\t\t\t}\n\t\t}\n\t\tcatch ( NoSuchMethodException e ) {\n\t\t\treturn null;\n\t\t}\n\t}\n"
  },
  {
    "id": "debezium_debezium-182-Param-2",
    "old_comment_raw": "@param fieldDefn the field definition; never null",
    "old_code_raw": "    protected Object convertSetToString(String options, Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return \"\";\n        }\n        if (data instanceof String) {\n            // JDBC should return strings ...\n            return data;\n        }\n        if (data instanceof Long) {\n            // The binlog will contain a long with the indexes of the options in the set value ...\n            long indexes = ((Long) data).longValue();\n            return convertSetValue(indexes, options);\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n",
    "new_code_raw": "    protected Object convertSetToString(List<String> options, Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return \"\";\n        }\n        if (data instanceof String) {\n            // JDBC should return strings ...\n            return data;\n        }\n        if (data instanceof Long) {\n            // The binlog will contain a long with the indexes of the options in the set value ...\n            long indexes = ((Long) data).longValue();\n            return convertSetValue(indexes, options);\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n"
  },
  {
    "id": "svn2github_my-33-Associations-Param0",
    "old_comment_raw": "@param id the module.",
    "old_code_raw": "    public synchronized final List<String> getDependentModulesRecursively(final String id) throws Exception {\r\n        final List<String> res = new ArrayList<String>();\r\n        for (final String depModule : getDependentModules(id)) {\r\n            res.add(depModule);\r\n            // the graph has no cycle, so we don't need to protected against infinite loop\r\n\r\n            res.addAll(this.getDependentModulesRecursively(depModule));\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n",
    "new_code_raw": "    public final List<ModuleReference> getDependentModulesRecursively(final ModuleReference ref) throws Exception {\r\n        return getDependentModulesRecursively(ref, new ArrayList<ModuleReference>());\r\n    }\r\n\n"
  },
  {
    "id": "graphql_java_graphql_java-263-Param-0",
    "old_comment_raw": "@param executionContext contains the top level execution parameters",
    "old_code_raw": "    protected FieldValueInfo completeField(ExecutionContext executionContext, ExecutionStrategyParameters parameters, Object fetchedValue) {\n        Field field = parameters.getField().getSingleField();\n        GraphQLObjectType parentType = (GraphQLObjectType) parameters.getExecutionStepInfo().getUnwrappedNonNullType();\n        GraphQLFieldDefinition fieldDef = getFieldDef(executionContext.getGraphQLSchema(), parentType, field);\n        ExecutionStepInfo executionStepInfo = createExecutionStepInfo(executionContext, parameters, fieldDef);\n\n        Instrumentation instrumentation = executionContext.getInstrumentation();\n        InstrumentationFieldCompleteParameters instrumentationParams = new InstrumentationFieldCompleteParameters(executionContext, parameters, fieldDef, executionStepInfo, fetchedValue);\n        InstrumentationContext<ExecutionResult> ctxCompleteField = instrumentation.beginFieldComplete(\n                instrumentationParams\n        );\n\n        GraphQLCodeRegistry codeRegistry = executionContext.getGraphQLSchema().getCodeRegistry();\n        Map<String, Object> argumentValues = valuesResolver.getArgumentValues(codeRegistry, fieldDef.getArguments(), field.getArguments(), executionContext.getVariables());\n\n        NonNullableFieldValidator nonNullableFieldValidator = new NonNullableFieldValidator(executionContext, executionStepInfo);\n\n        ExecutionStrategyParameters newParameters = parameters.transform(builder ->\n                builder.executionStepInfo(executionStepInfo)\n                        .arguments(argumentValues)\n                        .source(fetchedValue)\n                        .nonNullFieldValidator(nonNullableFieldValidator)\n        );\n\n        log.debug(\"'{}' completing field '{}'...\", executionContext.getExecutionId(), executionStepInfo.getPath());\n\n        FieldValueInfo fieldValueInfo = completeValue(executionContext, newParameters);\n\n        CompletableFuture<ExecutionResult> executionResultFuture = fieldValueInfo.getFieldValue();\n        ctxCompleteField.onDispatched(executionResultFuture);\n        executionResultFuture.whenComplete(ctxCompleteField::onCompleted);\n        return fieldValueInfo;\n    }\n",
    "new_code_raw": "    protected FieldValueInfo completeField(ExecutionContext executionContext, ExecutionStrategyParameters parameters, FetchedValue fetchedValue) {\n        Field field = parameters.getField().getSingleField();\n        GraphQLObjectType parentType = (GraphQLObjectType) parameters.getExecutionStepInfo().getUnwrappedNonNullType();\n        GraphQLFieldDefinition fieldDef = getFieldDef(executionContext.getGraphQLSchema(), parentType, field);\n        ExecutionStepInfo executionStepInfo = createExecutionStepInfo(executionContext, parameters, fieldDef);\n\n        Instrumentation instrumentation = executionContext.getInstrumentation();\n        InstrumentationFieldCompleteParameters instrumentationParams = new InstrumentationFieldCompleteParameters(executionContext, parameters, fieldDef, executionStepInfo, fetchedValue);\n        InstrumentationContext<ExecutionResult> ctxCompleteField = instrumentation.beginFieldComplete(\n                instrumentationParams\n        );\n\n        GraphQLCodeRegistry codeRegistry = executionContext.getGraphQLSchema().getCodeRegistry();\n        Map<String, Object> argumentValues = valuesResolver.getArgumentValues(codeRegistry, fieldDef.getArguments(), field.getArguments(), executionContext.getVariables());\n\n        NonNullableFieldValidator nonNullableFieldValidator = new NonNullableFieldValidator(executionContext, executionStepInfo);\n\n        ExecutionStrategyParameters newParameters = parameters.transform(builder ->\n                builder.executionStepInfo(executionStepInfo)\n                        .arguments(argumentValues)\n                        .source(fetchedValue.getFetchedValue())\n                        .localContext(fetchedValue.getLocalContext())\n                        .nonNullFieldValidator(nonNullableFieldValidator)\n        );\n\n        log.debug(\"'{}' completing field '{}'...\", executionContext.getExecutionId(), executionStepInfo.getPath());\n\n        FieldValueInfo fieldValueInfo = completeValue(executionContext, newParameters);\n\n        CompletableFuture<ExecutionResult> executionResultFuture = fieldValueInfo.getFieldValue();\n        ctxCompleteField.onDispatched(executionResultFuture);\n        executionResultFuture.whenComplete(ctxCompleteField::onCompleted);\n        return fieldValueInfo;\n    }\n"
  },
  {
    "id": "dropwizard_dropwizard-36-Associations-Param0",
    "old_comment_raw": "@param name the filter's name",
    "old_code_raw": "    public FilterRegistration.Dynamic addFilter(String name, Filter filter) {\n        final FilterHolder holder = new FilterHolder(checkNotNull(filter));\n        holder.setName(name);\n        handler.getServletHandler().addFilter(holder);\n        return holder.getRegistration();\n    }\n",
    "new_code_raw": "    public FilterBuilder addFilter(Filter filter,\n                                   String urlPattern) {\n        final FilterHolder holder = new FilterHolder(checkNotNull(filter));\n        final FilterBuilder builder = new FilterBuilder(holder, handler);\n        builder.addUrlPattern(checkNotNull(urlPattern));\n        return builder;\n    }\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-686-Param-3",
    "old_comment_raw": "@param scale The datatype scale",
    "old_code_raw": "\tpublic String getTypeName(int code, int length, int precision, int scale) throws HibernateException {\n\t\tString result = typeNames.get( code, length, precision, scale );\n\t\tif ( result == null ) {\n\t\t\tthrow new HibernateException(\n\t\t\t\t\t\"No type mapping for java.sql.Types code: \" +\n\t\t\t\t\tcode +\n\t\t\t\t\t\", length: \" +\n\t\t\t\t\tlength\n\t\t\t);\n\t\t}\n\t\treturn result;\n\t}\n",
    "new_code_raw": "\tpublic String getTypeName(int code, long length, int precision, int scale) throws HibernateException {\n\t\tString result = typeNames.get( code, length, precision, scale );\n\t\tif ( result == null ) {\n\t\t\tthrow new HibernateException(\n\t\t\t\t\t\"No type mapping for java.sql.Types code: \" +\n\t\t\t\t\tcode +\n\t\t\t\t\t\", length: \" +\n\t\t\t\t\tlength\n\t\t\t);\n\t\t}\n\t\treturn result;\n\t}\n"
  },
  {
    "id": "eclipse_eclipse.platform.releng-4-Associations-Param1",
    "old_comment_raw": "@param global",
    "old_code_raw": "    public static SummaryEntry[] querySummaries(Variations variationPatterns, boolean global) {\n        return getDefault().internalQuerySummaries(variationPatterns, null);\n    }\n",
    "new_code_raw": "    public static SummaryEntry[] querySummaries(Variations variationPatterns, String scenarioPattern) {\n        return getDefault().internalQuerySummaries(variationPatterns, scenarioPattern);\n    }\n\n"
  },
  {
    "id": "socketio_socket.io_client_java-11-Param-1",
    "old_comment_raw": "@param args data to send.",
    "old_code_raw": "    public Emitter emit(final String event, final Object... arguments) {\n        EventThread.exec(new Runnable() {\n            @Override\n            public void run() {\n                if (events.containsKey(event)) {\n                    Socket.super.emit(event, arguments);\n                    return;\n                }\n\n                List<Object> args = new ArrayList<Object>(arguments.length + 1);\n                args.add(event);\n                args.addAll(Arrays.asList(arguments));\n                JSONArray _args = new JSONArray(args);\n                int parserType = Parser.EVENT;\n                if (HasBinaryData.hasBinary(_args)) { parserType = Parser.BINARY_EVENT; }\n                Packet packet = new Packet(parserType, _args);\n\n                if (args.get(args.size() - 1) instanceof Ack) {\n                    logger.fine(String.format(\"emitting packet with ack id %d\", Socket.this.ids));\n                    Socket.this.acks.put(Socket.this.ids, (Ack)args.remove(args.size() - 1));\n                    packet.id = Socket.this.ids++;\n                }\n\n                Socket.this.packet(packet);\n            }\n        });\n        return this;\n    }\n",
    "new_code_raw": "    public Emitter emit(final String event, final Object... args) {\n        EventThread.exec(new Runnable() {\n            @Override\n            public void run() {\n                if (events.containsKey(event)) {\n                    Socket.super.emit(event, args);\n                    return;\n                }\n\n                List<Object> _args = new ArrayList<Object>(args.length + 1);\n                _args.add(event);\n                _args.addAll(Arrays.asList(args));\n                JSONArray jsonArgs = new JSONArray(_args);\n                int parserType = Parser.EVENT;\n                if (HasBinaryData.hasBinary(jsonArgs)) { parserType = Parser.BINARY_EVENT; }\n                Packet packet = new Packet(parserType, jsonArgs);\n\n                if (_args.get(_args.size() - 1) instanceof Ack) {\n                    logger.fine(String.format(\"emitting packet with ack id %d\", Socket.this.ids));\n                    Socket.this.acks.put(Socket.this.ids, (Ack)_args.remove(_args.size() - 1));\n                    packet.id = Socket.this.ids++;\n                }\n\n                Socket.this.packet(packet);\n            }\n        });\n        return this;\n    }\n"
  },
  {
    "id": "processing_processing-1243-Param-0",
    "old_comment_raw": "@param parent The PGraphics object (or any object, really) associated",
    "old_code_raw": "  public Object getCache(Object parent) {\n    if (cacheMap == null) return null;\n    return cacheMap.get(parent);\n  }\n",
    "new_code_raw": "  public PMetadata getCache(PGraphics renderer) {\n    if (cacheMap == null) return null;\n    return cacheMap.get(renderer);\n  }\n"
  },
  {
    "id": "RobotiumTech_robotium-1187-Param-3",
    "old_comment_raw": "@param scroll  true if scrolling should be performed",
    "old_code_raw": "\tpublic boolean waitForText(String text, int matches, long timeout, boolean scroll) {\n        final long endTime = System.currentTimeMillis() + timeout;\n\n\t\twhile (true) {\n\t\t\tfinal boolean timedOut = System.currentTimeMillis() > endTime;\n\t\t\tif (timedOut){\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tsleeper.sleep();\n\n\t\t\tfinal boolean foundAnyTextView = searcher.searchFor(TextView.class, text, matches, scroll);\n\t\t\tif (foundAnyTextView){\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfinal boolean foundAnyEditText = searcher.searchFor(EditText.class, text, 1, scroll);\n\t\t\tif (foundAnyEditText){\n\t\t\t\treturn true;\n\t\t\t}\n        }\n    }\n",
    "new_code_raw": "\tpublic boolean waitForText(String text, int expectedMinimumNumberOfMatches, long timeout, boolean scroll) {\n        final long endTime = System.currentTimeMillis() + timeout;\n\n\t\twhile (true) {\n\t\t\tfinal boolean timedOut = System.currentTimeMillis() > endTime;\n\t\t\tif (timedOut){\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tsleeper.sleep();\n\n\t\t\tfinal boolean foundAnyTextView = searcher.searchFor(TextView.class, text, expectedMinimumNumberOfMatches, scroll);\n\t\t\tif (foundAnyTextView){\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfinal boolean foundAnyEditText = searcher.searchFor(EditText.class, text, 1, scroll);\n\t\t\tif (foundAnyEditText){\n\t\t\t\treturn true;\n\t\t\t}\n        }\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1623-Param-1",
    "old_comment_raw": "@param model Swagger Model object",
    "old_code_raw": "    public CodegenModel fromModel(String name, Model model, Map<String, Model> allDefinitions) {\n        CodegenModel codegenModel = super.fromModel(name, model, allDefinitions);\n        return codegenModel;\n    }\n",
    "new_code_raw": "    public CodegenModel fromModel(String name, Schema model, Map<String, Schema> allDefinitions) {\n        CodegenModel codegenModel = super.fromModel(name, model, allDefinitions);\n        return codegenModel;\n    }\n"
  },
  {
    "id": "zaproxy_zaproxy-2017-Param-1",
    "old_comment_raw": "@param n",
    "old_code_raw": "    private static void algC(StringBuilder sb, int m, int n, String a, String b) {\n        int i;\n        int j;\n\n        // Step 1\n        if (n == 0) {\n            // Nothing to do\n        } else if (m == 1) {\n            for (j = 0; j < n; j++) {\n                if (a.charAt(0) == b.charAt(j)) {\n                    sb.append(a.charAt(0));\n                    break;\n                }\n            }\n\n        // Step 2\n        } else {\n            i = (int)Math.floor(((double) m) / 2);\n\n            // Step 3\n            int[] l1 = algB(i, n, a.substring(0, i), b);\n            int[] l2 = algB(m - i, n, reverseString(a.substring(i)), reverseString(b));\n\n            // Step 4\n            int k = findK(l1, l2, n);\n\n            // Step 5\n            algC(sb, i, k, a.substring(0, i), b.substring(0, k));\n            algC(sb, m - i, n - k, a.substring(i), b.substring(k));\n        }\n    }\n",
    "new_code_raw": "    private String algC(int m, int n, String a, String b) {\n        int i;\n        int j;\n        StringBuilder sb;\n\n        // Step 1\n        if (n == 0) {\n            sb = new StringBuilder();\n            \n        } else if (m == 1) {\n            sb = new StringBuilder();\n            for (j = 0; j < n; j++) {\n                if (a.charAt(0) == b.charAt(j)) {\n                    sb = new StringBuilder(a.charAt(0));\n                    break;\n                }\n            }\n\n        // Step 2\n        } else {\n            i = (int)Math.floor(((double) m) / 2);\n\n            // Step 3\n            int[] l1 = algB(i, n, a.substring(0, i), b);\n            int[] l2 = algB(m - i, n, reverseString(a.substring(i)), reverseString(b));\n\n            // Step 4\n            int k = findK(l1, l2, n);\n\n            // Step 5\n            sb = new StringBuilder(algC(i, k, a.substring(0, i), b.substring(0, k)));\n            sb.append(algC(m - i, n - k, a.substring(i), b.substring(k)));\n        }\n\n        // Return the LCS\n        return sb.toString();\n    }\n"
  },
  {
    "id": "apache_drill-1013-Param-1",
    "old_comment_raw": "@param metaFilePath metadata cache file path",
    "old_code_raw": "  private FileSelection expandSelectionFromMetadataCache(FileSelection selection, Path metaFilePath) throws IOException {\n    // get the metadata for the root directory by reading the metadata file\n    // parquetTableMetadata contains the metadata for all files in the selection root folder, but we need to make sure\n    // we only select the files that are part of selection (by setting fileSet appropriately)\n\n    // get (and set internal field) the metadata for the directory by reading the metadata file\n    FileSystem processUserFileSystem = ImpersonationUtil.createFileSystem(ImpersonationUtil.getProcessUserName(), fs.getConf());\n    parquetTableMetadata = Metadata.readBlockMeta(processUserFileSystem, metaFilePath, metaContext, readerConfig);\n    if (ignoreExpandingSelection(parquetTableMetadata)) {\n      return selection;\n    }\n    if (corruptDatesAutoCorrected) {\n      ParquetReaderUtility.correctDatesInMetadataCache(this.parquetTableMetadata);\n    }\n    ParquetReaderUtility.transformBinaryInMetadataCache(parquetTableMetadata, readerConfig);\n    List<FileStatus> fileStatuses = selection.getStatuses(fs);\n\n    if (fileSet == null) {\n      fileSet = new HashSet<>();\n    }\n\n    final Path first = fileStatuses.get(0).getPath();\n    if (fileStatuses.size() == 1 && selection.getSelectionRoot().equals(first)) {\n      // we are selecting all files from selection root. Expand the file list from the cache\n      for (MetadataBase.ParquetFileMetadata file : parquetTableMetadata.getFiles()) {\n        fileSet.add(file.getPath());\n      }\n\n    } else if (selection.isExpandedPartial() && !selection.hadWildcard() && cacheFileRoot != null) {\n      if (selection.wasAllPartitionsPruned()) {\n        // if all partitions were previously pruned, we only need to read 1 file (for the schema)\n        fileSet.add(this.parquetTableMetadata.getFiles().get(0).getPath());\n      } else {\n        // we are here if the selection is in the expanded_partial state (i.e it has directories).  We get the\n        // list of files from the metadata cache file that is present in the cacheFileRoot directory and populate\n        // the fileSet. However, this is *not* the final list of files that will be scanned in execution since the\n        // second phase of partition pruning will apply on the files and modify the file selection appropriately.\n        for (MetadataBase.ParquetFileMetadata file : this.parquetTableMetadata.getFiles()) {\n          fileSet.add(file.getPath());\n        }\n      }\n    } else {\n      // we need to expand the files from fileStatuses\n      for (FileStatus status : fileStatuses) {\n        Path currentCacheFileRoot = status.getPath();\n        if (status.isDirectory()) {\n          //TODO [DRILL-4496] read the metadata cache files in parallel\n          Path metaPath = new Path(currentCacheFileRoot, Metadata.METADATA_FILENAME);\n          MetadataBase.ParquetTableMetadataBase metadata = Metadata.readBlockMeta(processUserFileSystem, metaPath, metaContext, readerConfig);\n          if (ignoreExpandingSelection(metadata)) {\n            return selection;\n          }\n          for (MetadataBase.ParquetFileMetadata file : metadata.getFiles()) {\n            fileSet.add(file.getPath());\n          }\n        } else {\n          final Path path = Path.getPathWithoutSchemeAndAuthority(currentCacheFileRoot);\n          fileSet.add(path);\n        }\n      }\n    }\n\n    if (fileSet.isEmpty()) {\n      // no files were found, most likely we tried to query some empty sub folders\n      logger.warn(\"The table is empty but with outdated invalid metadata cache files. Please, delete them.\");\n      return null;\n    }\n\n    List<Path> fileNames = new ArrayList<>(fileSet);\n\n    // when creating the file selection, set the selection root without the URI prefix\n    // The reason is that the file names above have been created in the form\n    // /a/b/c.parquet and the format of the selection root must match that of the file names\n    // otherwise downstream operations such as partition pruning can break.\n    Path metaRootPath = Path.getPathWithoutSchemeAndAuthority(selection.getSelectionRoot());\n    this.selectionRoot = metaRootPath;\n\n    // Use the FileSelection constructor directly here instead of the FileSelection.create() method\n    // because create() changes the root to include the scheme and authority; In future, if create()\n    // is the preferred way to instantiate a file selection, we may need to do something different...\n    // WARNING: file statuses and file names are inconsistent\n    FileSelection newSelection = new FileSelection(selection.getStatuses(fs), fileNames, metaRootPath, cacheFileRoot,\n        selection.wasAllPartitionsPruned());\n\n    newSelection.setExpandedFully();\n    newSelection.setMetaContext(metaContext);\n    return newSelection;\n  }\n",
    "new_code_raw": "  private FileSelection expandSelectionFromMetadataCache(FileSelection selection, List<Path> metaFilePaths) throws IOException {\n    // get the metadata for the root directory by reading the metadata file\n    // parquetTableMetadata contains the metadata for all files in the selection root folder, but we need to make sure\n    // we only select the files that are part of selection (by setting fileSet appropriately)\n\n    // get (and set internal field) the metadata for the directory by reading the metadata file\n    FileSystem processUserFileSystem = ImpersonationUtil.createFileSystem(ImpersonationUtil.getProcessUserName(), fs.getConf());\n    parquetTableMetadata = Metadata.readBlockMeta(processUserFileSystem, metaFilePaths, metaContext, readerConfig);\n    if (ignoreExpandingSelection(parquetTableMetadata)) {\n      return selection;\n    }\n    if (corruptDatesAutoCorrected) {\n      ParquetReaderUtility.correctDatesInMetadataCache(this.parquetTableMetadata);\n    }\n    ParquetReaderUtility.transformBinaryInMetadataCache(parquetTableMetadata, readerConfig);\n    List<FileStatus> fileStatuses = selection.getStatuses(fs);\n\n    if (fileSet == null) {\n      fileSet = new HashSet<>();\n    }\n\n    final Path first = fileStatuses.get(0).getPath();\n    if (fileStatuses.size() == 1 && selection.getSelectionRoot().equals(first)) {\n      // we are selecting all files from selection root. Expand the file list from the cache\n      for (MetadataBase.ParquetFileMetadata file : parquetTableMetadata.getFiles()) {\n        fileSet.add(file.getPath());\n      }\n\n    } else if (selection.isExpandedPartial() && !selection.hadWildcard() && cacheFileRoot != null) {\n      if (selection.wasAllPartitionsPruned()) {\n        // if all partitions were previously pruned, we only need to read 1 file (for the schema)\n        fileSet.add(this.parquetTableMetadata.getFiles().get(0).getPath());\n      } else {\n        // we are here if the selection is in the expanded_partial state (i.e it has directories).  We get the\n        // list of files from the metadata cache file that is present in the cacheFileRoot directory and populate\n        // the fileSet. However, this is *not* the final list of files that will be scanned in execution since the\n        // second phase of partition pruning will apply on the files and modify the file selection appropriately.\n        for (MetadataBase.ParquetFileMetadata file : this.parquetTableMetadata.getFiles()) {\n          fileSet.add(file.getPath());\n        }\n      }\n    } else {\n      // we need to expand the files from fileStatuses\n      for (FileStatus status : fileStatuses) {\n        Path currentCacheFileRoot = status.getPath();\n        if (status.isDirectory()) {\n          // TODO [DRILL-4496] read the metadata cache files in parallel\n          // Depending on the version of metadata this may represent more than 1 metadata file paths.\n          List<Path> metaPaths = populateMetaPaths(currentCacheFileRoot, fs);\n          MetadataBase.ParquetTableMetadataBase metadata = Metadata.readBlockMeta(processUserFileSystem, metaPaths, metaContext, readerConfig);\n          if (ignoreExpandingSelection(metadata)) {\n            return selection;\n          }\n          for (MetadataBase.ParquetFileMetadata file : metadata.getFiles()) {\n            fileSet.add(file.getPath());\n          }\n        } else {\n          final Path path = Path.getPathWithoutSchemeAndAuthority(currentCacheFileRoot);\n          fileSet.add(path);\n        }\n      }\n    }\n\n    if (fileSet.isEmpty()) {\n      // no files were found, most likely we tried to query some empty sub folders\n      logger.warn(\"The table is empty but with outdated invalid metadata cache files. Please, delete them.\");\n      return null;\n    }\n\n    List<Path> fileNames = new ArrayList<>(fileSet);\n\n    // when creating the file selection, set the selection root without the URI prefix\n    // The reason is that the file names above have been created in the form\n    // /a/b/c.parquet and the format of the selection root must match that of the file names\n    // otherwise downstream operations such as partition pruning can break.\n    Path metaRootPath = Path.getPathWithoutSchemeAndAuthority(selection.getSelectionRoot());\n    this.selectionRoot = metaRootPath;\n\n    // Use the FileSelection constructor directly here instead of the FileSelection.create() method\n    // because create() changes the root to include the scheme and authority; In future, if create()\n    // is the preferred way to instantiate a file selection, we may need to do something different...\n    // WARNING: file statuses and file names are inconsistent\n    FileSelection newSelection = new FileSelection(selection.getStatuses(fs), fileNames, metaRootPath, cacheFileRoot,\n        selection.wasAllPartitionsPruned());\n\n    newSelection.setExpandedFully();\n    newSelection.setMetaContext(metaContext);\n    return newSelection;\n  }\n"
  },
  {
    "id": "apache_activemq-603-Param-0",
    "old_comment_raw": "@param broker",
    "old_code_raw": "    public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name, int maxBatchSize, Subscription sub) {\n        return new FilePendingMessageCursor(broker,name,AbstractPendingMessageCursor.isPrioritizedMessageSubscriber(broker, sub));\n    }\n",
    "new_code_raw": "    public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name, int maxBatchSize, DurableTopicSubscription sub) {\n        return new FilePendingMessageCursor(broker,name,AbstractPendingMessageCursor.isPrioritizedMessageSubscriber(broker, sub));\n    }\n"
  },
  {
    "id": "zaproxy_zaproxy-2307-Param-2",
    "old_comment_raw": "@param value",
    "old_code_raw": "    protected String setEscapedParameter(HttpMessage msg, String param, String value) {\n        return variant.setEscapedParameter(msg, originalPair, param, value);\n    }\n",
    "new_code_raw": "    protected String setEscapedParameter(HttpMessage message, String param, String value) {\n        return variant.setEscapedParameter(message, originalPair, param, value);\n    }\n"
  },
  {
    "id": "MilosKozak_AndroidAPS-129-Param-0",
    "old_comment_raw": "@param request",
    "old_code_raw": "    public boolean applyAPSRequest(APSResult request, Callback callback) {\n        PumpInterface pump = getActivePump();\n        request.rate = applyBasalConstraints(request.rate);\n\n        if (!pump.isInitialized()) {\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpNotInitialized));\n            if (callback != null) {\n                callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpNotInitialized)).enacted(false).success(false)).run();\n            }\n            return false;\n        }\n\n        if (pump.isSuspended()) {\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpsuspended));\n            if (callback != null) {\n                callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpsuspended)).enacted(false).success(false)).run();\n            }\n            return false;\n        }\n\n        if (request.smb != 0) {\n            long lastSMBTime = getLastBolusTime();\n            if (lastSMBTime != 0 && lastSMBTime + 4.5 * 60 * 1000 > System.currentTimeMillis()) {\n                log.debug(\"SMB requsted but still in 5 min interval\");\n            } else {\n                DetailedBolusInfo detailedBolusInfo = new DetailedBolusInfo();\n                detailedBolusInfo.eventType = CareportalEvent.CORRECTIONBOLUS;\n                detailedBolusInfo.insulin = request.smb;\n                detailedBolusInfo.isSMB = true;\n                detailedBolusInfo.source = Source.USER;\n                getCommandQueue().bolus(detailedBolusInfo, callback);\n            }\n        }\n\n        if (Config.logCongigBuilderActions)\n            log.debug(\"applyAPSRequest: \" + request.toString());\n        if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - pump.getBaseBasalRate()) < pump.getPumpDescription().basalStep) {\n            if (isTempBasalInProgress()) {\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: cancelTempBasal()\");\n                getCommandQueue().cancelTempBasal(false, callback);\n                return true;\n            } else {\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: Basal set correctly\");\n                if (callback != null) {\n                    callback.result(new PumpEnactResult().absolute(request.rate).duration(0).enacted(false).success(true).comment(\"Basal set correctly\")).run();\n                }\n                return false;\n            }\n        } else if (isTempBasalInProgress()\n                && getTempBasalRemainingMinutesFromHistory() > 5\n                && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < pump.getPumpDescription().basalStep) {\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: Temp basal set correctly\");\n            if (callback != null) {\n                callback.result(new PumpEnactResult().absolute(getTempBasalAbsoluteRateHistory()).duration(getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes()).enacted(false).success(true).comment(\"Temp basal set correctly\")).run();\n            }\n            return false;\n        } else {\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: setTempBasalAbsolute()\");\n            getCommandQueue().tempBasalAbsolute(request.rate, request.duration, false, callback);\n            return true;\n        }\n    }\n",
    "new_code_raw": "    public PumpEnactResult applyAPSRequest(APSResult request) {\n        request.rate = applyBasalConstraints(request.rate);\n        PumpEnactResult result;\n\n        if (!isInitialized()) {\n            result = new PumpEnactResult();\n            result.comment = MainApp.sResources.getString(R.string.pumpNotInitialized);\n            result.enacted = false;\n            result.success = false;\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpNotInitialized));\n            return result;\n        }\n\n        if (isSuspended()) {\n            result = new PumpEnactResult();\n            result.comment = MainApp.sResources.getString(R.string.pumpsuspended);\n            result.enacted = false;\n            result.success = false;\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpsuspended));\n            return result;\n        }\n\n        if (Config.logCongigBuilderActions)\n            log.debug(\"applyAPSRequest: \" + request.toString());\n        if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - getBaseBasalRate()) < getPumpDescription().basalStep) {\n            if (isTempBasalInProgress()) {\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: cancelTempBasal()\");\n                result = cancelTempBasal(false);\n            } else {\n                result = new PumpEnactResult();\n                result.absolute = request.rate;\n                result.duration = 0;\n                result.enacted = false;\n                result.comment = \"Basal set correctly\";\n                result.success = true;\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: Basal set correctly\");\n            }\n        } else if (isTempBasalInProgress()\n                && getTempBasalRemainingMinutesFromHistory() > 5\n                && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < getPumpDescription().basalStep) {\n            result = new PumpEnactResult();\n            result.absolute = getTempBasalAbsoluteRateHistory();\n            result.duration = getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes();\n            result.enacted = false;\n            result.comment = \"Temp basal set correctly\";\n            result.success = true;\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: Temp basal set correctly\");\n        } else {\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: setTempBasalAbsolute()\");\n            result = setTempBasalAbsolute(request.rate, request.duration);\n        }\n        return result;\n    }\n"
  },
  {
    "id": "Atmosphere_atmosphere-825-Param-0",
    "old_comment_raw": "@param req the  HttpServletResponse",
    "old_code_raw": "    protected AtmosphereHandlerWrapper map(HttpServletRequest req) throws ServletException {\n        String path;\n        if (req.getPathInfo() != null) {\n            path = req.getServletPath() + req.getPathInfo();\n        } else {\n            path = req.getServletPath();\n        }\n        if (path == null || path.length() <= 1) {\n            path = \"/all\";\n        }\n\n        AtmosphereHandlerWrapper atmosphereHandlerWrapper = map(path);\n        if (atmosphereHandlerWrapper == null) {\n            atmosphereHandlerWrapper = map(\"/all\");\n        }\n\n        if (atmosphereHandlerWrapper == null) {\n            throw new AtmosphereMappingException(\"No AtmosphereHandler maps request for \" + path);\n        }\n        config.getBroadcasterFactory().add(atmosphereHandlerWrapper.broadcaster,\n                atmosphereHandlerWrapper.broadcaster.getID());\n        return atmosphereHandlerWrapper;\n    }\n",
    "new_code_raw": "    protected AtmosphereHandlerWrapper map(AtmosphereRequest req) throws ServletException {\n        String path;\n        if (req.getPathInfo() != null) {\n            path = req.getServletPath() + req.getPathInfo();\n        } else {\n            path = req.getServletPath();\n        }\n        if (path == null || path.length() <= 1) {\n            path = \"/all\";\n        }\n\n        AtmosphereHandlerWrapper atmosphereHandlerWrapper = map(path);\n        if (atmosphereHandlerWrapper == null) {\n            atmosphereHandlerWrapper = map(\"/all\");\n        }\n\n        if (atmosphereHandlerWrapper == null) {\n            throw new AtmosphereMappingException(\"No AtmosphereHandler maps request for \" + path);\n        }\n        config.getBroadcasterFactory().add(atmosphereHandlerWrapper.broadcaster,\n                atmosphereHandlerWrapper.broadcaster.getID());\n        return atmosphereHandlerWrapper;\n    }\n"
  },
  {
    "id": "elastic_elasticsearch_hadoop-21-Param-1",
    "old_comment_raw": "@param str the String to match",
    "old_code_raw": "    public static boolean simpleMatch(List<String> patterns, String str) {\n        if (patterns != null) {\n            for (String pattern : patterns) {\n                if (simpleMatch(pattern, str)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n",
    "new_code_raw": "    public static boolean simpleMatch(Collection<String> patterns, String str) {\n        if (patterns != null) {\n            for (String pattern : patterns) {\n                if (simpleMatch(pattern, str)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1923-Param-0",
    "old_comment_raw": "@param context the annotation binding context with access to the service registry and the annotation index",
    "old_code_raw": "\tpublic static Set<ConfiguredClassHierarchy<EntityClass>> createEntityHierarchies(AnnotationsBindingContext context) {\n\t\tClassLoaderService classLoaderService = context.getServiceRegistry().getService( ClassLoaderService.class );\n\t\tMap<ClassInfo, List<ClassInfo>> processedClassInfos = new HashMap<ClassInfo, List<ClassInfo>>();\n\n\t\tfor ( ClassInfo info : context.getIndex().getKnownClasses() ) {\n\t\t\tif ( !isEntityClass( info ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( processedClassInfos.containsKey( info ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tList<ClassInfo> configuredClassList = new ArrayList<ClassInfo>();\n\t\t\tClassInfo tmpClassInfo = info;\n\t\t\tClass<?> clazz = classLoaderService.classForName( tmpClassInfo.toString() );\n\t\t\twhile ( clazz != null && !clazz.equals( Object.class ) ) {\n\t\t\t\ttmpClassInfo = context.getIndex().getClassByName( DotName.createSimple( clazz.getName() ) );\n\t\t\t\tclazz = clazz.getSuperclass();\n\t\t\t\tif ( tmpClassInfo == null ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( existsHierarchyWithClassInfoAsLeaf( processedClassInfos, tmpClassInfo ) ) {\n\t\t\t\t\tList<ClassInfo> classInfoList = processedClassInfos.get( tmpClassInfo );\n\t\t\t\t\tfor ( ClassInfo tmpInfo : configuredClassList ) {\n\t\t\t\t\t\tclassInfoList.add( tmpInfo );\n\t\t\t\t\t\tprocessedClassInfos.put( tmpInfo, classInfoList );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconfiguredClassList.add( 0, tmpClassInfo );\n\t\t\t\t\tprocessedClassInfos.put( tmpClassInfo, configuredClassList );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSet<ConfiguredClassHierarchy<EntityClass>> hierarchies = new HashSet<ConfiguredClassHierarchy<EntityClass>>();\n\t\tList<List<ClassInfo>> processedList = new ArrayList<List<ClassInfo>>();\n\t\tfor ( List<ClassInfo> classInfoList : processedClassInfos.values() ) {\n\t\t\tif ( !processedList.contains( classInfoList ) ) {\n\t\t\t\thierarchies.add( ConfiguredClassHierarchy.createEntityClassHierarchy( classInfoList, context ) );\n\t\t\t\tprocessedList.add( classInfoList );\n\t\t\t}\n\t\t}\n\n\t\treturn hierarchies;\n\t}\n",
    "new_code_raw": "\tpublic static Set<ConfiguredClassHierarchy<EntityClass>> createEntityHierarchies(AnnotationsBindingContext bindingContext) {\n\t\tMap<ClassInfo, List<ClassInfo>> processedClassInfos = new HashMap<ClassInfo, List<ClassInfo>>();\n\n\t\tfor ( ClassInfo info : bindingContext.getIndex().getKnownClasses() ) {\n\t\t\tif ( !isEntityClass( info ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( processedClassInfos.containsKey( info ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tList<ClassInfo> configuredClassList = new ArrayList<ClassInfo>();\n\t\t\tClassInfo tmpClassInfo = info;\n\t\t\tClass<?> clazz = bindingContext.locateClassByName( tmpClassInfo.toString() );\n\t\t\twhile ( clazz != null && !clazz.equals( Object.class ) ) {\n\t\t\t\ttmpClassInfo = bindingContext.getIndex().getClassByName( DotName.createSimple( clazz.getName() ) );\n\t\t\t\tclazz = clazz.getSuperclass();\n\t\t\t\tif ( tmpClassInfo == null ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( existsHierarchyWithClassInfoAsLeaf( processedClassInfos, tmpClassInfo ) ) {\n\t\t\t\t\tList<ClassInfo> classInfoList = processedClassInfos.get( tmpClassInfo );\n\t\t\t\t\tfor ( ClassInfo tmpInfo : configuredClassList ) {\n\t\t\t\t\t\tclassInfoList.add( tmpInfo );\n\t\t\t\t\t\tprocessedClassInfos.put( tmpInfo, classInfoList );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconfiguredClassList.add( 0, tmpClassInfo );\n\t\t\t\t\tprocessedClassInfos.put( tmpClassInfo, configuredClassList );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSet<ConfiguredClassHierarchy<EntityClass>> hierarchies = new HashSet<ConfiguredClassHierarchy<EntityClass>>();\n\t\tList<List<ClassInfo>> processedList = new ArrayList<List<ClassInfo>>();\n\t\tfor ( List<ClassInfo> classInfoList : processedClassInfos.values() ) {\n\t\t\tif ( !processedList.contains( classInfoList ) ) {\n\t\t\t\thierarchies.add( ConfiguredClassHierarchy.createEntityClassHierarchy( classInfoList, bindingContext ) );\n\t\t\t\tprocessedList.add( classInfoList );\n\t\t\t}\n\t\t}\n\n\t\treturn hierarchies;\n\t}\n"
  },
  {
    "id": "zaproxy_zaproxy-2206-Param-1",
    "old_comment_raw": "@param cookies the cookies present in the request header of the message",
    "old_code_raw": "\tprivate HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final HttpSessionTokensSet siteTokens) {\n\n\t\treturn CookieBasedSessionManagementHelper.getMatchingHttpSession(sessions, cookies, siteTokens);\n\t}\n",
    "new_code_raw": "\tprivate HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final Set<String> tokens) {\n\n\t\t// Pre-checks\n\t\tif (sessions.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tList<HttpSession> matchingSessions = new LinkedList<>(sessions);\n\t\tfor (String token : tokens) {\n\t\t\t// Get the corresponding cookie from the cookies list\n\t\t\tHttpCookie matchingCookie = null;\n\t\t\tfor (HttpCookie cookie : cookies) {\n\t\t\t\tif (cookie.getName().equals(token)) {\n\t\t\t\t\tmatchingCookie = cookie;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Filter the sessions that do not match the cookie value\n\t\t\tIterator<HttpSession> it = matchingSessions.iterator();\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tif (!it.next().matchesToken(token, matchingCookie)) {\n\t\t\t\t\tit.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Return the matching session\n\t\tif (matchingSessions.size() >= 1) {\n\t\t\tif (matchingSessions.size() > 1) {\n\t\t\t\tlog.warn(\"Multiple sessions matching the cookies from response for site: \" + getSite()\n\t\t\t\t\t\t+ \". Using first one.\");\n\t\t\t}\n\t\t\treturn matchingSessions.get(0);\n\t\t}\n\t\treturn null;\n\n\t}\n"
  },
  {
    "id": "querydsl_querydsl-1826-Param-0",
    "old_comment_raw": "@param operation",
    "old_code_raw": "    public static BooleanOperation booleanOperation(Operator operation, Expression<?>... args) {\n        return predicate(operation, args);\n    }\n",
    "new_code_raw": "    public static BooleanOperation booleanOperation(Operator operator, Expression<?>... args) {\n        return predicate(operator, args);\n    }\n"
  },
  {
    "id": "yanzhenjie_NoHttp-142-Param-3",
    "old_comment_raw": "@param filename Filename",
    "old_code_raw": "    public static DownloadRequest createDownloadRequest(String url, RequestMethod requestMethod, String fileFloder, String filename, boolean isRange, boolean isDeleteOld) {\n        return new RestDownloadRequestor(url, requestMethod, fileFloder, filename, isRange, isDeleteOld);\n    }\n",
    "new_code_raw": "    public static DownloadRequest createDownloadRequest(String url, RequestMethod requestMethod, String fileFolder, String filename, boolean isRange, boolean isDeleteOld) {\n        return new RestDownloadRequestor(url, requestMethod, fileFolder, filename, isRange, isDeleteOld);\n    }\n"
  },
  {
    "id": "justinedelson_felix-173-Associations-Param0",
    "old_comment_raw": "@param arg0 the object",
    "old_code_raw": "    public int compareTo(Object arg0) {\r\n        throw new UnsupportedOperationException(\"This feature has not yet been implemented.\");\r\n\r\n    }\r\n",
    "new_code_raw": "    public int compareTo(Object reference) {\r\n\r\n        ServiceReference other = (ServiceReference) reference;\r\n\r\n        Long id = (Long) getProperty(Constants.SERVICE_ID);\r\n        Long otherId = (Long) other.getProperty(Constants.SERVICE_ID);\r\n\r\n        if (id.equals(otherId)) {\r\n            return 0; // same service\r\n        }\r\n\r\n        Integer rank = (Integer) getProperty(Constants.SERVICE_RANKING);\r\n        Integer otherRank = (Integer) other\r\n                .getProperty(Constants.SERVICE_RANKING);\r\n\r\n        // If no rank, then spec says it defaults to zero.\r\n        rank = (rank == null) ? new Integer(0) : rank;\r\n        otherRank = (otherRank == null) ? new Integer(0) : otherRank;\r\n\r\n        // Sort by rank in ascending order.\r\n        if (rank.compareTo(otherRank) < 0) {\r\n            return -1; // lower rank\r\n        } else if (rank.compareTo(otherRank) > 0) {\r\n            return 1; // higher rank\r\n        }\r\n\r\n        // If ranks are equal, then sort by service id in descending order.\r\n        return (id.compareTo(otherId) < 0) ? 1 : -1;\r\n    }\r\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-797-Param-0",
    "old_comment_raw": "@param buffer The buffer to append the 'on' condition to.",
    "old_code_raw": "\tprotected boolean addCondition(StringBuffer buffer, String on) {\n\t\tif ( StringHelper.isNotEmpty( on ) ) {\n\t\t\tif ( !on.startsWith( \" and\" ) ) buffer.append( \" and \" );\n\t\t\tbuffer.append( on );\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n",
    "new_code_raw": "\tprotected boolean addCondition(StringBuilder buffer, String on) {\n\t\tif ( StringHelper.isNotEmpty( on ) ) {\n\t\t\tif ( !on.startsWith( \" and\" ) ) buffer.append( \" and \" );\n\t\t\tbuffer.append( on );\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n"
  },
  {
    "id": "Rajawali_Rajawali-57-Associations-Param0",
    "old_comment_raw": "@param x double The x component.",
    "old_code_raw": "\tpublic static double length(double x, double y, double z) {\n\t\treturn Math.sqrt(length2(x, y, z));\n\t}\n",
    "new_code_raw": "\tpublic static float length(float x, float y, float z) {\n\t\treturn (float) Math.sqrt(length2(x, y, z));\n\t}\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-1341-Param-0",
    "old_comment_raw": "@param semgrex the pattern string",
    "old_code_raw": "  public static SemgrexPattern compile(String semgrex, Env env) {\n    try {\n      SemgrexParser parser = new SemgrexParser(new StringReader(semgrex + \"\\n\"));\n      SemgrexPattern newPattern = parser.Root();\n      newPattern.setEnv(env);\n      newPattern.patternString = semgrex;\n      return newPattern;\n    } catch (ParseException ex) {\n      throw new SemgrexParseException(\"Error parsing semgrex pattern \" + semgrex, ex);\n    } catch (TokenMgrError er) {\n      throw new SemgrexParseException(\"Error parsing semgrex pattern \" + semgrex, er);\n    }\n  }\n",
    "new_code_raw": "  public static SemgrexPattern compile(String semgrex) {\n    // TODO: make this threadsafe by making SemgrexParser threadsafe.\n    // TODO: make semgrex parser objects non-public\n    try {\n      SemgrexParser parser = new SemgrexParser(new StringReader(semgrex + \"\\n\"));\n      SemgrexPattern newPattern = parser.Root();\n      newPattern.setPatternString(semgrex);\n      return newPattern;\n    } catch (ParseException ex) {\n      throw new SemgrexParseException(\"Error parsing semgrex pattern \" + semgrex, ex);\n    } catch (TokenMgrError er) {\n      throw new SemgrexParseException(\"Error parsing semgrex pattern \" + semgrex, er);\n    }\n  }\n"
  },
  {
    "id": "eclipse_rt.equinox.bundles-63-Associations-Param1",
    "old_comment_raw": "@param environment the current environment, which may affect the behavior of the expert. This parameter may be specified as null, in which case the  STextEnvironment#DEFAULT environment should be assumed.",
    "old_code_raw": "\tstatic public ISTextExpert getStatefulExpert(STextTypeHandler handler, STextEnvironment environment) {\n\t\tif (environment == null)\n\t\t\tenvironment = STextEnvironment.DEFAULT;\n\t\treturn new STextImpl(handler, environment, true);\n\t}\n",
    "new_code_raw": "\tstatic public IStructuredTextExpert getStatefulExpert(StructuredTextTypeHandler handler, StructuredTextEnvironment environment) {\n\t\tif (environment == null)\n\t\t\tenvironment = StructuredTextEnvironment.DEFAULT;\n\t\treturn new StructuredTextImpl(handler, environment, true);\n\t}\n\n"
  },
  {
    "id": "gabrielemariotti_cardslib-14-Param-0",
    "old_comment_raw": "@param viewCard",
    "old_code_raw": "    public boolean onCollapseStart(CardView viewCard) {\n        Card card = viewCard.getCard();\n        if (card!=null){\n            String itemId = card.getId();\n            if (mExpandedIds.contains(itemId)) {\n                return true;\n            }\n        }\n        return false;\n    }\n",
    "new_code_raw": "    public boolean onCollapseStart(CommonCardView viewCard) {\n        Card card = viewCard.getCard();\n        if (card!=null){\n            String itemId = card.getId();\n            if (mExpandedIds.contains(itemId)) {\n                return true;\n            }\n        }\n        return false;\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1661-Param-0",
    "old_comment_raw": "@param body Input composite as post body (optional)",
    "old_code_raw": "    public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws ApiException {\n        ApiResponse<OuterComposite> resp = fakeOuterCompositeSerializeWithHttpInfo(body);\n        return resp.getData();\n    }\n",
    "new_code_raw": "    public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws ApiException {\n        ApiResponse<OuterComposite> resp = fakeOuterCompositeSerializeWithHttpInfo(outerComposite);\n        return resp.getData();\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-486-Param-0",
    "old_comment_raw": "@param proto The serialized protobuf to read the CoreLabel from.",
    "old_code_raw": "  private static CoreLabel fromProto(CoreMapProtos.CoreLabel proto) {\n    CoreLabel word = new CoreLabel();\n    // Required fields\n    word.setWord(proto.getWord());\n    // Optional fields\n    if (proto.hasPos()) { word.setTag(proto.getPos()); }\n    if (proto.hasValue()) { word.setValue(proto.getValue()); }\n    if (proto.hasCategory()) { word.setCategory(proto.getCategory()); }\n    if (proto.hasBefore()) { word.setBefore(proto.getBefore()); }\n    if (proto.hasAfter()) { word.setAfter(proto.getAfter()); }\n    if (proto.hasOriginalText()) { word.setOriginalText(proto.getOriginalText()); }\n    if (proto.hasNer()) { word.setNER(proto.getNer()); }\n    if (proto.hasLemma()) { word.setLemma(proto.getLemma()); }\n    if (proto.hasBeginChar()) { word.setBeginPosition(proto.getBeginChar()); }\n    if (proto.hasEndChar()) { word.setEndPosition(proto.getEndChar()); }\n    if (proto.hasSpeaker()) { word.set(SpeakerAnnotation.class, proto.getSpeaker()); }\n    if (proto.hasUtterance()) { word.set(UtteranceAnnotation.class, proto.getUtterance()); }\n    if (proto.hasBeginIndex()) { word.set(BeginIndexAnnotation.class, proto.getBeginIndex()); }\n    if (proto.hasEndIndex()) { word.set(EndIndexAnnotation.class, proto.getEndIndex()); }\n    if (proto.hasTokenBeginIndex()) { word.set(TokenBeginAnnotation.class, proto.getTokenBeginIndex()); }\n    if (proto.hasTokenEndIndex()) { word.set(TokenEndAnnotation.class, proto.getTokenEndIndex()); }\n    if (proto.hasNormalizedNER()) { word.set(NormalizedNamedEntityTagAnnotation.class, proto.getNormalizedNER()); }\n    // Return\n    return word;\n  }\n",
    "new_code_raw": "  private static CoreLabel fromProto(CoreNLPProtos.Token proto) {\n    CoreLabel word = new CoreLabel();\n    // Required fields\n    word.setWord(proto.getWord());\n    // Optional fields\n    if (proto.hasPos()) { word.setTag(proto.getPos()); }\n    if (proto.hasValue()) { word.setValue(proto.getValue()); }\n    if (proto.hasCategory()) { word.setCategory(proto.getCategory()); }\n    if (proto.hasBefore()) { word.setBefore(proto.getBefore()); }\n    if (proto.hasAfter()) { word.setAfter(proto.getAfter()); }\n    if (proto.hasOriginalText()) { word.setOriginalText(proto.getOriginalText()); }\n    if (proto.hasNer()) { word.setNER(proto.getNer()); }\n    if (proto.hasLemma()) { word.setLemma(proto.getLemma()); }\n    if (proto.hasBeginChar()) { word.setBeginPosition(proto.getBeginChar()); }\n    if (proto.hasEndChar()) { word.setEndPosition(proto.getEndChar()); }\n    if (proto.hasSpeaker()) { word.set(SpeakerAnnotation.class, proto.getSpeaker()); }\n    if (proto.hasUtterance()) { word.set(UtteranceAnnotation.class, proto.getUtterance()); }\n    if (proto.hasBeginIndex()) { word.set(BeginIndexAnnotation.class, proto.getBeginIndex()); }\n    if (proto.hasEndIndex()) { word.set(EndIndexAnnotation.class, proto.getEndIndex()); }\n    if (proto.hasTokenBeginIndex()) { word.set(TokenBeginAnnotation.class, proto.getTokenBeginIndex()); }\n    if (proto.hasTokenEndIndex()) { word.set(TokenEndAnnotation.class, proto.getTokenEndIndex()); }\n    if (proto.hasNormalizedNER()) { word.set(NormalizedNamedEntityTagAnnotation.class, proto.getNormalizedNER()); }\n    if (proto.hasTimexValue()) { word.set(TimexAnnotation.class, fromProto(proto.getTimexValue())); }\n    if (proto.getXmlContextCount() > 0) { word.set(XmlContextAnnotation.class, proto.getXmlContextList()); }\n    if (proto.hasCorefClusterID()) { word.set(CorefClusterIdAnnotation.class, proto.getCorefClusterID()); }\n    // Non-default annotators\n    if (proto.hasGender()) { word.set(GenderAnnotation.class, proto.getGender()); }\n    if (proto.hasTrueCase()) { word.set(TrueCaseAnnotation.class, proto.getTrueCase()); }\n    if (proto.hasTrueCaseText()) { word.set(TrueCaseTextAnnotation.class, proto.getTrueCaseText()); }\n    // Return\n    return word;\n  }\n"
  },
  {
    "id": "debezium_debezium-1198-Param-0",
    "old_comment_raw": "@param str the input string",
    "old_code_raw": "    public static TableId parse(String str, char delimiter, boolean useCatalogBeforeSchema) {\n        String[] parts = str.split(\"[\\\\\" + delimiter + \"]\");\n        if (parts.length == 0) return null;\n        if (parts.length == 1) return new TableId(null, null, parts[0]); // table only\n        if (parts.length == 2) {\n            if (useCatalogBeforeSchema) return new TableId(parts[0], null, parts[1]); // catalog & table only\n            return new TableId(null, parts[0], parts[1]); // catalog & table only\n        }\n        return new TableId(parts[0], parts[1], parts[2]); // catalog & table only\n    }\n",
    "new_code_raw": "    protected static TableId parse(String[] parts, int numParts, boolean useCatalogBeforeSchema) {\n        if (numParts == 0) return null;\n        if (numParts == 1) return new TableId(null, null, parts[0]); // table only\n        if (numParts == 2) {\n            if (useCatalogBeforeSchema) return new TableId(parts[0], null, parts[1]); // catalog & table only\n            return new TableId(null, parts[0], parts[1]); // catalog & table only\n        }\n        return new TableId(parts[0], parts[1], parts[2]); // catalog & table only\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1200-Param-1",
    "old_comment_raw": "@param session The session from which the request originated.",
    "old_code_raw": "\tprivate static EntityKey getOptionalObjectKey(QueryParameters queryParameters, SessionImplementor session) {\n\t\tfinal Object optionalObject = queryParameters.getOptionalObject();\n\t\tfinal Serializable optionalId = queryParameters.getOptionalId();\n\t\tfinal String optionalEntityName = queryParameters.getOptionalEntityName();\n\n\t\tif ( optionalObject != null && optionalEntityName != null ) {\n\t\t\treturn session.generateEntityKey(\n\t\t\t\t\toptionalId, session.getEntityPersister(\n\t\t\t\t\t\t\toptionalEntityName,\n\t\t\t\t\t\t\toptionalObject\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\n\t}\n",
    "new_code_raw": "\tprivate static EntityKey getOptionalObjectKey(QueryParameters queryParameters, SharedSessionContractImplementor session) {\n\t\tfinal Object optionalObject = queryParameters.getOptionalObject();\n\t\tfinal Serializable optionalId = queryParameters.getOptionalId();\n\t\tfinal String optionalEntityName = queryParameters.getOptionalEntityName();\n\n\t\tif ( optionalObject != null && optionalEntityName != null ) {\n\t\t\treturn session.generateEntityKey(\n\t\t\t\t\toptionalId, session.getEntityPersister(\n\t\t\t\t\t\t\toptionalEntityName,\n\t\t\t\t\t\t\toptionalObject\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1648-Param-0",
    "old_comment_raw": "@param body client model",
    "old_code_raw": "    public Client testSpecialTags(Client body, Map<String, Object> params) throws IOException {\n        HttpResponse response = testSpecialTagsForHttpResponse(body, params);\n        TypeReference typeRef = new TypeReference<Client>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n",
    "new_code_raw": "    public Client testSpecialTags(Client client, Map<String, Object> params) throws IOException {\n        HttpResponse response = testSpecialTagsForHttpResponse(client, params);\n        TypeReference typeRef = new TypeReference<Client>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n"
  },
  {
    "id": "apache_activemq-1152-Param-2",
    "old_comment_raw": "@param remoteTransport",
    "old_code_raw": "    public static Transport createLocalTransport(Broker broker) throws Exception {\n        URI uri = broker.getVmConnectorURI();\n        HashMap<String, String> map = new HashMap<String, String>(URISupport.parseParameters(uri));\n        map.put(\"async\", \"true\");\n        map.put(\"create\", \"false\"); // we don't want a vm connect during shutdown to trigger a broker create\n        uri = URISupport.createURIWithQuery(uri, URISupport.createQueryString(map));\n        return TransportFactory.connect(uri);\n    }\n",
    "new_code_raw": "    public static Transport createLocalTransport(URI uri) throws Exception {\n        return createLocalTransport(uri, false);\n    }\n"
  },
  {
    "id": "codehaus_cake-6-Associations-Param0",
    "old_comment_raw": "@param attributes an object containing an AttributeMap",
    "old_code_raw": "    public double get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n",
    "new_code_raw": "    public double get(WithAttributes withAttributes) {\r\n        return withAttributes.getAttributes().get(this);\r\n    }\r\n\n"
  },
  {
    "id": "querydsl_querydsl-1041-Param-0",
    "old_comment_raw": "@param str",
    "old_code_raw": "    public BooleanExpression like(StringExpression str){\n        return BooleanOperation.create(Ops.LIKE, this, str);\n    }\n",
    "new_code_raw": "    public BooleanExpression like(Expression<String> str){\n        return BooleanOperation.create(Ops.LIKE, this, str);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1711-Param-0",
    "old_comment_raw": "@param outerComposite Input composite as post body (optional)",
    "old_code_raw": "  public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws ApiException {\n    Object localVarPostBody = outerComposite;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/composite\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"*/*\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/composite\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"*/*\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "runelite_runelite-122-Param-1",
    "old_comment_raw": "@param model the model to calculate a clickbox for",
    "old_code_raw": "\tpublic static Area getClickbox(@Nonnull Client client, Model model, int orientation, int tileX, int tileY)\n\t{\n\t\tif (model == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tList<Triangle> triangles = model.getTriangles().stream()\n\t\t\t.map(triangle -> triangle.rotate(orientation))\n\t\t\t.collect(Collectors.toList());\n\n\t\tList<Vertex> vertices = model.getVertices().stream()\n\t\t\t\t.map(v -> v.rotate(orientation))\n\t\t\t\t.collect(Collectors.toList());\n\n\t\tArea clickBox = get2DGeometry(client, triangles, orientation, tileX, tileY);\n\t\tArea visibleAABB = getAABB(client, vertices, orientation, tileX, tileY);\n\n\t\tif (visibleAABB == null || clickBox == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tclickBox.intersect(visibleAABB);\n\t\treturn clickBox;\n\t}\n",
    "new_code_raw": "\tpublic static Area getClickbox(@Nonnull Client client, Model model, int orientation, int localX, int localY)\n\t{\n\t\tif (model == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tList<Triangle> triangles = model.getTriangles().stream()\n\t\t\t.map(triangle -> triangle.rotate(orientation))\n\t\t\t.collect(Collectors.toList());\n\n\t\tList<Vertex> vertices = model.getVertices().stream()\n\t\t\t\t.map(v -> v.rotate(orientation))\n\t\t\t\t.collect(Collectors.toList());\n\n\t\tArea clickBox = get2DGeometry(client, triangles, orientation, localX, localY);\n\t\tArea visibleAABB = getAABB(client, vertices, orientation, localX, localY);\n\n\t\tif (visibleAABB == null || clickBox == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tclickBox.intersect(visibleAABB);\n\t\treturn clickBox;\n\t}\n"
  },
  {
    "id": "apache_jclouds-360-Associations-Param1",
    "old_comment_raw": "@param contextWrappableAs the contextWrappableAs to filter providers by",
    "old_code_raw": "   public static Iterable<ProviderMetadata> boundedByIso3166Code(String iso3166Code,\n            TypeToken<? extends Wrapper> contextWrappableAs) {\n      return filter(all(), Predicates.and(ProviderPredicates.boundedByIso3166Code(iso3166Code), ProviderPredicates\n               .contextWrappableAs(contextWrappableAs)));\n   }\n",
    "new_code_raw": "   public static Iterable<ProviderMetadata<?, ?, ?, ?>> boundedByIso3166Code(String iso3166Code, ApiType type) {\n      return filter(all(),\n            Predicates.and(ProviderPredicates.boundedByIso3166Code(iso3166Code), ProviderPredicates.type(type)));\n   }\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-824-Param-1",
    "old_comment_raw": "@param left left position to begin labeling the bracketings with",
    "old_code_raw": "  private int constituents(Set<Constituent> constituentsSet, int left, ConstituentFactory cf, boolean charLevel, Filter<Tree> filter, int maxDepth, int depth) {\n\n    if(isPreTerminal())\n      return left + ((charLevel) ? firstChild().value().length() : 1);\n\n    int position = left;\n\n    // System.err.println(\"In bracketing trees left is \" + left);\n    // System.err.println(\"  label is \" + label() +\n    //                       \"; num daughters: \" + children().length);\n    Tree[] kids = children();\n    for (Tree kid : kids) {\n      position = kid.constituents(constituentsSet, position, cf, charLevel, filter, maxDepth, depth + 1);\n      // System.err.println(\"  position went to \" + position);\n    }\n\n    if ((filter == null || filter.accept(this)) &&\n        (maxDepth < 0 || depth <= maxDepth)) {\n      //Compute span of entire tree at the end of recursion\n      constituentsSet.add(cf.newConstituent(left, position - 1, label(), score()));\n    }\n    // System.err.println(\"  added \" + label());\n    return position;\n  }\n",
    "new_code_raw": "  private int constituents(Set<Constituent> constituentsSet, int left, ConstituentFactory cf, boolean charLevel, Predicate<Tree> filter, int maxDepth, int depth) {\n\n    if(isPreTerminal())\n      return left + ((charLevel) ? firstChild().value().length() : 1);\n\n    int position = left;\n\n    // System.err.println(\"In bracketing trees left is \" + left);\n    // System.err.println(\"  label is \" + label() +\n    //                       \"; num daughters: \" + children().length);\n    Tree[] kids = children();\n    for (Tree kid : kids) {\n      position = kid.constituents(constituentsSet, position, cf, charLevel, filter, maxDepth, depth + 1);\n      // System.err.println(\"  position went to \" + position);\n    }\n\n    if ((filter == null || filter.test(this)) &&\n        (maxDepth < 0 || depth <= maxDepth)) {\n      //Compute span of entire tree at the end of recursion\n      constituentsSet.add(cf.newConstituent(left, position - 1, label(), score()));\n    }\n    // System.err.println(\"  added \" + label());\n    return position;\n  }\n"
  },
  {
    "id": "elastic_elasticsearch_hadoop-22-Param-1",
    "old_comment_raw": "@param includes",
    "old_code_raw": "    public static boolean filter(String path, Collection<String> includes, Collection<String> excludes) {\n        includes = (includes == null ? Collections.<String> emptyList() : includes);\n        excludes = (excludes == null ? Collections.<String> emptyList() : excludes);\n\n        if (includes.isEmpty() && excludes.isEmpty()) {\n            return true;\n        }\n\n        if (Regex.simpleMatch(excludes, path)) {\n            return false;\n        }\n\n        boolean exactIncludeMatch = false; // true if the current position was specifically mentioned\n        boolean pathIsPrefixOfAnInclude = false; // true if potentially a sub scope can be included\n        if (includes.isEmpty()) {\n            // implied match anything\n            exactIncludeMatch = true;\n        }\n        else {\n            for (String include : includes) {\n                // check for prefix matches as well to see if we need to zero in, something like: obj1.arr1.* or *.field\n                // note, this does not work well with middle matches, like obj1.*.obj3\n                if (include.charAt(0) == '*') {\n                    if (Regex.simpleMatch(include, path)) {\n                        exactIncludeMatch = true;\n                        break;\n                    }\n//                    pathIsPrefixOfAnInclude = true;\n//                    continue;\n                }\n                if (include.startsWith(path)) {\n                    if (include.length() == path.length()) {\n                        exactIncludeMatch = true;\n                        break;\n                    }\n                    else if (include.length() > path.length() && include.charAt(path.length()) == '.') {\n                        // include might may match deeper paths. Dive deeper.\n                        pathIsPrefixOfAnInclude = true;\n                        continue;\n                    }\n                }\n                if (Regex.simpleMatch(include, path)) {\n                    exactIncludeMatch = true;\n                    break;\n                }\n            }\n        }\n\n        if (pathIsPrefixOfAnInclude || exactIncludeMatch) {\n            // if match or part of the path\n            return true;\n        }\n        \n        return false;\n    }\n",
    "new_code_raw": "    public static boolean filter(String path, Collection<String> includes, Collection<String> excludes, boolean allowPartialMatches) {\n        includes = (includes == null ? Collections.<String> emptyList() : includes);\n        excludes = (excludes == null ? Collections.<String> emptyList() : excludes);\n\n        if (includes.isEmpty() && excludes.isEmpty()) {\n            return true;\n        }\n\n        if (Regex.simpleMatch(excludes, path)) {\n            return false;\n        }\n\n        boolean exactIncludeMatch = false; // true if the current position was specifically mentioned\n        boolean pathIsPrefixOfAnInclude = false; // true if potentially a sub scope can be included\n        if (includes.isEmpty()) {\n            // implied match anything\n            exactIncludeMatch = true;\n        }\n        else {\n            for (String include : includes) {\n                // check for prefix matches as well to see if we need to zero in, something like: obj1.arr1.* or *.field\n                // note, this does not work well with middle matches, like obj1.*.obj3\n                if (include.charAt(0) == '*') {\n                    if (Regex.simpleMatch(include, path)) {\n                        exactIncludeMatch = true;\n                        break;\n                    }\n//                    pathIsPrefixOfAnInclude = true;\n//                    continue;\n                }\n                if (include.startsWith(path)) {\n                    if (include.length() == path.length()) {\n                        exactIncludeMatch = true;\n                        break;\n                    }\n                    else if (include.length() > path.length() && include.charAt(path.length()) == '.') {\n                        // include might may match deeper paths. Dive deeper.\n                        pathIsPrefixOfAnInclude = true;\n                        continue;\n                    }\n                }\n                if (Regex.simpleMatch(include, path)) {\n                    exactIncludeMatch = true;\n                    break;\n                }\n            }\n        }\n\n        // if match or part of the path (based on the passed param)\n        if (exactIncludeMatch || (allowPartialMatches && pathIsPrefixOfAnInclude)) {\n            return true;\n        }\n\n        return false;\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1696-Param-1",
    "old_comment_raw": "@param file file to upload",
    "old_code_raw": "    public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws RestClientException {\n        Object postBody = new Object();\n        \n        // verify the required parameter 'petId' is set\n        if (petId == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n        }\n        \n        // verify the required parameter 'file' is set\n        if (file == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'file' when calling uploadFileWithRequiredFile\");\n        }\n        \n        // create path and map variables\n        final Map<String, Object> uriVariables = new HashMap<String, Object>();\n        uriVariables.put(\"petId\", petId);\n        String path = UriComponentsBuilder.fromPath(\"/fake/{petId}/uploadImageWithRequiredFile\").buildAndExpand(uriVariables).toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n        \n        if (additionalMetadata != null)\n            formParams.add(\"additionalMetadata\", additionalMetadata);\n        if (file != null)\n            formParams.add(\"file\", new FileSystemResource(file));\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"multipart/form-data\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"petstore_auth\" };\n\n        ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "new_code_raw": "    public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws RestClientException {\n        Object postBody = new Object();\n        \n        // verify the required parameter 'petId' is set\n        if (petId == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n        }\n        \n        // verify the required parameter 'requiredFile' is set\n        if (requiredFile == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\");\n        }\n        \n        // create path and map variables\n        final Map<String, Object> uriVariables = new HashMap<String, Object>();\n        uriVariables.put(\"petId\", petId);\n        String path = UriComponentsBuilder.fromPath(\"/fake/{petId}/uploadImageWithRequiredFile\").buildAndExpand(uriVariables).toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n        \n        if (additionalMetadata != null)\n            formParams.add(\"additionalMetadata\", additionalMetadata);\n        if (requiredFile != null)\n            formParams.add(\"requiredFile\", new FileSystemResource(requiredFile));\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"multipart/form-data\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"petstore_auth\" };\n\n        ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1201-Param-1",
    "old_comment_raw": "@param resultSet The JDBC result set (positioned at the row currently being processed).",
    "old_code_raw": "\tpublic Object buildResultRow(Object[] data, ResultSet resultSet, boolean hasTransformer, SessionImplementor session)\n\t\t\tthrows SQLException, HibernateException {\n\t\tfinal Object[] resultRow = buildResultRow( data, resultSet, session );\n\t\tif ( hasTransformer ) {\n\t\t\treturn resultRow;\n\t\t}\n\t\telse {\n\t\t\treturn resultRow.length == 1\n\t\t\t\t\t? resultRow[0]\n\t\t\t\t\t: resultRow;\n\t\t}\n\t}\n",
    "new_code_raw": "\tpublic Object buildResultRow(Object[] data, ResultSet resultSet, boolean hasTransformer, SharedSessionContractImplementor session)\n\t\t\tthrows SQLException, HibernateException {\n\t\tfinal Object[] resultRow = buildResultRow( data, resultSet, session );\n\t\tif ( hasTransformer ) {\n\t\t\treturn resultRow;\n\t\t}\n\t\telse {\n\t\t\treturn resultRow.length == 1\n\t\t\t\t\t? resultRow[0]\n\t\t\t\t\t: resultRow;\n\t\t}\n\t}\n"
  },
  {
    "id": "Rajawali_Rajawali-28-Associations-Param1",
    "old_comment_raw": "@param y float The y component.",
    "old_code_raw": "\tpublic static float length(float x, float y, float z) {\n\t\treturn (float) Math.sqrt(length2(x, y, z));\n\t}\n",
    "new_code_raw": "\tpublic static double length(double x, double y, double z) {\n\t\treturn Math.sqrt(length2(x, y, z));\n\t}\n\n"
  },
  {
    "id": "LawnchairLauncher_Lawnchair-188-Param-0",
    "old_comment_raw": "@param typeArray A 3d array of item types. @see #addItem(int, long, long, int, int) for type definitions. The first dimension represents the screens and the next two represent the workspace grid.",
    "old_code_raw": "    private long[][][] createGrid(int[][][] typeArray, long startScreen) throws Exception {\n        LauncherSettings.Settings.call(getMockContentResolver(),\n                LauncherSettings.Settings.METHOD_CREATE_EMPTY_DB);\n        long[][][] ids = new long[typeArray.length][][];\n\n        for (int i = 0; i < typeArray.length; i++) {\n            // Add screen to DB\n            long screenId = startScreen + i;\n\n            // Keep the screen id counter up to date\n            LauncherSettings.Settings.call(getMockContentResolver(),\n                    LauncherSettings.Settings.METHOD_NEW_SCREEN_ID);\n\n            ContentValues v = new ContentValues();\n            v.put(LauncherSettings.WorkspaceScreens._ID, screenId);\n            v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);\n            getMockContentResolver().insert(LauncherSettings.WorkspaceScreens.CONTENT_URI, v);\n\n            ids[i] = new long[typeArray[i].length][];\n            for (int y = 0; y < typeArray[i].length; y++) {\n                ids[i][y] = new long[typeArray[i][y].length];\n                for (int x = 0; x < typeArray[i][y].length; x++) {\n                    if (typeArray[i][y][x] < 0) {\n                        // Empty cell\n                        ids[i][y][x] = -1;\n                    } else {\n                        ids[i][y][x] = addItem(typeArray[i][y][x], screenId, DESKTOP, x, y);\n                    }\n                }\n            }\n        }\n        return ids;\n    }\n",
    "new_code_raw": "    private long[][][] createGrid(int[][][] typeArray) throws Exception {\n        long[][][] ids = new long[typeArray.length][][];\n\n        for (int i = 0; i < typeArray.length; i++) {\n            // Add screen to DB\n            long screenId = LauncherAppState.getLauncherProvider().generateNewScreenId();\n            ContentValues v = new ContentValues();\n            v.put(LauncherSettings.WorkspaceScreens._ID, screenId);\n            v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);\n            getMockContentResolver().insert(LauncherSettings.WorkspaceScreens.CONTENT_URI, v);\n\n            ids[i] = new long[typeArray[i].length][];\n            for (int y = 0; y < typeArray[i].length; y++) {\n                ids[i][y] = new long[typeArray[i][y].length];\n                for (int x = 0; x < typeArray[i][y].length; x++) {\n                    if (typeArray[i][y][x] < 0) {\n                        // Empty cell\n                        ids[i][y][x] = -1;\n                    } else {\n                        ids[i][y][x] = addItem(typeArray[i][y][x], screenId, DESKTOP, x, y);\n                    }\n                }\n            }\n        }\n        return ids;\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1656-Param-0",
    "old_comment_raw": "@param body client model (required)",
    "old_code_raw": "  public Client testClientModel(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling testClientModel\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public Client testClientModel(Client client) throws ApiException {\n    Object localVarPostBody = client;\n    \n    // verify the required parameter 'client' is set\n    if (client == null) {\n      throw new ApiException(400, \"Missing the required parameter 'client' when calling testClientModel\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-708-Param-0",
    "old_comment_raw": "@param number None (required)",
    "old_code_raw": "  public Call testEndpointParametersAsync(String number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password, final ApiCallback<Void> callback) throws ApiException {\n\n    ProgressResponseBody.ProgressListener progressListener = null;\n    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n    if (callback != null) {\n      progressListener = new ProgressResponseBody.ProgressListener() {\n        @Override\n        public void update(long bytesRead, long contentLength, boolean done) {\n          callback.onDownloadProgress(bytesRead, contentLength, done);\n        }\n      };\n\n      progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {\n        @Override\n        public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {\n          callback.onUploadProgress(bytesWritten, contentLength, done);\n        }\n      };\n    }\n\n    Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, progressListener, progressRequestListener);\n    apiClient.executeAsync(call, callback);\n    return call;\n  }\n",
    "new_code_raw": "  public Call testEndpointParametersAsync(BigDecimal number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password, final ApiCallback<Void> callback) throws ApiException {\n\n    ProgressResponseBody.ProgressListener progressListener = null;\n    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n    if (callback != null) {\n      progressListener = new ProgressResponseBody.ProgressListener() {\n        @Override\n        public void update(long bytesRead, long contentLength, boolean done) {\n          callback.onDownloadProgress(bytesRead, contentLength, done);\n        }\n      };\n\n      progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {\n        @Override\n        public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {\n          callback.onUploadProgress(bytesWritten, contentLength, done);\n        }\n      };\n    }\n\n    Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, progressListener, progressRequestListener);\n    apiClient.executeAsync(call, callback);\n    return call;\n  }\n"
  },
  {
    "id": "apache_calcite-895-Param-0",
    "old_comment_raw": "@param call Extract expression",
    "old_code_raw": "  public static boolean isValidTimeFloor(RexCall call) {\n    if (call.getKind() != SqlKind.FLOOR) {\n      return false;\n    }\n    final RexLiteral flag = (RexLiteral) call.operands.get(1);\n    final TimeUnitRange timeUnit = (TimeUnitRange) flag.getValue();\n    return timeUnit != null && VALID_TIME_EXTRACT.contains(timeUnit);\n  }\n",
    "new_code_raw": "  public static boolean isValidTimeFloor(RexNode rexNode) {\n    if (rexNode.getKind() != SqlKind.FLOOR) {\n      return false;\n    }\n    final RexCall call = (RexCall) rexNode;\n    if (call.operands.size() != 2) {\n      return false;\n    }\n    final RexLiteral flag = (RexLiteral) call.operands.get(1);\n    final TimeUnitRange timeUnit = (TimeUnitRange) flag.getValue();\n    return timeUnit != null && VALID_TIME_EXTRACT.contains(timeUnit);\n  }\n"
  },
  {
    "id": "apache_drill-1041-Param-0",
    "old_comment_raw": "@param parent the parent (tuple, union or list) that holds this list",
    "old_code_raw": "  private ColumnState buildUnionList(ContainerState parent, ColumnReadProjection colProj) {\n    ColumnMetadata columnSchema = colProj.providedSchema();\n\n    // The variant must start out empty.\n\n    assert columnSchema.variantSchema().size() == 0;\n\n    // Create the union writer, bound to an empty list shim.\n\n    final UnionWriterImpl unionWriter = new UnionWriterImpl(columnSchema);\n    unionWriter.bindShim(new EmptyListShim());\n    final VariantObjectWriter unionObjWriter = new VariantObjectWriter(unionWriter);\n\n    // Create the list vector. Starts with the default (dummy) data\n    // vector which corresponds to the empty union shim above.\n    // Don't get the list vector from the vector cache. List vectors may\n    // have content that varies from batch to batch. Only the leaf\n    // vectors can be cached.\n\n    final ListVector listVector = new ListVector(columnSchema.schema(),\n        parent.loader().allocator(), null);\n\n    // Create the list vector state that tracks the list vector lifecycle.\n\n    final ListVectorState vectorState = new ListVectorState(unionWriter, listVector);\n\n    // Create the list writer: an array of unions.\n\n    final AbstractObjectWriter listWriter = new ArrayObjectWriter(\n        new ListWriterImpl(columnSchema, listVector, unionObjWriter));\n\n    // Create the manager for the columns within the list (which may or\n    // may not be grouped into a union.)\n\n    final ListState listState = new ListState(parent.loader(),\n        parent.vectorCache().childCache(columnSchema.name()));\n\n    // Bind the union state to the union writer to handle column additions.\n\n    unionWriter.bindListener(listState);\n\n    // Assemble it all into a union column state.\n\n    return new UnionColumnState(parent.loader(),\n        listWriter, vectorState, listState);\n  }\n",
    "new_code_raw": "  private ColumnState buildUnionList(ContainerState parent, ColumnMetadata columnSchema) {\n\n    // The variant must start out empty.\n    assert columnSchema.variantSchema().size() == 0;\n\n    // Create the union writer, bound to an empty list shim.\n    final UnionWriterImpl unionWriter = new UnionWriterImpl(columnSchema);\n    unionWriter.bindShim(new EmptyListShim());\n    final VariantObjectWriter unionObjWriter = new VariantObjectWriter(unionWriter);\n\n    // Create the list vector. Starts with the default (dummy) data\n    // vector which corresponds to the empty union shim above.\n    // Don't get the list vector from the vector cache. List vectors may\n    // have content that varies from batch to batch. Only the leaf\n    // vectors can be cached.\n    final ListVector listVector = new ListVector(columnSchema.schema(),\n        parent.loader().allocator(), null);\n\n    // Create the list vector state that tracks the list vector lifecycle.\n    final ListVectorState vectorState = new ListVectorState(unionWriter, listVector);\n\n    // Create the list writer: an array of unions.\n    final AbstractObjectWriter listWriter = new ArrayObjectWriter(\n        new ListWriterImpl(columnSchema, listVector, unionObjWriter));\n\n    // Create the manager for the columns within the list (which may or\n    // may not be grouped into a union.)\n    final ListState listState = new ListState(parent.loader(),\n        parent.vectorCache().childCache(columnSchema.name()));\n\n    // Bind the union state to the union writer to handle column additions.\n    unionWriter.bindListener(listState);\n\n    // Assemble it all into a union column state.\n    return new UnionColumnState(parent.loader(),\n        listWriter, vectorState, listState);\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1693-Param-1",
    "old_comment_raw": "@param file file to upload (required)",
    "old_code_raw": "    public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws ApiException {\n        ApiResponse<ModelApiResponse> resp = uploadFileWithRequiredFileWithHttpInfo(petId, file, additionalMetadata);\n        return resp.getData();\n    }\n",
    "new_code_raw": "    public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException {\n        ApiResponse<ModelApiResponse> resp = uploadFileWithRequiredFileWithHttpInfo(petId, requiredFile, additionalMetadata);\n        return resp.getData();\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-1798-Param-1",
    "old_comment_raw": "@param verbose whether or not to output verbose information.",
    "old_code_raw": "  public QuoteAnnotator(String name, Properties props, boolean verbose) {\n    USE_SINGLE = Boolean.parseBoolean(props.getProperty(name + \".\" + \"singleQuotes\", \"false\"));\n    MAX_LENGTH = Integer.parseInt(props.getProperty(name + \".\" + \"maxLength\", \"-1\"));\n    ASCII_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"asciiQuotes\", \"false\"));\n    ALLOW_EMBEDDED_SAME = Boolean.parseBoolean(props.getProperty(name + \".\" + \"allowEmbeddedSame\", \"false\"));\n    SMART_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"smartQuotes\", \"false\"));\n    EXTRACT_UNCLOSED = Boolean.parseBoolean(props.getProperty(name + \".\" + \"extractUnclosedQuotes\", \"false\"));\n    ATTRIBUTE_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"attributeQuotes\", \"true\"));\n\n    VERBOSE = verbose;\n    Timing timer = null;\n    if (VERBOSE) {\n      timer = new Timing();\n      log.info(\"Preparing quote annotator...\");\n    }\n    if (ATTRIBUTE_QUOTES)\n      quoteAttributionAnnotator = new QuoteAttributionAnnotator(props);\n\n    if (VERBOSE) {\n      timer.stop(\"done.\");\n    }\n  }\n",
    "new_code_raw": "  public QuoteAnnotator(Properties props, boolean verbose) {\n    USE_SINGLE = Boolean.parseBoolean(props.getProperty(\"singleQuotes\", \"false\"));\n    MAX_LENGTH = Integer.parseInt(props.getProperty(\"maxLength\", \"-1\"));\n    ASCII_QUOTES = Boolean.parseBoolean(props.getProperty(\"asciiQuotes\", \"false\"));\n    ALLOW_EMBEDDED_SAME = Boolean.parseBoolean(props.getProperty(\"allowEmbeddedSame\", \"false\"));\n    SMART_QUOTES = Boolean.parseBoolean(props.getProperty(\"smartQuotes\", \"false\"));\n    EXTRACT_UNCLOSED = Boolean.parseBoolean(props.getProperty(\"extractUnclosedQuotes\", \"false\"));\n\n    VERBOSE = verbose;\n    Timing timer = null;\n    if (VERBOSE) {\n      timer = new Timing();\n      log.info(\"Preparing quote annotator...\");\n    }\n\n    if (VERBOSE) {\n      timer.stop(\"done.\");\n    }\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1695-Param-1",
    "old_comment_raw": "@param file file to upload (required)",
    "old_code_raw": "  public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws ApiException {\n    Object localVarPostBody = new Object();\n    \n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n    }\n    \n    // verify the required parameter 'file' is set\n    if (file == null) {\n      throw new ApiException(400, \"Missing the required parameter 'file' when calling uploadFileWithRequiredFile\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake/{petId}/uploadImageWithRequiredFile\".replaceAll(\"\\\\{format\\\\}\",\"json\")\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString()));\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    if (additionalMetadata != null)\n      localVarFormParams.put(\"additionalMetadata\", additionalMetadata);\nif (file != null)\n      localVarFormParams.put(\"file\", file);\n\n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"multipart/form-data\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"petstore_auth\" };\n\n    GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException {\n    Object localVarPostBody = new Object();\n    \n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n    }\n    \n    // verify the required parameter 'requiredFile' is set\n    if (requiredFile == null) {\n      throw new ApiException(400, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake/{petId}/uploadImageWithRequiredFile\".replaceAll(\"\\\\{format\\\\}\",\"json\")\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString()));\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    if (additionalMetadata != null)\n      localVarFormParams.put(\"additionalMetadata\", additionalMetadata);\nif (requiredFile != null)\n      localVarFormParams.put(\"requiredFile\", requiredFile);\n\n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"multipart/form-data\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"petstore_auth\" };\n\n    GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "apache_drill-622-Param-1",
    "old_comment_raw": "@param tabIdxName - The table/index identifier",
    "old_code_raw": "  public double getLeadingRowCount(RexNode condition, String tabIdxName, RelNode scanRel) {\n    String conditionAsStr = nullConditionAsString;\n    Map<String, StatisticsPayload> payloadMap;\n    if ((scanRel instanceof DrillScanRel && ((DrillScanRel)scanRel).getGroupScan() instanceof DbGroupScan)\n        || (scanRel instanceof ScanPrel && ((ScanPrel)scanRel).getGroupScan() instanceof DbGroupScan)) {\n      if (condition == null && fullTableScanPayload != null) {\n        return fullTableScanPayload.getLeadingRowCount();\n      } else if (condition != null) {\n        conditionAsStr = convertRexToString(condition, scanRel.getRowType());\n        payloadMap = statsCache.get(conditionAsStr);\n        if (payloadMap != null) {\n          if (payloadMap.get(tabIdxName) != null) {\n            return payloadMap.get(tabIdxName).getLeadingRowCount();\n          }\n          // Unlike rowcount, leading rowcount is dependent on the index. So, if tab/idx is\n          // not found, we are out of luck!\n        }\n      }\n    }\n    if (statsAvailable) {\n      logger.debug(\"Statistics: Leading filter row count is UNKNOWN for filter: {}\", conditionAsStr);\n    }\n    return ROWCOUNT_UNKNOWN;\n  }\n",
    "new_code_raw": "  public double getLeadingRowCount(RexNode condition, String tabIdxName, DrillScanRelBase scanRel) {\n    String conditionAsStr = nullConditionAsString;\n    Map<String, StatisticsPayload> payloadMap;\n    if ((scanRel instanceof DrillScanRel && ((DrillScanRel)scanRel).getGroupScan() instanceof DbGroupScan)\n        || (scanRel instanceof ScanPrel && ((ScanPrel)scanRel).getGroupScan() instanceof DbGroupScan)) {\n      if (condition == null && fullTableScanPayload != null) {\n        return fullTableScanPayload.getLeadingRowCount();\n      } else if (condition != null) {\n        conditionAsStr = convertRexToString(condition, scanRel.getRowType());\n        payloadMap = statsCache.get(conditionAsStr);\n        if (payloadMap != null) {\n          if (payloadMap.get(tabIdxName) != null) {\n            return payloadMap.get(tabIdxName).getLeadingRowCount();\n          }\n          // Unlike rowcount, leading rowcount is dependent on the index. So, if tab/idx is\n          // not found, we are out of luck!\n        }\n      }\n    }\n    if (statsAvailable) {\n      logger.debug(\"Statistics: Leading filter row count is UNKNOWN for filter: {}\", conditionAsStr);\n    }\n    return ROWCOUNT_UNKNOWN;\n  }\n"
  },
  {
    "id": "facebook_fresco-241-Param-0",
    "old_comment_raw": "@param key",
    "old_code_raw": "  public Task<Boolean> contains(final CacheKey key) {\n    Preconditions.checkNotNull(key);\n\n    final EncodedImage pinnedImage = mStagingArea.get(key);\n    if (pinnedImage != null) {\n      pinnedImage.close();\n      FLog.v(TAG, \"Found image for %s in staging area\", key.toString());\n      mImageCacheStatsTracker.onStagingAreaHit();\n      return Task.forResult(true);\n    }\n\n    try {\n      return Task.call(\n          new Callable<Boolean>() {\n            @Override\n            public Boolean call() throws Exception {\n              EncodedImage result = mStagingArea.get(key);\n              if (result != null) {\n                result.close();\n                FLog.v(TAG, \"Found image for %s in staging area\", key.toString());\n                mImageCacheStatsTracker.onStagingAreaHit();\n                return true;\n              } else {\n                FLog.v(TAG, \"Did not find image for %s in staging area\", key.toString());\n                mImageCacheStatsTracker.onStagingAreaMiss();\n                try {\n                  return mFileCache.hasKey(key);\n                } catch (Exception exception) {\n                  return false;\n                }\n              }\n            }\n          },\n          mReadExecutor);\n    } catch (Exception exception) {\n      // Log failure\n      // TODO: 3697790\n      FLog.w(\n          TAG,\n          exception,\n          \"Failed to schedule disk-cache read for %s\",\n          key.toString());\n      return Task.forError(exception);\n    }\n  }\n",
    "new_code_raw": "  public Task<Boolean> contains(final List<CacheKey> keys) {\n    if (keys.isEmpty()) {\n      return Task.forResult(false);\n    }\n    for (CacheKey key : keys) {\n      EncodedImage pinnedImage = mStagingArea.get(key);\n      if (pinnedImage != null) {\n        pinnedImage.close();\n        FLog.v(TAG, \"Found image for %s in staging area\", key.toString());\n        mImageCacheStatsTracker.onStagingAreaHit();\n        return Task.forResult(true);\n      }\n    }\n    Task<Boolean> masterTask = containsAsync(keys.get(0));\n    if (keys.size() == 1) {\n      return masterTask;\n    }\n    for (final CacheKey key : keys.subList(1, keys.size())) {\n      masterTask = masterTask.continueWithTask(\n          new Continuation<Boolean, Task<Boolean>>() {\n            @Override\n            public Task<Boolean> then(Task<Boolean> previousTask) throws Exception {\n              if (previousTask.isCancelled() || previousTask.getResult()) {\n                return previousTask;\n              }\n              return containsAsync(key);\n            }\n          },\n          mReadExecutor);\n    }\n    return masterTask;\n  }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2134-Param-1",
    "old_comment_raw": "@param selector The property of the sentence we are getting the mode of. For example, Sentence::posTags",
    "old_code_raw": "  public List<String> dependencyPathBetween(int start, int end, Function<Sentence, List<String>> selector) {\n    // Get paths from a node to the root of the sentence\n    LinkedList<Integer> rootToStart = new LinkedList<>();\n    LinkedList<Integer> rootToEnd = new LinkedList<>();\n    int startAncestor = start;\n    List<Optional<Integer>> governors = sentence.governors();\n    Set<Integer> seenVertices = new HashSet<>();\n    while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) {\n      if (seenVertices.contains(startAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(startAncestor);\n      rootToStart.addFirst(startAncestor);\n      startAncestor = governors.get(startAncestor).get();\n    }\n    if (startAncestor == -1) {\n      rootToStart.addFirst(-1);\n    }\n    int endAncestor = end;\n    seenVertices.clear();\n    while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) {\n      if (seenVertices.contains(endAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(endAncestor);\n      rootToEnd.addFirst(endAncestor);\n      endAncestor = governors.get(endAncestor).get();\n    }\n    if (endAncestor == -1) {\n      rootToEnd.addFirst(-1);\n    }\n\n    // Get least common node\n    int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0;\n    for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) {\n      if (rootToStart.get(i).equals(rootToEnd.get(i))) {\n        leastCommonNodeIndex = i;\n      }\n    }\n\n    // Construct the path\n    if (leastCommonNodeIndex < 0) {\n      return Collections.EMPTY_LIST;\n    }\n    List<String> path = new ArrayList<>();\n    for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) {\n      path.add(selector.apply(sentence).get(rootToStart.get(i)));\n      path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\");\n    }\n    path.add(selector.apply(sentence).get(rootToStart.get(leastCommonNodeIndex)));\n    for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) {\n      path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\");\n      path.add(selector.apply(sentence).get(rootToEnd.get(i)));\n    }\n    return path;\n  }\n",
    "new_code_raw": "  public List<String> dependencyPathBetween(int start, int end) {\n    // Get paths from a node to the root of the sentence\n    LinkedList<Integer> rootToStart = new LinkedList<>();\n    LinkedList<Integer> rootToEnd = new LinkedList<>();\n    int startAncestor = start;\n    while (sentence.governor(startAncestor).isPresent() && sentence.governor(startAncestor).get() >= 0) {\n      rootToStart.addFirst(startAncestor);\n      startAncestor = sentence.governor(startAncestor).get();\n    }\n    if (startAncestor == -1) {\n      rootToStart.addFirst(-1);\n    }\n    int endAncestor = start;\n    while (sentence.governor(endAncestor).isPresent() && sentence.governor(endAncestor).get() >= 0) {\n      rootToEnd.addFirst(endAncestor);\n      endAncestor = sentence.governor(endAncestor).get();\n    }\n    if (endAncestor == -1) {\n      rootToEnd.addFirst(-1);\n    }\n\n    // Get least common node\n    return null;   // TODO(gabor) write me!\n\n\n  }\n"
  },
  {
    "id": "RobotiumTech_robotium-1490-Param-0",
    "old_comment_raw": "@param spinnerIndex the index of the spinner to check.  0 if only one spinner is available",
    "old_code_raw": "\tpublic boolean isSpinnerTextSelected(int spinnerIndex, String text)\n\t{\n\t\treturn checker.isSpinnerTextSelected(spinnerIndex, text);\n\t}\n",
    "new_code_raw": "\tpublic boolean isSpinnerTextSelected(int index, String text)\n\t{\n\t\treturn checker.isSpinnerTextSelected(index, text);\n\t}\n"
  },
  {
    "id": "debezium_debezium-182-Param-3",
    "old_comment_raw": "@param data the data object to be converted into an  SET literal String value; never null",
    "old_code_raw": "    protected Object convertSetToString(String options, Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return \"\";\n        }\n        if (data instanceof String) {\n            // JDBC should return strings ...\n            return data;\n        }\n        if (data instanceof Long) {\n            // The binlog will contain a long with the indexes of the options in the set value ...\n            long indexes = ((Long) data).longValue();\n            return convertSetValue(indexes, options);\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n",
    "new_code_raw": "    protected Object convertSetToString(List<String> options, Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return \"\";\n        }\n        if (data instanceof String) {\n            // JDBC should return strings ...\n            return data;\n        }\n        if (data instanceof Long) {\n            // The binlog will contain a long with the indexes of the options in the set value ...\n            long indexes = ((Long) data).longValue();\n            return convertSetValue(indexes, options);\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n"
  },
  {
    "id": "runelite_runelite-122-Param-3",
    "old_comment_raw": "@param tileX the x-axis coordinate of the tile",
    "old_code_raw": "\tpublic static Area getClickbox(@Nonnull Client client, Model model, int orientation, int tileX, int tileY)\n\t{\n\t\tif (model == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tList<Triangle> triangles = model.getTriangles().stream()\n\t\t\t.map(triangle -> triangle.rotate(orientation))\n\t\t\t.collect(Collectors.toList());\n\n\t\tList<Vertex> vertices = model.getVertices().stream()\n\t\t\t\t.map(v -> v.rotate(orientation))\n\t\t\t\t.collect(Collectors.toList());\n\n\t\tArea clickBox = get2DGeometry(client, triangles, orientation, tileX, tileY);\n\t\tArea visibleAABB = getAABB(client, vertices, orientation, tileX, tileY);\n\n\t\tif (visibleAABB == null || clickBox == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tclickBox.intersect(visibleAABB);\n\t\treturn clickBox;\n\t}\n",
    "new_code_raw": "\tpublic static Area getClickbox(@Nonnull Client client, Model model, int orientation, int localX, int localY)\n\t{\n\t\tif (model == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tList<Triangle> triangles = model.getTriangles().stream()\n\t\t\t.map(triangle -> triangle.rotate(orientation))\n\t\t\t.collect(Collectors.toList());\n\n\t\tList<Vertex> vertices = model.getVertices().stream()\n\t\t\t\t.map(v -> v.rotate(orientation))\n\t\t\t\t.collect(Collectors.toList());\n\n\t\tArea clickBox = get2DGeometry(client, triangles, orientation, localX, localY);\n\t\tArea visibleAABB = getAABB(client, vertices, orientation, localX, localY);\n\n\t\tif (visibleAABB == null || clickBox == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tclickBox.intersect(visibleAABB);\n\t\treturn clickBox;\n\t}\n"
  },
  {
    "id": "wildabeast_BarcodeScanner-26-Param-0",
    "old_comment_raw": "@param matrix the scanned barcode image.",
    "old_code_raw": "  private static ResultPoint[] findVertices180(BitMatrix matrix) {\n    int height = matrix.getHeight();\n    int width = matrix.getWidth();\n    int halfWidth = width >> 1;\n\n    ResultPoint[] result = new ResultPoint[8];\n    boolean found = false;\n\n    // Top Left\n    for (int i = height - 1; i > 0; i--) {\n      int[] loc = findGuardPattern(matrix, halfWidth, i, halfWidth, true, START_PATTERN_REVERSE);\n      if (loc != null) {\n        result[0] = new ResultPoint(loc[1], i);\n        result[4] = new ResultPoint(loc[0], i);\n        found = true;\n        break;\n      }\n    }\n    // Bottom Left\n    if (found) { // Found the Top Left vertex\n      found = false;\n      for (int i = 0; i < height; i++) {\n        int[] loc = findGuardPattern(matrix, halfWidth, i, halfWidth, true, START_PATTERN_REVERSE);\n        if (loc != null) {\n          result[1] = new ResultPoint(loc[1], i);\n          result[5] = new ResultPoint(loc[0], i);\n          found = true;\n          break;\n        }\n      }\n    }\n    // Top Right\n    if (found) { // Found the Bottom Left vertex\n      found = false;\n      for (int i = height - 1; i > 0; i--) {\n        int[] loc = findGuardPattern(matrix, 0, i, halfWidth, false, STOP_PATTERN_REVERSE);\n        if (loc != null) {\n          result[2] = new ResultPoint(loc[0], i);\n          result[6] = new ResultPoint(loc[1], i);\n          found = true;\n          break;\n        }\n      }\n    }\n    // Bottom Right\n    if (found) { // Found the Top Right vertex\n      found = false;\n      for (int i = 0; i < height; i++) {\n        int[] loc = findGuardPattern(matrix, 0, i, halfWidth, false, STOP_PATTERN_REVERSE);\n        if (loc != null) {\n          result[3] = new ResultPoint(loc[0], i);\n          result[7] = new ResultPoint(loc[1], i);\n          found = true;\n          break;\n        }\n      }\n    }\n    return found ? result : null;\n  }\n",
    "new_code_raw": "  private static ResultPoint[] findVertices180(BitMatrix matrix, boolean tryHarder) {\n    int height = matrix.getHeight();\n    int width = matrix.getWidth();\n    int halfWidth = width >> 1;\n\n    ResultPoint[] result = new ResultPoint[8];\n    boolean found = false;\n\n    int[] counters = new int[START_PATTERN_REVERSE.length];\n\n    int rowStep = Math.max(1, height >> (tryHarder ? 9 : 7));\n\n    // Top Left\n    for (int i = height - 1; i > 0; i -= rowStep) {\n      int[] loc = findGuardPattern(matrix, halfWidth, i, halfWidth, true, START_PATTERN_REVERSE, counters);\n      if (loc != null) {\n        result[0] = new ResultPoint(loc[1], i);\n        result[4] = new ResultPoint(loc[0], i);\n        found = true;\n        break;\n      }\n    }\n    // Bottom Left\n    if (found) { // Found the Top Left vertex\n      found = false;\n      for (int i = 0; i < height; i += rowStep) {\n        int[] loc = findGuardPattern(matrix, halfWidth, i, halfWidth, true, START_PATTERN_REVERSE, counters);\n        if (loc != null) {\n          result[1] = new ResultPoint(loc[1], i);\n          result[5] = new ResultPoint(loc[0], i);\n          found = true;\n          break;\n        }\n      }\n    }\n    \n    counters = new int[STOP_PATTERN_REVERSE.length];\n    \n    // Top Right\n    if (found) { // Found the Bottom Left vertex\n      found = false;\n      for (int i = height - 1; i > 0; i -= rowStep) {\n        int[] loc = findGuardPattern(matrix, 0, i, halfWidth, false, STOP_PATTERN_REVERSE, counters);\n        if (loc != null) {\n          result[2] = new ResultPoint(loc[0], i);\n          result[6] = new ResultPoint(loc[1], i);\n          found = true;\n          break;\n        }\n      }\n    }\n    // Bottom Right\n    if (found) { // Found the Top Right vertex\n      found = false;\n      for (int i = 0; i < height; i += rowStep) {\n        int[] loc = findGuardPattern(matrix, 0, i, halfWidth, false, STOP_PATTERN_REVERSE, counters);\n        if (loc != null) {\n          result[3] = new ResultPoint(loc[0], i);\n          result[7] = new ResultPoint(loc[1], i);\n          found = true;\n          break;\n        }\n      }\n    }\n    return found ? result : null;\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-325-Param-1",
    "old_comment_raw": "@param clazz the annotation class to check for",
    "old_code_raw": "\tpublic static AnnotationMirror getAnnotationMirror(Element element, Class<? extends Annotation> clazz) {\n\t\tassert clazz != null;\n\t\treturn getAnnotationMirror( element, clazz.getName() );\n\t}\n",
    "new_code_raw": "\tpublic static AnnotationMirror getAnnotationMirror(Element element, String fqcn) {\n\t\tassert element != null;\n\t\tassert fqcn != null;\n\n\t\tAnnotationMirror mirror = null;\n\t\tfor ( AnnotationMirror am : element.getAnnotationMirrors() ) {\n\t\t\tif ( isAnnotationMirrorOfType( am, fqcn ) ) {\n\t\t\t\tmirror = am;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn mirror;\n\t}\n"
  },
  {
    "id": "rstudio_rstudio-134-Param-0",
    "old_comment_raw": "@param code escape sequence",
    "old_code_raw": "   public String processCode(String code, String baseClazz)\n   {\n      if (code == null || code.length() < 2)\n         return getStyle(baseClazz); // unrecognized sequence, ignore\n      if (code.charAt(0) != '\\033' && code.charAt(code.length() - 1) != 'm')\n         return getStyle(baseClazz); // unsupported sequence, ignore\n      if (code.length() == 2)\n      {\n         clazzes_.clear(); // CSIm is equivalent to CSI0m, which is 'reset'\n         return getStyle(baseClazz);\n      }\n      \n      int extendedColor = 0;\n      boolean extendedMarkerSeen = false;\n      boolean extendedRGBMarkerSeen = false;\n      int extendedRGBColorsSeen = 0;\n      \n      String[] tokens = code.substring(2, code.length() - 1).split(\";\");\n      for (String token : tokens)\n      {\n         int codeVal = StringUtil.parseInt(token,  -1);\n         if (codeVal == -1)\n            continue;\n\n         if (extendedColor > 0)\n         {\n            if (!extendedMarkerSeen && !extendedRGBMarkerSeen)\n            {\n               if (codeVal == EXT_BY_INDEX)\n               {\n                  extendedMarkerSeen = true;\n                  continue;\n               }\n               else if (codeVal == EXT_BY_RGB)\n               {\n                  extendedRGBMarkerSeen = true;\n                  extendedRGBColorsSeen = 0;\n               }\n               else\n               {\n                  // unknown extended color format; hard to recover so\n                  // just reset back to defaults and return\n                  clazzes_.clear();\n                  return getStyle(baseClazz);\n               }\n            }\n            else\n            {\n               // We don't support colors specified via RGB, but parse the\n               // sequence then ignore it in case there are supported \n               // sequences after it\n               if (extendedRGBMarkerSeen)\n               {\n                  extendedRGBColorsSeen++;\n                  if (extendedRGBColorsSeen == 3 /*red, green, blue*/)\n                  {\n                     extendedColor = 0;\n                     extendedRGBMarkerSeen = false;\n                     extendedRGBColorsSeen = 0;\n                  }\n               }\n               else \n               {\n                  if (extendedColor == FOREGROUND_EXT)\n                  {\n                     if (codeVal >= 0 && codeVal <= 255)\n                     {\n                        currentColor_.setExtended(codeVal);\n                        resetForeground();\n                        clazzes_.add(Color.clazzForColorIndex(codeVal, \n                              false /*background*/));\n                     }\n                  }\n                  else\n                  {\n                     if (codeVal >= 0 && codeVal <= 255)\n                     {\n                        currentBgColor_.setExtended(codeVal);\n                        resetBackground();\n                        clazzes_.add(Color.clazzForColorIndex(codeVal, \n                              true /*background*/));\n                     }\n                  }\n                  extendedColor = 0;\n                  extendedMarkerSeen = false;\n               }\n            }\n         }\n         else if (codeVal == RESET)\n         {\n            inverted_ = false;\n            currentColor_.reset();\n            currentBgColor_.reset();\n            clazzes_.clear();\n         }\n         else if (codeVal == BOLD)\n         {\n            clazzes_.add(BOLD_STYLE);\n         }\n         else if (codeVal == BLURRED)\n         {\n            // NYI clazzes_.add(BLURRED_STYLE);\n         }\n         else if (codeVal == BOLD_BLURRED_OFF)\n         {\n            clazzes_.remove(BOLD_STYLE);\n            // NYI clazzes_.remove(BLURRED_STYLE);\n         }\n         else if (codeVal == ITALIC)\n         {\n            // NYI clazzes_.add(ITALIC_STYLE);\n         }\n         else if (codeVal == ITALIC_OFF)\n         {\n            // NYI clazzes_.remove(ITALIC_STYLE);\n         }\n         else if (codeVal == UNDERLINE)\n         {\n            clazzes_.add(UNDERLINE_STYLE);\n         }\n         else if (codeVal == UNDERLINE_OFF)\n         {\n            clazzes_.remove(UNDERLINE_STYLE);\n         }\n         else if (codeVal == BLINKSLOW || codeVal == BLINKFAST)\n         {\n            clazzes_.add(BLINK_STYLE);\n         }\n         else if (codeVal == BLINK_OFF)\n         {\n            clazzes_.remove(BLINK_STYLE);\n         }\n         else if (codeVal == INVERSE)\n         {\n            if (!inverted_)\n            {\n               resetForeground();\n               resetBackground();\n               Color newFg = invertFgColor();\n               Color newBg = invertBgColor();\n               currentColor_ = newFg;\n               currentBgColor_ = newBg;\n               inverted_ = true;\n            }\n         }\n         else if (codeVal == INVERSE_OFF)\n         {\n            if (inverted_)\n            {\n               resetForeground();\n               resetBackground();\n               Color newFg = invertFgColor();\n               Color newBg = invertBgColor();\n               currentColor_ = newFg;\n               currentBgColor_ = newBg;\n               inverted_ = false;\n            }\n         }\n         else if (codeVal == HIDDEN)\n         {\n            clazzes_.add(HIDDEN_STYLE);\n         }\n         else if (codeVal == HIDDEN_OFF)\n         {\n            clazzes_.remove(HIDDEN_STYLE);\n         }\n         else if (codeVal == STRIKETHROUGH)\n         {\n            // NYI clazzes_.add(STRIKETHROUGH_STYLE);\n         }\n         else if (codeVal == STRIKETHROUGH_OFF)\n         {\n            // NYI clazzes_.remove(STRIKETHROUGH_OFF);\n         }\n         else if (Color.isFgColorCode(codeVal))\n         {\n            currentColor_.setCode(codeVal);\n            resetForeground();\n            clazzes_.add(clazzForColor(codeVal));\n         }\n         else if (Color.isBgColorCode(codeVal))\n         {\n            currentBgColor_ = new Color(false, codeVal);\n            resetBackground();\n            clazzes_.add(clazzForBgColor(codeVal));\n         }\n         else if (codeVal == RESET_FOREGROUND)\n         {\n            currentColor_.reset();\n            resetForeground();\n         }\n         else if (codeVal == RESET_BACKGROUND)\n         {\n            currentBgColor_.reset();\n            resetBackground();\n         }\n         else if (codeVal == FOREGROUND_EXT)\n         {\n           extendedColor = codeVal;\n           extendedMarkerSeen = false;\n         }\n         else if (codeVal == BACKGROUND_EXT)\n         {\n           extendedColor = codeVal;\n           extendedMarkerSeen = false;\n         }\n         else\n         {\n            // ignore all others\n         }\n      }\n      return getStyle(baseClazz);\n   }\n",
    "new_code_raw": "   public String processCode(String code)\n   {\n      if (code == null || code.length() < 2)\n         return null;\n      if (code.charAt(0) != '\\033' && code.charAt(code.length() - 1) != 'm')\n         return null;\n      if (code.length() == 2)\n      {\n         clazzes_.clear(); // CSIm is equivalent to CSI0m, which is 'reset'\n         return null;\n      }\n      \n      int extendedColor = 0;\n      boolean extendedMarkerSeen = false;\n      boolean extendedRGBMarkerSeen = false;\n      int extendedRGBColorsSeen = 0;\n      \n      String[] tokens = code.substring(2, code.length() - 1).split(\";\");\n      for (String token : tokens)\n      {\n         int codeVal = StringUtil.parseInt(token,  -1);\n         if (codeVal == -1)\n            continue;\n\n         if (extendedColor > 0)\n         {\n            if (!extendedMarkerSeen && !extendedRGBMarkerSeen)\n            {\n               if (codeVal == EXT_BY_INDEX)\n               {\n                  extendedMarkerSeen = true;\n                  continue;\n               }\n               else if (codeVal == EXT_BY_RGB)\n               {\n                  extendedRGBMarkerSeen = true;\n                  extendedRGBColorsSeen = 0;\n               }\n               else\n               {\n                  // unknown extended color format; hard to recover so\n                  // just reset back to defaults and return\n                  clazzes_.clear();\n                  return null;\n               }\n            }\n            else\n            {\n               // We don't support colors specified via RGB, but parse the\n               // sequence then ignore it in case there are supported \n               // sequences after it\n               if (extendedRGBMarkerSeen)\n               {\n                  extendedRGBColorsSeen++;\n                  if (extendedRGBColorsSeen == 3 /*red, green, blue*/)\n                  {\n                     extendedColor = 0;\n                     extendedRGBMarkerSeen = false;\n                     extendedRGBColorsSeen = 0;\n                  }\n               }\n               else \n               {\n                  if (extendedColor == FOREGROUND_EXT)\n                  {\n                     if (codeVal >= 0 && codeVal <= 255)\n                     {\n                        currentColor_.setExtended(codeVal);\n                        resetForeground();\n                        clazzes_.add(Color.clazzForColorIndex(codeVal, \n                              false /*background*/));\n                     }\n                  }\n                  else\n                  {\n                     if (codeVal >= 0 && codeVal <= 255)\n                     {\n                        currentBgColor_.setExtended(codeVal);\n                        resetBackground();\n                        clazzes_.add(Color.clazzForColorIndex(codeVal, \n                              true /*background*/));\n                     }\n                  }\n                  extendedColor = 0;\n                  extendedMarkerSeen = false;\n               }\n            }\n         }\n         else if (codeVal == RESET)\n         {\n            inverted_ = false;\n            currentColor_.reset();\n            currentBgColor_.reset();\n            clazzes_.clear();\n         }\n         else if (codeVal == BOLD)\n         {\n            clazzes_.add(BOLD_STYLE);\n         }\n         else if (codeVal == BLURRED)\n         {\n            // NYI clazzes_.add(BLURRED_STYLE);\n         }\n         else if (codeVal == BOLD_BLURRED_OFF)\n         {\n            clazzes_.remove(BOLD_STYLE);\n            // NYI clazzes_.remove(BLURRED_STYLE);\n         }\n         else if (codeVal == ITALIC)\n         {\n            // NYI clazzes_.add(ITALIC_STYLE);\n         }\n         else if (codeVal == ITALIC_OFF)\n         {\n            // NYI clazzes_.remove(ITALIC_STYLE);\n         }\n         else if (codeVal == UNDERLINE)\n         {\n            clazzes_.add(UNDERLINE_STYLE);\n         }\n         else if (codeVal == UNDERLINE_OFF)\n         {\n            clazzes_.remove(UNDERLINE_STYLE);\n         }\n         else if (codeVal == BLINKSLOW || codeVal == BLINKFAST)\n         {\n            clazzes_.add(BLINK_STYLE);\n         }\n         else if (codeVal == BLINK_OFF)\n         {\n            clazzes_.remove(BLINK_STYLE);\n         }\n         else if (codeVal == INVERSE)\n         {\n            if (!inverted_)\n            {\n               resetForeground();\n               resetBackground();\n               Color newFg = invertFgColor();\n               Color newBg = invertBgColor();\n               currentColor_ = newFg;\n               currentBgColor_ = newBg;\n               inverted_ = true;\n            }\n         }\n         else if (codeVal == INVERSE_OFF)\n         {\n            if (inverted_)\n            {\n               resetForeground();\n               resetBackground();\n               Color newFg = invertFgColor();\n               Color newBg = invertBgColor();\n               currentColor_ = newFg;\n               currentBgColor_ = newBg;\n               inverted_ = false;\n            }\n         }\n         else if (codeVal == HIDDEN)\n         {\n            clazzes_.add(HIDDEN_STYLE);\n         }\n         else if (codeVal == HIDDEN_OFF)\n         {\n            clazzes_.remove(HIDDEN_STYLE);\n         }\n         else if (codeVal == STRIKETHROUGH)\n         {\n            // NYI clazzes_.add(STRIKETHROUGH_STYLE);\n         }\n         else if (codeVal == STRIKETHROUGH_OFF)\n         {\n            // NYI clazzes_.remove(STRIKETHROUGH_OFF);\n         }\n         else if (Color.isFgColorCode(codeVal))\n         {\n            currentColor_.setCode(codeVal);\n            resetForeground();\n            clazzes_.add(clazzForColor(codeVal));\n         }\n         else if (Color.isBgColorCode(codeVal))\n         {\n            currentBgColor_ = new Color(false, codeVal);\n            resetBackground();\n            clazzes_.add(clazzForBgColor(codeVal));\n         }\n         else if (codeVal == RESET_FOREGROUND)\n         {\n            currentColor_.reset();\n            resetForeground();\n         }\n         else if (codeVal == RESET_BACKGROUND)\n         {\n            currentBgColor_.reset();\n            resetBackground();\n         }\n         else if (codeVal == FOREGROUND_EXT)\n         {\n           extendedColor = codeVal;\n           extendedMarkerSeen = false;\n         }\n         else if (codeVal == BACKGROUND_EXT)\n         {\n           extendedColor = codeVal;\n           extendedMarkerSeen = false;\n         }\n         else\n         {\n            // ignore all others\n         }\n      }\n      return getStyle();\n   }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1973-Param-1",
    "old_comment_raw": "@param id The identifier of the entity currently demanding load.",
    "old_code_raw": "\tprivate boolean isCached(EntityKey entityKey, EntityPersister persister) {\n\t\tif ( persister.hasCache() ) {\n\t\t\tCacheKey key = context.getSession().generateCacheKey(\n\t\t\t\t\tentityKey.getIdentifier(),\n\t\t\t\t\tpersister.getIdentifierType(),\n\t\t\t\t\tentityKey.getEntityName()\n\t\t\t);\n\t\t\treturn persister.getCacheAccessStrategy().get( key, context.getSession().getTimestamp() ) != null;\n\t\t}\n\t\treturn false;\n\t}\n",
    "new_code_raw": "\tprivate boolean isCached(Serializable collectionKey, CollectionPersister persister) {\n\t\tif ( persister.hasCache() ) {\n\t\t\tCacheKey cacheKey = context.getSession().generateCacheKey(\n\t\t\t\t\tcollectionKey,\n\t\t\t        persister.getKeyType(),\n\t\t\t        persister.getRole()\n\t\t\t);\n\t\t\treturn persister.getCacheAccessStrategy().get( cacheKey, context.getSession().getTimestamp() ) != null;\n\t\t}\n\t\treturn false;\n\t}\n"
  },
  {
    "id": "apache_drill-1288-Param-1",
    "old_comment_raw": "@param colProj implied projection type for the column",
    "old_code_raw": "  private ColumnState buildPrimitive(ContainerState parent, ColumnReadProjection colProj) {\n    ColumnMetadata columnSchema = colProj.providedSchema();\n\n    ValueVector vector;\n    if (!colProj.isProjected() && !allowCreation(parent)) {\n\n      // Column is not projected. No materialized backing for the column.\n\n      vector = null;\n    } else {\n\n      // Create the vector for the column.\n\n      vector = parent.vectorCache().addOrGet(columnSchema.schema());\n\n      // In permissive mode, the mode or precision of the vector may differ\n      // from that requested. Update the schema to match.\n\n      if (parent.vectorCache().isPermissive() && ! vector.getField().isEquivalent(columnSchema.schema())) {\n        columnSchema = ((PrimitiveColumnMetadata) columnSchema).mergeWith(vector.getField());\n      }\n    }\n\n    // Create the writer.\n\n    final AbstractObjectWriter colWriter = ColumnWriterFactory.buildColumnWriter(\n        columnSchema, colProj.conversionFactory(), vector);\n\n    // Build the vector state which manages the vector.\n\n    VectorState vectorState;\n    if (vector == null) {\n      vectorState = new NullVectorState();\n    } else if (columnSchema.isArray()) {\n      vectorState = new RepeatedVectorState(colWriter.array(), (RepeatedValueVector) vector);\n    } else if (columnSchema.isNullable()) {\n      vectorState = new NullableVectorState(\n          colWriter, (NullableVector) vector);\n    } else {\n      vectorState = SimpleVectorState.vectorState(columnSchema,\n            colWriter.events(), vector);\n    }\n\n    // Create the column state which binds the vector and writer together.\n\n    return new PrimitiveColumnState(parent.loader(), colWriter,\n        vectorState);\n  }\n",
    "new_code_raw": "  private ColumnState buildPrimitive(ContainerState parent, ColumnMetadata columnSchema) {\n\n    final ValueVector vector;\n    if (parent.projection().isProjected(columnSchema) || allowCreation(parent)) {\n\n      // Create the vector for the column.\n      vector = parent.vectorCache().vectorFor(columnSchema.schema());\n\n      // In permissive mode, the mode or precision of the vector may differ\n      // from that requested. Update the schema to match.\n      if (parent.vectorCache().isPermissive() && !vector.getField().isEquivalent(columnSchema.schema())) {\n        columnSchema = ((PrimitiveColumnMetadata) columnSchema).mergeWith(vector.getField());\n      }\n    } else {\n\n      // Column is not projected. No materialized backing for the column.\n      vector = null;\n    }\n\n    // Create the writer.\n    final AbstractObjectWriter colWriter =\n        ColumnWriterFactory.buildColumnWriter(columnSchema, vector);\n\n    // Build the vector state which manages the vector.\n    VectorState vectorState;\n    if (vector == null) {\n      vectorState = new NullVectorState();\n    } else if (columnSchema.isArray()) {\n      vectorState = new RepeatedVectorState(colWriter.array(), (RepeatedValueVector) vector);\n    } else if (columnSchema.isNullable()) {\n      vectorState = new NullableVectorState(\n          colWriter, (NullableVector) vector);\n    } else {\n      vectorState = SimpleVectorState.vectorState(columnSchema,\n            colWriter.events(), vector);\n    }\n\n    // Create the column state which binds the vector and writer together.\n    return new PrimitiveColumnState(parent.loader(), colWriter, vectorState);\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1618-Param-1",
    "old_comment_raw": "@param p Swagger property object",
    "old_code_raw": "    public String toDefaultValueWithParam(String name, Property p) {\n        return \" = data.\" + name + \";\";\n    }\n",
    "new_code_raw": "    public String toDefaultValueWithParam(String name, Schema schema) {\n        return \" = data.\" + name + \";\";\n    }\n"
  },
  {
    "id": "Atmosphere_atmosphere-273-Param-0",
    "old_comment_raw": "@param request",
    "old_code_raw": "    protected boolean isDisconnectRequest(HttpServletRequest request) {\n\n        if (\"GET\".equals(request.getMethod())) {\n\n            if (request.getParameterMap().containsKey(\"disconnect\")) {\n                return true;\n            }\n\n        } else if (\"POST\".equals(request.getMethod())) {\n            try {\n                String data = decodePostData(request.getContentType(), extractString(request.getReader()));\n                request.setAttribute(POST_MESSAGE_RECEIVED, data);\n                if (data != null && data.length() > 0) {\n                    List<SocketIOPacketImpl> list = SocketIOPacketImpl.parse(data);\n                    if (!list.isEmpty()) {\n                        if (SocketIOPacketImpl.PacketType.DISCONNECT.equals(list.get(0).getFrameType())) {\n                            return true;\n                        }\n                    }\n\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n        }\n\n        return false;\n    }\n",
    "new_code_raw": "    protected boolean isDisconnectRequest(AtmosphereRequest request) {\n\n        if (\"GET\".equals(request.getMethod())) {\n\n            if (request.getParameterMap().containsKey(\"disconnect\")) {\n                return true;\n            }\n\n        } else if (\"POST\".equals(request.getMethod())) {\n            try {\n                String data = decodePostData(request.getContentType(), extractString(request.getReader()));\n                request.setAttribute(POST_MESSAGE_RECEIVED, data);\n                if (data != null && data.length() > 0) {\n                    List<SocketIOPacketImpl> list = SocketIOPacketImpl.parse(data);\n                    if (!list.isEmpty()) {\n                        if (SocketIOPacketImpl.PacketType.DISCONNECT.equals(list.get(0).getFrameType())) {\n                            return true;\n                        }\n                    }\n\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n        }\n\n        return false;\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1659-Param-0",
    "old_comment_raw": "@param body client model (required)",
    "old_code_raw": "    public Client testSpecialTags(Client body) throws ApiException {\n        ApiResponse<Client> resp = testSpecialTagsWithHttpInfo(body);\n        return resp.getData();\n    }\n",
    "new_code_raw": "    public Client testSpecialTags(Client client) throws ApiException {\n        ApiResponse<Client> resp = testSpecialTagsWithHttpInfo(client);\n        return resp.getData();\n    }\n"
  },
  {
    "id": "debezium_debezium-544-Param-0",
    "old_comment_raw": "@param schemaPrefix the prefix added to the table identifier to construct the schema names; may be null if there is no prefix",
    "old_code_raw": "    public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers) {\n        if (schemaPrefix == null) {\n            schemaPrefix = \"\";\n        }\n\n        // Build the schemas ...\n        final TableId tableId = table.id();\n        final String tableIdStr = tableSchemaName(tableId);\n        final String schemaNamePrefix = schemaPrefix + tableIdStr;\n        LOGGER.debug(\"Mapping table '{}' to schemas under '{}'\", tableId, schemaNamePrefix);\n        SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Value\"));\n        SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Key\"));\n        AtomicBoolean hasPrimaryKey = new AtomicBoolean(false);\n        table.columns().forEach(column -> {\n            if (table.isPrimaryKeyColumn(column.name())) {\n                // The column is part of the primary key, so ALWAYS add it to the PK schema ...\n                addField(keySchemaBuilder, column, null);\n                hasPrimaryKey.set(true);\n            }\n            if (filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name())) {\n                // Add the column to the value schema only if the column has not been filtered ...\n                ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column);\n                addField(valSchemaBuilder, column, mapper);\n            }\n        });\n        Schema valSchema = valSchemaBuilder.optional().build();\n        Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null;\n\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Mapped primary key for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(keySchema));\n            LOGGER.debug(\"Mapped columns for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(valSchema));\n        }\n\n        Envelope envelope = Envelope.defineSchema()\n                .withName(schemaNameAdjuster.adjust(envelopSchemaName))\n                .withRecord(valSchema)\n                .withSource(sourceInfoSchema)\n                .build();\n\n\n        // Create the generators ...\n        Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, table.primaryKeyColumns());\n        Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers);\n\n        // And the table schema ...\n        return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator);\n    }\n",
    "new_code_raw": "    public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers, CustomKeyMapper keysMapper) {\n        if (schemaPrefix == null) {\n            schemaPrefix = \"\";\n        }\n\n        // Build the schemas ...\n        final TableId tableId = table.id();\n        final String tableIdStr = tableSchemaName(tableId);\n        final String schemaNamePrefix = schemaPrefix + tableIdStr;\n        LOGGER.debug(\"Mapping table '{}' to schemas under '{}'\", tableId, schemaNamePrefix);\n        SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Value\"));\n        SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Key\"));\n        AtomicBoolean hasPrimaryKey = new AtomicBoolean(false);\n        \n        Key tableKey = new Key.Builder(table).customKeyMapper(keysMapper).build();\n        tableKey.keyColumns().forEach(column -> {\n            addField(keySchemaBuilder, column, null);\n            hasPrimaryKey.set(true);\n        });\n        \n        table.columns()\n            .stream()\n            .filter(column -> filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name()))\n            .forEach(column -> {\n                ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column);\n                addField(valSchemaBuilder, column, mapper);\n            });\n        \n        Schema valSchema = valSchemaBuilder.optional().build();\n        Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null;\n\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Mapped primary key for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(keySchema));\n            LOGGER.debug(\"Mapped columns for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(valSchema));\n        }\n\n        Envelope envelope = Envelope.defineSchema()\n                .withName(schemaNameAdjuster.adjust(envelopSchemaName))\n                .withRecord(valSchema)\n                .withSource(sourceInfoSchema)\n                .build();\n\n\n        // Create the generators ...\n        Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, tableKey.keyColumns());\n        Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers);\n\n        // And the table schema ...\n        return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator);\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-157-Param-0",
    "old_comment_raw": "@param elems The list of items",
    "old_code_raw": "  public int[] indices(Collection<E> elems) {\n    int[] indices = new int[elems.size()];\n    int i = 0;\n    for (E elem : elems) {\n      indices[i++] = indexOf(elem);\n    }\n    return indices;\n  }\n",
    "new_code_raw": "  public int[] indices(Collection<E> elements) {\n    int[] indices = new int[elements.size()];\n    int i = 0;\n    for (E elem : elements) {\n      indices[i++] = indexOf(elem);\n    }\n    return indices;\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-950-Param-1",
    "old_comment_raw": "@param name Updated name of the pet",
    "old_code_raw": "  public void updatePetWithForm (Long petId, String name, String status) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = null;\n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'petId' when calling updatePetWithForm\",\n        new ApiException(400, \"Missing the required parameter 'petId' when calling updatePetWithForm\"));\n    }\n\n    // create path and map variables\n    String path = \"/pet/{petId}\".replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString()));\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n      \"application/x-www-form-urlencoded\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      if (name != null) {\n        localVarBuilder.addTextBody(\"name\", ApiInvoker.parameterToString(name), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      if (status != null) {\n        localVarBuilder.addTextBody(\"status\", ApiInvoker.parameterToString(status), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n      formParams.put(\"name\", ApiInvoker.parameterToString(name));\n      formParams.put(\"status\", ApiInvoker.parameterToString(status));\n    }\n\n    String[] authNames = new String[] { \"petstore_auth\" };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n",
    "new_code_raw": "  public void updatePetWithForm (String petId, String name, String status) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = null;\n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'petId' when calling updatePetWithForm\",\n        new ApiException(400, \"Missing the required parameter 'petId' when calling updatePetWithForm\"));\n    }\n\n    // create path and map variables\n    String path = \"/pet/{petId}\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString()));\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n      \"application/x-www-form-urlencoded\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      if (name != null) {\n        localVarBuilder.addTextBody(\"name\", ApiInvoker.parameterToString(name), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      if (status != null) {\n        localVarBuilder.addTextBody(\"status\", ApiInvoker.parameterToString(status), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n      formParams.put(\"name\", ApiInvoker.parameterToString(name));\n      formParams.put(\"status\", ApiInvoker.parameterToString(status));\n    }\n\n    String[] authNames = new String[] { \"petstore_auth\" };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n       if (ex.getCause() instanceof VolleyError) {\n         VolleyError volleyError = (VolleyError)ex.getCause();\n         if (volleyError.networkResponse != null) {\n           throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n         }\n       }\n       throw ex;\n    } catch (TimeoutException ex) {\n       throw ex;\n    }\n  }\n"
  },
  {
    "id": "zaproxy_zaproxy-2144-Param-0",
    "old_comment_raw": "@param invoker the component of the invoker",
    "old_code_raw": "\tprotected boolean processExtensionPopupChildren(Component invoker) {\n\t\tboolean childEnable = false;\n\t\tfor (int index = 0; index < this.getItemCount(); index++) {\n\t\t\tJMenuItem item = this.getItem(index);\n\t\t\tif (item instanceof PopupMenuHistoryReference) {\n\t\t\t\tPopupMenuHistoryReference itemRef=(PopupMenuHistoryReference) item;\n\t\t\t\tif (itemRef.isEnableForComponent(invoker)) {\n\t\t\t\t\tchildEnable = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn childEnable;\n\t}\n",
    "new_code_raw": "\tprotected boolean processExtensionPopupChildren(PopupMenuUtils.PopupMenuInvokerWrapper invokerWrapper) {\n\t\tboolean childEnable = false;\n\t\tfor (int index = 0; index < this.getItemCount(); index++) {\n\t\t\tJMenuItem item = this.getItem(index);\n\t\t\tif (isEnableForComponent(item, invokerWrapper)) {\n\t\t\t\tchildEnable = true;\n\t\t\t}\n\t\t}\n\t\treturn childEnable;\n\t}\n"
  },
  {
    "id": "SeleniumHQ_selenium-151-Param-1",
    "old_comment_raw": "@param parameters The parameters to execute that command with",
    "old_code_raw": "  public Object execute(DriverCommand commandName, Map<String, ?> parameters) {\n    Response response;\n\n    if (parameters == null || parameters.size() == 0) {\n      response = driver.execute(commandName);\n    } else {\n      response = driver.execute(commandName, parameters);\n    }\n\n    return response.getValue();\n  }\n",
    "new_code_raw": "  public Object execute(String commandName, Map<String, ?> parameters) {\n    Response response;\n\n    if (parameters == null || parameters.size() == 0) {\n      response = driver.execute(commandName);\n    } else {\n      response = driver.execute(commandName, parameters);\n    }\n\n    return response.getValue();\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1700-Param-0",
    "old_comment_raw": "@param client client model",
    "old_code_raw": "    public Client call123testSpecialTags(Client client, Map<String, Object> params) throws IOException {\n        HttpResponse response = call123testSpecialTagsForHttpResponse(client, params);\n        TypeReference typeRef = new TypeReference<Client>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n",
    "new_code_raw": "    public Client call123testSpecialTags(Client body, Map<String, Object> params) throws IOException {\n        HttpResponse response = call123testSpecialTagsForHttpResponse(body, params);\n        TypeReference typeRef = new TypeReference<Client>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-707-Param-0",
    "old_comment_raw": "@param number None (required)",
    "old_code_raw": "  public ApiResponse<Void> testEndpointParametersWithHttpInfo(String number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password) throws ApiException {\n    Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, null, null);\n    return apiClient.execute(call);\n  }\n",
    "new_code_raw": "  public ApiResponse<Void> testEndpointParametersWithHttpInfo(BigDecimal number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password) throws ApiException {\n    Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, null, null);\n    return apiClient.execute(call);\n  }\n"
  },
  {
    "id": "cryptomator_cryptomator-13-Param-0",
    "old_comment_raw": "@param localPort local TCP port of the webdav share",
    "old_code_raw": "\tpublic static WebDavMount mount(int localPort) throws CommandFailedException {\n\t\treturn chooseStrategy().mount(localPort);\n\t}\n",
    "new_code_raw": "\tpublic static WebDavMount mount(URI uri) throws CommandFailedException {\n\t\treturn chooseStrategy().mount(uri);\n\t}\n"
  },
  {
    "id": "JodaOrg_joda_time-1087-Param-1",
    "old_comment_raw": "@param month the month (1,12) to update the time to.",
    "old_code_raw": "    public long set(long millis, int month) {\n        super.verifyValueBounds(month, MIN, MAX);\n        //\n        int thisYear = iChronology.year().get(millis);\n        //\n        int thisDom = iChronology.getDayOfMonth(millis, thisYear);\n        int maxDom = iChronology.getDaysInYearMonth(thisYear, month);\n        if (thisDom > maxDom) {\n            // Quietly force DOM to nearest sane value.\n            thisDom = maxDom;\n        }\n        // Return newly calculated millis value\n        return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n            iChronology.millisOfDay().get(millis);\n    }\n",
    "new_code_raw": "    public long set(long instant, int month) {\n        Utils.verifyValueBounds(this, month, MIN, MAX);\n        //\n        int thisYear = iChronology.year().get(instant);\n        //\n        int thisDom = iChronology.getDayOfMonth(instant, thisYear);\n        int maxDom = iChronology.getDaysInYearMonth(thisYear, month);\n        if (thisDom > maxDom) {\n            // Quietly force DOM to nearest sane value.\n            thisDom = maxDom;\n        }\n        // Return newly calculated millis value\n        return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n            iChronology.millisOfDay().get(instant);\n    }\n"
  },
  {
    "id": "SeleniumHQ_selenium-840-Param-1",
    "old_comment_raw": "@param sub_locator used to find child element. For example td By.xpath(\"./tr/td\")",
    "old_code_raw": "      public List<WebElement> apply(WebDriver webDriver) {\n        List<WebElement> elements = null;\n        try {\n          elements = webDriver.findElement(locator).findElements(sub_locator);\n        } catch (Exception e) {/**/}\n        if (elements != null && elements.size() > 0) {\n          return elements;\n        }\n        return null;\n      }\n",
    "new_code_raw": "      public List<WebElement> apply(WebDriver driver) {\n        List<WebElement> allChildren = findElement(parent, driver).findElements(childLocator);\n\n        return allChildren.isEmpty() ? null : allChildren;\n      }\n"
  },
  {
    "id": "wildabeast_BarcodeScanner-25-Param-0",
    "old_comment_raw": "@param matrix the scanned barcode image.",
    "old_code_raw": "  private static ResultPoint[] findVertices(BitMatrix matrix) {\n    int height = matrix.getHeight();\n    int width = matrix.getWidth();\n\n    ResultPoint[] result = new ResultPoint[8];\n    boolean found = false;\n\n    // Top Left\n    for (int i = 0; i < height; i++) {\n      int[] loc = findGuardPattern(matrix, 0, i, width, false, START_PATTERN);\n      if (loc != null) {\n        result[0] = new ResultPoint(loc[0], i);\n        result[4] = new ResultPoint(loc[1], i);\n        found = true;\n        break;\n      }\n    }\n    // Bottom left\n    if (found) { // Found the Top Left vertex\n      found = false;\n      for (int i = height - 1; i > 0; i--) {\n        int[] loc = findGuardPattern(matrix, 0, i, width, false, START_PATTERN);\n        if (loc != null) {\n          result[1] = new ResultPoint(loc[0], i);\n          result[5] = new ResultPoint(loc[1], i);\n          found = true;\n          break;\n        }\n      }\n    }\n    // Top right\n    if (found) { // Found the Bottom Left vertex\n      found = false;\n      for (int i = 0; i < height; i++) {\n        int[] loc = findGuardPattern(matrix, 0, i, width, false, STOP_PATTERN);\n        if (loc != null) {\n          result[2] = new ResultPoint(loc[1], i);\n          result[6] = new ResultPoint(loc[0], i);\n          found = true;\n          break;\n        }\n      }\n    }\n    // Bottom right\n    if (found) { // Found the Top right vertex\n      found = false;\n      for (int i = height - 1; i > 0; i--) {\n        int[] loc = findGuardPattern(matrix, 0, i, width, false, STOP_PATTERN);\n        if (loc != null) {\n          result[3] = new ResultPoint(loc[1], i);\n          result[7] = new ResultPoint(loc[0], i);\n          found = true;\n          break;\n        }\n      }\n    }\n    return found ? result : null;\n  }\n",
    "new_code_raw": "  private static ResultPoint[] findVertices(BitMatrix matrix, boolean tryHarder) {\n    int height = matrix.getHeight();\n    int width = matrix.getWidth();\n\n    ResultPoint[] result = new ResultPoint[8];\n    boolean found = false;\n\n    int[] counters = new int[START_PATTERN.length];\n\n    int rowStep = Math.max(1, height >> (tryHarder ? 9 : 7));\n\n    // Top Left\n    for (int i = 0; i < height; i += rowStep) {\n      int[] loc = findGuardPattern(matrix, 0, i, width, false, START_PATTERN, counters);\n      if (loc != null) {\n        result[0] = new ResultPoint(loc[0], i);\n        result[4] = new ResultPoint(loc[1], i);\n        found = true;\n        break;\n      }\n    }\n    // Bottom left\n    if (found) { // Found the Top Left vertex\n      found = false;\n      for (int i = height - 1; i > 0; i -= rowStep) {\n        int[] loc = findGuardPattern(matrix, 0, i, width, false, START_PATTERN, counters);\n        if (loc != null) {\n          result[1] = new ResultPoint(loc[0], i);\n          result[5] = new ResultPoint(loc[1], i);\n          found = true;\n          break;\n        }\n      }\n    }\n\n    counters = new int[STOP_PATTERN.length];\n\n    // Top right\n    if (found) { // Found the Bottom Left vertex\n      found = false;\n      for (int i = 0; i < height; i += rowStep) {\n        int[] loc = findGuardPattern(matrix, 0, i, width, false, STOP_PATTERN, counters);\n        if (loc != null) {\n          result[2] = new ResultPoint(loc[1], i);\n          result[6] = new ResultPoint(loc[0], i);\n          found = true;\n          break;\n        }\n      }\n    }\n    // Bottom right\n    if (found) { // Found the Top right vertex\n      found = false;\n      for (int i = height - 1; i > 0; i -= rowStep) {\n        int[] loc = findGuardPattern(matrix, 0, i, width, false, STOP_PATTERN, counters);\n        if (loc != null) {\n          result[3] = new ResultPoint(loc[1], i);\n          result[7] = new ResultPoint(loc[0], i);\n          found = true;\n          break;\n        }\n      }\n    }\n    return found ? result : null;\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1477-Param-0",
    "old_comment_raw": "@param clazz",
    "old_code_raw": "\tpublic Configuration setCacheConcurrencyStrategy(String clazz, String concurrencyStrategy)\n\t\t\tthrows MappingException {\n\t\tsetCacheConcurrencyStrategy( clazz, concurrencyStrategy, clazz );\n\t\treturn this;\n\t}\n",
    "new_code_raw": "\tpublic Configuration setCacheConcurrencyStrategy(String entityName, String concurrencyStrategy) {\n\t\tsetCacheConcurrencyStrategy( entityName, concurrencyStrategy, entityName );\n\t\treturn this;\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-394-Param-0",
    "old_comment_raw": "@param body List of user object",
    "old_code_raw": "  public void createUsersWithArrayInput (List<User> body) throws ApiException {\n    Object postBody = body;\n    \n    // create path and map variables\n    String path = \"/user/createWithArray\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    Map<String, String> headerParams = new HashMap<String, String>();\n    Map<String, Object> formParams = new HashMap<String, Object>();\n\n    \n\n    \n\n    \n\n    final String[] accepts = {\n      \"application/json\", \"application/xml\"\n    };\n    final String accept = apiClient.selectHeaderAccept(accepts);\n\n    final String[] contentTypes = {\n      \n    };\n    final String contentType = apiClient.selectHeaderContentType(contentTypes);\n\n    String[] authNames = new String[] {  };\n\n    \n    apiClient.invokeAPI(path, \"POST\", queryParams, postBody, headerParams, formParams, accept, contentType, authNames, null);\n    \n  }\n",
    "new_code_raw": "  public void createUsersWithArrayInput (java.util.List<User> body) throws ApiException {\n    Object postBody = body;\n    \n    // create path and map variables\n    String path = \"/user/createWithArray\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    java.util.List<Pair> queryParams = new java.util.ArrayList<Pair>();\n    java.util.Map<String, String> headerParams = new java.util.HashMap<String, String>();\n    java.util.Map<String, Object> formParams = new java.util.HashMap<String, Object>();\n\n    \n\n    \n\n    \n\n    final String[] accepts = {\n      \"application/json\", \"application/xml\"\n    };\n    final String accept = apiClient.selectHeaderAccept(accepts);\n\n    final String[] contentTypes = {\n      \n    };\n    final String contentType = apiClient.selectHeaderContentType(contentTypes);\n\n    String[] authNames = new String[] {  };\n\n    \n    apiClient.invokeAPI(path, \"POST\", queryParams, postBody, headerParams, formParams, accept, contentType, authNames, null);\n    \n  }\n"
  },
  {
    "id": "zaproxy_zaproxy-2139-Param-0",
    "old_comment_raw": "@param tokens the tokens",
    "old_code_raw": "\tprivate HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final Set<String> tokens) {\n\n\t\t// Pre-checks\n\t\tif (sessions.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tList<HttpSession> matchingSessions = new LinkedList<>(sessions);\n\t\tfor (String token : tokens) {\n\t\t\t// Get the corresponding cookie from the cookies list\n\t\t\tHttpCookie matchingCookie = null;\n\t\t\tfor (HttpCookie cookie : cookies) {\n\t\t\t\tif (cookie.getName().equals(token)) {\n\t\t\t\t\tmatchingCookie = cookie;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Filter the sessions that do not match the cookie value\n\t\t\tIterator<HttpSession> it = matchingSessions.iterator();\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tif (!it.next().matchesToken(token, matchingCookie)) {\n\t\t\t\t\tit.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Return the matching session\n\t\tif (matchingSessions.size() >= 1) {\n\t\t\tif (matchingSessions.size() > 1) {\n\t\t\t\tlog.warn(\"Multiple sessions matching the cookies from response for site: \" + getSite()\n\t\t\t\t\t\t+ \". Using first one.\");\n\t\t\t}\n\t\t\treturn matchingSessions.get(0);\n\t\t}\n\t\treturn null;\n\n\t}\n",
    "new_code_raw": "\tprivate HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final HttpSessionTokensSet siteTokens) {\n\n\t\t// Pre-checks\n\t\tif (sessions.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tList<HttpSession> matchingSessions = new LinkedList<>(sessions);\n\t\tfor (String token : siteTokens.getTokensSet()) {\n\t\t\t// Get the corresponding cookie from the cookies list\n\t\t\tHttpCookie matchingCookie = null;\n\t\t\tfor (HttpCookie cookie : cookies) {\n\t\t\t\tif (cookie.getName().equals(token)) {\n\t\t\t\t\tmatchingCookie = cookie;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Filter the sessions that do not match the cookie value\n\t\t\tIterator<HttpSession> it = matchingSessions.iterator();\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tif (!it.next().matchesToken(token, matchingCookie)) {\n\t\t\t\t\tit.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Return the matching session\n\t\tif (matchingSessions.size() >= 1) {\n\t\t\tif (matchingSessions.size() > 1) {\n\t\t\t\tlog.warn(\"Multiple sessions matching the cookies from response for site: \" + getSite()\n\t\t\t\t\t\t+ \". Using first one.\");\n\t\t\t}\n\t\t\treturn matchingSessions.get(0);\n\t\t}\n\t\treturn null;\n\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-104-Param-0",
    "old_comment_raw": "@param path The sub-path of the HTTP URL",
    "old_code_raw": "  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String contentType) throws ApiException {\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder = client.resource(basePath + path + querystring).accept(\"application/json\");\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n",
    "new_code_raw": "  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType) throws ApiException {\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1657-Param-0",
    "old_comment_raw": "@param body client model (required)",
    "old_code_raw": "  public Client testClassname(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling testClassname\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake_classname_test\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"api_key_query\" };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public Client testClassname(Client client) throws ApiException {\n    Object localVarPostBody = client;\n    \n    // verify the required parameter 'client' is set\n    if (client == null) {\n      throw new ApiException(400, \"Missing the required parameter 'client' when calling testClassname\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake_classname_test\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"api_key_query\" };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "apache_activemq-63-Param-1",
    "old_comment_raw": "@param localLocation",
    "old_code_raw": "    protected Socket createSocket(URI remoteLocation, URI localLocation) throws IOException, UnknownHostException {\n        String host = resolveHostName(remoteLocation.getHost());\n        SocketAddress sockAddress = new InetSocketAddress(host, remoteLocation.getPort());\n        SocketAddress localAddress = new InetSocketAddress(InetAddress.getByName(localLocation.getHost()), localLocation.getPort());\n        Socket sock = new Socket();\n        initialiseSocket(sock);\n        sock.bind(localAddress);\n        sock.connect(sockAddress);\n        return sock;\n    }\n",
    "new_code_raw": "    protected Socket createSocket(SocketFactory socketFactory, URI remoteLocation, URI localLocation) throws IOException, UnknownHostException {\n        String host = resolveHostName(remoteLocation.getHost());\n        SocketAddress sockAddress = new InetSocketAddress(host, remoteLocation.getPort());\n        SocketAddress localAddress = new InetSocketAddress(InetAddress.getByName(localLocation.getHost()), localLocation.getPort());\n        Socket sock = socketFactory.createSocket();\n        initialiseSocket(sock);\n        sock.bind(localAddress);\n        sock.connect(sockAddress);\n        return sock;\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2428-Param-2",
    "old_comment_raw": "@param  The type of the element we are getting.",
    "old_code_raw": "  public List<String> dependencyPathBetween(int start, int end, Function<Sentence, List<String>> selector) {\n    // Get paths from a node to the root of the sentence\n    LinkedList<Integer> rootToStart = new LinkedList<>();\n    LinkedList<Integer> rootToEnd = new LinkedList<>();\n    int startAncestor = start;\n    List<Optional<Integer>> governors = sentence.governors();\n    Set<Integer> seenVertices = new HashSet<>();\n    while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) {\n      if (seenVertices.contains(startAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(startAncestor);\n      rootToStart.addFirst(startAncestor);\n      startAncestor = governors.get(startAncestor).get();\n    }\n    if (startAncestor == -1) {\n      rootToStart.addFirst(-1);\n    }\n    int endAncestor = end;\n    seenVertices.clear();\n    while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) {\n      if (seenVertices.contains(endAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(endAncestor);\n      rootToEnd.addFirst(endAncestor);\n      endAncestor = governors.get(endAncestor).get();\n    }\n    if (endAncestor == -1) {\n      rootToEnd.addFirst(-1);\n    }\n\n    // Get least common node\n    int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0;\n    for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) {\n      if (rootToStart.get(i).equals(rootToEnd.get(i))) {\n        leastCommonNodeIndex = i;\n      }\n    }\n\n    // Construct the path\n    if (leastCommonNodeIndex < 0) {\n      return Collections.EMPTY_LIST;\n    }\n    List<String> path = new ArrayList<>();\n    for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) {\n      path.add(selector.apply(sentence).get(rootToStart.get(i)));\n      path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\");\n    }\n    path.add(selector.apply(sentence).get(rootToStart.get(leastCommonNodeIndex)));\n    for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) {\n      path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\");\n      path.add(selector.apply(sentence).get(rootToEnd.get(i)));\n    }\n    return path;\n  }\n",
    "new_code_raw": "  public List<String> dependencyPathBetween(int start, int end, Optional<Function<Sentence, List<String>>> selector) {\n    // Get paths from a node to the root of the sentence\n    LinkedList<Integer> rootToStart = new LinkedList<>();\n    LinkedList<Integer> rootToEnd = new LinkedList<>();\n    int startAncestor = start;\n    List<Optional<Integer>> governors = sentence.governors();\n    Set<Integer> seenVertices = new HashSet<>();\n    while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) {\n      if (seenVertices.contains(startAncestor)) {\n        // Found loopiness -- revert to BFS\n        return loopyDependencyPathBetween(start, end, selector);\n      }\n      seenVertices.add(startAncestor);\n      rootToStart.addFirst(startAncestor);\n      startAncestor = governors.get(startAncestor).get();\n    }\n    if (startAncestor == -1) {\n      rootToStart.addFirst(-1);\n    }\n    int endAncestor = end;\n    seenVertices.clear();\n    while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) {\n      if (seenVertices.contains(endAncestor)) {\n        // Found loopiness -- revert to BFS\n        return loopyDependencyPathBetween(start, end, selector);\n      }\n      seenVertices.add(endAncestor);\n      rootToEnd.addFirst(endAncestor);\n      endAncestor = governors.get(endAncestor).get();\n    }\n    if (endAncestor == -1) {\n      rootToEnd.addFirst(-1);\n    }\n\n    // Get least common node\n    int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0;\n    for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) {\n      if (rootToStart.get(i).equals(rootToEnd.get(i))) {\n        leastCommonNodeIndex = i;\n      }\n    }\n\n    // Construct the path\n    if (leastCommonNodeIndex < 0) {\n      return Collections.emptyList();\n    }\n    List<String> path = new ArrayList<>();\n    Optional<List<String>> words = selector.map(x -> x.apply(sentence));\n    for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) {\n      final int index = i;\n      words.ifPresent(x -> path.add(x.get(rootToStart.get(index))));\n      path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\");\n    }\n    if (words.isPresent()) {\n      path.add(words.get().get(rootToStart.get(leastCommonNodeIndex)));\n    }\n    for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) {\n      final int index = i;\n      path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\");\n      words.ifPresent(x -> path.add(x.get(rootToEnd.get(index))));\n    }\n    return path;\n  }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-488-Param-0",
    "old_comment_raw": "@param proto The protocol buffer to read the document from.",
    "old_code_raw": "  public static Annotation fromProto(CoreMapProtos.Document proto) {\n    // Set text\n    Annotation ann = new Annotation(proto.getText());\n\n    // Add tokens\n    List<CoreLabel> tokens = new ArrayList<CoreLabel>(proto.getTokenCount());\n    for (CoreMapProtos.CoreLabel token : proto.getTokenList()) {\n      CoreLabel coreLabel = fromProto(token);\n      // Set docid\n      if (proto.hasDocID()) { coreLabel.setDocID(proto.getDocID()); }\n      tokens.add(coreLabel);\n    }\n    if (!tokens.isEmpty()) { ann.set(TokensAnnotation.class, tokens); }\n\n    // Add sentences\n    List<CoreMap> sentences = new ArrayList<CoreMap>(proto.getSentenceCount());\n    for (int sentIndex = 0; sentIndex < proto.getSentenceCount(); ++sentIndex) {\n      CoreMapProtos.Sentence sentence = proto.getSentence(sentIndex);\n      CoreMap map = fromProto(sentence);\n      if (!tokens.isEmpty() && sentence.hasTokenOffsetBegin() && sentence.hasTokenOffsetEnd()) {\n        // Set tokens for sentence\n        map.set(TokensAnnotation.class, tokens.subList(sentence.getTokenOffsetBegin(), sentence.getTokenOffsetEnd()));\n        // Set sentence index + token index + paragraph index\n        for (int i = sentence.getTokenOffsetBegin(); i < sentence.getTokenOffsetEnd(); ++i) {\n          tokens.get(i).setSentIndex(sentIndex);\n          tokens.get(i).setIndex(i - sentence.getTokenOffsetBegin() + 1);\n          if (sentence.hasParagraph()) { tokens.get(i).set(ParagraphAnnotation.class, sentence.getParagraph()); }\n        }\n        // Set text\n        map.set(TextAnnotation.class, proto.getText().substring(sentence.getCharacterOffsetBegin(), sentence.getCharacterOffsetEnd()));\n      }\n      // End iteration\n      sentences.add(map);\n    }\n    if (!sentences.isEmpty()) { ann.set(SentencesAnnotation.class, sentences); }\n\n    // Set DocID\n    String docid = null;\n    if (proto.hasDocID()) {\n      docid = proto.getDocID();\n      ann.set(DocIDAnnotation.class, docid);\n    }\n\n    // Set coref chain\n    Map<Integer, CorefChain> corefChains = new HashMap<Integer, CorefChain>();\n    for (CoreMapProtos.CorefChain chainProto : proto.getCorefChainList()) {\n      CorefChain chain = fromProto(chainProto, ann);\n      corefChains.put(chain.getChainID(), chain);\n    }\n    if (!corefChains.isEmpty()) { ann.set(CorefChainAnnotation.class, corefChains); }\n\n    // Set dependency graphs\n    // We need to wait until here, since this is the first time we see tokens\n    for (int i = 0; i < proto.getSentenceCount(); ++i) {\n      CoreMapProtos.Sentence sentence = proto.getSentenceList().get(i);\n      CoreMap map = sentences.get(i);\n      List<CoreLabel> sentenceTokens = map.get(TokensAnnotation.class);\n      if (sentence.hasBasicDependencies()) {\n        map.set(BasicDependenciesAnnotation.class, fromProto(sentence.getBasicDependencies(), sentenceTokens, docid));\n      }\n      if (sentence.hasCollapsedDependencies()) {\n        map.set(CollapsedDependenciesAnnotation.class, fromProto(sentence.getCollapsedDependencies(), sentenceTokens, docid));\n      }\n      if (sentence.hasCollapsedCCProcessedDependencies()) {\n        map.set(CollapsedCCProcessedDependenciesAnnotation.class, fromProto(sentence.getCollapsedCCProcessedDependencies(), sentenceTokens, docid));\n      }\n    }\n\n    // Redo some light annotation\n    for (CoreMap sentence : sentences) {\n      if (sentence.containsKey(TokensAnnotation.class)) {\n        sentence.set(NumerizedTokensAnnotation.class, NumberNormalizer.findAndMergeNumbers(sentence));\n      }\n    }\n\n    // Return\n    return ann;\n  }\n",
    "new_code_raw": "  public static Annotation fromProto(CoreNLPProtos.Document proto) {\n    // Set text\n    Annotation ann = new Annotation(proto.getText());\n\n    // Add tokens\n    List<CoreLabel> tokens = new ArrayList<CoreLabel>(proto.getTokenCount());\n    for (CoreNLPProtos.Token token : proto.getTokenList()) {\n      CoreLabel coreLabel = fromProto(token);\n      // Set docid\n      if (proto.hasDocID()) { coreLabel.setDocID(proto.getDocID()); }\n      tokens.add(coreLabel);\n    }\n    if (!tokens.isEmpty()) { ann.set(TokensAnnotation.class, tokens); }\n\n    // Add sentences\n    List<CoreMap> sentences = new ArrayList<CoreMap>(proto.getSentenceCount());\n    for (int sentIndex = 0; sentIndex < proto.getSentenceCount(); ++sentIndex) {\n      CoreNLPProtos.Sentence sentence = proto.getSentence(sentIndex);\n      CoreMap map = fromProto(sentence);\n      if (!tokens.isEmpty() && sentence.hasTokenOffsetBegin() && sentence.hasTokenOffsetEnd()) {\n        // Set tokens for sentence\n        map.set(TokensAnnotation.class, tokens.subList(sentence.getTokenOffsetBegin(), sentence.getTokenOffsetEnd()));\n        // Set sentence index + token index + paragraph index\n        for (int i = sentence.getTokenOffsetBegin(); i < sentence.getTokenOffsetEnd(); ++i) {\n          tokens.get(i).setSentIndex(sentIndex);\n          tokens.get(i).setIndex(i - sentence.getTokenOffsetBegin() + 1);\n          if (sentence.hasParagraph()) { tokens.get(i).set(ParagraphAnnotation.class, sentence.getParagraph()); }\n        }\n        // Set text\n        map.set(TextAnnotation.class, proto.getText().substring(sentence.getCharacterOffsetBegin(), sentence.getCharacterOffsetEnd()));\n      }\n      // End iteration\n      sentences.add(map);\n    }\n    if (!sentences.isEmpty()) { ann.set(SentencesAnnotation.class, sentences); }\n\n    // Set DocID\n    String docid = null;\n    if (proto.hasDocID()) {\n      docid = proto.getDocID();\n      ann.set(DocIDAnnotation.class, docid);\n    }\n\n    // Set coref chain\n    Map<Integer, CorefChain> corefChains = new HashMap<Integer, CorefChain>();\n    for (CoreNLPProtos.CorefChain chainProto : proto.getCorefChainList()) {\n      CorefChain chain = fromProto(chainProto, ann);\n      corefChains.put(chain.getChainID(), chain);\n    }\n    if (!corefChains.isEmpty()) { ann.set(CorefChainAnnotation.class, corefChains); }\n\n    // Set dependency graphs\n    // We need to wait until here, since this is the first time we see tokens\n    for (int i = 0; i < proto.getSentenceCount(); ++i) {\n      CoreNLPProtos.Sentence sentence = proto.getSentenceList().get(i);\n      CoreMap map = sentences.get(i);\n      List<CoreLabel> sentenceTokens = map.get(TokensAnnotation.class);\n      if (sentence.hasBasicDependencies()) {\n        map.set(BasicDependenciesAnnotation.class, fromProto(sentence.getBasicDependencies(), sentenceTokens, docid));\n      }\n      if (sentence.hasCollapsedDependencies()) {\n        map.set(CollapsedDependenciesAnnotation.class, fromProto(sentence.getCollapsedDependencies(), sentenceTokens, docid));\n      }\n      if (sentence.hasCollapsedCCProcessedDependencies()) {\n        map.set(CollapsedCCProcessedDependenciesAnnotation.class, fromProto(sentence.getCollapsedCCProcessedDependencies(), sentenceTokens, docid));\n      }\n    }\n\n    // Redo some light annotation\n    for (CoreMap sentence : sentences) {\n      if (sentence.containsKey(TokensAnnotation.class)) {\n        sentence.set(NumerizedTokensAnnotation.class, NumberNormalizer.findAndMergeNumbers(sentence));\n      }\n    }\n\n    // Return\n    return ann;\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-328-Param-1",
    "old_comment_raw": "@param dialect The dialect in effect.",
    "old_code_raw": "\tprotected String determineValueColumnName(Properties params, Dialect dialect) {\n\t\tfinal ObjectNameNormalizer normalizer = (ObjectNameNormalizer) params.get( IDENTIFIER_NORMALIZER );\n\t\tfinal String name = ConfigurationHelper.getString( VALUE_COLUMN_PARAM, params, DEF_VALUE_COLUMN );\n\t\treturn dialect.quote( normalizer.normalizeIdentifierQuoting( name ) );\n\t}\n",
    "new_code_raw": "\tprotected Identifier determineValueColumnName(Properties params, JdbcEnvironment jdbcEnvironment) {\n\t\tfinal String name = ConfigurationHelper.getString( VALUE_COLUMN_PARAM, params, DEF_VALUE_COLUMN );\n\t\treturn jdbcEnvironment.getIdentifierHelper().toIdentifier( name );\n\t}\n"
  },
  {
    "id": "apache_kylin-282-Param-1",
    "old_comment_raw": "@param sqlRequest",
    "old_code_raw": "    private SQLResponse execute(String correctedSql, SQLRequest sqlRequest) throws Exception {\n        Connection conn = null;\n        Statement stat = null;\n        ResultSet resultSet = null;\n        Boolean isPushDown = false;\n\n        List<List<String>> results = Lists.newArrayList();\n        List<SelectedColumnMeta> columnMetas = Lists.newArrayList();\n\n        try {\n            conn = QueryConnection.getConnection(sqlRequest.getProject());\n\n            // special case for prepare query. \n            if (BackdoorToggles.getPrepareOnly()) {\n                return getPrepareOnlySqlResponse(correctedSql, conn, isPushDown, results, columnMetas);\n            }\n\n            stat = conn.createStatement();\n            processStatementAttr(stat, sqlRequest);\n            resultSet = stat.executeQuery(correctedSql);\n\n            ResultSetMetaData metaData = resultSet.getMetaData();\n            int columnCount = metaData.getColumnCount();\n\n            // Fill in selected column meta\n            for (int i = 1; i <= columnCount; ++i) {\n                columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i),\n                        metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i),\n                        metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i),\n                        metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i),\n                        metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i),\n                        metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i),\n                        metaData.isDefinitelyWritable(i)));\n            }\n\n            // fill in results\n            while (resultSet.next()) {\n                List<String> oneRow = Lists.newArrayListWithCapacity(columnCount);\n                for (int i = 0; i < columnCount; i++) {\n                    oneRow.add((resultSet.getString(i + 1)));\n                }\n\n                results.add(oneRow);\n            }\n        } catch (SQLException sqlException) {\n            isPushDown = PushDownUtil.doPushDownQuery(sqlRequest.getProject(), correctedSql, conn.getSchema(), results, columnMetas,\n                    sqlException);\n            if (!isPushDown) {\n                throw sqlException;\n            }\n        } finally {\n            close(resultSet, stat, conn);\n        }\n\n        return getSqlResponse(isPushDown, results, columnMetas);\n    }\n",
    "new_code_raw": "    private SQLResponse execute(String correctedSql, SQLRequest sqlRequest, Connection conn) throws Exception {\n        Statement stat = null;\n        ResultSet resultSet = null;\n        Boolean isPushDown = false;\n\n        List<List<String>> results = Lists.newArrayList();\n        List<SelectedColumnMeta> columnMetas = Lists.newArrayList();\n\n        try {\n\n            // special case for prepare query. \n            if (BackdoorToggles.getPrepareOnly()) {\n                return getPrepareOnlySqlResponse(correctedSql, conn, isPushDown, results, columnMetas);\n            }\n\n            stat = conn.createStatement();\n            processStatementAttr(stat, sqlRequest);\n            resultSet = stat.executeQuery(correctedSql);\n\n            ResultSetMetaData metaData = resultSet.getMetaData();\n            int columnCount = metaData.getColumnCount();\n\n            // Fill in selected column meta\n            for (int i = 1; i <= columnCount; ++i) {\n                columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i),\n                        metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i),\n                        metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i),\n                        metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i),\n                        metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i),\n                        metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i),\n                        metaData.isDefinitelyWritable(i)));\n            }\n\n            // fill in results\n            while (resultSet.next()) {\n                List<String> oneRow = Lists.newArrayListWithCapacity(columnCount);\n                for (int i = 0; i < columnCount; i++) {\n                    oneRow.add((resultSet.getString(i + 1)));\n                }\n\n                results.add(oneRow);\n            }\n        } catch (SQLException sqlException) {\n            isPushDown = PushDownUtil.doPushDownQuery(sqlRequest.getProject(), correctedSql, conn.getSchema(), results,\n                    columnMetas, sqlException);\n            if (!isPushDown) {\n                throw sqlException;\n            }\n        } finally {\n            close(resultSet, stat, null);//conn is passed in, not my duty to close\n        }\n\n        return getSqlResponse(isPushDown, results, columnMetas);\n    }\n"
  },
  {
    "id": "debezium_debezium-31-Param-0",
    "old_comment_raw": "@param columnNames the comma-separated list of column names names to exclude; may be null or empty",
    "old_code_raw": "    public static Predicate<ColumnId> excludeColumns(String columnNames) {\n        return Predicates.excludes(columnNames, ColumnId::toString);\n    }\n",
    "new_code_raw": "    public static Predicate<ColumnId> excludeColumns(String fullyQualifiedColumnNames) {\n        return Predicates.excludes(fullyQualifiedColumnNames, ColumnId::toString);\n    }\n"
  },
  {
    "id": "apache_drill-828-Param-0",
    "old_comment_raw": "@param fs file system",
    "old_code_raw": "  public static ParquetTableMetadata_v4 getParquetTableMetadata(FileSystem fs, String path, ParquetReaderConfig readerConfig) throws IOException {\n    Metadata metadata = new Metadata(readerConfig);\n    return metadata.getParquetTableMetadata(path, fs);\n  }\n",
    "new_code_raw": "  public static ParquetTableMetadata_v4 getParquetTableMetadata(FileSystem fs, Path path, ParquetReaderConfig readerConfig) throws IOException {\n    Metadata metadata = new Metadata(readerConfig);\n    return metadata.getParquetTableMetadata(path, fs);\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2572-Param-0",
    "old_comment_raw": "@param schemes a map of Swagger SecuritySchemeDefinition object",
    "old_code_raw": "    public List<CodegenSecurity> fromSecurity(Map<String, SecuritySchemeDefinition> schemes) {\n        if (schemes == null) {\n            return Collections.emptyList();\n        }\n\n        List<CodegenSecurity> secs = new ArrayList<CodegenSecurity>(schemes.size());\n        for (Iterator<Map.Entry<String, SecuritySchemeDefinition>> it = schemes.entrySet().iterator(); it.hasNext(); ) {\n            final Map.Entry<String, SecuritySchemeDefinition> entry = it.next();\n            final SecuritySchemeDefinition schemeDefinition = entry.getValue();\n\n            CodegenSecurity sec = CodegenModelFactory.newInstance(CodegenModelType.SECURITY);\n            sec.name = entry.getKey();\n            sec.type = schemeDefinition.getType();\n            sec.isCode = sec.isPassword = sec.isApplication = sec.isImplicit = false;\n            sec.vendorExtensions = schemeDefinition.getVendorExtensions();\n\n            if (schemeDefinition instanceof ApiKeyAuthDefinition) {\n                final ApiKeyAuthDefinition apiKeyDefinition = (ApiKeyAuthDefinition) schemeDefinition;\n                sec.isBasic = sec.isOAuth = false;\n                sec.isApiKey = true;\n                sec.keyParamName = apiKeyDefinition.getName();\n                sec.isKeyInHeader = apiKeyDefinition.getIn() == In.HEADER;\n                sec.isKeyInQuery = !sec.isKeyInHeader;\n            } else if(schemeDefinition instanceof BasicAuthDefinition) {\n                sec.isKeyInHeader = sec.isKeyInQuery = sec.isApiKey = sec.isOAuth = false;\n                sec.isBasic = true;\n            } else {\n                final OAuth2Definition oauth2Definition = (OAuth2Definition) schemeDefinition;\n                sec.isKeyInHeader = sec.isKeyInQuery = sec.isApiKey = sec.isBasic = false;\n                sec.isOAuth = true;\n                sec.flow = oauth2Definition.getFlow();\n                if (sec.flow == null) {\n                    throw new RuntimeException(\"missing oauth flow in \" + sec.name);\n                }\n                switch(sec.flow) {\n                    case \"accessCode\":\n                        sec.isCode = true;\n                        break;\n                    case \"password\":\n                        sec.isPassword = true;\n                        break;\n                    case \"application\":\n                        sec.isApplication = true;\n                        break;\n                    case \"implicit\":\n                        sec.isImplicit = true;\n                        break;\n                    default:\n                        throw new RuntimeException(\"unknown oauth flow: \" + sec.flow);\n                }\n                sec.authorizationUrl = oauth2Definition.getAuthorizationUrl();\n                sec.tokenUrl = oauth2Definition.getTokenUrl();\n                if (oauth2Definition.getScopes() != null) {\n                    List<Map<String, Object>> scopes = new ArrayList<Map<String, Object>>();\n                    int count = 0, numScopes = oauth2Definition.getScopes().size();\n                    for(Map.Entry<String, String> scopeEntry : oauth2Definition.getScopes().entrySet()) {\n                        Map<String, Object> scope = new HashMap<String, Object>();\n                        scope.put(\"scope\", scopeEntry.getKey());\n                        scope.put(\"description\", escapeText(scopeEntry.getValue()));\n\n                        count += 1;\n                        if (count < numScopes) {\n                            scope.put(\"hasMore\", \"true\");\n                        } else {\n                            scope.put(\"hasMore\", null);\n                        }\n\n                        scopes.add(scope);\n                    }\n                    sec.scopes = scopes;\n                }\n            }\n\n            secs.add(sec);\n        }\n\n        // sort auth methods to maintain the same order\n        Collections.sort(secs, new Comparator<CodegenSecurity>() {\n            @Override\n            public int compare(CodegenSecurity one, CodegenSecurity another) {\n                return ObjectUtils.compare(one.name, another.name);\n            }\n        });\n        // set 'hasMore'\n        Iterator<CodegenSecurity> it = secs.iterator();\n        while (it.hasNext()) {\n            final CodegenSecurity security = it.next();\n            security.hasMore = it.hasNext();\n        }\n\n        return secs;\n    }\n",
    "new_code_raw": "    public List<CodegenSecurity> fromSecurity(Map<String, SecurityScheme> securitySchemeMap) {\n        if (securitySchemeMap == null) {\n            return Collections.emptyList();\n        }\n\n        List<CodegenSecurity> codegenSecurities = new ArrayList<CodegenSecurity>(securitySchemeMap.size());\n        for (String key : securitySchemeMap.keySet()) {\n            final SecurityScheme securityScheme = securitySchemeMap.get(key);\n\n            CodegenSecurity cs = CodegenModelFactory.newInstance(CodegenModelType.SECURITY);\n            cs.name = key;\n            cs.type = securityScheme.getType().toString();\n            cs.isCode = cs.isPassword = cs.isApplication = cs.isImplicit = false;\n\n            if (SecurityScheme.Type.APIKEY.equals(securityScheme.getType())) {\n                cs.isBasic = cs.isOAuth = false;\n                cs.isApiKey = true;\n                cs.keyParamName = securityScheme.getName();\n                cs.isKeyInHeader = securityScheme.getIn() == SecurityScheme.In.HEADER;\n                cs.isKeyInQuery = !cs.isKeyInHeader;\n            } else if (SecurityScheme.Type.HTTP.equals(securityScheme.getType())) {\n                cs.isKeyInHeader = cs.isKeyInQuery = cs.isApiKey = cs.isOAuth = false;\n                cs.isBasic = true;\n            } else if (SecurityScheme.Type.OAUTH2.equals(securityScheme.getType())) {\n                cs.isKeyInHeader = cs.isKeyInQuery = cs.isApiKey = cs.isBasic = false;\n                cs.isOAuth = true;\n                final OAuthFlows flows = securityScheme.getFlows();\n                if (securityScheme.getFlows() == null) {\n                    throw new RuntimeException(\"missing oauth flow in \" + cs.name);\n                }\n                if (flows.getPassword() != null) {\n                    setOauth2Info(cs, flows.getPassword());\n                    cs.isPassword = true;\n                    cs.flow = \"password\";\n                } else if (flows.getImplicit() != null) {\n                    setOauth2Info(cs, flows.getImplicit());\n                    cs.isImplicit = true;\n                    cs.flow = \"implicit\";\n                } else if (flows.getClientCredentials() != null) {\n                    setOauth2Info(cs, flows.getClientCredentials());\n                    cs.isApplication = true;\n                    cs.flow = \"application\";\n                } else if (flows.getAuthorizationCode() != null) {\n                    setOauth2Info(cs, flows.getAuthorizationCode());\n                    cs.isCode = true;\n                    cs.flow = \"accessCode\";\n                } else {\n                    throw new RuntimeException(\"Could not identify any oauth2 flow in \" + cs.name);\n                }\n            }\n\n            codegenSecurities.add(cs);\n        }\n\n        // sort auth methods to maintain the same order\n        Collections.sort(codegenSecurities, new Comparator<CodegenSecurity>() {\n            @Override\n            public int compare(CodegenSecurity one, CodegenSecurity another) {\n                return ObjectUtils.compare(one.name, another.name);\n            }\n        });\n        // set 'hasMore'\n        Iterator<CodegenSecurity> it = codegenSecurities.iterator();\n        while (it.hasNext()) {\n            final CodegenSecurity security = it.next();\n            security.hasMore = it.hasNext();\n        }\n\n        return codegenSecurities;\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1215-Param-0",
    "old_comment_raw": "@param key The collection owner key",
    "old_code_raw": "\tpublic Object getCollection(Serializable key, SessionImplementor session, Object owner) {\n\n\t\tCollectionPersister persister = getPersister( session );\n\t\tfinal PersistenceContext persistenceContext = session.getPersistenceContext();\n\t\tfinal EntityMode entityMode = persister.getOwnerEntityPersister().getEntityMode();\n\n\t\t// check if collection is currently being loaded\n\t\tPersistentCollection collection = persistenceContext.getLoadContexts().locateLoadingCollection( persister, key );\n\t\t\n\t\tif ( collection == null ) {\n\t\t\t\n\t\t\t// check if it is already completely loaded, but unowned\n\t\t\tcollection = persistenceContext.useUnownedCollection( new CollectionKey(persister, key, entityMode) );\n\t\t\t\n\t\t\tif ( collection == null ) {\n\n\t\t\t\tcollection = persistenceContext.getCollection( new CollectionKey(persister, key, entityMode) );\n\n\t\t\t\tif ( collection == null ) {\n\t\t\t\t\t// create a new collection wrapper, to be initialized later\n\t\t\t\t\tcollection = instantiate( session, persister, key );\n\n\t\t\t\t\tcollection.setOwner( owner );\n\n\t\t\t\t\tpersistenceContext.addUninitializedCollection( persister, collection, key );\n\n\t\t\t\t\t// some collections are not lazy:\n\t\t\t\t\tif ( initializeImmediately() ) {\n\t\t\t\t\t\tsession.initializeCollection( collection, false );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( !persister.isLazy() ) {\n\t\t\t\t\t\tpersistenceContext.addNonLazyCollection( collection );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasHolder() ) {\n\t\t\t\t\t\tsession.getPersistenceContext().addCollectionHolder( collection );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracef( \"Created collection wrapper: %s\",\n\t\t\t\t\t\tMessageHelper.collectionInfoString( persister, collection,\n\t\t\t\t\t\t\t\tkey, session ) );\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tcollection.setOwner(owner);\n\n\t\treturn collection.getValue();\n\t}\n",
    "new_code_raw": "\tpublic Object getCollection(Serializable key, SharedSessionContractImplementor session, Object owner) {\n\n\t\tCollectionPersister persister = getPersister( session );\n\t\tfinal PersistenceContext persistenceContext = session.getPersistenceContext();\n\t\tfinal EntityMode entityMode = persister.getOwnerEntityPersister().getEntityMode();\n\n\t\t// check if collection is currently being loaded\n\t\tPersistentCollection collection = persistenceContext.getLoadContexts().locateLoadingCollection( persister, key );\n\t\t\n\t\tif ( collection == null ) {\n\t\t\t\n\t\t\t// check if it is already completely loaded, but unowned\n\t\t\tcollection = persistenceContext.useUnownedCollection( new CollectionKey(persister, key, entityMode) );\n\t\t\t\n\t\t\tif ( collection == null ) {\n\n\t\t\t\tcollection = persistenceContext.getCollection( new CollectionKey(persister, key, entityMode) );\n\n\t\t\t\tif ( collection == null ) {\n\t\t\t\t\t// create a new collection wrapper, to be initialized later\n\t\t\t\t\tcollection = instantiate( session, persister, key );\n\n\t\t\t\t\tcollection.setOwner( owner );\n\n\t\t\t\t\tpersistenceContext.addUninitializedCollection( persister, collection, key );\n\n\t\t\t\t\t// some collections are not lazy:\n\t\t\t\t\tif ( initializeImmediately() ) {\n\t\t\t\t\t\tsession.initializeCollection( collection, false );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( !persister.isLazy() ) {\n\t\t\t\t\t\tpersistenceContext.addNonLazyCollection( collection );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasHolder() ) {\n\t\t\t\t\t\tsession.getPersistenceContext().addCollectionHolder( collection );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracef( \"Created collection wrapper: %s\",\n\t\t\t\t\t\tMessageHelper.collectionInfoString( persister, collection,\n\t\t\t\t\t\t\t\tkey, session ) );\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tcollection.setOwner(owner);\n\n\t\treturn collection.getValue();\n\t}\n"
  },
  {
    "id": "RSB4760_apq8016_developers_samples_android-0-Associations-Param1",
    "old_comment_raw": "@param appendStr The String to append",
    "old_code_raw": "    private String appendIfNotNull(String sourceStr, String appendStr, String delimiter) {\n        if (appendStr != null) {\n            if (appendStr.length() == 0) {\n                delimiter = \"\";\n            }\n            sourceStr += delimiter + appendStr;\n        }\n        return sourceStr;\n    }\n",
    "new_code_raw": "    private StringBuilder appendIfNotNull(StringBuilder source, String addStr, String delimiter) {\n        if (addStr != null) {\n            if (addStr.length() == 0) {\n                delimiter = \"\";\n            }\n\n            return source.append(addStr).append(delimiter);\n        }\n        return source;\n    }\n\n"
  },
  {
    "id": "apache_drill-287-Param-0",
    "old_comment_raw": "@param fs",
    "old_code_raw": "  public static ParquetTableMetadataBase readBlockMeta(FileSystem fs, String path, MetadataContext metaContext) throws IOException {\n    Metadata metadata = new Metadata(fs);\n    metadata.readBlockMeta(path, false, metaContext);\n    return metadata.parquetTableMetadata;\n  }\n",
    "new_code_raw": "  public static ParquetTableMetadataBase readBlockMeta(FileSystem fs, String path, MetadataContext metaContext, ParquetFormatConfig formatConfig) throws IOException {\n    Metadata metadata = new Metadata(fs, formatConfig);\n    metadata.readBlockMeta(path, false, metaContext);\n    return metadata.parquetTableMetadata;\n  }\n"
  },
  {
    "id": "Atmosphere_atmosphere-828-Param-0",
    "old_comment_raw": "@param req the  HttpServletRequest",
    "old_code_raw": "    public Action cancelled(HttpServletRequest req, HttpServletResponse res)\n            throws IOException, ServletException {\n\n        synchronized (req) {\n            AtmosphereResourceImpl r = null;\n            try {\n                if (trackActiveRequest) {\n                    long l = (Long) req.getAttribute(MAX_INACTIVE);\n                    if (l == -1) {\n                        // The closedDetector closed the connection.\n                        return timedoutAction;\n                    }\n                    req.setAttribute(MAX_INACTIVE, (long) -1);\n                }\n\n                logger.debug(\"Cancelling the connection for request {}\", req);\n\n                r = (AtmosphereResourceImpl) req.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n                if (r != null) {\n                    r.getAtmosphereResourceEvent().setCancelled(true);\n                    invokeAtmosphereHandler(r);\n\n                    try {\n                        r.getResponse().sendError(503);\n                        r.getResponse().getOutputStream().close();\n                    } catch (Throwable t) {\n                        try {\n                            r.getResponse().getWriter().close();\n                        } catch (Throwable t2) {\n                        }\n                    }\n                }\n            } catch (Throwable ex) {\n                // Something wrong happenned, ignore the exception\n                logger.debug(\"failed to cancel resource: \" + r, ex);\n            } finally {\n                try {\n                    if (r != null) {\n                        r.notifyListeners();\n                        r.setIsInScope(false);\n                        r.cancel();\n                    }\n                } catch (Throwable t) {\n                    logger.trace(\"cancel\", t);\n                } finally {\n                    if (r != null) {\n                        destroyResource(r);\n                    }\n                }\n            }\n        }\n\n        return cancelledAction;\n    }\n",
    "new_code_raw": "    public Action cancelled(AtmosphereRequest req, AtmosphereResponse res)\n            throws IOException, ServletException {\n\n        synchronized (req) {\n            AtmosphereResourceImpl r = null;\n            try {\n                if (trackActiveRequest) {\n                    long l = (Long) req.getAttribute(MAX_INACTIVE);\n                    if (l == -1) {\n                        // The closedDetector closed the connection.\n                        return timedoutAction;\n                    }\n                    req.setAttribute(MAX_INACTIVE, (long) -1);\n                }\n\n                logger.debug(\"Cancelling the connection for request {}\", req);\n\n                r = (AtmosphereResourceImpl) req.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n                if (r != null) {\n                    r.getAtmosphereResourceEvent().setCancelled(true);\n                    invokeAtmosphereHandler(r);\n\n                    try {\n                        r.getResponse().sendError(503);\n                        r.getResponse().getOutputStream().close();\n                    } catch (Throwable t) {\n                        try {\n                            r.getResponse().getWriter().close();\n                        } catch (Throwable t2) {\n                        }\n                    }\n                }\n            } catch (Throwable ex) {\n                // Something wrong happenned, ignore the exception\n                logger.debug(\"failed to cancel resource: \" + r, ex);\n            } finally {\n                try {\n                    if (r != null) {\n                        r.notifyListeners();\n                        r.setIsInScope(false);\n                        r.cancel();\n                    }\n                } catch (Throwable t) {\n                    logger.trace(\"cancel\", t);\n                } finally {\n                    if (r != null) {\n                        destroyResource(r);\n                    }\n                }\n            }\n        }\n\n        return cancelledAction;\n    }\n"
  },
  {
    "id": "debezium_debezium-730-Param-1",
    "old_comment_raw": "@param object the document; may not be null",
    "old_code_raw": "        public int recordObject(CollectionId id, Document object, long timestamp) throws InterruptedException {\n            source.collectionEvent(replicaSetName, id);\n            final Struct sourceValue = source.struct();\n            final Map<String, ?> offset = source.lastOffset(replicaSetName);\n            String objId = idObjToJson(object);\n            assert objId != null;\n            return createRecords(sourceValue, offset, Operation.READ, objId, object, timestamp);\n        }\n",
    "new_code_raw": "        public int recordObject(CollectionId id, Document object, Instant timestamp) throws InterruptedException {\n            source.collectionEvent(replicaSetName, id);\n            final Struct sourceValue = source.struct();\n            final Map<String, ?> offset = source.lastOffset(replicaSetName);\n            String objId = idObjToJson(object);\n            assert objId != null;\n            return createRecords(sourceValue, offset, Operation.READ, objId, object, timestamp);\n        }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1917-Param-0",
    "old_comment_raw": "@param connectionManager The connection manager to wrap with the connection proxy.",
    "old_code_raw": "\tpublic static Connection generateProxy(ConnectionManager connectionManager) {\n\t\tBorrowedConnectionProxy handler = new BorrowedConnectionProxy( connectionManager );\n\t\treturn ( Connection ) Proxy.newProxyInstance(\n\t\t\t\tgetProxyClassLoader(),\n\t\t        PROXY_INTERFACES,\n\t\t        handler\n\t\t);\n\t}\n",
    "new_code_raw": "\tpublic static Connection generateProxy(LogicalConnectionImpl logicalConnection) {\n\t\tBorrowedConnectionProxy handler = new BorrowedConnectionProxy( logicalConnection );\n\t\treturn ( Connection ) Proxy.newProxyInstance(\n\t\t\t\tgetProxyClassLoader(),\n\t\t        PROXY_INTERFACES,\n\t\t        handler\n\t\t);\n\t}\n"
  },
  {
    "id": "apache_activemq-604-Param-1",
    "old_comment_raw": "@param clientId",
    "old_code_raw": "    public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name, int maxBatchSize, Subscription sub) {\n        StoreDurableSubscriberCursor cursor = new StoreDurableSubscriberCursor(broker,clientId, name, maxBatchSize, sub);\n        cursor.setImmediatePriorityDispatch(isImmediatePriorityDispatch());\n        return cursor;\n    }\n",
    "new_code_raw": "    public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name, int maxBatchSize, DurableTopicSubscription sub) {\n        StoreDurableSubscriberCursor cursor = new StoreDurableSubscriberCursor(broker,clientId, name, maxBatchSize, sub);\n        cursor.setImmediatePriorityDispatch(isImmediatePriorityDispatch());\n        return cursor;\n    }\n"
  },
  {
    "id": "biddyweb_checker-framework-32-Associations-Param0",
    "old_comment_raw": "@param node the tree corresponding to a use of an element",
    "old_code_raw": "    public static final Element elementFromUse(ExpressionTree node) {\n        return InternalUtils.symbol(node);\n    }\n",
    "new_code_raw": "    public static final ExecutableElement elementFromUse(MethodInvocationTree node) {\n        return (ExecutableElement)TreeInfo.symbol((JCTree)node.getMethodSelect());\n    }\n\n"
  },
  {
    "id": "zaproxy_zaproxy-1041-Param-0",
    "old_comment_raw": "@param encodedString the encoded string",
    "old_code_raw": "\tprotected static User decode(String encodedString, ExtensionAuthentication authenticationExtension) {\n\t\tString[] pieces = encodedString.split(FIELD_SEPARATOR);\n\t\tUser user = null;\n\t\ttry {\n\t\t\tint id = Integer.parseInt(pieces[0]);\n\t\t\tif (id >= ID_SOURCE)\n\t\t\t\tID_SOURCE = id + 1;\n\t\t\tint contextId = Integer.parseInt(pieces[1]);\n\t\t\tboolean enabled = pieces[2].equals(\"true\");\n\t\t\tString name = new String(Base64.decodeBase64(pieces[3]));\n\t\t\tint authTypeId = Integer.parseInt(pieces[4]);\n\t\t\tuser = new User(contextId, name, id);\n\t\t\tuser.setEnabled(enabled);\n\n\t\t\tAuthenticationCredentials cred = authenticationExtension\n\t\t\t\t\t.getAuthenticationMethodTypeForIdentifier(authTypeId).createAuthenticationCredentials();\n\t\t\tcred.decode(pieces[5]);\n\t\t\tuser.setAuthenticationCredentials(cred);\n\t\t} catch (Exception ex) {\n\t\t\tlog.error(\"An error occured while decoding user from: \" + encodedString, ex);\n\t\t\treturn null;\n\t\t}\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"Decoded user: \" + user);\n\t\treturn user;\n\t}\n",
    "new_code_raw": "\tprotected static User decode(int contextId, String encodedString, ExtensionAuthentication authenticationExtension) {\n\t\tString[] pieces = encodedString.split(FIELD_SEPARATOR);\n\t\tUser user = null;\n\t\ttry {\n\t\t\tint id = Integer.parseInt(pieces[0]);\n\t\t\tif (id >= ID_SOURCE)\n\t\t\t\tID_SOURCE = id + 1;\n\t\t\tboolean enabled = pieces[2].equals(\"true\");\n\t\t\tString name = new String(Base64.decodeBase64(pieces[3]));\n\t\t\tint authTypeId = Integer.parseInt(pieces[4]);\n\t\t\tuser = new User(contextId, name, id);\n\t\t\tuser.setEnabled(enabled);\n\n\t\t\tAuthenticationCredentials cred = authenticationExtension\n\t\t\t\t\t.getAuthenticationMethodTypeForIdentifier(authTypeId).createAuthenticationCredentials();\n\t\t\tcred.decode(pieces[5]);\n\t\t\tuser.setAuthenticationCredentials(cred);\n\t\t} catch (Exception ex) {\n\t\t\tlog.error(\"An error occured while decoding user from: \" + encodedString, ex);\n\t\t\treturn null;\n\t\t}\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"Decoded user: \" + user);\n\t\treturn user;\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1633-Param-0",
    "old_comment_raw": "@param body Pet object that needs to be added to the store",
    "old_code_raw": "  public void addPet (Pet body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = body;\n    // verify the required parameter 'body' is set\n    if (body == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'body' when calling addPet\",\n        new ApiException(400, \"Missing the required parameter 'body' when calling addPet\"));\n    }\n\n    // create path and map variables\n    String path = \"/pet\";\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n      \"application/json\",\n      \"application/xml\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n    }\n\n    String[] authNames = new String[] { \"petstore_auth\" };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n",
    "new_code_raw": "  public void addPet (Pet pet) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = pet;\n    // verify the required parameter 'pet' is set\n    if (pet == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'pet' when calling addPet\",\n        new ApiException(400, \"Missing the required parameter 'pet' when calling addPet\"));\n    }\n\n    // create path and map variables\n    String path = \"/pet\";\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n    }\n\n    String[] authNames = new String[] { \"petstore_auth\" };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1221-Param-2",
    "old_comment_raw": "@param txTimestamp",
    "old_code_raw": "\tpublic Lock acquirePutFromLoadLock(SessionImplementor session, Object key, long txTimestamp) {\n\t\tif (trace) {\n\t\t\tlog.tracef(\"acquirePutFromLoadLock(%s#%s, %d)\", cache.getName(), key, txTimestamp);\n\t\t}\n\t\tboolean locked = false;\n\n\t\tPendingPutMap pending = pendingPuts.get( key );\n\t\tfor (;;) {\n\t\t\ttry {\n\t\t\t\tif (pending != null) {\n\t\t\t\t\tlocked = pending.acquireLock(100, TimeUnit.MILLISECONDS);\n\t\t\t\t\tif (locked) {\n\t\t\t\t\t\tboolean valid = false;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (pending.isRemoved()) {\n\t\t\t\t\t\t\t\t// this deals with a race between retrieving the map from cache vs. removing that\n\t\t\t\t\t\t\t\t// and locking the map\n\t\t\t\t\t\t\t\tpending.releaseLock();\n\t\t\t\t\t\t\t\tlocked = false;\n\t\t\t\t\t\t\t\tpending = null;\n\t\t\t\t\t\t\t\tif (trace) {\n\t\t\t\t\t\t\t\t\tlog.tracef(\"Record removed when waiting for the lock.\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinal PendingPut toCancel = pending.remove(session);\n\t\t\t\t\t\t\tif (toCancel != null) {\n\t\t\t\t\t\t\t\tvalid = !toCancel.completed;\n\t\t\t\t\t\t\t\ttoCancel.completed = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// this is a naked put\n\t\t\t\t\t\t\t\tif (pending.hasInvalidator()) {\n\t\t\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// we need this check since registerPendingPut (creating new pp) can get between invalidation\n\t\t\t\t\t\t\t\t// and naked put caused by the invalidation\n\t\t\t\t\t\t\t\telse if (pending.lastInvalidationEnd != Long.MIN_VALUE) {\n\t\t\t\t\t\t\t\t\t// if this transaction started afterQuery last invalidation we can continue\n\t\t\t\t\t\t\t\t\tvalid = txTimestamp > pending.lastInvalidationEnd;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tvalid = txTimestamp > regionInvalidationTimestamp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn valid ? pending : null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\tif (!valid && pending != null) {\n\t\t\t\t\t\t\t\tpending.releaseLock();\n\t\t\t\t\t\t\t\tlocked = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (trace) {\n\t\t\t\t\t\t\t\tlog.tracef(\"acquirePutFromLoadLock(%s#%s, %d) ended with %s, valid: %s\", cache.getName(), key, txTimestamp, pending, valid);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (trace) {\n\t\t\t\t\t\t\tlog.tracef(\"acquirePutFromLoadLock(%s#%s, %d) failed to lock\", cache.getName(), key, txTimestamp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// oops, we have leaked record for this owner, but we don't want to wait here\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlong regionInvalidationTimestamp = this.regionInvalidationTimestamp;\n\t\t\t\t\tif (txTimestamp <= regionInvalidationTimestamp) {\n\t\t\t\t\t\tif (trace) {\n\t\t\t\t\t\t\tlog.tracef(\"acquirePutFromLoadLock(%s#%s, %d) failed due to region invalidated at %d\", cache.getName(), key, txTimestamp, regionInvalidationTimestamp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (trace) {\n\t\t\t\t\t\t\tlog.tracef(\"Region invalidated at %d, this transaction started at %d\", regionInvalidationTimestamp, txTimestamp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tPendingPut pendingPut = new PendingPut(session);\n\t\t\t\t\tpending = new PendingPutMap(pendingPut);\n\t\t\t\t\tPendingPutMap existing = pendingPuts.putIfAbsent(key, pending);\n\t\t\t\t\tif (existing != null) {\n\t\t\t\t\t\tpending = existing;\n\t\t\t\t\t}\n\t\t\t\t\t// continue in next loop with lock acquisition\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable t) {\n\t\t\t\tif (locked) {\n\t\t\t\t\tpending.releaseLock();\n\t\t\t\t}\n\n\t\t\t\tif (t instanceof RuntimeException) {\n\t\t\t\t\tthrow (RuntimeException) t;\n\t\t\t\t}\n\t\t\t\telse if (t instanceof Error) {\n\t\t\t\t\tthrow (Error) t;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new RuntimeException(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "new_code_raw": "\tpublic Lock acquirePutFromLoadLock(SharedSessionContractImplementor session, Object key, long txTimestamp) {\n\t\tif (trace) {\n\t\t\tlog.tracef(\"acquirePutFromLoadLock(%s#%s, %d)\", cache.getName(), key, txTimestamp);\n\t\t}\n\t\tboolean locked = false;\n\n\t\tPendingPutMap pending = pendingPuts.get( key );\n\t\tfor (;;) {\n\t\t\ttry {\n\t\t\t\tif (pending != null) {\n\t\t\t\t\tlocked = pending.acquireLock(100, TimeUnit.MILLISECONDS);\n\t\t\t\t\tif (locked) {\n\t\t\t\t\t\tboolean valid = false;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (pending.isRemoved()) {\n\t\t\t\t\t\t\t\t// this deals with a race between retrieving the map from cache vs. removing that\n\t\t\t\t\t\t\t\t// and locking the map\n\t\t\t\t\t\t\t\tpending.releaseLock();\n\t\t\t\t\t\t\t\tlocked = false;\n\t\t\t\t\t\t\t\tpending = null;\n\t\t\t\t\t\t\t\tif (trace) {\n\t\t\t\t\t\t\t\t\tlog.tracef(\"Record removed when waiting for the lock.\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinal PendingPut toCancel = pending.remove(session);\n\t\t\t\t\t\t\tif (toCancel != null) {\n\t\t\t\t\t\t\t\tvalid = !toCancel.completed;\n\t\t\t\t\t\t\t\ttoCancel.completed = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// this is a naked put\n\t\t\t\t\t\t\t\tif (pending.hasInvalidator()) {\n\t\t\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// we need this check since registerPendingPut (creating new pp) can get between invalidation\n\t\t\t\t\t\t\t\t// and naked put caused by the invalidation\n\t\t\t\t\t\t\t\telse if (pending.lastInvalidationEnd != Long.MIN_VALUE) {\n\t\t\t\t\t\t\t\t\t// if this transaction started afterQuery last invalidation we can continue\n\t\t\t\t\t\t\t\t\tvalid = txTimestamp > pending.lastInvalidationEnd;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tvalid = txTimestamp > regionInvalidationTimestamp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn valid ? pending : null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\tif (!valid && pending != null) {\n\t\t\t\t\t\t\t\tpending.releaseLock();\n\t\t\t\t\t\t\t\tlocked = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (trace) {\n\t\t\t\t\t\t\t\tlog.tracef(\"acquirePutFromLoadLock(%s#%s, %d) ended with %s, valid: %s\", cache.getName(), key, txTimestamp, pending, valid);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (trace) {\n\t\t\t\t\t\t\tlog.tracef(\"acquirePutFromLoadLock(%s#%s, %d) failed to lock\", cache.getName(), key, txTimestamp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// oops, we have leaked record for this owner, but we don't want to wait here\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlong regionInvalidationTimestamp = this.regionInvalidationTimestamp;\n\t\t\t\t\tif (txTimestamp <= regionInvalidationTimestamp) {\n\t\t\t\t\t\tif (trace) {\n\t\t\t\t\t\t\tlog.tracef(\"acquirePutFromLoadLock(%s#%s, %d) failed due to region invalidated at %d\", cache.getName(), key, txTimestamp, regionInvalidationTimestamp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (trace) {\n\t\t\t\t\t\t\tlog.tracef(\"Region invalidated at %d, this transaction started at %d\", regionInvalidationTimestamp, txTimestamp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tPendingPut pendingPut = new PendingPut(session);\n\t\t\t\t\tpending = new PendingPutMap(pendingPut);\n\t\t\t\t\tPendingPutMap existing = pendingPuts.putIfAbsent(key, pending);\n\t\t\t\t\tif (existing != null) {\n\t\t\t\t\t\tpending = existing;\n\t\t\t\t\t}\n\t\t\t\t\t// continue in next loop with lock acquisition\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable t) {\n\t\t\t\tif (locked) {\n\t\t\t\t\tpending.releaseLock();\n\t\t\t\t}\n\n\t\t\t\tif (t instanceof RuntimeException) {\n\t\t\t\t\tthrow (RuntimeException) t;\n\t\t\t\t}\n\t\t\t\telse if (t instanceof Error) {\n\t\t\t\t\tthrow (Error) t;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new RuntimeException(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n"
  },
  {
    "id": "RobotiumTech_robotium-1507-Param-1",
    "old_comment_raw": "@param expectedMinimumNumberOfMatches the minimum number of matches expected to be found.  0 matches means that one or more matches are expected to be found",
    "old_code_raw": "\tpublic boolean searchText(String regex, int expectedMinimumNumberOfMatches, boolean scroll) {\n\t\treturn searcher.searchWithTimeoutFor(TextView.class, regex, expectedMinimumNumberOfMatches, scroll);\n\t}\n",
    "new_code_raw": "\tpublic boolean searchText(String text, int minimumNumberOfMatches, boolean scroll) {\n\t\treturn searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, scroll);\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2600-Param-2",
    "old_comment_raw": "@param additionalMetadata Additional data to pass to server (optional, default to null)",
    "old_code_raw": "  public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws ApiException {\n    return uploadFileWithRequiredFileWithHttpInfo(petId, file, additionalMetadata).getData();\n      }\n",
    "new_code_raw": "  public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException {\n    return uploadFileWithRequiredFileWithHttpInfo(petId, requiredFile, additionalMetadata).getData();\n      }\n"
  },
  {
    "id": "querydsl_querydsl-1827-Param-0",
    "old_comment_raw": "@param operator operator",
    "old_code_raw": "    public static BooleanOperation predicate(Operator operator, Expression<?>... args) {\n        return new BooleanOperation(operator, args);\n    }\n",
    "new_code_raw": "    public static BooleanOperation predicate(Operator operation, Expression<?>... args) {\n        return new BooleanOperation(operation, args);\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-301-Param-0",
    "old_comment_raw": "@param partial an object to check against",
    "old_code_raw": "    public int compareTo(Object partial) {\n        // override to perform faster\n        if (this == partial) {\n            return 0;\n        }\n        if (partial instanceof LocalDate) {\n            LocalDate other = (LocalDate) partial;\n            if (iChronology.equals(other.iChronology)) {\n                return (iLocalMillis < other.iLocalMillis ? -1 :\n                            (iLocalMillis == other.iLocalMillis ? 0 : 1));\n\n            }\n        }\n        return super.compareTo(partial);\n    }\n",
    "new_code_raw": "    public int compareTo(ReadablePartial partial) {\n        // override to perform faster\n        if (this == partial) {\n            return 0;\n        }\n        if (partial instanceof LocalDate) {\n            LocalDate other = (LocalDate) partial;\n            if (iChronology.equals(other.iChronology)) {\n                return (iLocalMillis < other.iLocalMillis ? -1 :\n                            (iLocalMillis == other.iLocalMillis ? 0 : 1));\n\n            }\n        }\n        return super.compareTo(partial);\n    }\n"
  },
  {
    "id": "scribejava_scribejava-73-Param-0",
    "old_comment_raw": "@param signatureType SignatureType",
    "old_code_raw": "    public ServiceBuilder signatureType(SignatureType signatureType) {\n        Preconditions.checkNotNull(signatureType, \"Signature type can't be null\");\n        this.signatureType = signatureType;\n        return this;\n    }\n",
    "new_code_raw": "    public ServiceBuilder signatureType(OAuth1SignatureType signatureType) {\n        this.signatureType = signatureType;\n        return this;\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1534-Param-3",
    "old_comment_raw": "@param body The request body object",
    "old_code_raw": "  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    final String url = buildUrl(path, queryParams);\n    final Request.Builder reqBuilder = new Request.Builder().url(url);\n    processHeaderParams(headerParams, reqBuilder);\n\n    String contentType = (String) headerParams.get(\"Content-Type\");\n    // ensuring a default content type\n    if (contentType == null) contentType = \"application/json\";\n\n    RequestBody reqBody;\n    if (!HttpMethod.permitsRequestBody(method)) {\n      reqBody = null;\n    } else if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n      reqBody = buildRequestBodyFormEncoding(formParams);\n    } else if (\"multipart/form-data\".equals(contentType)) {\n      reqBody = buildRequestBodyMultipart(formParams);\n    } else if (body == null) {\n      if (\"DELETE\".equals(method)) {\n        // allow calling DELETE without sending a request body\n        reqBody = null;\n      } else {\n        // use an empty request body (for POST, PUT and PATCH)\n        reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n      }\n    } else {\n      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));\n    }\n\n    Request request = null;\n\n    if(progressRequestListener != null && reqBody != null) {\n      ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener);\n      request = reqBuilder.method(method, progressRequestBody).build();\n    } else {\n      request = reqBuilder.method(method, reqBody).build();\n    }\n\n    return httpClient.newCall(request);\n  }\n",
    "new_code_raw": "  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    final String url = buildUrl(path, queryParams);\n    final Request.Builder reqBuilder = new Request.Builder().url(url);\n    processHeaderParams(headerParams, reqBuilder);\n\n    String contentType = (String) headerParams.get(\"Content-Type\");\n    // ensuring a default content type\n    if (contentType == null) contentType = \"application/json\";\n\n    RequestBody reqBody;\n    if (!HttpMethod.permitsRequestBody(method)) {\n      reqBody = null;\n    } else if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n      reqBody = buildRequestBodyFormEncoding(formParams);\n    } else if (\"multipart/form-data\".equals(contentType)) {\n      reqBody = buildRequestBodyMultipart(formParams);\n    } else if (body == null) {\n      if (\"DELETE\".equals(method)) {\n        // allow calling DELETE without sending a request body\n        reqBody = null;\n      } else {\n        // use an empty request body (for POST, PUT and PATCH)\n        reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n      }\n    } else {\n      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));\n    }\n\n    Request request = reqBuilder.method(method, reqBody).build();\n    return httpClient.newCall(request);\n  }\n"
  },
  {
    "id": "linkedin_pinot-75-Associations-Param0",
    "old_comment_raw": "@param inputReq BrokerRequest that is to be optimized",
    "old_code_raw": "  public BrokerRequest optimize(BrokerRequest inputReq) {\n    // Flatten the query tree if possible\n    return flatten(inputReq);\n  }\n",
    "new_code_raw": "  public BrokerRequest optimize(BrokerRequest brokerRequest) {\n    optimizeFilterQueryTree(brokerRequest);\n\n    return brokerRequest;\n  }\n\n"
  },
  {
    "id": "RobotiumTech_robotium-1434-Param-0",
    "old_comment_raw": "@param view the id of the view to wait for",
    "old_code_raw": "\tpublic View waitForView(int id, int index){\n\t\tArrayList<View> viewsMatchingId = new ArrayList<View>();\n\t\tlong endTime = SystemClock.uptimeMillis() + SMALL_TIMEOUT;\n\n\t\twhile (SystemClock.uptimeMillis() <= endTime) {\n\t\t\tsleeper.sleep();\n\n\t\t\tfor (View view : viewFetcher.getAllViews(false)) {\n\t\t\t\tInteger idOfView = Integer.valueOf(view.getId());\n\n\t\t\t\tif (idOfView.equals(id)) {\n\t\t\t\t\tviewsMatchingId.add(view);\n\n\t\t\t\t\tif(viewsMatchingId.size() > index) {\n\t\t\t\t\t\treturn viewsMatchingId.get(index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tviewsMatchingId.clear();\n\t\t}\n\t\treturn null;\n\t}\n",
    "new_code_raw": "\tpublic View waitForView(int id, int index, int timeout, boolean scroll){\n\t\tSet<View> uniqueViewsMatchingId = new HashSet<View>();\n\t\tlong endTime = SystemClock.uptimeMillis() + timeout;\n\n\t\twhile (SystemClock.uptimeMillis() <= endTime) {\n\t\t\tsleeper.sleep();\n\n\t\t\tfor (View view : viewFetcher.getAllViews(false)) {\n\t\t\t\tInteger idOfView = Integer.valueOf(view.getId());\n\n\t\t\t\tif (idOfView.equals(id)) {\n\t\t\t\t\tuniqueViewsMatchingId.add(view);\n\n\t\t\t\t\tif(uniqueViewsMatchingId.size() > index) {\n\t\t\t\t\t\treturn view;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(scroll) \n\t\t\t\tscroller.scroll(Scroller.DOWN);\n\t\t}\n\t\treturn null;\n\t}\n"
  },
  {
    "id": "apache_calcite-959-Param-1",
    "old_comment_raw": "@param simplify Whether to simplify (in addition to normalizing)",
    "old_code_raw": "  public RexProgram normalize(RexBuilder rexBuilder, boolean simplify) {\n    // Normalize program by creating program builder from the program, then\n    // converting to a program. getProgram does not need to normalize\n    // because the builder was normalized on creation.\n    assert isValid(Litmus.THROW, null);\n    final RexProgramBuilder builder =\n        RexProgramBuilder.create(rexBuilder, inputRowType, exprs, projects,\n            condition, outputRowType, true, simplify);\n    return builder.getProgram(false);\n  }\n",
    "new_code_raw": "  public RexProgram normalize(RexBuilder rexBuilder, RexSimplify simplify) {\n    // Normalize program by creating program builder from the program, then\n    // converting to a program. getProgram does not need to normalize\n    // because the builder was normalized on creation.\n    assert isValid(Litmus.THROW, null);\n    final RexProgramBuilder builder =\n        RexProgramBuilder.create(rexBuilder, inputRowType, exprs, projects,\n            condition, outputRowType, true, simplify);\n    return builder.getProgram(false);\n  }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-826-Param-0",
    "old_comment_raw": "@param nodeFilter a Filter method which returns true to mean keep this node, false to mean delete it",
    "old_code_raw": "  public Tree spliceOut(final Filter<Tree> nodeFilter, final TreeFactory tf) {\n    List<Tree> l = spliceOutHelper(nodeFilter, tf);\n    if (l.isEmpty()) {\n      return null;\n    } else if (l.size() == 1) {\n      return l.get(0);\n    }\n    // for a forest, make a new root\n    return tf.newTreeNode((Label) null, l);\n  }\n",
    "new_code_raw": "  public Tree spliceOut(final Predicate<Tree> nodeFilter, final TreeFactory tf) {\n    List<Tree> l = spliceOutHelper(nodeFilter, tf);\n    if (l.isEmpty()) {\n      return null;\n    } else if (l.size() == 1) {\n      return l.get(0);\n    }\n    // for a forest, make a new root\n    return tf.newTreeNode((Label) null, l);\n  }\n"
  },
  {
    "id": "Atmosphere_atmosphere-827-Param-1",
    "old_comment_raw": "@param response the  HttpServletResponse",
    "old_code_raw": "    public Action resumed(HttpServletRequest request, HttpServletResponse response)\n            throws IOException, ServletException {\n        return action(request, response);\n    }\n",
    "new_code_raw": "    public Action resumed(AtmosphereRequest request, AtmosphereResponse response)\n            throws IOException, ServletException {\n        return action(request, response);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1700-Param-1",
    "old_comment_raw": "@param params Map of query params. A collection will be interpreted as passing in multiple instances of the same query param.",
    "old_code_raw": "    public Client call123testSpecialTags(Client client, Map<String, Object> params) throws IOException {\n        HttpResponse response = call123testSpecialTagsForHttpResponse(client, params);\n        TypeReference typeRef = new TypeReference<Client>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n",
    "new_code_raw": "    public Client call123testSpecialTags(Client body, Map<String, Object> params) throws IOException {\n        HttpResponse response = call123testSpecialTagsForHttpResponse(body, params);\n        TypeReference typeRef = new TypeReference<Client>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1619-Param-1",
    "old_comment_raw": "@param model Swagger Model object",
    "old_code_raw": "    public CodegenModel fromModel(String name, Model model, Map<String, Model> allDefinitions) {\n        if (typeAliases == null) {\n            // Only do this once during first call\n            typeAliases = getAllAliases(allDefinitions);\n        }\n        CodegenModel m = CodegenModelFactory.newInstance(CodegenModelType.MODEL);\n        if (reservedWords.contains(name)) {\n            m.name = escapeReservedWord(name);\n        } else {\n            m.name = name;\n        }\n        m.title = escapeText(model.getTitle());\n        m.description = escapeText(model.getDescription());\n        m.unescapedDescription = model.getDescription();\n        m.classname = toModelName(name);\n        m.classVarName = toVarName(name);\n        m.classFilename = toModelFilename(name);\n        m.modelJson = Json.pretty(model);\n        m.externalDocs = model.getExternalDocs();\n        m.vendorExtensions = model.getVendorExtensions();\n        m.isAlias = typeAliases.containsKey(name);\n\n        if (model instanceof ModelImpl) {\n            ModelImpl modelImpl = (ModelImpl) model;\n            m.discriminator = modelImpl.getDiscriminator();\n\n            if (modelImpl.getXml() != null) {\n                m.xmlPrefix = modelImpl.getXml().getPrefix();\n                m.xmlNamespace = modelImpl.getXml().getNamespace();\n                m.xmlName = modelImpl.getXml().getName();\n            }\n        }\n\n        if (model instanceof ArrayModel) {\n            ArrayModel am = (ArrayModel) model;\n            ArrayProperty arrayProperty = new ArrayProperty(am.getItems());\n            m.isArrayModel = true;\n            m.arrayModelType = fromProperty(name, arrayProperty).complexType;\n            addParentContainer(m, name, arrayProperty);\n        } else if (model instanceof RefModel) {\n            // TODO\n        } else if (model instanceof ComposedModel) {\n            final ComposedModel composed = (ComposedModel) model;\n            Map<String, Property> properties = new LinkedHashMap<String, Property>();\n            List<String> required = new ArrayList<String>();\n            Map<String, Property> allProperties;\n            List<String> allRequired;\n            if (supportsInheritance || supportsMixins) {\n                allProperties = new LinkedHashMap<String, Property>();\n                allRequired = new ArrayList<String>();\n                m.allVars = new ArrayList<CodegenProperty>();\n                int modelImplCnt = 0; // only one inline object allowed in a ComposedModel\n                for (Model innerModel: ((ComposedModel)model).getAllOf()) {\n                    if (innerModel instanceof ModelImpl) {\n                        ModelImpl modelImpl = (ModelImpl) innerModel;\n                        if (m.discriminator == null) {\n                            m.discriminator = modelImpl.getDiscriminator();\n                        }\n                        if (modelImpl.getXml() != null) {\n                            m.xmlPrefix = modelImpl.getXml().getPrefix();\n                            m.xmlNamespace = modelImpl.getXml().getNamespace();\n                            m.xmlName = modelImpl.getXml().getName();\n                        }\n                        if (modelImplCnt++ > 1) {\n                            LOGGER.warn(\"More than one inline schema specified in allOf:. Only the first one is recognized. All others are ignored.\");\n                            break; // only one ModelImpl with discriminator allowed in allOf\n                        }\n                    }\n                }\n            } else {\n                allProperties = null;\n                allRequired = null;\n            }\n            // parent model\n            RefModel parent = (RefModel) composed.getParent();\n\n            // interfaces (intermediate models)\n            if (composed.getInterfaces() != null) {\n                if (m.interfaces == null)\n                    m.interfaces = new ArrayList<String>();\n                for (RefModel _interface : composed.getInterfaces()) {\n                    Model interfaceModel = null;\n                    if (allDefinitions != null) {\n                        interfaceModel = allDefinitions.get(_interface.getSimpleRef());\n                    }\n                    // set first interface with discriminator found as parent\n                    if (parent == null\n                            && ((interfaceModel instanceof ModelImpl && ((ModelImpl) interfaceModel).getDiscriminator() != null)\n                            || (interfaceModel instanceof ComposedModel && isDiscriminatorInInterfaceTree((ComposedModel) interfaceModel, allDefinitions)))) {\n                        parent = _interface;\n                    } else {\n                        final String interfaceRef = toModelName(_interface.getSimpleRef());\n                        m.interfaces.add(interfaceRef);\n                        addImport(m, interfaceRef);\n                        if (allDefinitions != null) {\n                            if (!supportsMixins) {\n                                addProperties(properties, required, interfaceModel, allDefinitions);\n                            }\n                            if (supportsInheritance) {\n                                addProperties(allProperties, allRequired, interfaceModel, allDefinitions);\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (parent != null) {\n                final String parentRef = parent.getSimpleRef();\n                m.parentSchema = parentRef;\n                m.parent = toModelName(parent.getSimpleRef());\n                addImport(m, m.parent);\n                if (allDefinitions != null) {\n                    final Model parentModel = allDefinitions.get(m.parentSchema);\n                    if (supportsInheritance) {\n                        addProperties(allProperties, allRequired, parentModel, allDefinitions);\n                    } else {\n                        addProperties(properties, required, parentModel, allDefinitions);\n                    }\n                }\n            }\n\n            // child model (properties owned by the model itself)\n            Model child = composed.getChild();\n            if (child != null && child instanceof RefModel && allDefinitions != null) {\n                final String childRef = ((RefModel) child).getSimpleRef();\n                child = allDefinitions.get(childRef);\n            }\n            if (child != null && child instanceof ModelImpl) {\n                addProperties(properties, required, child, allDefinitions);\n                if (supportsInheritance) {\n                    addProperties(allProperties, allRequired, child, allDefinitions);\n                }\n            }\n            addVars(m, properties, required, allProperties, allRequired);\n        } else {\n            ModelImpl impl = (ModelImpl) model;\n            if (impl.getType() != null) {\n                Property p = PropertyBuilder.build(impl.getType(), impl.getFormat(), null);\n                m.dataType = getSwaggerType(p);\n            }\n            if(impl.getEnum() != null && impl.getEnum().size() > 0) {\n                m.isEnum = true;\n                // comment out below as allowableValues is not set in post processing model enum\n                m.allowableValues = new HashMap<String, Object>();\n                m.allowableValues.put(\"values\", impl.getEnum());\n            }\n            if (impl.getAdditionalProperties() != null) {\n                addAdditionPropertiesToCodeGenModel(m, impl);\n            }\n            addVars(m, impl.getProperties(), impl.getRequired());\n        }\n\n        if (m.vars != null) {\n            for(CodegenProperty prop : m.vars) {\n                postProcessModelProperty(m, prop);\n            }\n        }\n        return m;\n    }\n",
    "new_code_raw": "    public CodegenModel fromModel(String name, Schema schema, Map<String, Schema> allDefinitions) {\n        if (typeAliases == null) {\n            // Only do this once during first call\n            typeAliases = getAllAliases(allDefinitions);\n        }\n\n        CodegenModel m = CodegenModelFactory.newInstance(CodegenModelType.MODEL);\n\n        if (reservedWords.contains(name)) {\n            m.name = escapeReservedWord(name);\n        } else {\n            m.name = name;\n        }\n        m.title = escapeText(schema.getTitle());\n        m.description = escapeText(schema.getDescription());\n        m.unescapedDescription = schema.getDescription();\n        m.classname = toModelName(name);\n        m.classVarName = toVarName(name);\n        m.classFilename = toModelFilename(name);\n        m.modelJson = Json.pretty(schema);\n        m.externalDocumentation = schema.getExternalDocs();\n        if (schema.getExtensions() != null && !schema.getExtensions().isEmpty()) {\n            m.getVendorExtensions().putAll(schema.getExtensions());\n        }\n        m.isAlias = typeAliases.containsKey(name);\n        m.discriminator = schema.getDiscriminator();\n\n        if (schema.getXml() != null) {\n            m.xmlPrefix = schema.getXml().getPrefix();\n            m.xmlNamespace = schema.getXml().getNamespace();\n            m.xmlName = schema.getXml().getName();\n        }\n\n        if (ModelUtils.isArraySchema(schema)) {\n            m.isArrayModel = true;\n            m.arrayModelType = fromProperty(name, schema).complexType;\n            addParentContainer(m, name, schema);\n        } else if (schema instanceof ComposedSchema) {\n            final ComposedSchema composed = (ComposedSchema) schema;\n            Map<String, Schema> properties = new LinkedHashMap<String, Schema>();\n            List<String> required = new ArrayList<String>();\n            Map<String, Schema> allProperties;\n            List<String> allRequired;\n\n            if (supportsInheritance || supportsMixins) {\n                allProperties = new LinkedHashMap<String, Schema>();\n                allRequired = new ArrayList<String>();\n                m.allVars = new ArrayList<CodegenProperty>();\n                int modelImplCnt = 0; // only one inline object allowed in a ComposedModel\n                for (Schema innerModel : composed.getAllOf()) {\n                    if (m.discriminator == null) {\n                        m.discriminator = schema.getDiscriminator();\n                    }\n                    if (innerModel.getXml() != null) {\n                        m.xmlPrefix = innerModel.getXml().getPrefix();\n                        m.xmlNamespace = innerModel.getXml().getNamespace();\n                        m.xmlName = innerModel.getXml().getName();\n                    }\n                    if (modelImplCnt++ > 1) {\n                        LOGGER.warn(\"More than one inline schema specified in allOf:. Only the first one is recognized. All others are ignored.\");\n                        break; // only one ModelImpl with discriminator allowed in allOf\n                    }\n                }\n            } else {\n                allProperties = null;\n                allRequired = null;\n            }\n            // parent model\n            final String parentName = getParentName(composed, allDefinitions);\n            final Schema parent = StringUtils.isBlank(parentName) ? null : allDefinitions.get(parentName);\n\n            List<Schema> interfaces = getInterfaces(composed);\n\n            // interfaces (intermediate models)\n            if (interfaces != null) {\n                if (m.interfaces == null)\n                    m.interfaces = new ArrayList<String>();\n\n                for (Schema interfaceSchema : interfaces) {\n                    if (StringUtils.isBlank(interfaceSchema.get$ref())) {\n                        continue;\n                    }\n                    Schema refSchema = null;\n                    String ref = getSimpleRef(interfaceSchema.get$ref());\n                    if (allDefinitions != null) {\n                        refSchema = allDefinitions.get(ref);\n                    }\n                    final String modelName = toModelName(ref);\n                    m.interfaces.add(modelName);\n                    addImport(m, modelName);\n                    if (allDefinitions != null && refSchema != null) {\n                        if (!supportsMixins && !supportsInheritance) {\n                            addProperties(properties, required, refSchema, allDefinitions);\n                        }\n                        if (supportsInheritance) {\n                            addProperties(allProperties, allRequired, refSchema, allDefinitions);\n                        }\n                    }\n                }\n            }\n\n            if (parent != null) {\n                m.parentSchema = parentName;\n                m.parent = toModelName(parentName);\n                addImport(m, m.parent);\n                if (allDefinitions != null && !allDefinitions.isEmpty()) {\n                    if (supportsInheritance) {\n                        addProperties(allProperties, allRequired, parent, allDefinitions);\n                    } else {\n                        addProperties(properties, required, parent, allDefinitions);\n                    }\n                }\n            }\n\n            // child model (properties owned by the model itself)\n            Schema child = null;\n            if (composed.getAllOf() != null && !composed.getAllOf().isEmpty()) {\n                for (Schema component : composed.getAllOf()) {\n                    if (component.get$ref() == null) {\n                        child = component;\n                    }\n                }\n            }\n            if (child != null) {\n                addProperties(properties, required, child, allDefinitions);\n                if (supportsInheritance) {\n                    addProperties(allProperties, allRequired, child, allDefinitions);\n                }\n            }\n            addVars(m, properties, required, allProperties, allRequired);\n            // TODO\n            //} else if (schema instanceof RefModel) {\n        } else {\n            m.dataType = getSchemaType(schema);\n            if (schema.getEnum() != null && !schema.getEnum().isEmpty()) {\n                m.isEnum = true;\n                // comment out below as allowableValues is not set in post processing model enum\n                m.allowableValues = new HashMap<String, Object>();\n                m.allowableValues.put(\"values\", schema.getEnum());\n            }\n            if (ModelUtils.isMapSchema(schema)) {\n                addAdditionPropertiesToCodeGenModel(m, schema);\n            }\n            addVars(m, schema.getProperties(), schema.getRequired());\n        }\n\n        if (m.vars != null) {\n            for (CodegenProperty prop : m.vars) {\n                postProcessModelProperty(m, prop);\n            }\n        }\n        LOGGER.debug(\"debugging fromModel return: \" + m);\n\n        return m;\n    }\n"
  },
  {
    "id": "SeleniumHQ_selenium-651-Param-0",
    "old_comment_raw": "@param appName",
    "old_code_raw": "\tpublic static RemoteProxy getNewBasicRemoteProxy(String appName, String url) {\n\n\t\tRegistrationRequest req = new RegistrationRequest();\n\n\t\tMap<String, Object> capability = new HashMap<String, Object>();\n\t\tcapability.put(\"applicationName\", appName);\n\t\treq.addDesiredCapabilitiy(capability);\n\n\t\tMap<String, Object> config = new HashMap<String, Object>();\n\t\tconfig.put(\"url\", url);\n\t\treq.setConfiguration(config);\n\t\treturn new RemoteProxy(req);\n\n\t}\n",
    "new_code_raw": "\tpublic static RemoteProxy getNewBasicRemoteProxy(String appName, String url,Registry registry) {\n\n\t\tRegistrationRequest req = new RegistrationRequest();\n\n\t\tMap<String, Object> capability = new HashMap<String, Object>();\n\t\tcapability.put(\"applicationName\", appName);\n\t\treq.addDesiredCapabilitiy(capability);\n\n\t\tMap<String, Object> config = new HashMap<String, Object>();\n\t\tconfig.put(\"url\", url);\n\t\treq.setConfiguration(config);\n\t\treturn new RemoteProxy(req,registry);\n\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2569-Param-0",
    "old_comment_raw": "@param p Swagger property object",
    "old_code_raw": "    public String toDefaultValue(Property p) {\n        if (p instanceof StringProperty) {\n            return \"null\";\n        } else if (p instanceof BooleanProperty) {\n            return \"null\";\n        } else if (p instanceof DateProperty) {\n            return \"null\";\n        } else if (p instanceof DateTimeProperty) {\n            return \"null\";\n        } else if (p instanceof DoubleProperty) {\n            DoubleProperty dp = (DoubleProperty) p;\n            if (dp.getDefault() != null) {\n                return dp.getDefault().toString();\n            }\n            return \"null\";\n        } else if (p instanceof FloatProperty) {\n            FloatProperty dp = (FloatProperty) p;\n            if (dp.getDefault() != null) {\n                return dp.getDefault().toString();\n            }\n            return \"null\";\n        } else if (p instanceof IntegerProperty) {\n            IntegerProperty dp = (IntegerProperty) p;\n            if (dp.getDefault() != null) {\n                return dp.getDefault().toString();\n            }\n            return \"null\";\n        } else if (p instanceof LongProperty) {\n            LongProperty dp = (LongProperty) p;\n            if (dp.getDefault() != null) {\n                return dp.getDefault().toString();\n            }\n            return \"null\";\n        } else {\n            return \"null\";\n        }\n    }\n",
    "new_code_raw": "    public String toDefaultValue(Schema schema) {\n        if (ModelUtils.isBooleanSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isDateSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isDateTimeSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isNumberSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isIntegerSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isStringSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isObjectSchema(schema)) {\n            return \"null\";\n        } else {\n            return \"null\";\n        }\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-411-Param-2",
    "old_comment_raw": "@param status Updated status of the pet",
    "old_code_raw": "  public void  updatePetWithForm (String petId, String name, String status) throws ApiException {\n    Object postBody = null;\n    \n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n       throw new ApiException(400, \"Missing the required parameter 'petId' when calling updatePetWithForm\");\n    }\n    \n\n    // create path and map variables\n    String path = \"/pet/{petId}\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString()));\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n\n    \n\n    \n\n    String[] contentTypes = {\n      \"application/x-www-form-urlencoded\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder builder = MultipartEntityBuilder.create();\n      \n      if (name != null) {\n        builder.addTextBody(\"name\", ApiInvoker.parameterToString(name), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      \n      if (status != null) {\n        builder.addTextBody(\"status\", ApiInvoker.parameterToString(status), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      \n\n      HttpEntity httpEntity = builder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n      formParams.put(\"name\", ApiInvoker.parameterToString(name));\n      formParams.put(\"status\", ApiInvoker.parameterToString(status));\n      \n    }\n\n    try {\n      String response = apiInvoker.invokeAPI(basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType);\n      if(response != null){\n        return ;\n      }\n      else {\n        return ;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n",
    "new_code_raw": "  public void  updatePetWithForm (Long petId, String name, String status) throws ApiException {\n    Object postBody = null;\n    \n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n       throw new ApiException(400, \"Missing the required parameter 'petId' when calling updatePetWithForm\");\n    }\n    \n\n    // create path and map variables\n    String path = \"/pet/{petId}\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString()));\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n\n    \n\n    \n\n    String[] contentTypes = {\n      \"application/x-www-form-urlencoded\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder builder = MultipartEntityBuilder.create();\n      \n      if (name != null) {\n        builder.addTextBody(\"name\", ApiInvoker.parameterToString(name), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      \n      if (status != null) {\n        builder.addTextBody(\"status\", ApiInvoker.parameterToString(status), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      \n\n      HttpEntity httpEntity = builder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n      formParams.put(\"name\", ApiInvoker.parameterToString(name));\n      formParams.put(\"status\", ApiInvoker.parameterToString(status));\n      \n    }\n\n    try {\n      String response = apiInvoker.invokeAPI(basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType);\n      if(response != null){\n        return ;\n      }\n      else {\n        return ;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n"
  },
  {
    "id": "Atmosphere_atmosphere-828-Param-1",
    "old_comment_raw": "@param res the  HttpServletResponse",
    "old_code_raw": "    public Action cancelled(HttpServletRequest req, HttpServletResponse res)\n            throws IOException, ServletException {\n\n        synchronized (req) {\n            AtmosphereResourceImpl r = null;\n            try {\n                if (trackActiveRequest) {\n                    long l = (Long) req.getAttribute(MAX_INACTIVE);\n                    if (l == -1) {\n                        // The closedDetector closed the connection.\n                        return timedoutAction;\n                    }\n                    req.setAttribute(MAX_INACTIVE, (long) -1);\n                }\n\n                logger.debug(\"Cancelling the connection for request {}\", req);\n\n                r = (AtmosphereResourceImpl) req.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n                if (r != null) {\n                    r.getAtmosphereResourceEvent().setCancelled(true);\n                    invokeAtmosphereHandler(r);\n\n                    try {\n                        r.getResponse().sendError(503);\n                        r.getResponse().getOutputStream().close();\n                    } catch (Throwable t) {\n                        try {\n                            r.getResponse().getWriter().close();\n                        } catch (Throwable t2) {\n                        }\n                    }\n                }\n            } catch (Throwable ex) {\n                // Something wrong happenned, ignore the exception\n                logger.debug(\"failed to cancel resource: \" + r, ex);\n            } finally {\n                try {\n                    if (r != null) {\n                        r.notifyListeners();\n                        r.setIsInScope(false);\n                        r.cancel();\n                    }\n                } catch (Throwable t) {\n                    logger.trace(\"cancel\", t);\n                } finally {\n                    if (r != null) {\n                        destroyResource(r);\n                    }\n                }\n            }\n        }\n\n        return cancelledAction;\n    }\n",
    "new_code_raw": "    public Action cancelled(AtmosphereRequest req, AtmosphereResponse res)\n            throws IOException, ServletException {\n\n        synchronized (req) {\n            AtmosphereResourceImpl r = null;\n            try {\n                if (trackActiveRequest) {\n                    long l = (Long) req.getAttribute(MAX_INACTIVE);\n                    if (l == -1) {\n                        // The closedDetector closed the connection.\n                        return timedoutAction;\n                    }\n                    req.setAttribute(MAX_INACTIVE, (long) -1);\n                }\n\n                logger.debug(\"Cancelling the connection for request {}\", req);\n\n                r = (AtmosphereResourceImpl) req.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n                if (r != null) {\n                    r.getAtmosphereResourceEvent().setCancelled(true);\n                    invokeAtmosphereHandler(r);\n\n                    try {\n                        r.getResponse().sendError(503);\n                        r.getResponse().getOutputStream().close();\n                    } catch (Throwable t) {\n                        try {\n                            r.getResponse().getWriter().close();\n                        } catch (Throwable t2) {\n                        }\n                    }\n                }\n            } catch (Throwable ex) {\n                // Something wrong happenned, ignore the exception\n                logger.debug(\"failed to cancel resource: \" + r, ex);\n            } finally {\n                try {\n                    if (r != null) {\n                        r.notifyListeners();\n                        r.setIsInScope(false);\n                        r.cancel();\n                    }\n                } catch (Throwable t) {\n                    logger.trace(\"cancel\", t);\n                } finally {\n                    if (r != null) {\n                        destroyResource(r);\n                    }\n                }\n            }\n        }\n\n        return cancelledAction;\n    }\n"
  },
  {
    "id": "ata4_disunity-0-Param-1",
    "old_comment_raw": "@param path object path",
    "old_code_raw": "    public static String getObjectName(AssetFile asset, AssetObjectPath path) {\n        Deserializer deser = new Deserializer(asset);\n        String name = null;\n        \n        try {\n            UnityObject obj = deser.deserialize(path);\n            name = obj.getValue(\"m_Name\");\n        } catch (OutOfMemoryError ex) {\n            // Deserializer choked on an array size and clogged the heap, try\n            // to clean up this mess\n            deser = null;\n            System.gc();\n        } catch (Throwable ex) {\n        }\n        \n        return name;\n    }\n",
    "new_code_raw": "    public static String getObjectName(AssetFile asset, ObjectPath path) {\n        Deserializer deser = new Deserializer(asset);\n        String name = null;\n        \n        try {\n            UnityObject obj = deser.deserialize(path);\n            name = obj.getValue(\"m_Name\");\n        } catch (OutOfMemoryError ex) {\n            // Deserializer choked on an array size and clogged the heap, try\n            // to clean up this mess\n            deser = null;\n            System.gc();\n        } catch (Throwable ex) {\n        }\n        \n        return name;\n    }\n"
  },
  {
    "id": "apache_tuscany-sca-1.x-142-Associations-Param1",
    "old_comment_raw": "@param methods the methods to match against",
    "old_code_raw": "    public static Method findMethod(Operation<?> operation, Method[] methods) {\n        for (Method method : methods) {\n            if (match(operation, method)) {\n                return method;\n            }\n        }\n        return null;\n    }\n",
    "new_code_raw": "    public static <T> Method findMethod(Class<?> implClass, Operation<T> operation) throws NoSuchMethodException {\n        String name = operation.getName();\n        Class<?>[] paramTypes = getPhysicalTypes(operation);\n        return implClass.getMethod(name, paramTypes);\n    }\n\n"
  },
  {
    "id": "zaproxy_zaproxy-2001-Param-1",
    "old_comment_raw": "@param user the user to scan as, or null if the scan is done without the perspective of any user",
    "old_code_raw": "\tprivate int scanURL(String url, User user) throws ApiException {\n\t\tlog.debug(\"API Spider scanning url: \" + url);\n\n\t\tURI startURI;\n\t\ttry {\n\t\t\t// Try to build uri\n\t\t\tstartURI = new URI(url, true);\n\t\t} catch (URIException e) {\n\t\t\tthrow new ApiException(ApiException.Type.BAD_FORMAT);\n\t\t}\n\n\t\tSiteNode startNode = Model.getSingleton().getSession().getSiteTree().findNode(startURI);\n\t\tString scheme = startURI.getScheme();\n\t\tif (scheme == null || (!scheme.equalsIgnoreCase(\"http\") && !scheme.equalsIgnoreCase(\"https\"))) {\n\t\t\tthrow new ApiException(ApiException.Type.BAD_FORMAT);\n\t\t}\n\t\tTarget target = new Target(startNode);\n\t\ttarget.setRecurse(true);\n\t\treturn extension.startScan(target.getDisplayName(), target, user, null);\n\t}\n",
    "new_code_raw": "\tprivate int scanURL(String url, User user, int maxChildren) throws ApiException {\n\t\tlog.debug(\"API Spider scanning url: \" + url);\n\n\t\tURI startURI;\n\t\ttry {\n\t\t\t// Try to build uri\n\t\t\tstartURI = new URI(url, true);\n\t\t} catch (URIException e) {\n\t\t\tthrow new ApiException(ApiException.Type.BAD_FORMAT);\n\t\t}\n\n\t\tSiteNode startNode = Model.getSingleton().getSession().getSiteTree().findNode(startURI);\n\t\tString scheme = startURI.getScheme();\n\t\tif (scheme == null || (!scheme.equalsIgnoreCase(\"http\") && !scheme.equalsIgnoreCase(\"https\"))) {\n\t\t\tthrow new ApiException(ApiException.Type.BAD_FORMAT);\n\t\t}\n\t\tTarget target = new Target(startNode);\n\t\ttarget.setRecurse(true);\n\t\t\n\t\tObject[] objs = null;\n\t\tif (maxChildren > 0) {\n    \t\t// Add the filters to filter on maximum number of children\n    \t\tMaxChildrenFetchFilter maxChildrenFetchFilter = new MaxChildrenFetchFilter();\n    \t\tmaxChildrenFetchFilter.setMaxChildren(maxChildren);\n    \t\tmaxChildrenFetchFilter.setModel(extension.getModel());\n    \t\t\n    \t\tMaxChildrenParseFilter maxChildrenParseFilter = new MaxChildrenParseFilter();\n    \t\tmaxChildrenParseFilter.setMaxChildren(maxChildren);\n    \t\tmaxChildrenParseFilter.setModel(extension.getModel());\n\t\t\tobjs = new Object[] {\n\t\t\t\t\tmaxChildrenFetchFilter,\n\t\t\t\t\tmaxChildrenParseFilter\n\t\t\t};\n\t\t}\n\t\t\n\t\treturn extension.startScan(target.getDisplayName(), target, user, objs);\n\t}\n"
  },
  {
    "id": "frohoff_jdk6-56-Associations-Param0",
    "old_comment_raw": "@param element an int specifying an element in the path, where 0 is the first element in the path",
    "old_code_raw": "    public Object getPathComponent(int element) {\n        int          pathLength = getPathCount();\n\n        if(element < 0 || element >= pathLength)\n            throw new IllegalArgumentException(\"Index \" + element + \" is out of the specified range\");\n\n        TreePath         path = this;\n\n        for(int i = pathLength-1; i != element; i--) {\n           path = path.parentPath;\n        }\n        return path.lastPathComponent;\n    }\n",
    "new_code_raw": "    public Object getPathComponent(int index) {\n        int          pathLength = getPathCount();\n\n        if(index < 0 || index >= pathLength)\n            throw new IllegalArgumentException(\"Index \" + index +\n                                           \" is out of the specified range\");\n\n        TreePath         path = this;\n\n        for(int i = pathLength-1; i != index; i--) {\n            path = path.getParentPath();\n        }\n        return path.getLastPathComponent();\n    }\n\n"
  },
  {
    "id": "apache_drill-1290-Param-1",
    "old_comment_raw": "@param colProj implied projection type for the column",
    "old_code_raw": "  private ColumnState buildMap(ContainerState parent, ColumnReadProjection colProj) {\n    ColumnMetadata columnSchema = colProj.providedSchema();\n\n    // When dynamically adding columns, must add the (empty)\n    // map by itself, then add columns to the map via separate\n    // calls.\n\n    assert columnSchema.isMap();\n    assert columnSchema.tupleSchema().isEmpty();\n\n    // Create the vector, vector state and writer.\n\n    if (columnSchema.isArray()) {\n      return buildMapArray(parent, colProj);\n    } else {\n      return buildSingleMap(parent, colProj);\n    }\n  }\n",
    "new_code_raw": "  private ColumnState buildMap(ContainerState parent, ColumnMetadata columnSchema) {\n\n    // When dynamically adding columns, must add the (empty)\n    // map by itself, then add columns to the map via separate\n    // calls.\n    assert columnSchema.isMap();\n    assert columnSchema.tupleSchema().isEmpty();\n\n    // Create the vector, vector state and writer.\n    if (columnSchema.isArray()) {\n      return buildMapArray(parent, columnSchema);\n    } else {\n      return buildSingleMap(parent, columnSchema);\n    }\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-423-Param-0",
    "old_comment_raw": "@param millis milliseconds from 1970-01-01T00:00:00Z to get the name for",
    "old_code_raw": "    public String getShortName(long millis, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(millis);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getShortName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return offsetFormatter().print(millis, this);\n    }\n",
    "new_code_raw": "    public String getShortName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getShortName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return offsetFormatter().print(instant, this);\n    }\n"
  },
  {
    "id": "SeleniumHQ_selenium-178-Param-3",
    "old_comment_raw": "@param outputFile - The file to which we'll output the HTML results",
    "old_code_raw": "    private String runHTMLSuite(String browser, String browserURL, String suiteURL, File outputFile, int timeoutInSeconds, boolean multiWindow, String defaultLogLevel) throws IOException {\n        outputFile.createNewFile();\n        if (!outputFile.canWrite()) {\n        \tthrow new IOException(\"Can't write to outputFile: \" + outputFile.getAbsolutePath());\n        }\n    \tlong timeoutInMs = 1000l * timeoutInSeconds;\n        if (timeoutInMs < 0) {\n            log.warn(\"Looks like the timeout overflowed, so resetting it to the maximum.\");\n            timeoutInMs = Long.MAX_VALUE;\n        }\n        \n        RemoteControlConfiguration configuration = remoteControl.getConfiguration();\n        remoteControl.handleHTMLRunnerResults(this);\n\n        String sessionId = Long.toString(System.currentTimeMillis() % 1000000);\n        FrameGroupCommandQueueSet.makeQueueSet(\n                sessionId, configuration.getPortDriversShouldContact(), configuration);\n\n        BrowserConfigurationOptions browserOptions = new BrowserConfigurationOptions();\n        \n        configuration.copySettingsIntoBrowserOptions(browserOptions);\n        \n        browserOptions.setSingleWindow(!multiWindow);\n        \n        BrowserLauncher launcher = getBrowserLauncher(browser, sessionId, configuration, browserOptions);\n        BrowserSessionInfo sessionInfo = new BrowserSessionInfo(sessionId, \n            browser, browserURL, launcher, null);\n        \n        remoteControl.registerBrowserSession(sessionInfo);\n        \n        // JB: -- aren't these URLs in the wrong order according to declaration?\n        launcher.launchHTMLSuite(suiteURL, browserURL);\n        \n        sleepTight(timeoutInMs);\n        \n        launcher.close();\n        \n        remoteControl.deregisterBrowserSession(sessionInfo);\n        \n        if (results == null) {\n            throw new SeleniumCommandTimedOutException();\n        }\n        \n        writeResults(outputFile);\n        \n        return results.getResult().toUpperCase();\n    }\n",
    "new_code_raw": "    private String runHTMLSuite(String browser, String browserURL, String suiteURL, File outputFile, long timeoutInSeconds, boolean multiWindow, String defaultLogLevel) throws IOException {\n        outputFile.createNewFile();\n        if (!outputFile.canWrite()) {\n        \tthrow new IOException(\"Can't write to outputFile: \" + outputFile.getAbsolutePath());\n        }\n    \tlong timeoutInMs = 1000l * timeoutInSeconds;\n        if (timeoutInMs < 0) {\n            log.warn(\"Looks like the timeout overflowed, so resetting it to the maximum.\");\n            timeoutInMs = Long.MAX_VALUE;\n        }\n        \n        RemoteControlConfiguration configuration = remoteControl.getConfiguration();\n        remoteControl.handleHTMLRunnerResults(this);\n\n        String sessionId = Long.toString(System.currentTimeMillis() % 1000000);\n        FrameGroupCommandQueueSet.makeQueueSet(\n                sessionId, configuration.getPortDriversShouldContact(), configuration);\n\n        BrowserConfigurationOptions browserOptions = new BrowserConfigurationOptions();\n        \n        configuration.copySettingsIntoBrowserOptions(browserOptions);\n        \n        browserOptions.setSingleWindow(!multiWindow);\n        \n        BrowserLauncher launcher = getBrowserLauncher(browser, sessionId, configuration, browserOptions);\n        BrowserSessionInfo sessionInfo = new BrowserSessionInfo(sessionId, \n            browser, browserURL, launcher, null);\n        \n        remoteControl.registerBrowserSession(sessionInfo);\n        \n        // JB: -- aren't these URLs in the wrong order according to declaration?\n        launcher.launchHTMLSuite(suiteURL, browserURL);\n        \n        sleepTight(timeoutInMs);\n        \n        launcher.close();\n        \n        remoteControl.deregisterBrowserSession(sessionInfo);\n        \n        if (results == null) {\n            throw new SeleniumCommandTimedOutException();\n        }\n        \n        writeResults(outputFile);\n        \n        return results.getResult().toUpperCase();\n    }\n"
  },
  {
    "id": "debezium_debezium-1198-Param-1",
    "old_comment_raw": "@param delimiter the delimiter between parts",
    "old_code_raw": "    public static TableId parse(String str, char delimiter, boolean useCatalogBeforeSchema) {\n        String[] parts = str.split(\"[\\\\\" + delimiter + \"]\");\n        if (parts.length == 0) return null;\n        if (parts.length == 1) return new TableId(null, null, parts[0]); // table only\n        if (parts.length == 2) {\n            if (useCatalogBeforeSchema) return new TableId(parts[0], null, parts[1]); // catalog & table only\n            return new TableId(null, parts[0], parts[1]); // catalog & table only\n        }\n        return new TableId(parts[0], parts[1], parts[2]); // catalog & table only\n    }\n",
    "new_code_raw": "    protected static TableId parse(String[] parts, int numParts, boolean useCatalogBeforeSchema) {\n        if (numParts == 0) return null;\n        if (numParts == 1) return new TableId(null, null, parts[0]); // table only\n        if (numParts == 2) {\n            if (useCatalogBeforeSchema) return new TableId(parts[0], null, parts[1]); // catalog & table only\n            return new TableId(null, parts[0], parts[1]); // catalog & table only\n        }\n        return new TableId(parts[0], parts[1], parts[2]); // catalog & table only\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-1183-Param-1",
    "old_comment_raw": "@param matches the number of matches expected to be found.  0 matches means that one or more matches are expected to be found",
    "old_code_raw": "\tpublic boolean searchButton(String search, int matches) {\n\t\tboolean found = searcher.searchButton(search, matches);\n\t\treturn found;\n\n\t}\n",
    "new_code_raw": "\tpublic boolean searchButton(String regex, int matches) {\n\t\tboolean found = searcher.searchButton(regex, matches);\n\t\treturn found;\n\n\t}\n"
  },
  {
    "id": "hazelcast_hazelcast-377-Associations-Param0",
    "old_comment_raw": "@param flag the flag to check",
    "old_code_raw": "    public boolean isFlagSet(int flag) {\n        return (flags & flag) != 0;\n    }\n",
    "new_code_raw": "    public boolean isFlagSet(int flagsToCheck) {\n        return (flags & flagsToCheck) != 0;\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-324-Param-6",
    "old_comment_raw": "@param accept The request's Accept header",
    "old_code_raw": "  public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n",
    "new_code_raw": "  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-2132-Param-0",
    "old_comment_raw": "@param instant instant from 1970-01-01T00:00:00 local time",
    "old_code_raw": "    private long localToUTC(long instant) {\n        DateTimeZone zone = getZone();\n        int offset = zone.getOffsetFromLocal(instant);\n        instant -= offset;\n        if (offset != zone.getOffset(instant)) {\n            throw new IllegalArgumentException\n                (\"Illegal instant due to time zone offset transition: \" +\n                    DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instant)));\n        }\n        return instant;\n    }\n",
    "new_code_raw": "    private long localToUTC(long localInstant) {\n        DateTimeZone zone = getZone();\n        int offset = zone.getOffsetFromLocal(localInstant);\n        localInstant -= offset;\n        if (offset != zone.getOffset(localInstant)) {\n            throw new IllegalInstantException(localInstant, zone.getID());\n        }\n        return localInstant;\n    }\n"
  },
  {
    "id": "SeleniumHQ_selenium-178-Param-5",
    "old_comment_raw": "@param defaultLogLevel TODO",
    "old_code_raw": "    private String runHTMLSuite(String browser, String browserURL, String suiteURL, File outputFile, int timeoutInSeconds, boolean multiWindow, String defaultLogLevel) throws IOException {\n        outputFile.createNewFile();\n        if (!outputFile.canWrite()) {\n        \tthrow new IOException(\"Can't write to outputFile: \" + outputFile.getAbsolutePath());\n        }\n    \tlong timeoutInMs = 1000l * timeoutInSeconds;\n        if (timeoutInMs < 0) {\n            log.warn(\"Looks like the timeout overflowed, so resetting it to the maximum.\");\n            timeoutInMs = Long.MAX_VALUE;\n        }\n        \n        RemoteControlConfiguration configuration = remoteControl.getConfiguration();\n        remoteControl.handleHTMLRunnerResults(this);\n\n        String sessionId = Long.toString(System.currentTimeMillis() % 1000000);\n        FrameGroupCommandQueueSet.makeQueueSet(\n                sessionId, configuration.getPortDriversShouldContact(), configuration);\n\n        BrowserConfigurationOptions browserOptions = new BrowserConfigurationOptions();\n        \n        configuration.copySettingsIntoBrowserOptions(browserOptions);\n        \n        browserOptions.setSingleWindow(!multiWindow);\n        \n        BrowserLauncher launcher = getBrowserLauncher(browser, sessionId, configuration, browserOptions);\n        BrowserSessionInfo sessionInfo = new BrowserSessionInfo(sessionId, \n            browser, browserURL, launcher, null);\n        \n        remoteControl.registerBrowserSession(sessionInfo);\n        \n        // JB: -- aren't these URLs in the wrong order according to declaration?\n        launcher.launchHTMLSuite(suiteURL, browserURL);\n        \n        sleepTight(timeoutInMs);\n        \n        launcher.close();\n        \n        remoteControl.deregisterBrowserSession(sessionInfo);\n        \n        if (results == null) {\n            throw new SeleniumCommandTimedOutException();\n        }\n        \n        writeResults(outputFile);\n        \n        return results.getResult().toUpperCase();\n    }\n",
    "new_code_raw": "    private String runHTMLSuite(String browser, String browserURL, String suiteURL, File outputFile, long timeoutInSeconds, boolean multiWindow, String defaultLogLevel) throws IOException {\n        outputFile.createNewFile();\n        if (!outputFile.canWrite()) {\n        \tthrow new IOException(\"Can't write to outputFile: \" + outputFile.getAbsolutePath());\n        }\n    \tlong timeoutInMs = 1000l * timeoutInSeconds;\n        if (timeoutInMs < 0) {\n            log.warn(\"Looks like the timeout overflowed, so resetting it to the maximum.\");\n            timeoutInMs = Long.MAX_VALUE;\n        }\n        \n        RemoteControlConfiguration configuration = remoteControl.getConfiguration();\n        remoteControl.handleHTMLRunnerResults(this);\n\n        String sessionId = Long.toString(System.currentTimeMillis() % 1000000);\n        FrameGroupCommandQueueSet.makeQueueSet(\n                sessionId, configuration.getPortDriversShouldContact(), configuration);\n\n        BrowserConfigurationOptions browserOptions = new BrowserConfigurationOptions();\n        \n        configuration.copySettingsIntoBrowserOptions(browserOptions);\n        \n        browserOptions.setSingleWindow(!multiWindow);\n        \n        BrowserLauncher launcher = getBrowserLauncher(browser, sessionId, configuration, browserOptions);\n        BrowserSessionInfo sessionInfo = new BrowserSessionInfo(sessionId, \n            browser, browserURL, launcher, null);\n        \n        remoteControl.registerBrowserSession(sessionInfo);\n        \n        // JB: -- aren't these URLs in the wrong order according to declaration?\n        launcher.launchHTMLSuite(suiteURL, browserURL);\n        \n        sleepTight(timeoutInMs);\n        \n        launcher.close();\n        \n        remoteControl.deregisterBrowserSession(sessionInfo);\n        \n        if (results == null) {\n            throw new SeleniumCommandTimedOutException();\n        }\n        \n        writeResults(outputFile);\n        \n        return results.getResult().toUpperCase();\n    }\n"
  },
  {
    "id": "Omegaphora_cts-166-Associations-Param0",
    "old_comment_raw": "@param requestRegions The input 3A regions",
    "old_code_raw": "    public static MeteringRectangle[] getExpectedOutputRegion(\n            MeteringRectangle[] requestRegions, Rect cropRect){\n        MeteringRectangle[] resultRegions = new MeteringRectangle[requestRegions.length];\n        for (int i = 0; i < requestRegions.length; i++) {\n            Rect requestRect = requestRegions[i].getRect();\n            Rect resultRect = new Rect();\n            assertTrue(\"Input 3A region must intersect cropped region\",\n                        resultRect.setIntersect(requestRect, cropRect));\n            resultRegions[i] = new MeteringRectangle(\n                    resultRect,\n                    requestRegions[i].getMeteringWeight());\n        }\n        return resultRegions;\n    }\n",
    "new_code_raw": "    public static int[] getExpectedOutputRegion(int[] requestRegion, Rect cropRect){\n        Rect requestRect = new Rect(requestRegion[0], requestRegion[1],\n                requestRegion[2], requestRegion[3]);\n        Rect resultRect = new Rect();\n        assertTrue(\"Input 3A region must intersect cropped region\",\n                    resultRect.setIntersect(requestRect, cropRect));\n        return new int[] {\n                resultRect.left,\n                resultRect.top,\n                resultRect.right,\n                resultRect.bottom,\n                requestRegion[4]};\n    }\n\n"
  },
  {
    "id": "apache_calcite-877-Param-1",
    "old_comment_raw": "@param rexBuilder Rex builder",
    "old_code_raw": "  public boolean isNormalized(boolean fail, RexBuilder rexBuilder) {\n    final RexProgram normalizedProgram =\n        RexProgramBuilder.normalize(rexBuilder, this);\n    String normalized = normalizedProgram.toString();\n    String string = toString();\n    if (!normalized.equals(string)) {\n      assert !fail\n          : \"Program is not normalized:\\n\"\n          + \"program:    \" + string + \"\\n\"\n          + \"normalized: \" + normalized + \"\\n\";\n      return false;\n    }\n    return true;\n  }\n",
    "new_code_raw": "  public boolean isNormalized(Litmus litmus, RexBuilder rexBuilder) {\n    final RexProgram normalizedProgram = normalize(rexBuilder, false);\n    String normalized = normalizedProgram.toString();\n    String string = toString();\n    if (!normalized.equals(string)) {\n      return litmus.fail(\"Program is not normalized:\\n\"\n          + \"program:    \" + string + \"\\n\"\n          + \"normalized: \" + normalized + \"\\n\");\n    }\n    return litmus.succeed();\n  }\n"
  },
  {
    "id": "processing_processing-261-Param-0",
    "old_comment_raw": "@param astGenerator",
    "old_code_raw": "  public boolean highlightNode(ASTGenerator astGenerator){\n    if (!(Node instanceof SimpleName)) {\n      return false;\n    }\n    SimpleName nodeName = (SimpleName) node;\n    try {\n      //TODO: Redundant code. See ASTGenerator.getJavaSourceCodeline()\n      int javaLineNumber = getLineNumber(nodeName);\n      int pdeOffs[] = astGenerator.errorCheckerService\n          .calculateTabIndexAndLineNumber(javaLineNumber);\n      PlainDocument javaSource = new PlainDocument();\n      javaSource.insertString(0, astGenerator.errorCheckerService.sourceCode, null);\n      Element lineElement = javaSource.getDefaultRootElement()\n          .getElement(javaLineNumber-1);\n      if(lineElement == null) {\n        Messages.log(lineNumber + \" line element null while highlighting \" + nodeName);\n        return false;\n      }\n\n      String javaLine = javaSource.getText(lineElement.getStartOffset(),\n                                           lineElement.getEndOffset()\n                                               - lineElement.getStartOffset());\n      astGenerator.editor.getSketch().setCurrentCode(pdeOffs[0]);\n      String pdeLine = astGenerator.editor.getLineText(pdeOffs[1]);\n      String lookingFor = nodeName.toString();\n      Messages.log(lookingFor + \", \" + nodeName.getStartPosition());\n      Messages.log(javaLineNumber +\" JL \" + javaLine + \" LSO \" + lineElement.getStartOffset() + \",\"\n          + lineElement.getEndOffset());\n      Messages.log(pdeOffs[1] + \" PL \" + pdeLine);\n      if (!javaLine.contains(lookingFor) || !pdeLine.contains(lookingFor)) {\n        Messages.loge(\"Logical error in highLightNode(). Please file a bug report.\");\n        return false;\n      }\n\n      OffsetMatcher ofm = new OffsetMatcher(pdeLine, javaLine);\n      int highlightStart = ofm.getPdeOffForJavaOff(nodeName.getStartPosition()\n                                  - lineElement.getStartOffset(),\n                              nodeName.getLength());\n      if (highlightStart == -1) {\n        Messages.loge(\"Logical error in highLightNode() during offset matching. \" +\n        \t\t\"Please file a bug report.\");\n        return false;\n      }\n      int lso = astGenerator.editor.getTextArea().getLineStartOffset(pdeOffs[1]);\n      highlightStart += lso;\n      astGenerator.editor.setSelection(highlightStart, highlightStart\n          + nodeName.getLength());\n      /*\n      // First find the name in the java line, and marks its index\n      Pattern toFind = Pattern.compile(\"\\\\b\" + nodeName.toString() + \"\\\\b\");\n      Matcher matcher = toFind.matcher(javaLine);\n      int count = 0, index = 0;\n      int lsto = lineElement.getStartOffset();\n      while(matcher.find()){\n        count++;\n        //log(matcher.start() + lsto);\n        if(lsto + matcher.start() == nodeName.getStartPosition())\n          break;\n      }\n      log(\"count=\" + count);\n      index = 0;\n      // find the same name in the pde line by its index and get its offsets\n      matcher = toFind.matcher(pdeLine);\n      while(matcher.find()){\n        count--;\n        if(count == 0){\n          log(\"Found on pde line lso: \" + matcher.start());\n          index = matcher.end();\n          break;\n        }\n      }\n      log(\"pde lso \" + (index - lookingFor.length()));\n\n      int lso = astGenerator.editor.ta.getLineStartOffset(pdeOffs[1]);\n      astGenerator.editor.setSelection(lso + index - lookingFor.length(), lso\n          + index);\n      */\n      return true;\n\n    } catch (BadLocationException e) {\n      Messages.loge(\"BLE in highLightNode() for \" + nodeName);\n      e.printStackTrace();\n    }\n    return false;\n  }\n",
    "new_code_raw": "  public boolean highlightNode(JavaEditor editor){\n    if (!(node instanceof SimpleName)) {\n      return false;\n    }\n    SimpleName nodeName = (SimpleName) node;\n    try {\n      //TODO: Redundant code. See ASTGenerator.getJavaSourceCodeline()\n      int javaLineNumber = getLineNumber(nodeName);\n      int pdeOffs[] = editor.getErrorChecker().calculateTabIndexAndLineNumber(javaLineNumber);\n      PlainDocument javaSource = new PlainDocument();\n      javaSource.insertString(0, editor.getErrorChecker().sourceCode, null);\n      Element lineElement = javaSource.getDefaultRootElement()\n          .getElement(javaLineNumber-1);\n      if(lineElement == null) {\n        Messages.log(lineNumber + \" line element null while highlighting \" + nodeName);\n        return false;\n      }\n\n      String javaLine = javaSource.getText(lineElement.getStartOffset(),\n                                           lineElement.getEndOffset()\n                                               - lineElement.getStartOffset());\n      editor.getSketch().setCurrentCode(pdeOffs[0]);\n      String pdeLine = editor.getLineText(pdeOffs[1]);\n      String lookingFor = nodeName.toString();\n      Messages.log(lookingFor + \", \" + nodeName.getStartPosition());\n      Messages.log(javaLineNumber +\" JL \" + javaLine + \" LSO \" + lineElement.getStartOffset() + \",\"\n          + lineElement.getEndOffset());\n      Messages.log(pdeOffs[1] + \" PL \" + pdeLine);\n      if (!javaLine.contains(lookingFor) || !pdeLine.contains(lookingFor)) {\n        Messages.loge(\"Logical error in highLightNode(). Please file a bug report.\");\n        return false;\n      }\n\n      OffsetMatcher ofm = new OffsetMatcher(pdeLine, javaLine);\n      int highlightStart = ofm.getPdeOffForJavaOff(nodeName.getStartPosition()\n                                  - lineElement.getStartOffset(),\n                              nodeName.getLength());\n      if (highlightStart == -1) {\n        Messages.loge(\"Logical error in highLightNode() during offset matching. \" +\n        \t\t\"Please file a bug report.\");\n        return false;\n      }\n      int lso = editor.getTextArea().getLineStartOffset(pdeOffs[1]);\n      highlightStart += lso;\n      editor.setSelection(highlightStart, highlightStart\n          + nodeName.getLength());\n      /*\n      // First find the name in the java line, and marks its index\n      Pattern toFind = Pattern.compile(\"\\\\b\" + nodeName.toString() + \"\\\\b\");\n      Matcher matcher = toFind.matcher(javaLine);\n      int count = 0, index = 0;\n      int lsto = lineElement.getStartOffset();\n      while(matcher.find()){\n        count++;\n        //log(matcher.start() + lsto);\n        if(lsto + matcher.start() == nodeName.getStartPosition())\n          break;\n      }\n      log(\"count=\" + count);\n      index = 0;\n      // find the same name in the pde line by its index and get its offsets\n      matcher = toFind.matcher(pdeLine);\n      while(matcher.find()){\n        count--;\n        if(count == 0){\n          log(\"Found on pde line lso: \" + matcher.start());\n          index = matcher.end();\n          break;\n        }\n      }\n      log(\"pde lso \" + (index - lookingFor.length()));\n\n      int lso = astGenerator.editor.ta.getLineStartOffset(pdeOffs[1]);\n      astGenerator.editor.setSelection(lso + index - lookingFor.length(), lso\n          + index);\n      */\n      return true;\n\n    } catch (BadLocationException e) {\n      Messages.loge(\"BLE in highLightNode() for \" + nodeName);\n      e.printStackTrace();\n    }\n    return false;\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1785-Param-0",
    "old_comment_raw": "@param session The session from which the request is originating.",
    "old_code_raw": "\tprivate CollectionPersister getPersister(SessionImplementor session) {\n\t\treturn session.getFactory().getCollectionPersister( role );\n\t}\n",
    "new_code_raw": "\tprivate CollectionPersister getPersister(SharedSessionContractImplementor session) {\n\t\treturn session.getFactory().getMetamodel().collectionPersister( role );\n\t}\n"
  },
  {
    "id": "RobotiumTech_robotium-1006-Param-0",
    "old_comment_raw": "@param regex the text to search for. The parameter will be interpreted as a regular expression.",
    "old_code_raw": "\tpublic boolean searchText(String regex) {\n\t\tboolean found = searcher.searchWithTimeoutFor(TextView.class, regex, 0, true);\n\t\treturn found;\n\t}\n",
    "new_code_raw": "\tpublic boolean searchText(String text) {\n\t\tboolean found = searcher.searchWithTimeoutFor(TextView.class, search, 0, true);\n\t\treturn found;\n\t}\n"
  },
  {
    "id": "RobotiumTech_robotium-1450-Param-0",
    "old_comment_raw": "@param by the By object e.g. By.id(\"id\");",
    "old_code_raw": "\tprivate boolean executeJavaScript(final By by){\n\t\tif(by instanceof By.Id){\n\t\t\treturn executeJavaScriptFunction(\"id(\\\"\"+by.getValue()+\"\\\");\");\n\t\t}\n\t\telse if(by instanceof By.Xpath){\n\t\t\treturn executeJavaScriptFunction(\"xpath(\\\"\"+by.getValue()+\"\\\");\");\n\t\t}\n\t\telse if(by instanceof By.CssSelector){\n\t\t\treturn executeJavaScriptFunction(\"cssSelector(\\\"\"+by.getValue()+\"\\\");\");\n\t\t}\n\t\telse if(by instanceof By.Name){\n\t\t\treturn executeJavaScriptFunction(\"name(\\\"\"+by.getValue()+\"\\\");\");\n\t\t}\n\t\telse if(by instanceof By.ClassName){\n\t\t\treturn executeJavaScriptFunction(\"className(\\\"\"+by.getValue()+\"\\\");\");\n\t\t}\n\t\telse if(by instanceof By.Text){\n\t\t\treturn executeJavaScriptFunction(\"textContent(\\\"\"+by.getValue()+\"\\\");\");\n\t\t}\n\t\telse if(by instanceof By.TagName){\n\t\t\treturn executeJavaScriptFunction(\"tagName(\\\"\"+by.getValue()+\"\\\");\");\n\t\t}\n\t\treturn false;\n\t}\n",
    "new_code_raw": "\tpublic boolean executeJavaScript(final By by, boolean click){\n\t\tif(by instanceof By.Id){\n\t\t\treturn executeJavaScriptFunction(\"id(\\\"\"+by.getValue()+\"\\\", \\\"\" + String.valueOf(click) + \"\\\");\");\n\t\t}\n\t\telse if(by instanceof By.Xpath){\n\t\t\treturn executeJavaScriptFunction(\"xpath(\\\"\"+by.getValue()+\"\\\", \\\"\" + String.valueOf(click) + \"\\\");\");\n\t\t}\n\t\telse if(by instanceof By.CssSelector){\n\t\t\treturn executeJavaScriptFunction(\"cssSelector(\\\"\"+by.getValue()+\"\\\", \\\"\" + String.valueOf(click) + \"\\\");\");\n\t\t}\n\t\telse if(by instanceof By.Name){\n\t\t\treturn executeJavaScriptFunction(\"name(\\\"\"+by.getValue()+\"\\\", \\\"\" + String.valueOf(click) + \"\\\");\");\n\t\t}\n\t\telse if(by instanceof By.ClassName){\n\t\t\treturn executeJavaScriptFunction(\"className(\\\"\"+by.getValue()+\"\\\", \\\"\" + String.valueOf(click) + \"\\\");\");\n\t\t}\n\t\telse if(by instanceof By.Text){\n\t\t\treturn executeJavaScriptFunction(\"textContent(\\\"\"+by.getValue()+\"\\\", \\\"\" + String.valueOf(click) + \"\\\");\");\n\t\t}\n\t\telse if(by instanceof By.TagName){\n\t\t\treturn executeJavaScriptFunction(\"tagName(\\\"\"+by.getValue()+\"\\\", \\\"\" + String.valueOf(click) + \"\\\");\");\n\t\t}\n\t\treturn false;\n\t}\n"
  },
  {
    "id": "JodaOrg_joda_time-433-Param-0",
    "old_comment_raw": "@param millis the time instant in millis to query.",
    "old_code_raw": "    public int get(long millis) {\n        int year = iChronology.year().get(millis);\n        //\n        long firstWeekMillis1 = iChronology.getFirstWeekOfYearMillis(year);\n        if (millis < firstWeekMillis1) {\n            return iChronology.getWeeksInYear(year - 1);\n        }\n        long firstWeekMillis2 = iChronology.getFirstWeekOfYearMillis(year + 1);\n        if (millis >= firstWeekMillis2) {\n            return 1;\n        }\n        return (int) ((millis - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1;\n    }\n",
    "new_code_raw": "    public int get(long instant) {\n        int year = iChronology.year().get(instant);\n        //\n        long firstWeekMillis1 = iChronology.getFirstWeekOfYearMillis(year);\n        if (instant < firstWeekMillis1) {\n            return iChronology.getWeeksInYear(year - 1);\n        }\n        long firstWeekMillis2 = iChronology.getFirstWeekOfYearMillis(year + 1);\n        if (instant >= firstWeekMillis2) {\n            return 1;\n        }\n        return (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1;\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-347-Param-2",
    "old_comment_raw": "@param queryParams The query parameters",
    "old_code_raw": "  public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getStatusInfo() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getStatusInfo().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getStatusInfo().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n",
    "new_code_raw": "  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2359-Param-0",
    "old_comment_raw": "@param t Target for finding dependents of t related by this GR",
    "old_code_raw": "  public Collection<TreeGraphNode> getRelatedNodes(TreeGraphNode t, TreeGraphNode root, HeadFinder headFinder) {\n    Set<TreeGraphNode> nodeList = new ArraySet<TreeGraphNode>();\n    for (TregexPattern p : targetPatterns) {    // cdm: I deleted: && nodeList.isEmpty()\n      // Initialize the TregexMatcher with the HeadFinder so that we\n      // can use the same HeadFinder through the entire process of\n      // building the dependencies\n      TregexMatcher m = p.matcher(root, headFinder);\n      while (m.findAt(t)) {\n        TreeGraphNode target = (TreeGraphNode) m.getNode(\"target\");\n        if (target == null) {\n          throw new AssertionError(\"Expression has no target: \" + p);\n        }\n        nodeList.add(target);\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \"-\" + t.headWordNode() + \", \" + m.getNode(\"target\") + \"-\" + ((TreeGraphNode) m.getNode(\"target\")).headWordNode() + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\"))\n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n",
    "new_code_raw": "  public Collection<Tree> getRelatedNodes(Tree t, Tree root) {\n    if (root.value() == null) {\n      root.setValue(\"ROOT\");  // todo: cdm: it doesn't seem like this line should be here\n    }\n    Set<Tree> nodeList = new LinkedHashSet<Tree>();\n    for (TregexPattern p : targetPatterns) {    // cdm: I deleted: && nodeList.isEmpty()\n      TregexMatcher m = p.matcher(root);\n      while (m.findAt(t)) {\n        nodeList.add(m.getNode(\"target\"));\n        //System.out.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p);\n      }\n    }\n    return nodeList;\n  }\n"
  },
  {
    "id": "graphql_java_graphql_java-274-Param-0",
    "old_comment_raw": "@param rootParentType the root parent type",
    "old_code_raw": "        public Builder rootParentType(GraphQLObjectType rootParentType) {\n            this.rootParentType = rootParentType;\n            return this;\n        }\n",
    "new_code_raw": "        public Builder rootParentType(GraphQLCompositeType rootParentType) {\n            this.rootParentType = rootParentType;\n            return this;\n        }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1942-Param-1",
    "old_comment_raw": "@param clazz the annotation class to check for",
    "old_code_raw": "\tpublic static AnnotationMirror getAnnotationMirror(Element element, Class<? extends Annotation> clazz) {\n\t\tassert element != null;\n\t\tassert clazz != null;\n\n\t\tAnnotationMirror mirror = null;\n\t\tfor ( AnnotationMirror am : element.getAnnotationMirrors() ) {\n\t\t\tif ( isAnnotationMirrorOfType( am, clazz ) ) {\n\t\t\t\tmirror = am;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn mirror;\n\t}\n",
    "new_code_raw": "\tpublic static AnnotationMirror getAnnotationMirror(Element element, String fqcn) {\n\t\tassert element != null;\n\t\tassert fqcn != null;\n\n\t\tAnnotationMirror mirror = null;\n\t\tfor ( AnnotationMirror am : element.getAnnotationMirrors() ) {\n\t\t\tif ( isAnnotationMirrorOfType( am, fqcn ) ) {\n\t\t\t\tmirror = am;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn mirror;\n\t}\n"
  },
  {
    "id": "hibernate_hibernate_orm-1211-Param-0",
    "old_comment_raw": "@param session The session from which the request is originating.",
    "old_code_raw": "\tpublic Object nullSafeGet(ResultSet rs, String name, SessionImplementor session, Object owner) throws SQLException {\n\t\treturn nullSafeGet( rs, new String[] { name }, session, owner );\n\t}\n",
    "new_code_raw": "\tpublic Object nullSafeGet(ResultSet rs, String name, SharedSessionContractImplementor session, Object owner) throws SQLException {\n\t\treturn nullSafeGet( rs, new String[] { name }, session, owner );\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1629-Param-0",
    "old_comment_raw": "@param body Created user object",
    "old_code_raw": "  public void  createUser (User body) throws ApiException {\n    Object localVarPostBody = body;\n    // verify the required parameter 'body' is set\n    if (body == null) {\n       throw new ApiException(400, \"Missing the required parameter 'body' when calling createUser\");\n    }\n\n    // create path and map variables\n    String localVarPath = \"/user\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> localVarFormParams = new HashMap<String, String>();\n\n\n\n    String[] localVarContentTypes = {\n      \n    };\n    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application/json\";\n\n    if (localVarContentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      \n\n      localVarPostBody = localVarBuilder.build();\n    } else {\n      // normal form params\n          }\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);\n      if(localVarResponse != null){\n        return ;\n      }\n      else {\n        return ;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n",
    "new_code_raw": "  public void  createUser (User user) throws ApiException {\n    Object localVarPostBody = user;\n    // verify the required parameter 'user' is set\n    if (user == null) {\n       throw new ApiException(400, \"Missing the required parameter 'user' when calling createUser\");\n    }\n\n    // create path and map variables\n    String localVarPath = \"/user\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> localVarFormParams = new HashMap<String, String>();\n\n\n\n    String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application/json\";\n\n    if (localVarContentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      \n\n      localVarPostBody = localVarBuilder.build();\n    } else {\n      // normal form params\n          }\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);\n      if(localVarResponse != null){\n        return ;\n      }\n      else {\n        return ;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n"
  },
  {
    "id": "MyCATApache_Mycat_Server-10-Param-0",
    "old_comment_raw": "@param sql",
    "old_code_raw": "\tpublic static String getTableName(String sql) {\n\t\tint pos = 0;\n\t\tboolean insertFound = false;\n\t\tboolean intoFound = false;\n\t\tint tableStartIndx = -1;\n\t\tint tableEndIndex = -1;\n\t\twhile (pos < sql.length()) {\n\t\t\tchar ch = sql.charAt(pos);\n\t\t\tif (ch <= ' ' || ch == '(' || ch=='`') {//\n\t\t\t\tif (tableStartIndx > 0) {\n\t\t\t\t\ttableEndIndex = pos;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tpos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (ch == 'i' || ch == 'I') {\n\t\t\t\tif (intoFound) {\n\t\t\t\t\tif (tableStartIndx == -1 && ch!='`') {\n\t\t\t\t\t\ttableStartIndx = pos;\n\t\t\t\t\t}\n\t\t\t\t\tpos++;\n\t\t\t\t} else if (insertFound) {// into start\n\t\t\t\t\tpos = pos + 5;\n\t\t\t\t\tintoFound = true;\n\t\t\t\t} else {\n\t\t\t\t\t// insert start\n\t\t\t\t\tpos = pos + 7;\n\t\t\t\t\tinsertFound = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (tableStartIndx == -1) {\n\t\t\t\t\ttableStartIndx = pos;\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\n\t\t}\n\t\treturn sql.substring(tableStartIndx, tableEndIndex);\n\t}\n",
    "new_code_raw": "\tpublic static String getTableName(String oriSql) {\n        //\u00e6\u00ad\u00a4\u00e5\u00a4\u0084\u00e5\u00ba\u0094\u00e8\u00af\u00a5\u00e4\u00bc\u0098\u00e5\u008c\u0096\u00e4\u00b8\u00ba\u00e5\u008e\u00bb\u00e6\u008e\u0089sql\u00e4\u00b8\u00ad\u00e7\u009a\u0084\u00e6\u00b3\u00a8\u00e9\u0087\u008a\u00ef\u00bc\u008c\u00e6\u0088\u0096\u00e5\u0085\u00bc\u00e5\u00ae\u00b9\u00e6\u00b3\u00a8\u00e9\u0087\u008a\n        String sql=null;\n        if(oriSql.startsWith(LoadData.loadDataHint))\n        {\n           sql=oriSql.substring(LoadData.loadDataHint.length()) ;\n        } else\n        {\n            sql=oriSql;\n        }\n\t\tint pos = 0;\n\t\tboolean insertFound = false;\n\t\tboolean intoFound = false;\n\t\tint tableStartIndx = -1;\n\t\tint tableEndIndex = -1;\n\t\twhile (pos < sql.length()) {\n\t\t\tchar ch = sql.charAt(pos);\n\t\t\tif (ch <= ' ' || ch == '(' || ch=='`') {//\n\t\t\t\tif (tableStartIndx > 0) {\n\t\t\t\t\ttableEndIndex = pos;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tpos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (ch == 'i' || ch == 'I') {\n\t\t\t\tif (intoFound) {\n\t\t\t\t\tif (tableStartIndx == -1 && ch!='`') {\n\t\t\t\t\t\ttableStartIndx = pos;\n\t\t\t\t\t}\n\t\t\t\t\tpos++;\n\t\t\t\t} else if (insertFound) {// into start\n\t\t\t\t\tpos = pos + 5;\n\t\t\t\t\tintoFound = true;\n\t\t\t\t} else {\n\t\t\t\t\t// insert start\n\t\t\t\t\tpos = pos + 7;\n\t\t\t\t\tinsertFound = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (tableStartIndx == -1) {\n\t\t\t\t\ttableStartIndx = pos;\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\n\t\t}\n\t\treturn sql.substring(tableStartIndx, tableEndIndex);\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1623-Param-2",
    "old_comment_raw": "@param allDefinitions a map of all Swagger models from the spec",
    "old_code_raw": "    public CodegenModel fromModel(String name, Model model, Map<String, Model> allDefinitions) {\n        CodegenModel codegenModel = super.fromModel(name, model, allDefinitions);\n        return codegenModel;\n    }\n",
    "new_code_raw": "    public CodegenModel fromModel(String name, Schema model, Map<String, Schema> allDefinitions) {\n        CodegenModel codegenModel = super.fromModel(name, model, allDefinitions);\n        return codegenModel;\n    }\n"
  },
  {
    "id": "zaproxy_zaproxy-2015-Param-3",
    "old_comment_raw": "@param b",
    "old_code_raw": "    private String algC(int m, int n, String a, String b) {\n        int i;\n        int j;\n        StringBuilder sb;\n\n        // Step 1\n        if (n == 0) {\n            sb = new StringBuilder();\n            \n        } else if (m == 1) {\n            sb = new StringBuilder();\n            for (j = 0; j < n; j++) {\n                if (a.charAt(0) == b.charAt(j)) {\n                    sb.append(a.charAt(0));\n                    break;\n                }\n            }\n\n        // Step 2\n        } else {\n            i = (int)Math.floor(((double) m) / 2);\n\n            // Step 3\n            int[] l1 = algB(i, n, a.substring(0, i), b);\n            int[] l2 = algB(m - i, n, reverseString(a.substring(i)), reverseString(b));\n\n            // Step 4\n            int k = findK(l1, l2, n);\n\n            // Step 5\n            sb = new StringBuilder(algC(i, k, a.substring(0, i), b.substring(0, k)));\n            sb.append(algC(m - i, n - k, a.substring(i), b.substring(k)));\n        }\n\n        // Return the LCS\n        return sb.toString();\n    }\n",
    "new_code_raw": "    private static void algC(StringBuilder sb, int m, int n, String a, String b) {\n        int i;\n        int j;\n\n        // Step 1\n        if (n == 0) {\n            // Nothing to do\n        } else if (m == 1) {\n            for (j = 0; j < n; j++) {\n                if (a.charAt(0) == b.charAt(j)) {\n                    sb.append(a.charAt(0));\n                    break;\n                }\n            }\n\n        // Step 2\n        } else {\n            i = (int)Math.floor(((double) m) / 2);\n\n            // Step 3\n            int[] l1 = algB(i, n, a.substring(0, i), b);\n            int[] l2 = algB(m - i, n, reverseString(a.substring(i)), reverseString(b));\n\n            // Step 4\n            int k = findK(l1, l2, n);\n\n            // Step 5\n            algC(sb, i, k, a.substring(0, i), b.substring(0, k));\n            algC(sb, m - i, n - k, a.substring(i), b.substring(k));\n        }\n    }\n"
  },
  {
    "id": "apache_qpid-jms-17-Associations-Param1",
    "old_comment_raw": "@param props",
    "old_code_raw": "    public static String addPropertiesToURI(URI uri, Map<String, String> props) throws Exception {\n        return addPropertiesToURI(uri.toString(), props);\n    }\n",
    "new_code_raw": "    public static String addPropertiesToURI(URI uri, Map<String, String> properties) throws Exception {\n        return addPropertiesToURI(uri.toString(), properties);\n    }\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2134-Param-2",
    "old_comment_raw": "@param  The type of the element we are getting.",
    "old_code_raw": "  public List<String> dependencyPathBetween(int start, int end, Function<Sentence, List<String>> selector) {\n    // Get paths from a node to the root of the sentence\n    LinkedList<Integer> rootToStart = new LinkedList<>();\n    LinkedList<Integer> rootToEnd = new LinkedList<>();\n    int startAncestor = start;\n    List<Optional<Integer>> governors = sentence.governors();\n    Set<Integer> seenVertices = new HashSet<>();\n    while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) {\n      if (seenVertices.contains(startAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(startAncestor);\n      rootToStart.addFirst(startAncestor);\n      startAncestor = governors.get(startAncestor).get();\n    }\n    if (startAncestor == -1) {\n      rootToStart.addFirst(-1);\n    }\n    int endAncestor = end;\n    seenVertices.clear();\n    while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) {\n      if (seenVertices.contains(endAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(endAncestor);\n      rootToEnd.addFirst(endAncestor);\n      endAncestor = governors.get(endAncestor).get();\n    }\n    if (endAncestor == -1) {\n      rootToEnd.addFirst(-1);\n    }\n\n    // Get least common node\n    int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0;\n    for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) {\n      if (rootToStart.get(i).equals(rootToEnd.get(i))) {\n        leastCommonNodeIndex = i;\n      }\n    }\n\n    // Construct the path\n    if (leastCommonNodeIndex < 0) {\n      return Collections.EMPTY_LIST;\n    }\n    List<String> path = new ArrayList<>();\n    for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) {\n      path.add(selector.apply(sentence).get(rootToStart.get(i)));\n      path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\");\n    }\n    path.add(selector.apply(sentence).get(rootToStart.get(leastCommonNodeIndex)));\n    for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) {\n      path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\");\n      path.add(selector.apply(sentence).get(rootToEnd.get(i)));\n    }\n    return path;\n  }\n",
    "new_code_raw": "  public List<String> dependencyPathBetween(int start, int end) {\n    // Get paths from a node to the root of the sentence\n    LinkedList<Integer> rootToStart = new LinkedList<>();\n    LinkedList<Integer> rootToEnd = new LinkedList<>();\n    int startAncestor = start;\n    while (sentence.governor(startAncestor).isPresent() && sentence.governor(startAncestor).get() >= 0) {\n      rootToStart.addFirst(startAncestor);\n      startAncestor = sentence.governor(startAncestor).get();\n    }\n    if (startAncestor == -1) {\n      rootToStart.addFirst(-1);\n    }\n    int endAncestor = start;\n    while (sentence.governor(endAncestor).isPresent() && sentence.governor(endAncestor).get() >= 0) {\n      rootToEnd.addFirst(endAncestor);\n      endAncestor = sentence.governor(endAncestor).get();\n    }\n    if (endAncestor == -1) {\n      rootToEnd.addFirst(-1);\n    }\n\n    // Get least common node\n    return null;   // TODO(gabor) write me!\n\n\n  }\n"
  },
  {
    "id": "apache_drill-1211-Param-0",
    "old_comment_raw": "@param childPath full absolute path",
    "old_code_raw": "  public static String relativize(String baseDir, String childPath) {\n    Path fullPathWithoutSchemeAndAuthority = Path.getPathWithoutSchemeAndAuthority(new Path(childPath));\n    Path basePathWithoutSchemeAndAuthority = Path.getPathWithoutSchemeAndAuthority(new Path(baseDir));\n\n    // Since hadoop Path hasn't relativize() we use uri.relativize() to get relative path\n    Path relativeFilePath = new Path(basePathWithoutSchemeAndAuthority.toUri()\n        .relativize(fullPathWithoutSchemeAndAuthority.toUri()));\n    if (relativeFilePath.isAbsolute()) {\n      throw new IllegalStateException(String.format(\"Path %s is not a subpath of %s.\",\n          basePathWithoutSchemeAndAuthority.toUri().getPath(), fullPathWithoutSchemeAndAuthority.toUri().getPath()));\n    }\n    return relativeFilePath.toUri().getPath();\n  }\n",
    "new_code_raw": "  public static Path relativize(Path baseDir, Path childPath) {\n    Path fullPathWithoutSchemeAndAuthority = Path.getPathWithoutSchemeAndAuthority(childPath);\n    Path basePathWithoutSchemeAndAuthority = Path.getPathWithoutSchemeAndAuthority(baseDir);\n\n    // Since hadoop Path hasn't relativize() we use uri.relativize() to get relative path\n    Path relativeFilePath = new Path(basePathWithoutSchemeAndAuthority.toUri()\n        .relativize(fullPathWithoutSchemeAndAuthority.toUri()));\n    if (relativeFilePath.isAbsolute()) {\n      throw new IllegalStateException(String.format(\"Path %s is not a subpath of %s.\",\n          basePathWithoutSchemeAndAuthority.toUri().getPath(), fullPathWithoutSchemeAndAuthority.toUri().getPath()));\n    }\n    return relativeFilePath;\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1666-Param-0",
    "old_comment_raw": "@param body Input boolean as post body (optional)",
    "old_code_raw": "  public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/boolean\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public Boolean fakeOuterBooleanSerialize(Boolean booleanPostBody) throws ApiException {\n    Object localVarPostBody = booleanPostBody;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/boolean\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"*/*\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "debezium_debezium-261-Param-0",
    "old_comment_raw": "@param schema of the encoded value",
    "old_code_raw": "    public static Struct fromLogical(Schema schema, DebeziumDecimal value) {\n        Struct result = new Struct(schema);\n        final BigDecimal decimalValue = value.getDecimalValue().orElse(null);\n        assert decimalValue != null : \"Unable to encode special value\";\n        result.put(VALUE_FIELD, decimalValue.unscaledValue().toByteArray());\n        result.put(SCALE_FIELD, decimalValue.scale());\n        return result;\n    }\n",
    "new_code_raw": "    public static Struct fromLogical(Schema schema, SpecialValueDecimal value) {\n        Struct result = new Struct(schema);\n        final BigDecimal decimalValue = value.getDecimalValue().orElse(null);\n        assert decimalValue != null : \"Unable to encode special value\";\n        result.put(VALUE_FIELD, decimalValue.unscaledValue().toByteArray());\n        result.put(SCALE_FIELD, decimalValue.scale());\n        return result;\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1973-Param-0",
    "old_comment_raw": "@param persister The persister for the entities being loaded.",
    "old_code_raw": "\tprivate boolean isCached(EntityKey entityKey, EntityPersister persister) {\n\t\tif ( persister.hasCache() ) {\n\t\t\tCacheKey key = context.getSession().generateCacheKey(\n\t\t\t\t\tentityKey.getIdentifier(),\n\t\t\t\t\tpersister.getIdentifierType(),\n\t\t\t\t\tentityKey.getEntityName()\n\t\t\t);\n\t\t\treturn persister.getCacheAccessStrategy().get( key, context.getSession().getTimestamp() ) != null;\n\t\t}\n\t\treturn false;\n\t}\n",
    "new_code_raw": "\tprivate boolean isCached(Serializable collectionKey, CollectionPersister persister) {\n\t\tif ( persister.hasCache() ) {\n\t\t\tCacheKey cacheKey = context.getSession().generateCacheKey(\n\t\t\t\t\tcollectionKey,\n\t\t\t        persister.getKeyType(),\n\t\t\t        persister.getRole()\n\t\t\t);\n\t\t\treturn persister.getCacheAccessStrategy().get( cacheKey, context.getSession().getTimestamp() ) != null;\n\t\t}\n\t\treturn false;\n\t}\n"
  },
  {
    "id": "runelite_runelite-25-Param-1",
    "old_comment_raw": "@param localLocation local location of the tile",
    "old_code_raw": "\tpublic static Point getMiniMapImageLocation(Client client, Point localLocation, BufferedImage image)\n\t{\n\t\tPoint p = Perspective.worldToMiniMap(client, localLocation.getX(), localLocation.getY());\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tint xOffset = p.getX() - image.getWidth() / 2;\n\t\tint yOffset = p.getY() - image.getHeight() / 2;\n\n\t\treturn new Point(xOffset, yOffset);\n\t}\n",
    "new_code_raw": "\tpublic static Point getMiniMapImageLocation(Client client, LocalPoint localLocation, BufferedImage image)\n\t{\n\t\tPoint p = Perspective.worldToMiniMap(client, localLocation.getX(), localLocation.getY());\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tint xOffset = p.getX() - image.getWidth() / 2;\n\t\tint yOffset = p.getY() - image.getHeight() / 2;\n\n\t\treturn new Point(xOffset, yOffset);\n\t}\n"
  },
  {
    "id": "android_platform_packages_providers_contactsprovider-70-Associations-Param0",
    "old_comment_raw": "@param values the values for the new row",
    "old_code_raw": "    private long insertData(ContentValues values, boolean callerIsSyncAdapter) {\n        long id = 0;\n        mValues.clear();\n        mValues.putAll(values);\n\n        Long rawContactId = mValues.getAsLong(Data.RAW_CONTACT_ID);\n        if (rawContactId == null) {\n            throw new IllegalArgumentException(Data.RAW_CONTACT_ID + \" is required\");\n        }\n\n        // Replace package with internal mapping.\n        final String packageName = mValues.getAsString(Data.RES_PACKAGE);\n        if (packageName != null) {\n            mValues.put(DataColumns.PACKAGE_ID, mDbHelper.get().getPackageId(packageName));\n        }\n        mValues.remove(Data.RES_PACKAGE);\n\n        // Replace mimetype with internal mapping.\n        final String mimeType = mValues.getAsString(Data.MIMETYPE);\n        if (TextUtils.isEmpty(mimeType)) {\n            throw new IllegalArgumentException(Data.MIMETYPE + \" is required\");\n        }\n\n        mValues.put(DataColumns.MIMETYPE_ID, mDbHelper.get().getMimeTypeId(mimeType));\n        mValues.remove(Data.MIMETYPE);\n\n        DataRowHandler rowHandler = getDataRowHandler(mimeType);\n        final SQLiteDatabase db = mDbHelper.get().getWritableDatabase();\n        id = rowHandler.insert(db, mTransactionContext.get(), rawContactId, mValues);\n        mTransactionContext.get().markRawContactDirtyAndChanged(rawContactId, callerIsSyncAdapter);\n        mTransactionContext.get().rawContactUpdated(rawContactId);\n        return id;\n    }\n",
    "new_code_raw": "    private long insertData(ContentValues inputValues, boolean callerIsSyncAdapter) {\n        final Long rawContactId = inputValues.getAsLong(Data.RAW_CONTACT_ID);\n        if (rawContactId == null) {\n            throw new IllegalArgumentException(Data.RAW_CONTACT_ID + \" is required\");\n        }\n\n        final String mimeType = inputValues.getAsString(Data.MIMETYPE);\n        if (TextUtils.isEmpty(mimeType)) {\n            throw new IllegalArgumentException(Data.MIMETYPE + \" is required\");\n        }\n\n        // The input seem valid, create a shallow copy.\n        final ContentValues values = new ContentValues(inputValues);\n\n        // Populate the relevant values before inserting the new entry into the database.\n        replacePackageNameByPackageId(values);\n\n        // Replace the mimetype by the corresponding mimetype ID.\n        values.put(DataColumns.MIMETYPE_ID, mDbHelper.get().getMimeTypeId(mimeType));\n        values.remove(Data.MIMETYPE);\n\n        // Insert the new entry.\n        final SQLiteDatabase db = mDbHelper.get().getWritableDatabase();\n        final TransactionContext context = mTransactionContext.get();\n        final long dataId = getDataRowHandler(mimeType).insert(db, context, rawContactId, values);\n        context.markRawContactDirtyAndChanged(rawContactId, callerIsSyncAdapter);\n        context.rawContactUpdated(rawContactId);\n\n        return dataId;\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1727-Param-4",
    "old_comment_raw": "@param body The request body object",
    "old_code_raw": "    public Call buildCall(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n        Request request = buildRequest(path, method, queryParams, collectionQueryParams, body, headerParams, formParams, authNames, progressRequestListener);\n\n        return httpClient.newCall(request);\n    }\n",
    "new_code_raw": "    public Call buildCall(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {\n        Request request = buildRequest(path, method, queryParams, collectionQueryParams, body, headerParams, formParams, authNames, callback);\n\n        return httpClient.newCall(request);\n    }\n"
  },
  {
    "id": "SeleniumHQ_selenium-827-Param-0",
    "old_comment_raw": "@param driver The driver to enhance",
    "old_code_raw": "  public WebDriver augment(WebDriver driver) {\n    // TODO(simon): We should really add a \"SelfDescribing\" interface for this\n    if (!(driver instanceof RemoteWebDriver)) {\n      return driver;\n    }\n\n    Map<String, ?> capabilities = ((RemoteWebDriver) driver).getCapabilities().asMap();\n\n    CompoundHandler handler = new CompoundHandler((RemoteWebDriver) driver);\n\n    for (Map.Entry<String, ?> capablityName : capabilities.entrySet()) {\n      AugmenterProvider augmenter = augmentors.get(capablityName.getKey());\n      if (augmenter == null) {\n        continue;\n      }\n\n      Object value = capablityName.getValue();\n      if (value instanceof Boolean && !((Boolean) value).booleanValue()) {\n        continue;\n      }\n\n      handler.addCapabilityHander(augmenter.getDescribedInterface(),\n          augmenter.getImplementation(value));\n    }\n\n    if (handler.isNeedingApplication()) {\n      // Gather the existing interfaces\n      Set<Class<?>> interfaces = new HashSet<Class<?>>();\n      interfaces.addAll(handler.getInterfaces());\n      interfaces.addAll(getInterfacesFrom(driver.getClass()));\n\n      Enhancer enhancer = new Enhancer();\n      enhancer.setInterfaces(interfaces.toArray(new Class<?>[interfaces.size()]));\n      enhancer.setCallback(handler);\n      enhancer.setSuperclass(driver.getClass());\n\n      RemoteWebDriver remote = (RemoteWebDriver) enhancer.create();\n      remote.setCommandExecutor(((RemoteWebDriver) driver).getCommandExecutor());\n      remote.setElementConverter(((RemoteWebDriver) driver).getElementConverter());\n      return remote;\n    }\n\n    return driver;\n  }\n",
    "new_code_raw": "  public WebElement augment(RemoteWebElement element) {\n    // TODO(simon): We should really add a \"SelfDescribing\" interface for this\n    RemoteWebDriver parent = (RemoteWebDriver) element.getWrappedDriver();\n    if (parent == null) {\n      return element;\n    }\n    Map<String, AugmenterProvider> augmentors = elementAugmentors;\n\n    CompoundHandler handler = determineAugmentation(parent, augmentors);\n    RemoteWebElement remote = create(handler, element);\n\n    remote.setId(element.getId());\n    remote.setParent(parent);\n\n    return remote;\n  }\n"
  },
  {
    "id": "apache_drill-768-Param-1",
    "old_comment_raw": "@param columnSchema metadata description of the list (must be empty of subtypes)",
    "old_code_raw": "  private ColumnState buildUnionList(ContainerState parent, ColumnTransform outputCol) {\n    ColumnMetadata columnSchema = outputCol.outputSchema();\n\n    // The variant must start out empty.\n\n    assert columnSchema.variantSchema().size() == 0;\n\n    // Create the union writer, bound to an empty list shim.\n\n    final UnionWriterImpl unionWriter = new UnionWriterImpl(columnSchema);\n    unionWriter.bindShim(new EmptyListShim());\n    final VariantObjectWriter unionObjWriter = new VariantObjectWriter(unionWriter);\n\n    // Create the list vector. Starts with the default (dummy) data\n    // vector which corresponds to the empty union shim above.\n    // Don't get the list vector from the vector cache. List vectors may\n    // have content that varies from batch to batch. Only the leaf\n    // vectors can be cached.\n\n    final ListVector listVector = new ListVector(columnSchema.schema(),\n        parent.loader().allocator(), null);\n\n    // Create the list vector state that tracks the list vector lifecycle.\n\n    final ListVectorState vectorState = new ListVectorState(unionWriter, listVector);\n\n    // Create the list writer: an array of unions.\n\n    final AbstractObjectWriter listWriter = new ArrayObjectWriter(\n        new ListWriterImpl(columnSchema, listVector, unionObjWriter));\n\n    // Create the manager for the columns within the list (which may or\n    // may not be grouped into a union.)\n\n    final ListState listState = new ListState(parent.loader(),\n        parent.vectorCache().childCache(columnSchema.name()),\n        ImpliedTupleRequest.ALL_MEMBERS);\n\n    // Bind the union state to the union writer to handle column additions.\n\n    unionWriter.bindListener(listState);\n\n    // Assemble it all into a union column state.\n\n    return new UnionColumnState(parent.loader(),\n        listWriter, vectorState, listState);\n  }\n",
    "new_code_raw": "  private ColumnState buildUnionList(ContainerState parent, ColumnReadProjection colProj) {\n    ColumnMetadata columnSchema = colProj.providedSchema();\n\n    // The variant must start out empty.\n\n    assert columnSchema.variantSchema().size() == 0;\n\n    // Create the union writer, bound to an empty list shim.\n\n    final UnionWriterImpl unionWriter = new UnionWriterImpl(columnSchema);\n    unionWriter.bindShim(new EmptyListShim());\n    final VariantObjectWriter unionObjWriter = new VariantObjectWriter(unionWriter);\n\n    // Create the list vector. Starts with the default (dummy) data\n    // vector which corresponds to the empty union shim above.\n    // Don't get the list vector from the vector cache. List vectors may\n    // have content that varies from batch to batch. Only the leaf\n    // vectors can be cached.\n\n    final ListVector listVector = new ListVector(columnSchema.schema(),\n        parent.loader().allocator(), null);\n\n    // Create the list vector state that tracks the list vector lifecycle.\n\n    final ListVectorState vectorState = new ListVectorState(unionWriter, listVector);\n\n    // Create the list writer: an array of unions.\n\n    final AbstractObjectWriter listWriter = new ArrayObjectWriter(\n        new ListWriterImpl(columnSchema, listVector, unionObjWriter));\n\n    // Create the manager for the columns within the list (which may or\n    // may not be grouped into a union.)\n\n    final ListState listState = new ListState(parent.loader(),\n        parent.vectorCache().childCache(columnSchema.name()));\n\n    // Bind the union state to the union writer to handle column additions.\n\n    unionWriter.bindListener(listState);\n\n    // Assemble it all into a union column state.\n\n    return new UnionColumnState(parent.loader(),\n        listWriter, vectorState, listState);\n  }\n"
  },
  {
    "id": "android_platform_packages_providers_contactsprovider-23-Associations-Param0",
    "old_comment_raw": "@param uri the ContentValues to read from and update",
    "old_code_raw": "    private boolean resolveAccount(Uri uri, ContentValues values) {\n        String accountName = getQueryParameter(uri, RawContacts.ACCOUNT_NAME);\n        String accountType = getQueryParameter(uri, RawContacts.ACCOUNT_TYPE);\n\n        if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(accountType)) {\n            accountName = null;\n            accountType = null;\n        }\n\n        String valueAccountName = values.getAsString(RawContacts.ACCOUNT_NAME);\n        String valueAccountType = values.getAsString(RawContacts.ACCOUNT_TYPE);\n\n        if (TextUtils.isEmpty(valueAccountName) && TextUtils.isEmpty(valueAccountType)) {\n            values.put(RawContacts.ACCOUNT_NAME, accountName);\n            values.put(RawContacts.ACCOUNT_TYPE, accountType);\n        } else {\n            if (accountName != null && !accountName.equals(valueAccountName)) {\n                return false;\n            }\n\n            if (accountType != null && !accountType.equals(valueAccountType)) {\n                return false;\n            }\n\n            accountName = valueAccountName;\n            accountType = valueAccountType;\n        }\n\n        if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(accountType)) {\n            mAccount = null;\n            return true;\n        }\n\n        if (mAccount == null\n                || !mAccount.name.equals(accountName)\n                || !mAccount.type.equals(accountType)) {\n            mAccount = new Account(accountName, accountType);\n        }\n\n        return true;\n    }\n",
    "new_code_raw": "    private boolean resolveAccount(ContentValues values, Account account) {\n        // If either is specified then both must be specified.\n        final String accountName = values.getAsString(RawContacts.ACCOUNT_NAME);\n        final String accountType = values.getAsString(RawContacts.ACCOUNT_TYPE);\n        if (!TextUtils.isEmpty(accountName) || !TextUtils.isEmpty(accountType)) {\n            final Account valuesAccount = new Account(accountName, accountType);\n            if (account != null && !valuesAccount.equals(account)) {\n                return false;\n            }\n            account = valuesAccount;\n        }\n        if (account != null) {\n            values.put(RawContacts.ACCOUNT_NAME, account.name);\n            values.put(RawContacts.ACCOUNT_TYPE, account.type);\n        }\n        return true;\n    }\n\n"
  },
  {
    "id": "debezium_debezium-719-Param-0",
    "old_comment_raw": "@param row the values of the row, in the same order as the columns in the  Table definition in the  MySqlSchema.",
    "old_code_raw": "        public int create(Object[] row, long ts) throws InterruptedException {\n            return create(row, ts, 0, 1);\n        }\n",
    "new_code_raw": "        public int create(Object[] row, Instant ts) throws InterruptedException {\n            return create(row, ts, 0, 1);\n        }\n"
  },
  {
    "id": "Omegaphora_dalvik-396-Associations-Param0",
    "old_comment_raw": "@param e the element to add",
    "old_code_raw": "    public boolean add(E e) {\n        return offer(e);\n    }\n",
    "new_code_raw": "    public boolean add(E o) {\n        return super.add(o);\n    }\n\n"
  },
  {
    "id": "apache_kylin-395-Param-0",
    "old_comment_raw": "@param path",
    "old_code_raw": "    private static File getKylinPropertiesFile(String path, String env) {\n        File dir = new File(path);\n        System.out.println(dir.getAbsolutePath());\n        if (dir.exists() && dir.isDirectory()) {\n            File propFile = new File(dir, KYLIN_CONF_PROPERTIES_FILE);\n            String fName = KYLIN_CONF_PROPERTIES_FILE;\n            File envPropFile = null;\n            if (env != null) {\n                fName = fName.replace(\".\", \"_\" + env + \".\");\n                envPropFile = new File(dir, fName);\n            }\n            if (envPropFile != null && envPropFile.exists()) {\n                logger.info(fName + \" found in \" + path);\n                return envPropFile;\n            }\n            if (propFile != null && propFile.exists()) {\n                logger.info(KYLIN_CONF_PROPERTIES_FILE + \" found in \" + path);\n                return propFile;\n            }\n        }\n        return null;\n    }\n",
    "new_code_raw": "    private static File getKylinPropertiesFile(String path) {\n        if (path == null)\n            return null;\n        \n        File propFile = new File(path, KYLIN_CONF_PROPERTIES_FILE);\n        if (propFile.exists()) {\n            logger.info(KYLIN_CONF_PROPERTIES_FILE + \" was found at \" + propFile.getAbsolutePath());\n        }\n        \n        logger.info(KYLIN_CONF_PROPERTIES_FILE + \" was NOT found at \" + propFile.getAbsolutePath());\n        return null;\n    }\n"
  },
  {
    "id": "SeleniumHQ_selenium-849-Param-1",
    "old_comment_raw": "@param frameAddress - frame from which the reply came",
    "old_code_raw": "    public SeleneseCommand handleCommandResult(String commandResult, FrameAddress frameAddress, String uniqueId) {\n        SeleneseQueue queue;\n        if (!SeleniumServer.isProxyInjectionMode()) {\n            queue = getSeleneseQueue();\n        }\n        else {\n            if (frameAddress.getWindowName().equals(SELENIUM_WINDOW_NAME_UNKNOWN_POPUP)) {\n                boolean foundFrameAddressOfUnknownPopup = false;\n                for (FrameAddress f : frameAddressToSeleneseQueue.keySet()) {\n                    // the situation being handled here: a pop-up window has either just loaded or reloaded, and therefore\n                    // doesn't know its name.  It uses SELENIUM_WINDOW_NAME_UNKNOWN_POPUP as a placeholder.\n                    // Meanwhile, on the selenium server-side, a thread is waiting for this result.\n                    //\n                    // To determine if this has happened, we cycle through all of the SeleneseQueue objects,\n                    // looking for ones with a matching local frame address (e.g., top.frames[1]), is also a\n                    // pop-up, and which has a thread waiting on a result.  If all of these conditions hold,\n                    // then we figure this queue is the one that we want:\n                    if (f.getLocalFrameAddress().equals(frameAddress.getLocalFrameAddress())\n                            && !f.getWindowName().equals(DEFAULT_SELENIUM_WINDOW_NAME)\n                            && frameAddressToSeleneseQueue.get(f).getCommandResultHolder().hasBlockedGetter()) {\n                        frameAddress = f;\n                        foundFrameAddressOfUnknownPopup = true;\n                        break;\n                    }\n                }\n                if (!foundFrameAddressOfUnknownPopup) {\n                    SeleniumServer.log(\"WARNING: unknown popup \" + frameAddress + \" was not resolved\");\n                }\n            }\n            queue = getSeleneseQueue(frameAddress);\n        }\n        queue.setUniqueId(uniqueId);\n        return queue.handleCommandResult(commandResult);\n    }\n",
    "new_code_raw": "    public SeleneseCommand handleCommandResult(String commandResult, FrameAddress incomingFrameAddress, String uniqueId) {\n        SeleneseQueue queue;\n        if (!SeleniumServer.isProxyInjectionMode()) {\n            queue = getSeleneseQueue();\n        }\n        else {\n            if (incomingFrameAddress.getWindowName().equals(SELENIUM_WINDOW_NAME_UNKNOWN_POPUP)) {\n                boolean foundFrameAddressOfUnknownPopup = false;\n                for (FrameAddress knownFrameAddress : frameAddressToSeleneseQueue.keySet()) {\n                    // the situation being handled here: a pop-up window has either just loaded or reloaded, and therefore\n                    // doesn't know its name.  It uses SELENIUM_WINDOW_NAME_UNKNOWN_POPUP as a placeholder.\n                    // Meanwhile, on the selenium server-side, a thread is waiting for this result.\n                    //\n                    // To determine if this has happened, we cycle through all of the SeleneseQueue objects,\n                    // looking for ones with a matching local frame address (e.g., top.frames[1]), is also a\n                    // pop-up, and which has a thread waiting on a result.  If all of these conditions hold,\n                    // then we figure this queue is the one that we want:\n                    if (knownFrameAddress.getLocalFrameAddress().equals(incomingFrameAddress.getLocalFrameAddress())\n                            && !knownFrameAddress.getWindowName().equals(DEFAULT_SELENIUM_WINDOW_NAME)\n                            && frameAddressToSeleneseQueue.get(knownFrameAddress).getCommandResultHolder().hasBlockedGetter()) {\n                        incomingFrameAddress = knownFrameAddress;\n                        foundFrameAddressOfUnknownPopup = true;\n                        break;\n                    }\n                }\n                if (!foundFrameAddressOfUnknownPopup) {\n                    SeleniumServer.log(\"WARNING: unknown popup \" + incomingFrameAddress + \" was not resolved\");\n                }\n            }\n            queue = getSeleneseQueue(incomingFrameAddress);\n        }\n        queue.setUniqueId(uniqueId);\n        return queue.handleCommandResult(commandResult);\n    }\n"
  },
  {
    "id": "runelite_runelite-23-Param-1",
    "old_comment_raw": "@param graphics",
    "old_code_raw": "\tpublic static Point getCanvasTextLocation(Client client, Graphics2D graphics, Point localLocation, String text, int zOffset)\n\t{\n\t\tint plane = client.getPlane();\n\n\t\tPoint p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset);\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tFontMetrics fm = graphics.getFontMetrics();\n\t\tRectangle2D bounds = fm.getStringBounds(text, graphics);\n\t\tint xOffset = p.getX() - (int) (bounds.getWidth() / 2);\n\n\t\treturn new Point(xOffset, p.getY());\n\t}\n",
    "new_code_raw": "\tpublic static Point getCanvasTextLocation(Client client, Graphics2D graphics, LocalPoint localLocation, String text, int zOffset)\n\t{\n\t\tint plane = client.getPlane();\n\n\t\tPoint p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset);\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tFontMetrics fm = graphics.getFontMetrics();\n\t\tRectangle2D bounds = fm.getStringBounds(text, graphics);\n\t\tint xOffset = p.getX() - (int) (bounds.getWidth() / 2);\n\n\t\treturn new Point(xOffset, p.getY());\n\t}\n"
  },
  {
    "id": "codehaus_cake-0-Associations-Param0",
    "old_comment_raw": "@param attributes an object containing an AttributeMap",
    "old_code_raw": "    public boolean get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n",
    "new_code_raw": "    public boolean get(WithAttributes withAttributes) {\r\n        return withAttributes.getAttributes().get(this);\r\n    }\r\n\n"
  },
  {
    "id": "apache_kylin-480-Param-0",
    "old_comment_raw": "@param tableName",
    "old_code_raw": "    public TableExtDesc getTableExt(String tableName, String prj) {\n        TableDesc t = getTableDesc(tableName, prj);\n        if (t == null)\n            return null;\n\n        TableExtDesc result = srcTableExtMap.get(mapKey(t.getIdentity(), t.getProject()));\n\n        // avoid returning null, since the TableDesc exists\n        if (null == result) {\n            result = new TableExtDesc();\n            result.setIdentity(t.getIdentity());\n            result.setUuid(UUID.randomUUID().toString());\n            result.setLastModified(0);\n            result.init(t.getProject());\n            srcTableExtMap.put(mapKey(t.getIdentity(), t.getProject()), result);\n        }\n        return result;\n    }\n",
    "new_code_raw": "    public TableExtDesc getTableExt(String tableName) {\n        if (tableName.indexOf(\".\") < 0)\n            tableName = \"DEFAULT.\" + tableName;\n\n        TableExtDesc result = srcTableExdMap.get(tableName.toUpperCase());\n\n        // create new\n        if (null == result) {\n            result = new TableExtDesc();\n            result.setName(tableName);\n            result.setUuid(UUID.randomUUID().toString());\n            result.setLastModified(0);\n            result.init();\n            srcTableExdMap.put(result.getName(), result);\n        }\n        return result;\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-431-Param-0",
    "old_comment_raw": "@param millis the time instant in millis to update.",
    "old_code_raw": "    public long add(long millis, int months) {\n        if (months == 0) {\n            return millis; // the easy case\n        }\n        //\n        // Save time part first.\n        //\n        long timePart = iChronology.millisOfDay().get(millis);\n        //\n        //\n        // Get this year and month.\n        //\n        int thisYear = iChronology.year().get(millis);\n        int thisMonth = iChronology.getMonthOfYear(millis, thisYear);\n        // ----------------------------------------------------------\n        //\n        // Do not refactor without careful consideration.\n        // Order of calculation is important.\n        //\n        int yearToUse;\n        // Initially, monthToUse is zero-based\n        int monthToUse = thisMonth - 1 + months;\n        if (monthToUse >= 0) {\n            yearToUse = thisYear + (monthToUse / MAX);\n            monthToUse = (monthToUse % MAX) + 1;\n        } else {\n            yearToUse = thisYear + (monthToUse / MAX) - 1;\n            monthToUse = Math.abs(monthToUse);\n            int remMonthToUse = monthToUse % MAX;\n            // Take care of the boundary condition\n            if (remMonthToUse == 0) {\n                remMonthToUse = MAX;\n            }\n            monthToUse = MAX - remMonthToUse + 1;\n            // Take care of the boundary condition\n            if (monthToUse == 1) {\n                yearToUse += 1;\n            }\n        }\n        // End of do not refactor.\n        // ----------------------------------------------------------\n\n        //\n        // Quietly force DOM to nearest sane value.\n        //\n        int dayToUse = iChronology.getDayOfMonth(millis, thisYear, thisMonth);\n        int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse);\n        if (dayToUse > maxDay) {\n            dayToUse = maxDay;\n        }\n        //\n        // get proper date part, and return result\n        //\n        long datePart =\n            iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse);\n        return datePart + timePart;\n    }\n",
    "new_code_raw": "    public long add(long instant, int months) {\n        if (months == 0) {\n            return instant; // the easy case\n        }\n        //\n        // Save time part first.\n        //\n        long timePart = iChronology.millisOfDay().get(instant);\n        //\n        //\n        // Get this year and month.\n        //\n        int thisYear = iChronology.year().get(instant);\n        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n        // ----------------------------------------------------------\n        //\n        // Do not refactor without careful consideration.\n        // Order of calculation is important.\n        //\n        int yearToUse;\n        // Initially, monthToUse is zero-based\n        int monthToUse = thisMonth - 1 + months;\n        if (monthToUse >= 0) {\n            yearToUse = thisYear + (monthToUse / MAX);\n            monthToUse = (monthToUse % MAX) + 1;\n        } else {\n            yearToUse = thisYear + (monthToUse / MAX) - 1;\n            monthToUse = Math.abs(monthToUse);\n            int remMonthToUse = monthToUse % MAX;\n            // Take care of the boundary condition\n            if (remMonthToUse == 0) {\n                remMonthToUse = MAX;\n            }\n            monthToUse = MAX - remMonthToUse + 1;\n            // Take care of the boundary condition\n            if (monthToUse == 1) {\n                yearToUse += 1;\n            }\n        }\n        // End of do not refactor.\n        // ----------------------------------------------------------\n\n        //\n        // Quietly force DOM to nearest sane value.\n        //\n        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);\n        int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse);\n        if (dayToUse > maxDay) {\n            dayToUse = maxDay;\n        }\n        //\n        // get proper date part, and return result\n        //\n        long datePart =\n            iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse);\n        return datePart + timePart;\n    }\n"
  },
  {
    "id": "apache_kylin-283-Param-1",
    "old_comment_raw": "@param sqlRequest",
    "old_code_raw": "    private SQLResponse execute(String correctedSql, SQLRequest sqlRequest, Connection conn) throws Exception {\n        Statement stat = null;\n        ResultSet resultSet = null;\n        Boolean isPushDown = false;\n\n        List<List<String>> results = Lists.newArrayList();\n        List<SelectedColumnMeta> columnMetas = Lists.newArrayList();\n\n        try {\n\n            // special case for prepare query. \n            if (BackdoorToggles.getPrepareOnly()) {\n                return getPrepareOnlySqlResponse(correctedSql, conn, isPushDown, results, columnMetas);\n            }\n\n            stat = conn.createStatement();\n            processStatementAttr(stat, sqlRequest);\n            resultSet = stat.executeQuery(correctedSql);\n\n            ResultSetMetaData metaData = resultSet.getMetaData();\n            int columnCount = metaData.getColumnCount();\n\n            // Fill in selected column meta\n            for (int i = 1; i <= columnCount; ++i) {\n                columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i),\n                        metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i),\n                        metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i),\n                        metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i),\n                        metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i),\n                        metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i),\n                        metaData.isDefinitelyWritable(i)));\n            }\n\n            // fill in results\n            while (resultSet.next()) {\n                List<String> oneRow = Lists.newArrayListWithCapacity(columnCount);\n                for (int i = 0; i < columnCount; i++) {\n                    oneRow.add((resultSet.getString(i + 1)));\n                }\n\n                results.add(oneRow);\n            }\n        } catch (SQLException sqlException) {\n            isPushDown = PushDownUtil.doPushDownQuery(sqlRequest.getProject(), correctedSql, conn.getSchema(), results,\n                    columnMetas, sqlException);\n            if (!isPushDown) {\n                throw sqlException;\n            }\n        } finally {\n            close(resultSet, stat, null);//conn is passed in, not my duty to close\n        }\n\n        return getSqlResponse(isPushDown, results, columnMetas);\n    }\n",
    "new_code_raw": "    private SQLResponse execute(String correctedSql, SQLRequest sqlRequest) throws Exception {\n        Connection conn = null;\n        Statement stat = null;\n        ResultSet resultSet = null;\n        Boolean isPushDown = false;\n\n        List<List<String>> results = Lists.newArrayList();\n        List<SelectedColumnMeta> columnMetas = Lists.newArrayList();\n\n        try {\n            conn = cacheService.getOLAPDataSource(sqlRequest.getProject()).getConnection();\n\n            // special case for prepare query. \n            if (BackdoorToggles.getPrepareOnly()) {\n                return getPrepareOnlySqlResponse(correctedSql, conn, isPushDown, results, columnMetas);\n            }\n\n            stat = conn.createStatement();\n            processStatementAttr(stat, sqlRequest);\n            resultSet = stat.executeQuery(correctedSql);\n\n            ResultSetMetaData metaData = resultSet.getMetaData();\n            int columnCount = metaData.getColumnCount();\n\n            // Fill in selected column meta\n            for (int i = 1; i <= columnCount; ++i) {\n                columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i),\n                        metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i),\n                        metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i),\n                        metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i),\n                        metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i),\n                        metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i),\n                        metaData.isDefinitelyWritable(i)));\n            }\n\n            // fill in results\n            while (resultSet.next()) {\n                List<String> oneRow = Lists.newArrayListWithCapacity(columnCount);\n                for (int i = 0; i < columnCount; i++) {\n                    oneRow.add((resultSet.getString(i + 1)));\n                }\n\n                results.add(oneRow);\n            }\n        } catch (SQLException sqlException) {\n            isPushDown = PushDownUtil.doPushDownQuery(sqlRequest.getProject(), correctedSql, results, columnMetas,\n                    sqlException);\n        } finally {\n            close(resultSet, stat, conn);\n        }\n\n        return getSqlResponse(isPushDown, results, columnMetas);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1694-Param-1",
    "old_comment_raw": "@param file file to upload (required)",
    "old_code_raw": "    public ApiResponse<ModelApiResponse> uploadFileWithRequiredFileWithHttpInfo(Long petId, File file, String additionalMetadata) throws ApiException {\n        com.squareup.okhttp.Call call = uploadFileWithRequiredFileValidateBeforeCall(petId, file, additionalMetadata, null, null);\n        Type localVarReturnType = new TypeToken<ModelApiResponse>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n",
    "new_code_raw": "    public ApiResponse<ModelApiResponse> uploadFileWithRequiredFileWithHttpInfo(Long petId, File requiredFile, String additionalMetadata) throws ApiException {\n        com.squareup.okhttp.Call call = uploadFileWithRequiredFileValidateBeforeCall(petId, requiredFile, additionalMetadata, null, null);\n        Type localVarReturnType = new TypeToken<ModelApiResponse>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n"
  },
  {
    "id": "dropwizard_dropwizard-142-Param-0",
    "old_comment_raw": "@param registry the SchemeRegistry",
    "old_code_raw": "    protected InstrumentedClientConnManager createConnectionManager(SchemeRegistry registry) {\n        final long ttl = configuration.getTimeToLive().toMilliseconds();\n        final InstrumentedClientConnManager manager =\n                new InstrumentedClientConnManager(Metrics.defaultRegistry(),\n                                                  registry,\n                                                  ttl,\n                                                  TimeUnit.MILLISECONDS,\n                                                  resolver);\n        manager.setDefaultMaxPerRoute(configuration.getMaxConnectionsPerRoute());\n        manager.setMaxTotal(configuration.getMaxConnections());\n        return manager;\n    }\n",
    "new_code_raw": "    protected InstrumentedClientConnManager createConnectionManager(SchemeRegistry registry, String name) {\n        final long ttl = configuration.getTimeToLive().toMilliseconds();\n        final InstrumentedClientConnManager manager =\n                new InstrumentedClientConnManager(metricRegistry,\n                                                  registry,\n                                                  ttl,\n                                                  TimeUnit.MILLISECONDS,\n                                                  resolver,\n                                                  name);\n        manager.setDefaultMaxPerRoute(configuration.getMaxConnectionsPerRoute());\n        manager.setMaxTotal(configuration.getMaxConnections());\n        return manager;\n    }\n"
  },
  {
    "id": "Atmosphere_atmosphere-824-Param-0",
    "old_comment_raw": "@param request the  HttpServletRequest",
    "old_code_raw": "    public Action suspended(HttpServletRequest request, HttpServletResponse response)\n            throws IOException, ServletException {\n        return action(request, response);\n    }\n",
    "new_code_raw": "    public Action suspended(AtmosphereRequest request, AtmosphereResponse response)\n            throws IOException, ServletException {\n        return action(request, response);\n    }\n"
  },
  {
    "id": "apache_drill-923-Param-0",
    "old_comment_raw": "@param bitNames array of (unique) Drillbit names",
    "old_code_raw": "  public ClusterFixtureBuilder withBits(String bitNames[]) {\n    this.bitNames = bitNames;\n    bitCount = bitNames.length;\n    return this;\n  }\n",
    "new_code_raw": "  public ClusterFixtureBuilder withBits(String...bitNames) {\n    this.bitNames = bitNames;\n    bitCount = bitNames.length;\n    return this;\n  }\n"
  },
  {
    "id": "apache_kylin-68-Associations-Param0",
    "old_comment_raw": "@param serverName the hostname of job server",
    "old_code_raw": "\n    private boolean isKeepLock(String serverName, String lockPath) {\n        try {\n            if (zkClient.checkExists().forPath(lockPath) != null) {\n                byte[] data = zkClient.getData().forPath(lockPath);\n                String lockServerName = new String(data, Charset.forName(\"UTF-8\"));\n                return lockServerName.equalsIgnoreCase(serverName);\n            }\n        } catch (Exception e) {\n            logger.error(\"fail to get the serverName for the path: \" + lockPath, e);\n        }\n        return false;\n    }\n",
    "new_code_raw": "\n    private boolean isKeepLock(String lockClient, String lockPath) {\n        try {\n            if (zkClient.checkExists().forPath(lockPath) != null) {\n                byte[] data = zkClient.getData().forPath(lockPath);\n                String lockServerName = new String(data, Charset.forName(\"UTF-8\"));\n                return lockServerName.equalsIgnoreCase(lockClient);\n            }\n        } catch (Exception e) {\n            logger.error(\"fail to get the lockClient for the path: \" + lockPath, e);\n        }\n        return false;\n    }\n\n"
  },
  {
    "id": "debezium_debezium-142-Param-2",
    "old_comment_raw": "@param source the information about the source where the update occurred; may be null",
    "old_code_raw": "    public Struct update(Struct before, Struct after, Struct source, Long timestamp) {\n        Struct struct = new Struct(schema);\n        struct.put(FieldName.OPERATION, Operation.UPDATE.code());\n        if (before != null) struct.put(FieldName.BEFORE, before);\n        struct.put(FieldName.AFTER, after);\n        if (source != null) struct.put(FieldName.SOURCE, source);\n        if (timestamp != null) struct.put(FieldName.TIMESTAMP, timestamp);\n        return struct;\n    }\n",
    "new_code_raw": "    public Struct update(Object before, Struct after, Struct source, Long timestamp) {\n        Struct struct = new Struct(schema);\n        struct.put(FieldName.OPERATION, Operation.UPDATE.code());\n        if (before != null) struct.put(FieldName.BEFORE, before);\n        struct.put(FieldName.AFTER, after);\n        if (source != null) struct.put(FieldName.SOURCE, source);\n        if (timestamp != null) struct.put(FieldName.TIMESTAMP, timestamp);\n        return struct;\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-177-Param-2",
    "old_comment_raw": "@param featureFactories The FeatureFactories to use to extract features",
    "old_code_raw": "  private double[] makeDatumUsingEmbedding(List<IN> info, int loc, List<FeatureFactory<IN>> featureFactories, PaddedList<IN> pInfo, List<String> featuresC, List<Clique> windowCliques) {\n    double[] featureValArr;\n    List<double[]> embeddingList = new ArrayList<double[]>();\n    int concatEmbeddingLen = 0;\n    String currentWord = null;\n    for (int currLoc = loc-2; currLoc <= loc+2; currLoc++) {\n      double[] embedding = null;\n      if (currLoc >=0 && currLoc < info.size()) {\n        currentWord = info.get(loc).get(CoreAnnotations.TextAnnotation.class);\n        String word = currentWord.toLowerCase();\n        word = word.replaceAll(\"(-)?\\\\d+(\\\\.\\\\d*)?\", \"0\");\n        if (embeddings.containsKey(word))\n          embedding = embeddings.get(word);\n        else\n          embedding = embeddings.get(\"UNKNOWN\");\n      } else {\n        embedding = embeddings.get(\"PADDING\");\n      }\n\n      for (int e = 0; e < embedding.length; e++) {\n        featuresC.add(\"EMBEDDING-(\" + (currLoc-loc) + \")-\" + e);\n      }\n\n      if (flags.addCapitalFeatures) {\n        int numOfCapitalFeatures = 4;\n        double[] newEmbedding = new double[embedding.length + numOfCapitalFeatures];\n        int currLen = embedding.length;\n        System.arraycopy(embedding, 0, newEmbedding, 0, currLen);\n        for (int e = 0; e < numOfCapitalFeatures; e++)\n          featuresC.add(\"CAPITAL-(\" + (currLoc-loc) + \")-\" + e);\n\n        if (currLoc >=0 && currLoc < info.size()) { // skip PADDING\n          // check if word is all caps\n          if (currentWord.toUpperCase().equals(currentWord))\n            newEmbedding[currLen] = 1;\n          else {\n            currLen += 1;\n            // check if word is all lower\n            if (currentWord.toLowerCase().equals(currentWord))\n              newEmbedding[currLen] = 1;\n            else {\n              currLen += 1;\n              // check first letter cap\n              if (Character.isUpperCase(currentWord.charAt(0)))\n                newEmbedding[currLen] = 1;\n              else {\n                currLen += 1;\n                // check if at least one non-initial letter is cap\n                String remainder = currentWord.substring(1);\n                if (!remainder.toLowerCase().equals(remainder))\n                  newEmbedding[currLen] = 1;\n              }\n            }\n          }\n        }\n        embedding = newEmbedding;\n      }\n\n      embeddingList.add(embedding);\n      concatEmbeddingLen += embedding.length;\n    }\n    double[] concatEmbedding = new double[concatEmbeddingLen];\n    int currPos = 0;\n    for (double[] em: embeddingList) {\n      System.arraycopy(em, 0, concatEmbedding, currPos, em.length);\n      currPos += em.length;\n    }\n\n    if (flags.prependEmbedding) {\n      int additionalFeatureCount = 0;\n      for (Clique c : windowCliques) {\n        for (FeatureFactory featureFactory : featureFactories) {\n          Collection<String> fCol = featureFactory.getCliqueFeatures(pInfo, loc, c); //todo useless copy because of typing reasons\n          featuresC.addAll(fCol);\n          additionalFeatureCount += fCol.size();\n        }\n      }\n      featureValArr = new double[concatEmbedding.length + additionalFeatureCount];\n      System.arraycopy(concatEmbedding, 0, featureValArr, 0, concatEmbedding.length);\n      Arrays.fill(featureValArr, concatEmbedding.length, featureValArr.length, 1.0);\n    } else {\n      featureValArr = concatEmbedding;\n    }\n\n    if (flags.addBiasToEmbedding) {\n      featuresC.add(\"BIAS-FEATURE\");\n      double[] newFeatureValArr = new double[featureValArr.length + 1];\n      System.arraycopy(featureValArr, 0, newFeatureValArr, 0, featureValArr.length);\n      newFeatureValArr[newFeatureValArr.length-1] = 1;\n      featureValArr = newFeatureValArr;\n    }\n    return featureValArr;\n  }\n",
    "new_code_raw": "  private double[] makeDatumUsingEmbedding(List<IN> info, int loc, FeatureFactory<IN> featureFactory, PaddedList<IN> pInfo, List<String> featuresC, List<Clique> windowCliques) {\n    double[] featureValArr;\n    List<double[]> embeddingList = new ArrayList<double[]>();\n    int concatEmbeddingLen = 0;\n    String currentWord = null;\n    for (int currLoc = loc-2; currLoc <= loc+2; currLoc++) {\n      double[] embedding = null;\n      if (currLoc >=0 && currLoc < info.size()) {\n        currentWord = info.get(loc).get(CoreAnnotations.TextAnnotation.class);\n        String word = currentWord.toLowerCase();\n        word = word.replaceAll(\"(-)?\\\\d+(\\\\.\\\\d*)?\", \"0\");\n        if (embeddings.containsKey(word))\n          embedding = embeddings.get(word);\n        else\n          embedding = embeddings.get(\"UNKNOWN\");\n      } else {\n        embedding = embeddings.get(\"PADDING\");\n      }\n\n      for (int e = 0; e < embedding.length; e++) {\n        featuresC.add(\"EMBEDDING-(\" + (currLoc-loc) + \")-\" + e);\n      }\n\n      if (flags.addCapitalFeatures) {\n        int numOfCapitalFeatures = 4;\n        double[] newEmbedding = new double[embedding.length + numOfCapitalFeatures];\n        int currLen = embedding.length;\n        System.arraycopy(embedding, 0, newEmbedding, 0, currLen);\n        for (int e = 0; e < numOfCapitalFeatures; e++)\n          featuresC.add(\"CAPITAL-(\" + (currLoc-loc) + \")-\" + e);\n\n        if (currLoc >=0 && currLoc < info.size()) { // skip PADDING\n          // check if word is all caps\n          if (currentWord.toUpperCase().equals(currentWord))\n            newEmbedding[currLen] = 1;\n          else {\n            currLen += 1;\n            // check if word is all lower\n            if (currentWord.toLowerCase().equals(currentWord))\n              newEmbedding[currLen] = 1;\n            else {\n              currLen += 1;\n              // check first letter cap\n              if (Character.isUpperCase(currentWord.charAt(0)))\n                newEmbedding[currLen] = 1;\n              else {\n                currLen += 1;\n                // check if at least one non-initial letter is cap\n                String remainder = currentWord.substring(1);\n                if (!remainder.toLowerCase().equals(remainder))\n                  newEmbedding[currLen] = 1;\n              }\n            }\n          }\n        }\n        embedding = newEmbedding;\n      }\n\n      embeddingList.add(embedding);\n      concatEmbeddingLen += embedding.length;\n    }\n    double[] concatEmbedding = new double[concatEmbeddingLen];\n    int currPos = 0;\n    for (double[] em: embeddingList) {\n      System.arraycopy(em, 0, concatEmbedding, currPos, em.length);\n      currPos += em.length;\n    }\n\n    if (flags.prependEmbedding) {\n      int additionalFeatureCount = 0;\n      for (Clique c : windowCliques) {\n        Collection<String> fCol = featureFactory.getCliqueFeatures(pInfo, loc, c); //todo useless copy because of typing reasons\n        featuresC.addAll(fCol);\n        additionalFeatureCount += fCol.size();\n      }\n      featureValArr = new double[concatEmbedding.length + additionalFeatureCount];\n      System.arraycopy(concatEmbedding, 0, featureValArr, 0, concatEmbedding.length);\n      Arrays.fill(featureValArr, concatEmbedding.length, featureValArr.length, 1.0);\n    } else {\n      featureValArr = concatEmbedding;\n    }\n\n    if (flags.addBiasToEmbedding) {\n      featuresC.add(\"BIAS-FEATURE\");\n      double[] newFeatureValArr = new double[featureValArr.length + 1];\n      System.arraycopy(featureValArr, 0, newFeatureValArr, 0, featureValArr.length);\n      newFeatureValArr[newFeatureValArr.length-1] = 1;\n      featureValArr = newFeatureValArr;\n    }\n    return featureValArr;\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1192-Param-2",
    "old_comment_raw": "@param session The originating session",
    "old_code_raw": "\tpublic static Object increment(Object version, VersionType versionType, SessionImplementor session) {\n\t\tfinal Object next = versionType.next( version, session );\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracef(\n\t\t\t\t\t\"Incrementing: %s to %s\",\n\t\t\t\t\tversionType.toLoggableString( version, session.getFactory() ),\n\t\t\t\t\tversionType.toLoggableString( next, session.getFactory() )\n\t\t\t);\n\t\t}\n\t\treturn next;\n\t}\n",
    "new_code_raw": "\tpublic static Object increment(Object version, VersionType versionType, SharedSessionContractImplementor session) {\n\t\tfinal Object next = versionType.next( version, session );\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracef(\n\t\t\t\t\t\"Incrementing: %s to %s\",\n\t\t\t\t\tversionType.toLoggableString( version, session.getFactory() ),\n\t\t\t\t\tversionType.toLoggableString( next, session.getFactory() )\n\t\t\t);\n\t\t}\n\t\treturn next;\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1669-Param-0",
    "old_comment_raw": "@param body client model (required)",
    "old_code_raw": "  public Client testClassname(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling testClassname\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake_classname_test\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"api_key_query\" };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public Client testClassname(Client client) throws ApiException {\n    Object localVarPostBody = client;\n    \n    // verify the required parameter 'client' is set\n    if (client == null) {\n      throw new ApiException(400, \"Missing the required parameter 'client' when calling testClassname\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake_classname_test\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"api_key_query\" };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "LawnchairLauncher_Lawnchair-52-Param-3",
    "old_comment_raw": "@param preview bitmap that can be recycled",
    "old_code_raw": "    private RectF drawBoxWithShadow(Canvas c, int width, int height) {\n        Resources res = mContext.getResources();\n\n        ShadowGenerator.Builder builder = new ShadowGenerator.Builder(Color.WHITE);\n        builder.shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);\n        builder.radius = res.getDimension(R.dimen.widget_preview_corner_radius);\n        builder.keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);\n\n        builder.bounds.set(builder.shadowBlur, builder.shadowBlur,\n                width - builder.shadowBlur,\n                height - builder.shadowBlur - builder.keyShadowDistance);\n        builder.drawShadow(c);\n        return builder.bounds;\n    }\n",
    "new_code_raw": "    private RectF drawBoxWithShadow(Canvas c, Paint p, int width, int height) {\n        Resources res = mContext.getResources();\n        float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);\n        float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);\n        float corner = res.getDimension(R.dimen.widget_preview_corner_radius);\n\n        RectF bounds = new RectF(shadowBlur, shadowBlur,\n                width - shadowBlur, height - shadowBlur - keyShadowDistance);\n        p.setColor(Color.WHITE);\n\n        // Key shadow\n        p.setShadowLayer(shadowBlur, 0, keyShadowDistance,\n                ShadowGenerator.KEY_SHADOW_ALPHA << 24);\n        c.drawRoundRect(bounds, corner, corner, p);\n\n        // Ambient shadow\n        p.setShadowLayer(shadowBlur, 0, 0,\n                ColorUtils.setAlphaComponent(Color.BLACK, ShadowGenerator.AMBIENT_SHADOW_ALPHA));\n        c.drawRoundRect(bounds, corner, corner, p);\n\n        p.clearShadowLayer();\n        return bounds;\n    }\n"
  },
  {
    "id": "Atmosphere_atmosphere-855-Param-1",
    "old_comment_raw": "@param res the  HttpServletResponse",
    "old_code_raw": "    public Action resumed(HttpServletRequest req, HttpServletResponse res)\n            throws IOException, ServletException {\n        if (logger.isLoggable(Level.FINE)) {\n            logger.fine(\"(resumed) invoked:\\n HttpServletRequest: \" + req\n                    + \"\\n HttpServletResponse: \" + res);\n        }\n        return action(req, res);\n    }\n",
    "new_code_raw": "    public Action resumed(HttpServletRequest request, HttpServletResponse response)\n            throws IOException, ServletException {\n        logger.debug(\"(resumed) invoked:\\n HttpServletRequest: {}\\n HttpServletResponse: {}\", request, response);\n        return action(request, response);\n    }\n"
  },
  {
    "id": "apache_activemq-605-Param-4",
    "old_comment_raw": "@param sub",
    "old_code_raw": "    public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name,int maxBatchSize, Subscription sub) {\n        return new VMPendingMessageCursor(AbstractPendingMessageCursor.isPrioritizedMessageSubscriber(broker, sub));\n    }\n",
    "new_code_raw": "    public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name,int maxBatchSize, DurableTopicSubscription sub) {\n        return new VMPendingMessageCursor(AbstractPendingMessageCursor.isPrioritizedMessageSubscriber(broker, sub));\n    }\n"
  },
  {
    "id": "lingochamp_FileDownloader-84-Param-0",
    "old_comment_raw": "@param downloadId The downloadId.",
    "old_code_raw": "    public byte getStatus(final int downloadId, final String path) {\n        byte status;\n        BaseDownloadTask.IRunningTask task = FileDownloadList.getImpl().get(downloadId);\n        if (task == null) {\n            status = FileDownloadServiceProxy.getImpl().getStatus(downloadId);\n        } else {\n            status = task.getOrigin().getStatus();\n        }\n\n        if (path != null && status == FileDownloadStatus.INVALID_STATUS) {\n            if (FileDownloadUtils.isFilenameConverted(FileDownloadHelper.getAppContext()) &&\n                    new File(path).exists()) {\n                status = FileDownloadStatus.completed;\n            }\n        }\n\n        return status;\n    }\n",
    "new_code_raw": "    public byte getStatus(final int id, final String path) {\n        byte status;\n        BaseDownloadTask.IRunningTask task = FileDownloadList.getImpl().get(id);\n        if (task == null) {\n            status = FileDownloadServiceProxy.getImpl().getStatus(id);\n        } else {\n            status = task.getOrigin().getStatus();\n        }\n\n        if (path != null && status == FileDownloadStatus.INVALID_STATUS) {\n            if (FileDownloadUtils.isFilenameConverted(FileDownloadHelper.getAppContext()) &&\n                    new File(path).exists()) {\n                status = FileDownloadStatus.completed;\n            }\n        }\n\n        return status;\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-649-Param-2",
    "old_comment_raw": "@param tableAlias The table alias to use in qualifying the join conditions",
    "old_code_raw": "\tpublic JoinSequence createJoinSequence(boolean implicit, AssociationType associationType, String tableAlias, int joinType, String[] columns) {\n\t\tJoinSequence joinSequence = createJoinSequence();\n\t\tjoinSequence.setUseThetaStyle( implicit );\t// Implicit joins use theta style (WHERE pk = fk), explicit joins use JOIN (after from)\n\t\tjoinSequence.addJoin( associationType, tableAlias, joinType, columns );\n\t\treturn joinSequence;\n\t}\n",
    "new_code_raw": "\tpublic JoinSequence createJoinSequence(boolean implicit, AssociationType associationType, String tableAlias, JoinType joinType, String[] columns) {\n\t\tJoinSequence joinSequence = createJoinSequence();\n\t\tjoinSequence.setUseThetaStyle( implicit );\t// Implicit joins use theta style (WHERE pk = fk), explicit joins use JOIN (after from)\n\t\tjoinSequence.addJoin( associationType, tableAlias, joinType, columns );\n\t\treturn joinSequence;\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1710-Param-0",
    "old_comment_raw": "@param client client model (required)",
    "old_code_raw": "  public Client call123testSpecialTags(Client client) throws ApiException {\n    Object localVarPostBody = client;\n    \n    // verify the required parameter 'client' is set\n    if (client == null) {\n      throw new ApiException(400, \"Missing the required parameter 'client' when calling call123testSpecialTags\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/another-fake/dummy\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public Client call123testSpecialTags(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling call123testSpecialTags\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/another-fake/dummy\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "apache_drill-828-Param-1",
    "old_comment_raw": "@param path path",
    "old_code_raw": "  public static ParquetTableMetadata_v4 getParquetTableMetadata(FileSystem fs, String path, ParquetReaderConfig readerConfig) throws IOException {\n    Metadata metadata = new Metadata(readerConfig);\n    return metadata.getParquetTableMetadata(path, fs);\n  }\n",
    "new_code_raw": "  public static ParquetTableMetadata_v4 getParquetTableMetadata(FileSystem fs, Path path, ParquetReaderConfig readerConfig) throws IOException {\n    Metadata metadata = new Metadata(readerConfig);\n    return metadata.getParquetTableMetadata(path, fs);\n  }\n"
  },
  {
    "id": "apache_deltaspike-18-Associations-Param0",
    "old_comment_raw": "@param repoClass The Repository class to lookup the method for",
    "old_code_raw": "    public RepositoryMethodMetadata lookupMethod(Class<?> repoClass, Method method)\r\n    {\r\n        return lookupComponent(repoClass).getMethodsMetadata().get(method);\r\n    }\r\n",
    "new_code_raw": "    public RepositoryMethodMetadata lookupMethod(RepositoryMetadata repositoryMetadata, Method method)\r\n    {\r\n        return repositoryMetadata.getMethodsMetadata().get(method);\r\n    }\r\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2219-Param-0",
    "old_comment_raw": "@param s Input date string",
    "old_code_raw": "  public static String normalizeDateString(String s, Date ctxdate) {\n    // TODO [pengqi]: need to handle basic localization (\"\u00e5\u009c\u00a8\u00e4\u00b8\u0083\u00e6\u009c\u0088\u00e4\u00ba\u008c\u00e6\u0097\u00a5\u00e5\u0088\u00b0[\u00e5\u0085\u00ab\u00e6\u0097\u00a5]\u00e9\u0097\u00b4\")\n    // TODO [pengqi]: need to handle literal numeral dates (usually used in events, e.g. \"\u00e4\u00b8\u0089\u00e4\u00b8\u0080\u00e4\u00ba\u0094\" for 03-15)\n    // TODO [pengqi]: might need to add a pattern for centuries (\"\u00e4\u00b8\u008a\u00e4\u00b8\u0096\u00e7\u00ba\u00aa90\u00e5\u00b9\u00b4\u00e4\u00bb\u00a3\")?\n    String ctxyear = new SimpleDateFormat(\"yyyy\").format(ctxdate);\n    String ctxmonth = new SimpleDateFormat(\"MM\").format(ctxdate);\n    String ctxday = new SimpleDateFormat(\"dd\").format(ctxdate);\n\n    Pattern p = Pattern.compile(\"^\" + BASIC_YYYYMMDD_PATTERN + \"$\");\n    Matcher m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 3) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(normalizeYear(m.group(1), ctxyear));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2), ctxmonth));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(3), ctxday));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + BASIC_MMDD_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 2) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(ctxyear);\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1), ctxmonth));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2), ctxday));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + BASIC_DD_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 1) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(ctxyear);\n      res.append(\"-\");\n      res.append(ctxmonth);\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1), ctxday));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + ENGLISH_MMDDYYYY_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 3) {\n      StringBuilder res = new StringBuilder();\n\n      if (m.group(3) == null)\n        res.append(ctxyear);\n      else\n        res.append(normalizeYear(m.group(3), ctxyear));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1), ctxmonth));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2), ctxday));\n\n      return res.toString();\n    }\n\n    return s;\n  }\n",
    "new_code_raw": "  public static String normalizeDateString(String s, String ctxdate) {\n    // TODO [pengqi]: need to handle basic localization (\"\u00e5\u009c\u00a8\u00e4\u00b8\u0083\u00e6\u009c\u0088\u00e4\u00ba\u008c\u00e6\u0097\u00a5\u00e5\u0088\u00b0[\u00e5\u0085\u00ab\u00e6\u0097\u00a5]\u00e9\u0097\u00b4\")\n    // TODO [pengqi]: need to handle literal numeral dates (usually used in events, e.g. \"\u00e4\u00b8\u0089\u00e4\u00b8\u0080\u00e4\u00ba\u0094\" for 03-15)\n    // TODO [pengqi]: might need to add a pattern for centuries (\"\u00e4\u00b8\u008a\u00e4\u00b8\u0096\u00e7\u00ba\u00aa90\u00e5\u00b9\u00b4\u00e4\u00bb\u00a3\")?\n\n    Pattern p;\n    Matcher m;\n    String ctxyear = \"XXXX\", ctxmonth = \"XX\", ctxday = \"XX\";\n\n    // set up context date\n    if (ctxdate != null) {\n      p = Pattern.compile(\"^\" + BASIC_YYYYMMDD_PATTERN + \"$\");\n      m = p.matcher(ctxdate);\n\n      if (m.find() && m.groupCount() == 3) {\n        ctxyear = m.group(1);\n        ctxmonth = m.group(2);\n        ctxday = m.group(3);\n      }\n    }\n\n    p = Pattern.compile(\"^\" + BIRTH_DECADE_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 1) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(normalizeYear(m.group(1), ctxyear, true).substring(0, 3) + \"X\");\n      res.append(\"-XX-XX\");\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + RELATIVE_TIME_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 1) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(ctxyear);\n      res.append(\"-\");\n      res.append(ctxmonth);\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1), ctxday));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + BASIC_YYYYMMDD_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 3) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(normalizeYear(m.group(1), ctxyear));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2), ctxmonth));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(3), ctxday));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + BASIC_MMDD_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 2) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(ctxyear);\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1), ctxmonth));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2), ctxday));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + BASIC_DD_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 1) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(ctxyear);\n      res.append(\"-\");\n      res.append(ctxmonth);\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1), ctxday));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + ENGLISH_MMDDYYYY_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 3) {\n      StringBuilder res = new StringBuilder();\n\n      if (m.group(3) == null)\n        res.append(ctxyear);\n      else\n        res.append(normalizeYear(m.group(3), ctxyear));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1), ctxmonth));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2), ctxday));\n\n      return res.toString();\n    }\n\n    return s;\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-458-Param-0",
    "old_comment_raw": "@param newDateTimeZone the new time zone",
    "old_code_raw": "    public DateTime withZone(DateTimeZone newDateTimeZone) {\n        return withChronology(getChronology().withZone(newDateTimeZone));\n    }\n",
    "new_code_raw": "    public DateTime withZone(DateTimeZone newZone) {\n        return withChronology(getChronology().withZone(newZone));\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-441-Param-3",
    "old_comment_raw": "@param body The request body object",
    "old_code_raw": "  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    final String url = buildUrl(path, queryParams);\n    final Request.Builder reqBuilder = new Request.Builder().url(url);\n    processHeaderParams(headerParams, reqBuilder);\n\n    String contentType = (String) headerParams.get(\"Content-Type\");\n    // ensuring a default content type\n    if (contentType == null) contentType = \"application/json\";\n\n    RequestBody reqBody;\n    if (!HttpMethod.permitsRequestBody(method)) {\n      reqBody = null;\n    } else if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n      reqBody = buildRequestBodyFormEncoding(formParams);\n    } else if (\"multipart/form-data\".equals(contentType)) {\n      reqBody = buildRequestBodyMultipart(formParams);\n    } else if (body == null) {\n      if (\"DELETE\".equals(method)) {\n        // allow calling DELETE without sending a request body\n        reqBody = null;\n      } else {\n        // use an empty request body (for POST, PUT and PATCH)\n        reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n      }\n    } else {\n      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));\n    }\n\n    Request request = reqBuilder.method(method, reqBody).build();\n    return httpClient.newCall(request);\n  }\n",
    "new_code_raw": "  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    final String url = buildUrl(path, queryParams);\n    final Request.Builder reqBuilder = new Request.Builder().url(url);\n    processHeaderParams(headerParams, reqBuilder);\n\n    String contentType = (String) headerParams.get(\"Content-Type\");\n    // ensuring a default content type\n    if (contentType == null) contentType = \"application/json\";\n\n    RequestBody reqBody;\n    if (!HttpMethod.permitsRequestBody(method)) {\n      reqBody = null;\n    } else if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n      reqBody = buildRequestBodyFormEncoding(formParams);\n    } else if (\"multipart/form-data\".equals(contentType)) {\n      reqBody = buildRequestBodyMultipart(formParams);\n    } else if (body == null) {\n      if (\"DELETE\".equals(method)) {\n        // allow calling DELETE without sending a request body\n        reqBody = null;\n      } else {\n        // use an empty request body (for POST, PUT and PATCH)\n        reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n      }\n    } else {\n      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));\n    }\n\n    Request request = null;\n\n    if(progressRequestListener != null) {\n      ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener);\n      request = reqBuilder.method(method, progressRequestBody).build();\n    } else {\n      request = reqBuilder.method(method, reqBody).build();\n    }\n\n    return httpClient.newCall(request);\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-298-Param-1",
    "old_comment_raw": "@param aliasedLockModes a map of lock modes indexed by aliased table names.",
    "old_code_raw": "\tpublic String applyLocksToSql(String sql, Map aliasedLockModes, Map keyColumnNames) {\n\t\treturn sql + new ForUpdateFragment( this, aliasedLockModes, keyColumnNames ).toFragmentString();\n\t}\n",
    "new_code_raw": "\tpublic String applyLocksToSql(String sql, Map aliasedLockOptions, Map keyColumnNames) {\n\t\treturn sql + new ForUpdateFragment( this, aliasedLockOptions, keyColumnNames ).toFragmentString();\n\t}\n"
  },
  {
    "id": "debezium_debezium-718-Param-2",
    "old_comment_raw": "@param rowNumber the number of this row; must be 0 or more",
    "old_code_raw": "        public int read(Object[] row, long ts, int rowNumber, int numberOfRows) throws InterruptedException {\n            return converter.read(source, row, rowNumber, numberOfRows, includedColumns, ts, consumer);\n        }\n",
    "new_code_raw": "        public int read(Object[] row, Instant ts, int rowNumber, int numberOfRows) throws InterruptedException {\n            return converter.read(source, row, rowNumber, numberOfRows, includedColumns, ts, consumer);\n        }\n"
  },
  {
    "id": "JodaOrg_joda_time-438-Param-0",
    "old_comment_raw": "@param millis the time instant in millis to update.",
    "old_code_raw": "    public long add(long millis, int years) {\n        if (years == 0) {\n            return millis;\n        }\n        int thisYear = get(millis);\n        int newYear = thisYear + years;\n        return set(millis, newYear);\n    }\n",
    "new_code_raw": "    public long add(long instant, int years) {\n        if (years == 0) {\n            return instant;\n        }\n        int thisYear = get(instant);\n        int newYear = thisYear + years;\n        return set(instant, newYear);\n    }\n"
  },
  {
    "id": "SeleniumHQ_selenium-180-Param-1",
    "old_comment_raw": "@param sessionId the sessionId to launch",
    "old_code_raw": "  public BrowserLauncher getBrowserLauncher(String browser, String sessionId, RemoteControlConfiguration configuration, BrowserConfigurationOptions browserOptions) {\n    if (browser == null) {\n      throw new IllegalArgumentException(\"browser may not be null\");\n    }\n    String executablePath = null;\n    if (browserOptions.hasOptions()) {\n      executablePath = BrowserOptions.getExecutablePath(browserOptions.asCapabilities());\n    } else {\n      configuration.copySettingsIntoBrowserOptions(browserOptions);\n    }\n\n    for (String key : supportedBrowsers.keySet()) {\n      final BrowserStringParser.Result result;\n      result = new BrowserStringParser().parseBrowserStartCommand(key, browser);\n      if (result.match()) {\n        if (executablePath == null) {\n          executablePath = result.customLauncher();\n          browserOptions.setExecutablePath(executablePath);\n        }\n        LOGGER.debug(\"Requested browser string '\" + browser + \"' matches *\" + key + \" \");\n        return createBrowserLauncher(supportedBrowsers.get(key), executablePath, sessionId,\n            configuration, browserOptions);\n      }\n    }\n\n    LOGGER.debug(\"Requested browser string '\" + browser\n                 + \"' does not match any known browser, treating it as a custom browser...\");\n    Matcher CustomMatcher = CUSTOM_PATTERN.matcher(browser);\n    if (CustomMatcher.find()) {\n      String browserStartCommand = CustomMatcher.group(1);\n      if (browserStartCommand == null) {\n        throw new RuntimeException(\n            \"You must specify the path to an executable when using *custom!\\n\\n\");\n      }\n      browserStartCommand = browserStartCommand.substring(1);\n      return new CustomBrowserLauncher(browserStartCommand, sessionId, configuration,\n          browserOptions);\n    }\n    throw browserNotSupported(browser);\n  }\n",
    "new_code_raw": "  public BrowserLauncher getBrowserLauncher(String browser, String sessionId, RemoteControlConfiguration configuration, Capabilities browserOptions) {\n    if (browser == null) {\n      throw new IllegalArgumentException(\"browser may not be null\");\n    }\n    String executablePath = null;\n    if (BrowserOptions.hasOptionsSet(browserOptions)) {\n      executablePath = BrowserOptions.getExecutablePath(browserOptions);\n    } else {\n      configuration.copySettingsIntoBrowserOptions(browserOptions);\n    }\n\n    for (String key : supportedBrowsers.keySet()) {\n      final BrowserStringParser.Result result;\n      result = new BrowserStringParser().parseBrowserStartCommand(key, browser);\n      if (result.match()) {\n        if (executablePath == null) {\n          executablePath = result.customLauncher();\n          browserOptions = BrowserOptions.setExecutablePath(browserOptions, executablePath);\n        }\n        LOGGER.debug(\"Requested browser string '\" + browser + \"' matches *\" + key + \" \");\n        return createBrowserLauncher(supportedBrowsers.get(key), executablePath, sessionId,\n            configuration, browserOptions);\n      }\n    }\n\n    LOGGER.debug(\"Requested browser string '\" + browser\n                 + \"' does not match any known browser, treating it as a custom browser...\");\n    Matcher CustomMatcher = CUSTOM_PATTERN.matcher(browser);\n    if (CustomMatcher.find()) {\n      String browserStartCommand = CustomMatcher.group(1);\n      if (browserStartCommand == null) {\n        throw new RuntimeException(\n            \"You must specify the path to an executable when using *custom!\\n\\n\");\n      }\n      browserStartCommand = browserStartCommand.substring(1);\n      return new CustomBrowserLauncher(browserStartCommand, sessionId, configuration,\n          browserOptions);\n    }\n    throw browserNotSupported(browser);\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1721-Param-0",
    "old_comment_raw": "@param client client model",
    "old_code_raw": "    public Mono<Client> testClientModel(Client client) throws RestClientException {\n        Object postBody = client;\n        \n        // verify the required parameter 'client' is set\n        if (client == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'client' when calling testClientModel\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"/fake\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "new_code_raw": "    public Mono<Client> testClientModel(Client body) throws RestClientException {\n        Object postBody = body;\n        \n        // verify the required parameter 'body' is set\n        if (body == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling testClientModel\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"/fake\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n"
  },
  {
    "id": "apache_activemq-1153-Param-0",
    "old_comment_raw": "@param configuration",
    "old_code_raw": "    public static Transport createLocalTransport(URI uri) throws Exception {\n        return createLocalTransport(uri, false);\n    }\n",
    "new_code_raw": "    public static Transport createLocalTransport(NetworkBridgeConfiguration configuration, URI uri) throws Exception {\n        // one end of the localbroker<->bridge transport needs to be async to allow concurrent forwards and acks\n        return createLocalTransport(uri, !configuration.isDispatchAsync());\n    }\n"
  },
  {
    "id": "svn2github_my-23-Associations-Param1",
    "old_comment_raw": "@param value value of the metadata, eg \"ACME, inc\".",
    "old_code_raw": "    boolean setFwkMetadata(String name, String value, boolean createTable) throws SQLException {\r\n        if (Boolean.getBoolean(NOAUTO_CREATE_METADATA))\r\n            return false;\r\n\r\n        synchronized (this.getTreeMutex()) {\r\n            // don't refresh until after the insert, that way if the refresh triggers an access to\r\n            // the metadata name will already be set to value.\r\n            final boolean shouldRefresh;\r\n            if (createTable && !this.contains(METADATA_TABLENAME)) {\r\n                final SQLCreateMoveableTable create = getCreateMetadata(getServer().getSQLSystem().getSyntax());\r\n                this.getBase().getDataSource().execute(create.asString(getDBRoot().getName()));\r\n                shouldRefresh = true;\r\n            } else\r\n                shouldRefresh = false;\r\n\r\n            final boolean res;\r\n            if (createTable || this.contains(METADATA_TABLENAME)) {\r\n                // don't use SQLRowValues, cause it means getting the SQLTable and thus calling\r\n                // fetchTables(), but setFwkMetadata() might itself be called by fetchTables()\r\n                // furthermore SQLRowValues support only rowable tables\r\n                final SQLName tableName = new SQLName(this.getBase().getName(), this.getName(), METADATA_TABLENAME);\r\n                final String del = SQLSelect.quote(\"DELETE FROM %i WHERE %i = %s\", tableName, \"NAME\", name);\r\n                final String ins = SQLSelect.quote(\"INSERT INTO %i(%i,%i) VALUES(%s,%s)\", tableName, \"NAME\", \"VALUE\", name, value);\r\n                SQLUtils.executeAtomic(this.getBase().getDataSource(), new SQLFactory<Object>() {\r\n                    public Object create() throws SQLException {\r\n                        getBase().getDataSource().execute(del);\r\n                        getBase().getDataSource().execute(ins);\r\n                        return null;\r\n                    }\r\n                });\r\n                res = true;\r\n            } else\r\n                res = false;\r\n            if (shouldRefresh)\r\n                this.fetchTable(METADATA_TABLENAME);\r\n            return res;\r\n        }\r\n    }\r\n",
    "new_code_raw": "    Tuple2<Boolean, String> setFwkMetadata(String name, String sqlExpr, boolean createTable) throws SQLException {\r\n        if (Boolean.getBoolean(NOAUTO_CREATE_METADATA))\r\n            return Tuple2.create(false, null);\r\n\r\n        final SQLSystem sys = getServer().getSQLSystem();\r\n        final SQLSyntax syntax = sys.getSyntax();\r\n        final SQLDataSource ds = this.getDBSystemRoot().getDataSource();\r\n        synchronized (this.getTreeMutex()) {\r\n            // don't refresh until after the insert, that way if the refresh triggers an access to\r\n            // the metadata name will already be set to value.\r\n            final boolean shouldRefresh;\r\n            if (createTable && !this.contains(METADATA_TABLENAME)) {\r\n                final SQLCreateMoveableTable create = getCreateMetadata(syntax);\r\n                ds.execute(create.asString(getDBRoot().getName()));\r\n                shouldRefresh = true;\r\n            } else {\r\n                shouldRefresh = false;\r\n            }\r\n\r\n            final Tuple2<Boolean, String> res;\r\n            if (createTable || this.contains(METADATA_TABLENAME)) {\r\n                // don't use SQLRowValues, cause it means getting the SQLTable and thus calling\r\n                // fetchTables(), but setFwkMetadata() might itself be called by fetchTables()\r\n                // furthermore SQLRowValues support only rowable tables\r\n\r\n                final List<String> queries = new ArrayList<String>();\r\n\r\n                final SQLName tableName = new SQLName(this.getBase().getName(), this.getName(), METADATA_TABLENAME);\r\n                final String where = \" WHERE \" + SQLBase.quoteIdentifier(\"NAME\") + \" = \" + getBase().quoteString(name);\r\n                queries.add(\"DELETE FROM \" + tableName.quote() + where);\r\n\r\n                final String returning = sys == SQLSystem.POSTGRESQL ? \" RETURNING \" + SQLBase.quoteIdentifier(\"VALUE\") : \"\";\r\n                final String ins = syntax.getInsertOne(tableName, Arrays.asList(\"NAME\", \"VALUE\"), getBase().quoteString(name), sqlExpr) + returning;\r\n                queries.add(ins);\r\n\r\n                final List<? extends ResultSetHandler> handlers;\r\n                if (returning.length() == 0) {\r\n                    queries.add(\"SELECT \" + SQLBase.quoteIdentifier(\"VALUE\") + \" FROM \" + tableName.quote() + where);\r\n                    handlers = Arrays.asList(null, null, SQLDataSource.SCALAR_HANDLER);\r\n                } else {\r\n                    handlers = Arrays.asList(null, SQLDataSource.SCALAR_HANDLER);\r\n                }\r\n\r\n                final List<?> ress = SQLUtils.executeMultiple(getDBSystemRoot(), queries, handlers);\r\n                res = Tuple2.create(true, (String) ress.get(ress.size() - 1));\r\n            } else {\r\n                res = Tuple2.create(false, null);\r\n            }\r\n            if (shouldRefresh)\r\n                this.fetchTable(METADATA_TABLENAME);\r\n            return res;\r\n        }\r\n    }\r\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1698-Param-0",
    "old_comment_raw": "@param petId ID of pet to update",
    "old_code_raw": "    public Mono<ModelApiResponse> uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws RestClientException {\n        Object postBody = null;\n        \n        // verify the required parameter 'petId' is set\n        if (petId == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n        }\n        \n        // verify the required parameter 'file' is set\n        if (file == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'file' when calling uploadFileWithRequiredFile\");\n        }\n        \n        // create path and map variables\n        final Map<String, Object> uriVariables = new HashMap<String, Object>();\n        uriVariables.put(\"petId\", petId);\n        String path = UriComponentsBuilder.fromPath(\"/fake/{petId}/uploadImageWithRequiredFile\").buildAndExpand(uriVariables).toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n        \n        if (additionalMetadata != null)\n            formParams.add(\"additionalMetadata\", additionalMetadata);\n        if (file != null)\n            formParams.add(\"file\", new FileSystemResource(file));\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"multipart/form-data\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"petstore_auth\" };\n\n        ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "new_code_raw": "    public Mono<ModelApiResponse> uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws RestClientException {\n        Object postBody = null;\n        \n        // verify the required parameter 'petId' is set\n        if (petId == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n        }\n        \n        // verify the required parameter 'requiredFile' is set\n        if (requiredFile == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\");\n        }\n        \n        // create path and map variables\n        final Map<String, Object> uriVariables = new HashMap<String, Object>();\n        uriVariables.put(\"petId\", petId);\n        String path = UriComponentsBuilder.fromPath(\"/fake/{petId}/uploadImageWithRequiredFile\").buildAndExpand(uriVariables).toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n        \n        if (additionalMetadata != null)\n            formParams.add(\"additionalMetadata\", additionalMetadata);\n        if (requiredFile != null)\n            formParams.add(\"requiredFile\", new FileSystemResource(requiredFile));\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"multipart/form-data\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"petstore_auth\" };\n\n        ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1701-Param-0",
    "old_comment_raw": "@param client client model",
    "old_code_raw": "    public Client testClientModel(Client client) throws IOException {\n        HttpResponse response = testClientModelForHttpResponse(client);\n        TypeReference typeRef = new TypeReference<Client>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n",
    "new_code_raw": "    public Client testClientModel(Client body) throws IOException {\n        HttpResponse response = testClientModelForHttpResponse(body);\n        TypeReference typeRef = new TypeReference<Client>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n"
  },
  {
    "id": "querydsl_querydsl-473-Param-0",
    "old_comment_raw": "@param other",
    "old_code_raw": "    public CaseForEqBuilder<D> when(D other){\n        return new CaseForEqBuilder<D>(this, new ConstantImpl<D>(other));\n    }\n",
    "new_code_raw": "    public CaseForEqBuilder<T> when(T other){\n        return new CaseForEqBuilder<T>(this, new ConstantImpl<T>(other));\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-210-Param-0",
    "old_comment_raw": "@param conll The CoNLL tree to parse.",
    "old_code_raw": "  public static SemanticGraph parseTree(String conll, List<CoreLabel> tokens) {\n    SemanticGraph tree = new SemanticGraph();\n    if (conll == null || conll.isEmpty()) {\n      return tree;\n    }\n    String[] treeLines = newline.split(conll);\n    IndexedWord[] vertices = new IndexedWord[tokens.size() + 2];\n    // Add edges\n    for (String line : treeLines) {\n      // Parse row\n      String[] fields = tab.split(line);\n      int dependentIndex = Integer.parseInt(fields[0]);\n      if (vertices[dependentIndex] == null) {\n        if (dependentIndex > tokens.size()) {\n          // Bizarre mismatch in sizes; the malt parser seems to do this often\n          return new SemanticGraph();\n        }\n        vertices[dependentIndex] = new IndexedWord(tokens.get(dependentIndex - 1));\n      }\n      IndexedWord dependent = vertices[dependentIndex];\n      int governorIndex = Integer.parseInt(fields[1]);\n      if (governorIndex > tokens.size()) {\n        // Bizarre mismatch in sizes; the malt parser seems to do this often\n        return new SemanticGraph();\n      }\n      if (vertices[governorIndex] == null && governorIndex > 0) {\n        vertices[governorIndex] = new IndexedWord(tokens.get(governorIndex - 1));\n      }\n      IndexedWord governor = vertices[governorIndex];\n      String relation = fields[2];\n\n      // Process row\n      if (governorIndex == 0) {\n        tree.addRoot(dependent);\n      } else {\n        tree.addVertex(dependent);\n        if (!tree.containsVertex(governor)) {\n          tree.addVertex(governor);\n        }\n        if (!\"ref\".equals(relation)) {\n          tree.addEdge(governor, dependent, GrammaticalRelation.valueOf(Language.English, relation), Double.NEGATIVE_INFINITY, false);\n        }\n      }\n    }\n    return tree;\n  }\n",
    "new_code_raw": "  public static SemanticGraph parseTree(JsonReader json, List<CoreLabel> tokens) {\n    SemanticGraph tree = new SemanticGraph();\n    JsonArray array = json.readArray();\n\n    if (array == null || array.isEmpty()) {\n      return tree;\n    }\n\n    IndexedWord[] vertices = new IndexedWord[tokens.size() + 2];\n    // Add edges\n    for(int i = 0; i < array.size(); i++) {\n      JsonObject entry = array.getJsonObject(i);\n      // Parse row\n      int dependentIndex = entry.getInt(\"dependent\");\n      if (vertices[dependentIndex] == null) {\n        if (dependentIndex > tokens.size()) {\n          // Bizarre mismatch in sizes; the malt parser seems to do this often\n          return new SemanticGraph();\n        }\n        vertices[dependentIndex] = new IndexedWord(tokens.get(dependentIndex - 1));\n      }\n      IndexedWord dependent = vertices[dependentIndex];\n      int governorIndex = entry.getInt(\"governor\");\n      if (governorIndex > tokens.size()) {\n        // Bizarre mismatch in sizes; the malt parser seems to do this often\n        return new SemanticGraph();\n      }\n      if (vertices[governorIndex] == null && governorIndex > 0) {\n        vertices[governorIndex] = new IndexedWord(tokens.get(governorIndex - 1));\n      }\n      IndexedWord governor = vertices[governorIndex];\n      String relation = entry.getString(\"dep\");\n\n      // Process row\n      if (governorIndex == 0) {\n        tree.addRoot(dependent);\n      } else {\n        tree.addVertex(dependent);\n        if (!tree.containsVertex(governor)) {\n          tree.addVertex(governor);\n        }\n        if (!\"ref\".equals(relation)) {\n          tree.addEdge(governor, dependent, GrammaticalRelation.valueOf(Language.English, relation), Double.NEGATIVE_INFINITY, false);\n        }\n      }\n    }\n    return tree;\n  }\n"
  },
  {
    "id": "jhipster_jhipster_sample_app-2-Param-0",
    "old_comment_raw": "@param persistentAuditEvents the list to convert",
    "old_code_raw": "    public List<AuditEvent> convertToAuditEvent(List<PersistentAuditEvent> persistentAuditEvents) {\n        if (persistentAuditEvents == null) {\n            return Collections.emptyList();\n        }\n\n        List<AuditEvent> auditEvents = new ArrayList<>();\n\n        for (PersistentAuditEvent persistentAuditEvent : persistentAuditEvents) {\n            AuditEvent auditEvent = new AuditEvent(persistentAuditEvent.getAuditEventDate().toDate(), persistentAuditEvent.getPrincipal(),\n                    persistentAuditEvent.getAuditEventType(), convertDataToObjects(persistentAuditEvent.getData()));\n            auditEvents.add(auditEvent);\n        }\n\n        return auditEvents;\n    }\n",
    "new_code_raw": "    public List<AuditEvent> convertToAuditEvent(Iterable<PersistentAuditEvent> persistentAuditEvents) {\n        if (persistentAuditEvents == null) {\n            return Collections.emptyList();\n        }\n\n        List<AuditEvent> auditEvents = new ArrayList<>();\n\n        for (PersistentAuditEvent persistentAuditEvent : persistentAuditEvents) {\n            AuditEvent auditEvent = new AuditEvent(persistentAuditEvent.getAuditEventDate().toDate(), persistentAuditEvent.getPrincipal(),\n                    persistentAuditEvent.getAuditEventType(), convertDataToObjects(persistentAuditEvent.getData()));\n            auditEvents.add(auditEvent);\n        }\n\n        return auditEvents;\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-166-Param-0",
    "old_comment_raw": "@param cl",
    "old_code_raw": "  private static CoreLabel createDatum(CoreLabel cl, String token, String label) {\n    CoreLabel newTok = new CoreLabel();\n    newTok.set(CoreAnnotations.TextAnnotation.class, token);\n    newTok.set(CoreAnnotations.CharAnnotation.class, token);\n    newTok.set(CoreAnnotations.AnswerAnnotation.class, label);\n    newTok.set(CoreAnnotations.GoldAnswerAnnotation.class, label);\n    if (cl != null && cl.containsKey(CoreAnnotations.DomainAnnotation.class))\n      newTok.set(CoreAnnotations.DomainAnnotation.class,\n                 cl.get(CoreAnnotations.DomainAnnotation.class));\n    return newTok;\n  }\n",
    "new_code_raw": "  private static CoreLabel createDatum(String token, String label, int index) {\n    CoreLabel newTok = new CoreLabel();\n    newTok.set(CoreAnnotations.CharAnnotation.class, token);\n    newTok.set(CoreAnnotations.AnswerAnnotation.class, label);\n    newTok.set(CoreAnnotations.GoldAnswerAnnotation.class, label);\n    newTok.setIndex(index);\n    return newTok;\n  }\n"
  },
  {
    "id": "yanzhenjie_NoHttp-143-Param-0",
    "old_comment_raw": "@param implRestConnection network operating interface, The implementation of the network layer.",
    "old_code_raw": "    public static RequestQueue newRequestQueue(ImplRestConnection implRestConnection, int threadPoolSize) {\n        return newRequestQueue(HttpRestParser.getInstance(implRestConnection), threadPoolSize);\n    }\n",
    "new_code_raw": "    public static RequestQueue newRequestQueue(IRestProtocol implRestConnection, int threadPoolSize) {\n        return newRequestQueue(RestParser.getInstance(implRestConnection), threadPoolSize);\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-1118-Param-0",
    "old_comment_raw": "@param field field should operate in UTC or be time zone agnostic",
    "old_code_raw": "    public DateTimeFormatterBuilder appendText(final DateTimeField field) {\n        return append0(new TextField(iChrono, field, iLocale, false));\n    }\n",
    "new_code_raw": "    public DateTimeFormatterBuilder appendText(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        DateTimeField field = fieldType.getField(iChronoUTC);\n        return append0(new TextField(iChrono, field, iLocale, false));\n    }\n"
  },
  {
    "id": "processing_processing-379-Param-1",
    "old_comment_raw": "@param programImports",
    "old_code_raw": "  protected int writeImportList(PrintStream out, List<String> imports) {\n    return writeImportList(out, (String[]) imports.toArray(new String[0]));\n  }\n",
    "new_code_raw": "  protected int writeImportList(PrintWriter out, List<String> imports) {\n    return writeImportList(out, (String[]) imports.toArray(new String[0]));\n  }\n"
  },
  {
    "id": "Atmosphere_atmosphere-854-Param-0",
    "old_comment_raw": "@param req the  HttpServletRequest",
    "old_code_raw": "    public Action suspended(HttpServletRequest req, HttpServletResponse res)\n            throws IOException, ServletException {\n        if (logger.isLoggable(Level.FINE)) {\n            logger.fine(\"(suspend) invoked:\\n HttpServletRequest: \" + req\n                    + \"\\n HttpServletResponse: \" + res);\n        }\n        return action(req, res);\n    }\n",
    "new_code_raw": "    public Action suspended(HttpServletRequest request, HttpServletResponse response)\n            throws IOException, ServletException {\n        logger.debug(\"(suspend) invoked:\\n HttpServletRequest: {}\\n HttpServletResponse: {}\", request, response);\n        return action(request, response);\n    }\n"
  },
  {
    "id": "runelite_runelite-23-Param-3",
    "old_comment_raw": "@param text string for width measurement",
    "old_code_raw": "\tpublic static Point getCanvasTextLocation(Client client, Graphics2D graphics, Point localLocation, String text, int zOffset)\n\t{\n\t\tint plane = client.getPlane();\n\n\t\tPoint p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset);\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tFontMetrics fm = graphics.getFontMetrics();\n\t\tRectangle2D bounds = fm.getStringBounds(text, graphics);\n\t\tint xOffset = p.getX() - (int) (bounds.getWidth() / 2);\n\n\t\treturn new Point(xOffset, p.getY());\n\t}\n",
    "new_code_raw": "\tpublic static Point getCanvasTextLocation(Client client, Graphics2D graphics, LocalPoint localLocation, String text, int zOffset)\n\t{\n\t\tint plane = client.getPlane();\n\n\t\tPoint p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset);\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tFontMetrics fm = graphics.getFontMetrics();\n\t\tRectangle2D bounds = fm.getStringBounds(text, graphics);\n\t\tint xOffset = p.getX() - (int) (bounds.getWidth() / 2);\n\n\t\treturn new Point(xOffset, p.getY());\n\t}\n"
  },
  {
    "id": "apache_calcite-964-Param-0",
    "old_comment_raw": "@param strings Expected expressions",
    "old_code_raw": "  private static Consumer<List> mongoChecker(final String... strings) {\n    return actual -> {\n      Object[] actualArray =\n          actual == null || actual.isEmpty()\n              ? null\n              : ((List) actual.get(0)).toArray();\n      CalciteAssert.assertArrayEqual(\"expected MongoDB query not found\",\n          strings, actualArray);\n    };\n  }\n",
    "new_code_raw": "  private static Consumer<List> mongoChecker(final String... expected) {\n    return actual -> {\n      if (expected == null) {\n        Assert.assertThat(\"null mongo Query\", actual, CoreMatchers.nullValue());\n        return;\n      }\n\n      if (expected.length == 0) {\n        CalciteAssert.assertArrayEqual(\"empty Mongo query\", expected,\n            actual.toArray(new Object[0]));\n        return;\n      }\n\n      final BsonDocument expectedBson = BsonDocument.parse(String.join(\",\", expected));\n      final BsonDocument actualBson = BsonDocument.parse(((List<?>) actual.get(0))\n          .stream()\n          .map(Objects::toString)\n          .collect(Collectors.joining(\"\\n\")));\n\n      // compare Bson (not string) representation\n      if (!expectedBson.equals(actualBson)) {\n        final JsonWriterSettings settings = JsonWriterSettings.builder().indent(true).build();\n        // used to pretty print Assertion error\n        Assert.assertEquals(\"expected and actual Mongo queries do not match\",\n            expectedBson.toJson(settings),\n            actualBson.toJson(settings));\n        Assert.fail(\"Should have failed previously because (expected != actual) is already known\");\n      }\n    };\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1219-Param-1",
    "old_comment_raw": "@param key The key of the item to be retrieved",
    "old_code_raw": "\tpublic Object get(SessionImplementor session, Object key, long txTimestamp) throws CacheException {\n\t\tif ( !region.checkValid() ) {\n\t\t\treturn null;\n\t\t}\n\t\tfinal Object val = cache.get( key );\n\t\tif ( val == null ) {\n\t\t\tputValidator.registerPendingPut(session, key, txTimestamp );\n\t\t}\n\t\treturn val;\n\t}\n",
    "new_code_raw": "\tpublic Object get(SharedSessionContractImplementor session, Object key, long txTimestamp) throws CacheException {\n\t\tif ( !region.checkValid() ) {\n\t\t\treturn null;\n\t\t}\n\t\tfinal Object val = cache.get( key );\n\t\tif ( val == null ) {\n\t\t\tputValidator.registerPendingPut(session, key, txTimestamp );\n\t\t}\n\t\treturn val;\n\t}\n"
  },
  {
    "id": "runelite_runelite-105-Param-1",
    "old_comment_raw": "@param archiveId",
    "old_code_raw": "\tpublic static DataFileReadResult decompress(byte[] b)\n\t{\n\t\tInputStream stream = new InputStream(b);\n\t\t\n\t\tint compression = stream.readUnsignedByte();\n\t\tint compressedLength = stream.readInt();\n\t\tif (compressedLength < 0 || compressedLength > 1000000)\n\t\t\tthrow new RuntimeException(\"Invalid data\");\n\t\t\n\t\tbyte[] data;\n\t\tint revision;\n\t\tswitch (compression)\n\t\t{\n\t\t\tcase CompressionType.NONE:\n\t\t\t\tdata = new byte[compressedLength];\n\t\t\t\trevision = checkRevision(stream, compressedLength);\n\t\t\t\tstream.readBytes(data, 0, compressedLength);\n\t\t\t\tbreak;\n\t\t\tcase CompressionType.BZ2:\n\t\t\t{\n\t\t\t\tint length = stream.readInt();\n\t\t\t\trevision = checkRevision(stream, compressedLength);\n\t\t\t\tdata = BZip2.decompress(stream.getRemaining(), compressedLength);\n\t\t\t\tassert data.length == length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CompressionType.GZ:\n\t\t\t{\n\t\t\t\tint length = stream.readInt();\n\t\t\t\trevision = checkRevision(stream, compressedLength);\n\t\t\t\tdata = GZip.decompress(stream.getRemaining(), compressedLength);\n\t\t\t\tassert data.length == length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException(\"Unknown decompression type\");\n\t\t}\n\t\t\n\t\tDataFileReadResult res = new DataFileReadResult();\n\t\tres.data = data;\n\t\tres.revision = revision;\n\t\tint length = revision != -1 ? b.length - 2 : b.length;\n\t\tres.crc = CRC32HGenerator.getHash(b, length);\n\t\tres.whirlpool = Whirlpool.getHash(b, length);\n\t\tres.compression = compression;\n\t\treturn res;\n\t}\n",
    "new_code_raw": "\tpublic static DataFileReadResult decompress(byte[] b, int[] keys)\n\t{\n\t\tInputStream stream = new InputStream(b);\n\t\t\n\t\tint compression = stream.readUnsignedByte();\n\t\tint compressedLength = stream.readInt();\n\t\tif (compressedLength < 0 || compressedLength > 1000000)\n\t\t\tthrow new RuntimeException(\"Invalid data\");\n\n\t\tCrc32 crc32 = new Crc32();\n\t\tcrc32.update(b, 0, 5); // compression + length\n\t\t\n\t\tbyte[] data;\n\t\tint revision = -1;\n\t\tswitch (compression)\n\t\t{\n\t\t\tcase CompressionType.NONE:\n\t\t\t{\n\t\t\t\tbyte[] encryptedData = new byte[compressedLength];\n\t\t\t\tstream.readBytes(encryptedData, 0, compressedLength);\n\n\t\t\t\tcrc32.update(encryptedData, 0, compressedLength);\n\t\t\t\tbyte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys);\n\n\t\t\t\tif (stream.remaining() >= 2)\n\t\t\t\t{\n\t\t\t\t\trevision = stream.readUnsignedShort();\n\t\t\t\t\tassert revision != -1;\n\t\t\t\t}\n\n\t\t\t\tdata = decryptedData;\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CompressionType.BZ2:\n\t\t\t{\n\t\t\t\tbyte[] encryptedData = new byte[compressedLength + 4];\n\t\t\t\tstream.readBytes(encryptedData);\n\n\t\t\t\tcrc32.update(encryptedData, 0, encryptedData.length);\n\t\t\t\tbyte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys);\n\n\t\t\t\tif (stream.remaining() >= 2)\n\t\t\t\t{\n\t\t\t\t\trevision = stream.readUnsignedShort();\n\t\t\t\t\tassert revision != -1;\n\t\t\t\t}\n\n\t\t\t\tstream = new InputStream(decryptedData);\n\n\t\t\t\tint decompressedLength = stream.readInt();\n\t\t\t\tdata = BZip2.decompress(stream.getRemaining(), compressedLength);\n\n\t\t\t\tif (data == null)\n\t\t\t\t{\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tassert data.length == decompressedLength;\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CompressionType.GZ:\n\t\t\t{\n\t\t\t\tbyte[] encryptedData = new byte[compressedLength + 4];\n\t\t\t\tstream.readBytes(encryptedData);\n\n\t\t\t\tcrc32.update(encryptedData, 0, encryptedData.length);\n\t\t\t\tbyte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys);\n\n\t\t\t\tif (stream.remaining() >= 2)\n\t\t\t\t{\n\t\t\t\t\trevision = stream.readUnsignedShort();\n\t\t\t\t\tassert revision != -1;\n\t\t\t\t}\n\n\t\t\t\tstream = new InputStream(decryptedData);\n\n\t\t\t\tint decompressedLength = stream.readInt();\n\t\t\t\tdata = GZip.decompress(stream.getRemaining(), compressedLength);\n\n\t\t\t\tif (data == null)\n\t\t\t\t{\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tassert data.length == decompressedLength;\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException(\"Unknown decompression type\");\n\t\t}\n\t\t\n\t\tDataFileReadResult res = new DataFileReadResult();\n\t\tres.data = data;\n\t\tres.revision = revision;\n\t\tint length = revision != -1 ? b.length - 2 : b.length;;\n\t\tres.crc = crc32.getHash();\n\t\tres.whirlpool = Whirlpool.getHash(b, length);\n\t\tres.compression = compression;\n\t\treturn res;\n\t}\n"
  },
  {
    "id": "LawnchairLauncher_Lawnchair-258-Param-1",
    "old_comment_raw": "@param info information about the widget",
    "old_code_raw": "    private RectF drawBoxWithShadow(Canvas c, Paint p, int width, int height) {\n        Resources res = mContext.getResources();\n        float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);\n        float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);\n        float corner = res.getDimension(R.dimen.widget_preview_corner_radius);\n\n        RectF bounds = new RectF(shadowBlur, shadowBlur,\n                width - shadowBlur, height - shadowBlur - keyShadowDistance);\n        p.setColor(Color.WHITE);\n\n        // Key shadow\n        p.setShadowLayer(shadowBlur, 0, keyShadowDistance,\n                ShadowGenerator.KEY_SHADOW_ALPHA << 24);\n        c.drawRoundRect(bounds, corner, corner, p);\n\n        // Ambient shadow\n        p.setShadowLayer(shadowBlur, 0, 0,\n                ColorUtils.setAlphaComponent(Color.BLACK, ShadowGenerator.AMBIENT_SHADOW_ALPHA));\n        c.drawRoundRect(bounds, corner, corner, p);\n\n        p.clearShadowLayer();\n        return bounds;\n    }\n",
    "new_code_raw": "    private RectF drawBoxWithShadow(Canvas c, int width, int height) {\n        Resources res = mContext.getResources();\n        float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);\n        float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);\n        float corner = res.getDimension(R.dimen.widget_preview_corner_radius);\n\n        RectF bounds = new RectF(shadowBlur, shadowBlur,\n                width - shadowBlur, height - shadowBlur - keyShadowDistance);\n        ShadowGenerator.drawShadow(c, bounds, Color.WHITE, shadowBlur, keyShadowDistance, corner);\n        return bounds;\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1963-Param-6",
    "old_comment_raw": "@param incrementSize the increment size to use (after any adjustments).",
    "old_code_raw": "\tpublic Serializable generate(SessionImplementor session, Object object) throws HibernateException {\n\t\treturn optimizer.generate( databaseStructure.buildCallback( session ) );\n\t}\n",
    "new_code_raw": "\tpublic Serializable generate(SharedSessionContractImplementor session, Object object) throws HibernateException {\n\t\treturn optimizer.generate( databaseStructure.buildCallback( session ) );\n\t}\n"
  },
  {
    "id": "lingochamp_FileDownloader-74-Param-0",
    "old_comment_raw": "@param url The downloading URL.",
    "old_code_raw": "    public static int generateId(final String url, final String path, final boolean pathAsDirectory) {\n        return CustomComponentHolder.getImpl().getIdGeneratorInstance().generateId(url, path, pathAsDirectory);\n    }\n",
    "new_code_raw": "    public static int generateId(final String url, final String path) {\n        return CustomComponentHolder.getImpl().getIdGeneratorInstance()\n                .generateId(url, path, false);\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-1492-Param-1",
    "old_comment_raw": "@param onlyFullyVisible if only fully visible views should be returned",
    "old_code_raw": "\tpublic ArrayList<View> getViews(View parent, boolean onlyFullyVisible) {\n\t\tfinal ArrayList<View> views = new ArrayList<View>();\n\t\tfinal View parentToUse;\n\n\t\tif (parent == null){\n\t\t\tinst.waitForIdleSync();\n\t\t\treturn getAllViews(onlyFullyVisible);\n\t\t}else{\n\t\t\tparentToUse = parent;\n\n\t\t\tviews.add(parentToUse);\n\n\t\t\tif (parentToUse instanceof ViewGroup) {\n\t\t\t\taddChildren(views, (ViewGroup) parentToUse, onlyFullyVisible);\n\t\t\t}\n\t\t}\n\n\n\t\treturn views;\n\t}\n",
    "new_code_raw": "\tpublic ArrayList<View> getViews(View parent, boolean onlySufficientlyVisible) {\n\t\tfinal ArrayList<View> views = new ArrayList<View>();\n\t\tfinal View parentToUse;\n\n\t\tif (parent == null){\n\t\t\tinst.waitForIdleSync();\n\t\t\treturn getAllViews(onlySufficientlyVisible);\n\t\t}else{\n\t\t\tparentToUse = parent;\n\n\t\t\tviews.add(parentToUse);\n\n\t\t\tif (parentToUse instanceof ViewGroup) {\n\t\t\t\taddChildren(views, (ViewGroup) parentToUse, onlySufficientlyVisible);\n\t\t\t}\n\t\t}\n\n\n\t\treturn views;\n\t}\n"
  },
  {
    "id": "apache_kylin-282-Param-0",
    "old_comment_raw": "@param correctedSql",
    "old_code_raw": "    private SQLResponse execute(String correctedSql, SQLRequest sqlRequest) throws Exception {\n        Connection conn = null;\n        Statement stat = null;\n        ResultSet resultSet = null;\n        Boolean isPushDown = false;\n\n        List<List<String>> results = Lists.newArrayList();\n        List<SelectedColumnMeta> columnMetas = Lists.newArrayList();\n\n        try {\n            conn = QueryConnection.getConnection(sqlRequest.getProject());\n\n            // special case for prepare query. \n            if (BackdoorToggles.getPrepareOnly()) {\n                return getPrepareOnlySqlResponse(correctedSql, conn, isPushDown, results, columnMetas);\n            }\n\n            stat = conn.createStatement();\n            processStatementAttr(stat, sqlRequest);\n            resultSet = stat.executeQuery(correctedSql);\n\n            ResultSetMetaData metaData = resultSet.getMetaData();\n            int columnCount = metaData.getColumnCount();\n\n            // Fill in selected column meta\n            for (int i = 1; i <= columnCount; ++i) {\n                columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i),\n                        metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i),\n                        metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i),\n                        metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i),\n                        metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i),\n                        metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i),\n                        metaData.isDefinitelyWritable(i)));\n            }\n\n            // fill in results\n            while (resultSet.next()) {\n                List<String> oneRow = Lists.newArrayListWithCapacity(columnCount);\n                for (int i = 0; i < columnCount; i++) {\n                    oneRow.add((resultSet.getString(i + 1)));\n                }\n\n                results.add(oneRow);\n            }\n        } catch (SQLException sqlException) {\n            isPushDown = PushDownUtil.doPushDownQuery(sqlRequest.getProject(), correctedSql, conn.getSchema(), results, columnMetas,\n                    sqlException);\n            if (!isPushDown) {\n                throw sqlException;\n            }\n        } finally {\n            close(resultSet, stat, conn);\n        }\n\n        return getSqlResponse(isPushDown, results, columnMetas);\n    }\n",
    "new_code_raw": "    private SQLResponse execute(String correctedSql, SQLRequest sqlRequest, Connection conn) throws Exception {\n        Statement stat = null;\n        ResultSet resultSet = null;\n        Boolean isPushDown = false;\n\n        List<List<String>> results = Lists.newArrayList();\n        List<SelectedColumnMeta> columnMetas = Lists.newArrayList();\n\n        try {\n\n            // special case for prepare query. \n            if (BackdoorToggles.getPrepareOnly()) {\n                return getPrepareOnlySqlResponse(correctedSql, conn, isPushDown, results, columnMetas);\n            }\n\n            stat = conn.createStatement();\n            processStatementAttr(stat, sqlRequest);\n            resultSet = stat.executeQuery(correctedSql);\n\n            ResultSetMetaData metaData = resultSet.getMetaData();\n            int columnCount = metaData.getColumnCount();\n\n            // Fill in selected column meta\n            for (int i = 1; i <= columnCount; ++i) {\n                columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i),\n                        metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i),\n                        metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i),\n                        metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i),\n                        metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i),\n                        metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i),\n                        metaData.isDefinitelyWritable(i)));\n            }\n\n            // fill in results\n            while (resultSet.next()) {\n                List<String> oneRow = Lists.newArrayListWithCapacity(columnCount);\n                for (int i = 0; i < columnCount; i++) {\n                    oneRow.add((resultSet.getString(i + 1)));\n                }\n\n                results.add(oneRow);\n            }\n        } catch (SQLException sqlException) {\n            isPushDown = PushDownUtil.doPushDownQuery(sqlRequest.getProject(), correctedSql, conn.getSchema(), results,\n                    columnMetas, sqlException);\n            if (!isPushDown) {\n                throw sqlException;\n            }\n        } finally {\n            close(resultSet, stat, null);//conn is passed in, not my duty to close\n        }\n\n        return getSqlResponse(isPushDown, results, columnMetas);\n    }\n"
  },
  {
    "id": "SeleniumHQ_selenium-837-Param-0",
    "old_comment_raw": "@param locator used to check parent element. For example table with locator By.xpath(\"//table\")",
    "old_code_raw": "      public List<WebElement> apply(WebDriver webDriver) {\n        Boolean displayed = false;\n        Boolean exists = false;\n        try {\n          exists = findElement(locator, webDriver).findElements(sub_locator).size() > 0;\n          displayed =\n            findElement(locator, webDriver).findElement(sub_locator).isDisplayed();\n        } catch (Exception e) {\n          int i = 0;\n        }\n        return (exists && displayed) ?\n               findElement(locator, webDriver).findElements(sub_locator) :\n               null;\n      }\n",
    "new_code_raw": "      public List<WebElement> apply(WebDriver driver) {\n        WebElement current = findElement(parent, driver);\n\n        List<WebElement> allChildren = current.findElements(childLocator);\n        // The original code only checked the first element. Fair enough.\n        if (!allChildren.isEmpty() && allChildren.get(0).isDisplayed()) {\n          return allChildren;\n        }\n\n        return null;\n      }\n"
  },
  {
    "id": "zaproxy_zaproxy-928-Param-2",
    "old_comment_raw": "@param value null = not to append parameter value.",
    "old_code_raw": "    private boolean paramAppend(StringBuilder sb, String name, String value) {\n        boolean isEdited = false;\n        \n        if (name != null) {\n            sb.append(name);\n            isEdited = true;\n        }\n        \n        if (value != null) {\n            sb.append('=');\n            sb.append(value);\n            isEdited = true;\n        }\n        \n        return isEdited;\n    }\n",
    "new_code_raw": "    private boolean paramAppend(StringBuilder sb, String name, String value, ParameterParser parser) {\n        boolean isEdited = false;\n        \n        if (name != null) {\n            sb.append(name);\n            isEdited = true;\n        }\n        \n        if (value != null) {\n            sb.append(parser.getDefaultKeyValueSeparator());\n            sb.append(value);\n            isEdited = true;\n        }\n        \n        return isEdited;\n    }\n"
  },
  {
    "id": "zaproxy_zaproxy-2164-Param-0",
    "old_comment_raw": "@param sortedParamMap Parameter name-value pairs in lexicographical order.",
    "old_code_raw": "\tprivate static String canonicalize(final SortedMap<String, String> sortedParamMap) {\n\t\tif (sortedParamMap == null || sortedParamMap.isEmpty()) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tfinal StringBuilder sb = new StringBuilder(100);\n\t\tfor (Map.Entry<String, String> pair : sortedParamMap.entrySet()) {\n\t\t\tfinal String key = pair.getKey().toLowerCase();\n\t\t\t// Ignore irrelevant parameters\n\t\t\tif (IRRELEVANT_PARAMETERS.contains(key) || key.startsWith(\"utm_\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sb.length() > 0) {\n\t\t\t\tsb.append('&');\n\t\t\t}\n\t\t\tsb.append(pair.getKey());\n\t\t\tif (!pair.getValue().isEmpty()) {\n\t\t\t\tsb.append('=');\n\t\t\t\tsb.append(pair.getValue());\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n",
    "new_code_raw": "\tprivate static String canonicalize(final SortedSet<QueryParameter> sortedParameters) {\n\t\tif (sortedParameters == null || sortedParameters.isEmpty()) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tfinal StringBuilder sb = new StringBuilder(100);\n\t\tfor (QueryParameter parameter : sortedParameters) {\n\t\t\tfinal String name = parameter.getName().toLowerCase();\n\t\t\t// Ignore irrelevant parameters\n\t\t\tif (IRRELEVANT_PARAMETERS.contains(name) || name.startsWith(\"utm_\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sb.length() > 0) {\n\t\t\t\tsb.append('&');\n\t\t\t}\n\t\t\tsb.append(parameter.getName());\n\t\t\tif (!parameter.getValue().isEmpty()) {\n\t\t\t\tsb.append('=');\n\t\t\t\tsb.append(parameter.getValue());\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n"
  },
  {
    "id": "Atmosphere_atmosphere-818-Param-0",
    "old_comment_raw": "@param clazz A class implementing  Broadcaster",
    "old_code_raw": "    public static BroadcasterFactory buildAndReplaceDefaultfactory(Class<? extends Broadcaster> clazz, BroadcasterConfig config)\n            throws InstantiationException, IllegalAccessException {\n\n        factory = new DefaultBroadcasterFactory(clazz);\n        return factory;\n    }\n",
    "new_code_raw": "    public static BroadcasterFactory buildAndReplaceDefaultfactory(Class<? extends Broadcaster> clazz, AtmosphereServlet.AtmosphereConfig c)\n            throws InstantiationException, IllegalAccessException {\n\n        factory = new DefaultBroadcasterFactory(clazz);\n        config = c;\n        return factory;\n    }\n"
  },
  {
    "id": "graphql_java_graphql_java-54-Param-0",
    "old_comment_raw": "@param builderFunction a supplier for the builder impl",
    "old_code_raw": "        public Builder argument(BuilderFunction<GraphQLArgument.Builder> builderFunction) {\n            GraphQLArgument.Builder builder = GraphQLArgument.newArgument();\n            builder = builderFunction.apply(builder);\n            return argument(builder);\n        }\n",
    "new_code_raw": "        public Builder argument(UnaryOperator<GraphQLArgument.Builder> builderFunction) {\n            GraphQLArgument.Builder builder = GraphQLArgument.newArgument();\n            builder = builderFunction.apply(builder);\n            return argument(builder);\n        }\n"
  },
  {
    "id": "JodaOrg_joda_time-1110-Param-0",
    "old_comment_raw": "@param instant the partial instant",
    "old_code_raw": "    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, int newValue) {\n        FieldUtils.verifyValueBounds(this, newValue, getMinimumValue(instant, values), getMaximumValue(instant, values));\n        values[fieldIndex] = newValue;\n        \n        // may need to adjust smaller fields\n        if (fieldIndex < instant.getFieldSize()) {\n            for (int i = fieldIndex + 1; i < instant.getFieldSize(); i++) {\n                DateTimeField field = instant.getField(i);\n                if (values[i] > field.getMaximumValue(instant, values)) {\n                    values[i] = field.getMaximumValue(instant, values);\n                }\n                if (values[i] < field.getMinimumValue(instant, values)) {\n                    values[i] = field.getMinimumValue(instant, values);\n                }\n            }\n        }\n        return values;\n    }\n",
    "new_code_raw": "    public int[] set(ReadablePartial partial, int fieldIndex, int[] values, int newValue) {\n        FieldUtils.verifyValueBounds(this, newValue, getMinimumValue(partial, values), getMaximumValue(partial, values));\n        values[fieldIndex] = newValue;\n        \n        // may need to adjust smaller fields\n        if (fieldIndex < partial.size()) {\n            for (int i = fieldIndex + 1; i < partial.size(); i++) {\n                DateTimeField field = partial.getField(i);\n                if (values[i] > field.getMaximumValue(partial, values)) {\n                    values[i] = field.getMaximumValue(partial, values);\n                }\n                if (values[i] < field.getMinimumValue(partial, values)) {\n                    values[i] = field.getMinimumValue(partial, values);\n                }\n            }\n        }\n        return values;\n    }\n"
  },
  {
    "id": "apache_calcite-580-Param-1",
    "old_comment_raw": "@param nameList Collection of names already used",
    "old_code_raw": "    public static String uniquify(String name, Collection<String> nameList)\n    {\n        if (name == null) {\n            name = \"EXPR$\";\n        }\n        if (nameList.contains(name)) {\n            String aliasBase = name;\n            for (int j = 0;; j++) {\n                name = aliasBase + j;\n                if (!nameList.contains(name)) {\n                    break;\n                }\n            }\n        }\n        nameList.add(name);\n        return name;\n    }\n",
    "new_code_raw": "    public static String uniquify(String name, Set<String> nameList)\n    {\n        if (name == null) {\n            name = \"EXPR$\";\n        }\n        if (nameList.add(name)) {\n            return name;\n        }\n        String aliasBase = name;\n        for (int j = 0;; j++) {\n            name = aliasBase + j;\n            if (nameList.add(name)) {\n                return name;\n            }\n        }\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1640-Param-0",
    "old_comment_raw": "@param body client model (required)",
    "old_code_raw": "  public ApiResponse<Client> testSpecialTagsWithHttpInfo(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling testSpecialTags\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/another-fake/dummy\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public ApiResponse<Client> testSpecialTagsWithHttpInfo(Client client) throws ApiException {\n    Object localVarPostBody = client;\n    \n    // verify the required parameter 'client' is set\n    if (client == null) {\n      throw new ApiException(400, \"Missing the required parameter 'client' when calling testSpecialTags\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/another-fake/dummy\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "debezium_debezium-831-Param-1",
    "old_comment_raw": "@param column the column definition describing the  data value; never null",
    "old_code_raw": "    protected Object convertEnumToString(String options, Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return \"\";\n        }\n        if (data instanceof String) {\n            // JDBC should return strings ...\n            return data;\n        }\n        if (data instanceof Integer) {\n            // The binlog will contain an int with the 1-based index of the option in the enum value ...\n            int index = ((Integer) data).intValue() - 1; // 'options' is 0-based\n            if (index < options.length()) {\n                return options.substring(index, index + 1);\n            }\n            return null;\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n",
    "new_code_raw": "    protected Object convertEnumToString(List<String> options, Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return \"\";\n        }\n        if (data instanceof String) {\n            // JDBC should return strings ...\n            return data;\n        }\n        if (data instanceof Integer) {\n\n            if (options != null) {\n                // The binlog will contain an int with the 1-based index of the option in the enum value ...\n                int index = ((Integer) data).intValue() - 1; // 'options' is 0-based\n                if (index < options.size()) {\n                    return options.get(index);\n                }\n            }\n            return null;\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1644-Param-0",
    "old_comment_raw": "@param body client model (required)",
    "old_code_raw": "  public ApiResponse<Client> testClassnameWithHttpInfo(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling testClassname\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake_classname_test\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"api_key_query\" };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public ApiResponse<Client> testClassnameWithHttpInfo(Client client) throws ApiException {\n    Object localVarPostBody = client;\n    \n    // verify the required parameter 'client' is set\n    if (client == null) {\n      throw new ApiException(400, \"Missing the required parameter 'client' when calling testClassname\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake_classname_test\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"api_key_query\" };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "RobotiumTech_robotium-276-Param-1",
    "old_comment_raw": "@param direction the direction to be scrolled",
    "old_code_raw": "\tpublic boolean scrollList(int listIndex, Direction direction, ArrayList<ListView> listViews) {\n\t\tint[] xy = new int[2];\n\t\tListView listView = viewFetcher.getView(ListView.class, listViews, listIndex);\n\n\t\twhile (listView ==null && scrollScrollView(direction, null)) {\n\t\t\tsleeper.sleep();\n\t\t\tlistView = viewFetcher.getView(ListView.class, listViews, listIndex);\n\t\t}\n\t\t\n\t\tif(listView ==null)\n\t\t\tAssert.assertTrue(\"No ListView with index \" + listIndex + \" is found!\", false);\n\t\t\n\t\tlistView.getLocationOnScreen(xy);\n\t\t\n\t\tif (direction == Direction.DOWN) {\n\t\t\t\n\t\t\tif (listView.getLastVisiblePosition() >= listView.getCount()-1) {\n\t\t\t\tscrollListToLine(listView, listView.getLastVisiblePosition());\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tscrollListToLine(listView, listView.getLastVisiblePosition());\n\n\t\t} else if (direction == Direction.UP) {\n\n\t\t\tif (listView.getFirstVisiblePosition() < 2) {\n\t\t\t\tscrollListToLine(listView, 0);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfinal int lines = listView.getLastVisiblePosition() - listView.getFirstVisiblePosition();\n\t\t\tint lineToScrollTo = listView.getFirstVisiblePosition() - lines;\n\t\t\tif(lineToScrollTo < 0)\n\t\t\t\tlineToScrollTo=0;\n\n\t\t\tscrollListToLine(listView, lineToScrollTo);\n\t\t}\t\n\t\tsleeper.sleep();\n\t\treturn true;\n\t}\n",
    "new_code_raw": "\tpublic boolean scrollList(int listIndex, int direction, ArrayList<ListView> listViews) {\n\t\tint[] xy = new int[2];\n\t\tListView listView = viewFetcher.getView(ListView.class, listViews, listIndex);\n\n\t\twhile (listView ==null && scrollScrollView(direction, null)) {\n\t\t\tsleeper.sleep();\n\t\t\tlistView = viewFetcher.getView(ListView.class, listViews, listIndex);\n\t\t}\n\t\t\n\t\tif(listView ==null)\n\t\t\tAssert.assertTrue(\"No ListView with index \" + listIndex + \" is found!\", false);\n\t\t\n\t\tlistView.getLocationOnScreen(xy);\n\t\t\n\t\tif (direction == DOWN) {\n\t\t\t\n\t\t\tif (listView.getLastVisiblePosition() >= listView.getCount()-1) {\n\t\t\t\tscrollListToLine(listView, listView.getLastVisiblePosition());\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tscrollListToLine(listView, listView.getLastVisiblePosition());\n\n\t\t} else if (direction == UP) {\n\n\t\t\tif (listView.getFirstVisiblePosition() < 2) {\n\t\t\t\tscrollListToLine(listView, 0);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfinal int lines = listView.getLastVisiblePosition() - listView.getFirstVisiblePosition();\n\t\t\tint lineToScrollTo = listView.getFirstVisiblePosition() - lines;\n\t\t\tif(lineToScrollTo < 0)\n\t\t\t\tlineToScrollTo=0;\n\n\t\t\tscrollListToLine(listView, lineToScrollTo);\n\t\t}\t\n\t\tsleeper.sleep();\n\t\treturn true;\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2672-Param-1",
    "old_comment_raw": "@param property",
    "old_code_raw": "   protected String getParameterDataType(Parameter parameter, Property property) {\n        return null;\n   }\n",
    "new_code_raw": "    protected String getParameterDataType(Parameter parameter, Schema schema) {\n        return null;\n    }\n"
  },
  {
    "id": "zaproxy_zaproxy-2116-Param-1",
    "old_comment_raw": "@param name Null = not to append parameter.",
    "old_code_raw": "    private boolean paramAppend(StringBuffer sb, String name, String value) {\n        boolean isEdited = false;\n        if (name != null) {\n            sb.append(name);\n            isEdited = true;\n        }\n        if (value != null) {\n            sb.append('=');\n            sb.append(value);\n            isEdited = true;\n        }\n        return isEdited;\n    }\n",
    "new_code_raw": "    private boolean paramAppend(StringBuilder sb, String name, String value) {\n        boolean isEdited = false;\n        if (name != null) {\n            sb.append(name);\n            isEdited = true;\n        }\n        if (value != null) {\n            sb.append('=');\n            sb.append(value);\n            isEdited = true;\n        }\n        return isEdited;\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1698-Param-1",
    "old_comment_raw": "@param file file to upload",
    "old_code_raw": "    public Mono<ModelApiResponse> uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws RestClientException {\n        Object postBody = null;\n        \n        // verify the required parameter 'petId' is set\n        if (petId == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n        }\n        \n        // verify the required parameter 'file' is set\n        if (file == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'file' when calling uploadFileWithRequiredFile\");\n        }\n        \n        // create path and map variables\n        final Map<String, Object> uriVariables = new HashMap<String, Object>();\n        uriVariables.put(\"petId\", petId);\n        String path = UriComponentsBuilder.fromPath(\"/fake/{petId}/uploadImageWithRequiredFile\").buildAndExpand(uriVariables).toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n        \n        if (additionalMetadata != null)\n            formParams.add(\"additionalMetadata\", additionalMetadata);\n        if (file != null)\n            formParams.add(\"file\", new FileSystemResource(file));\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"multipart/form-data\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"petstore_auth\" };\n\n        ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "new_code_raw": "    public Mono<ModelApiResponse> uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws RestClientException {\n        Object postBody = null;\n        \n        // verify the required parameter 'petId' is set\n        if (petId == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n        }\n        \n        // verify the required parameter 'requiredFile' is set\n        if (requiredFile == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\");\n        }\n        \n        // create path and map variables\n        final Map<String, Object> uriVariables = new HashMap<String, Object>();\n        uriVariables.put(\"petId\", petId);\n        String path = UriComponentsBuilder.fromPath(\"/fake/{petId}/uploadImageWithRequiredFile\").buildAndExpand(uriVariables).toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n        \n        if (additionalMetadata != null)\n            formParams.add(\"additionalMetadata\", additionalMetadata);\n        if (requiredFile != null)\n            formParams.add(\"requiredFile\", new FileSystemResource(requiredFile));\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"multipart/form-data\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"petstore_auth\" };\n\n        ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n"
  },
  {
    "id": "processing_processing-199-Param-1",
    "old_comment_raw": "@param exampleFolder",
    "old_code_raw": "  static public boolean isCompatible(Base base, StringDict props) {\n    String currentIdentifier =\n      base.getActiveEditor().getMode().getIdentifier();\n    StringList compatibleList = parseModeList(props);\n    if (compatibleList.size() == 0) {\n      return true;  // if no mode specified, assume compatible everywhere\n    }\n    for (String c : compatibleList) {\n      if (c.equals(currentIdentifier)) {\n        return true;\n      }\n    }\n    return false;\n  }\n",
    "new_code_raw": "  static public boolean isCompatible(Base base, File exampleFolder) {\n    String currentIdentifier = base.getActiveEditor().getMode().getIdentifier();\n    File propertiesFile =\n      new File(exampleFolder, EXAMPLES.getPropertiesName());\n    if (propertiesFile.exists()) {\n      StringList compatibleList =\n        parseModeList(Util.readSettings(propertiesFile));\n      if (compatibleList.size() == 0) {\n        return true;  // if no mode specified, just include everywhere\n      }\n      for (String c : compatibleList) {\n        if (c.equals(currentIdentifier)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n"
  },
  {
    "id": "apache_drill-1526-Param-0",
    "old_comment_raw": "@param columnChunkMetaData metadata to check",
    "old_code_raw": "  private boolean hasSingleValue(ColumnMetadata columnChunkMetaData, long rowCount) {\n    return (columnChunkMetaData != null) && (columnChunkMetaData.hasSingleValue(rowCount));\n  }\n",
    "new_code_raw": "  private boolean hasSingleValue(ColumnStatistics columnStatistics, long rowCount) {\n    return columnStatistics != null && isSingleVal(columnStatistics, rowCount);\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-52-Param-3",
    "old_comment_raw": "@param valueToAdd the value to add, in the units of the field",
    "old_code_raw": "    public int[] add(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {\n        if (valueToAdd == 0) {\n            return values;\n        }\n        // there are more efficient algorithms than this (especially for time only fields)\n        // trouble is when dealing with days and months, so we use this technique of\n        // adding/removing one from the larger field at a time\n        DateTimeField nextField = null;\n        \n        while (valueToAdd > 0) {\n            int max = getMaximumValue(instant, values);\n            long proposed = values[fieldIndex] + valueToAdd;\n            if (proposed <= max) {\n                values[fieldIndex] = (int) proposed;\n                break;\n            }\n            if (nextField == null) {\n                if (fieldIndex == 0) {\n                    throw new IllegalArgumentException(\"Maximum value exceeded for add\");\n                }\n                nextField = instant.getField(fieldIndex - 1);\n                if (getRangeDurationField() != nextField.getDurationField()) {\n                    throw new IllegalArgumentException(\"Fields invalid for add\");\n                }\n            }\n            valueToAdd -= (max + 1) - values[fieldIndex];\n            values = nextField.add(instant, fieldIndex - 1, values, 1);\n            values[fieldIndex] = getMinimumValue(instant, values);\n        }\n        while (valueToAdd < 0) {\n            int min = getMinimumValue(instant, values);\n            long proposed = values[fieldIndex] + valueToAdd;\n            if (proposed >= min) {\n                values[fieldIndex] = (int) proposed;\n                break;\n            }\n            if (nextField == null) {\n                if (fieldIndex == 0) {\n                    throw new IllegalArgumentException(\"Maximum value exceeded for add\");\n                }\n                nextField = instant.getField(fieldIndex - 1);\n                if (getRangeDurationField() != nextField.getDurationField()) {\n                    throw new IllegalArgumentException(\"Fields invalid for add\");\n                }\n            }\n            valueToAdd -= (min - 1) - values[fieldIndex];\n            values = nextField.add(instant, fieldIndex - 1, values, -1);\n            values[fieldIndex] = getMaximumValue(instant, values);\n        }\n        \n        return set(instant, fieldIndex, values, values[fieldIndex]);  // adjusts smaller fields\n    }\n",
    "new_code_raw": "    public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n        if (valueToAdd == 0) {\n            return values;\n        }\n        // there are more efficient algorithms than this (especially for time only fields)\n        // trouble is when dealing with days and months, so we use this technique of\n        // adding/removing one from the larger field at a time\n        DateTimeField nextField = null;\n        \n        while (valueToAdd > 0) {\n            int max = getMaximumValue(instant, values);\n            long proposed = values[fieldIndex] + valueToAdd;\n            if (proposed <= max) {\n                values[fieldIndex] = (int) proposed;\n                break;\n            }\n            if (nextField == null) {\n                if (fieldIndex == 0) {\n                    throw new IllegalArgumentException(\"Maximum value exceeded for add\");\n                }\n                nextField = instant.getField(fieldIndex - 1);\n                if (getRangeDurationField() != nextField.getDurationField()) {\n                    throw new IllegalArgumentException(\"Fields invalid for add\");\n                }\n            }\n            valueToAdd -= (max + 1) - values[fieldIndex];\n            values = nextField.add(instant, fieldIndex - 1, values, 1);\n            values[fieldIndex] = getMinimumValue(instant, values);\n        }\n        while (valueToAdd < 0) {\n            int min = getMinimumValue(instant, values);\n            long proposed = values[fieldIndex] + valueToAdd;\n            if (proposed >= min) {\n                values[fieldIndex] = (int) proposed;\n                break;\n            }\n            if (nextField == null) {\n                if (fieldIndex == 0) {\n                    throw new IllegalArgumentException(\"Maximum value exceeded for add\");\n                }\n                nextField = instant.getField(fieldIndex - 1);\n                if (getRangeDurationField() != nextField.getDurationField()) {\n                    throw new IllegalArgumentException(\"Fields invalid for add\");\n                }\n            }\n            valueToAdd -= (min - 1) - values[fieldIndex];\n            values = nextField.add(instant, fieldIndex - 1, values, -1);\n            values[fieldIndex] = getMaximumValue(instant, values);\n        }\n        \n        return set(instant, fieldIndex, values, values[fieldIndex]);  // adjusts smaller fields\n    }\n"
  },
  {
    "id": "yanzhenjie_NoHttp-150-Param-0",
    "old_comment_raw": "@param request  BasicServerRequest.",
    "old_code_raw": "    protected HttpURLConnection createHttpURLConnection(BasicServerRequest request) throws IOException, URISyntaxException {\n        // 1.Pre operation notice\n        request.onPreExecute();\n\n        // 2.Build URL\n        String urlStr = request.url();\n        Logger.i(\"Request address: \" + urlStr);\n        URL url = new URL(urlStr);\n        HttpURLConnection connection;\n        Proxy proxy = request.getProxy();\n        if (proxy == null)\n            connection = (HttpURLConnection) url.openConnection();\n        else\n            connection = (HttpURLConnection) url.openConnection(proxy);\n\n        connection.setConnectTimeout(request.getConnectTimeout());\n        connection.setReadTimeout(request.getReadTimeout());\n        connection.setInstanceFollowRedirects(false);\n\n        if (connection instanceof HttpsURLConnection) {\n            SSLSocketFactory sslSocketFactory = request.getSSLSocketFactory();\n            if (sslSocketFactory != null)\n                ((HttpsURLConnection) connection).setSSLSocketFactory(sslSocketFactory);\n            HostnameVerifier hostnameVerifier = request.getHostnameVerifier();\n            if (hostnameVerifier != null)\n                ((HttpsURLConnection) connection).setHostnameVerifier(hostnameVerifier);\n        }\n\n        // 3. Base attribute\n        RequestMethod requestMethod = request.getRequestMethod();\n        Logger.i(\"Request method: \" + requestMethod.toString());\n        // Fix delete patch error.\n        try {\n            connection.setRequestMethod(requestMethod.toString());\n        } catch (ProtocolException protocol) {\n            try {\n                Field methodField = connection.getClass().getDeclaredField(\"method\");\n                methodField.setAccessible(true);\n                methodField.set(connection, requestMethod.toString());\n            } catch (Exception noSuchFieldIllegalAccess) {\n                throw protocol;\n            }\n        }\n\n        connection.setDoInput(true);\n        connection.setDoOutput(requestMethod.allowRequestBody());\n\n        // 4.Set request headers\n        URI uri = null;\n        try {\n            uri = url.toURI();\n        } catch (URISyntaxException e) {\n            Logger.w(e);\n        }\n        setHeaders(uri, connection, request);\n\n        // 5. Connect\n        connection.connect();\n\n        // 6. Write request body\n        if (requestMethod.allowRequestBody()) {\n            Logger.i(\"-------Send request data start-------\");\n            OutputStream outputStream = IOUtils.toBufferedOutputStream(connection.getOutputStream());\n            request.onWriteRequestBody(outputStream);\n            IOUtils.flushQuietly(outputStream);\n            IOUtils.closeQuietly(outputStream);\n            Logger.i(\"-------Send request data end-------\");\n        }\n\n        return connection;\n    }\n",
    "new_code_raw": "    private HttpURLConnection createHttpURLConnection(IBasicRequest request) throws Exception {\n        // 1.Pre operation notice\n        request.onPreExecute();\n\n        // 2.Build URL\n        String urlStr = request.url();\n        Logger.i(\"Request address: \" + urlStr);\n        URL url = new URL(urlStr);\n        HttpURLConnection connection;\n        Proxy proxy = request.getProxy();\n        if (proxy == null)\n            connection = (HttpURLConnection) url.openConnection();\n        else\n            connection = (HttpURLConnection) url.openConnection(proxy);\n\n        connection.setConnectTimeout(request.getConnectTimeout());\n        connection.setReadTimeout(request.getReadTimeout());\n        connection.setInstanceFollowRedirects(false);\n\n        if (connection instanceof HttpsURLConnection) {\n            SSLSocketFactory sslSocketFactory = request.getSSLSocketFactory();\n            if (sslSocketFactory != null)\n                ((HttpsURLConnection) connection).setSSLSocketFactory(sslSocketFactory);\n            HostnameVerifier hostnameVerifier = request.getHostnameVerifier();\n            if (hostnameVerifier != null)\n                ((HttpsURLConnection) connection).setHostnameVerifier(hostnameVerifier);\n        }\n\n        // 3. Base attribute\n        RequestMethod requestMethod = request.getRequestMethod();\n        String requestMethodStr = requestMethod.toString();\n        Logger.i(\"Request method: \" + requestMethodStr);\n        // Fix delete patch error.\n        try {\n            connection.setRequestMethod(requestMethodStr);\n        } catch (ProtocolException protocol) {\n            try {\n                Field methodField = connection.getClass().getDeclaredField(\"method\");\n                methodField.setAccessible(true);\n                methodField.set(connection, requestMethodStr);\n            } catch (Exception noSuchFieldIllegalAccess) {\n                throw protocol;\n            }\n        }\n\n        connection.setDoInput(true);\n        connection.setDoOutput(requestMethod.allowRequestBody());\n\n        // 4.Set request headers\n        setHeaders(url.toURI(), connection, request);\n\n        // 5. Connect\n        connection.connect();\n        return connection;\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-1151-Param-0",
    "old_comment_raw": "@param s The short name of the GrammaticalRelation",
    "old_code_raw": "  public static GrammaticalRelation valueOf(String s, Collection<GrammaticalRelation> values) {\n    for (GrammaticalRelation reln : values) {\n      if (reln.toString().equals(s)) return reln;\n    }\n\n    return null;\n  }\n",
    "new_code_raw": "  public static GrammaticalRelation valueOf(String s, Collection<GrammaticalRelation> values, Lock readValuesLock) {\n    readValuesLock.lock();\n    try {\n      for (GrammaticalRelation reln : values) {\n        if (reln.toString().equals(s)) return reln;\n      }\n    } finally {\n      readValuesLock.unlock();\n    }\n\n    return null;\n  }\n"
  },
  {
    "id": "Rajawali_Rajawali-57-Associations-Param2",
    "old_comment_raw": "@param z double The z component.",
    "old_code_raw": "\tpublic static double length(double x, double y, double z) {\n\t\treturn Math.sqrt(length2(x, y, z));\n\t}\n",
    "new_code_raw": "\tpublic static float length(float x, float y, float z) {\n\t\treturn (float) Math.sqrt(length2(x, y, z));\n\t}\n\n"
  },
  {
    "id": "runelite_runelite-27-Param-0",
    "old_comment_raw": "@param client",
    "old_code_raw": "\tpublic static Point getCanvasTextMiniMapLocation(Client client, Graphics2D graphics, Point localLocation, String text)\n\t{\n\t\tPoint p = Perspective.worldToMiniMap(client, localLocation.getX(), localLocation.getY());\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tFontMetrics fm = graphics.getFontMetrics();\n\t\tRectangle2D bounds = fm.getStringBounds(text, graphics);\n\t\tint xOffset = p.getX() - (int) (bounds.getWidth() / 2);\n\t\tint yOffset = p.getY() - (int) (bounds.getHeight() / 2) + fm.getAscent();\n\n\t\treturn new Point(xOffset, yOffset);\n\t}\n",
    "new_code_raw": "\tpublic static Point getCanvasTextMiniMapLocation(Client client, Graphics2D graphics, LocalPoint localLocation, String text)\n\t{\n\t\tPoint p = Perspective.worldToMiniMap(client, localLocation.getX(), localLocation.getY());\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tFontMetrics fm = graphics.getFontMetrics();\n\t\tRectangle2D bounds = fm.getStringBounds(text, graphics);\n\t\tint xOffset = p.getX() - (int) (bounds.getWidth() / 2);\n\t\tint yOffset = p.getY() - (int) (bounds.getHeight() / 2) + fm.getAscent();\n\n\t\treturn new Point(xOffset, yOffset);\n\t}\n"
  },
  {
    "id": "JodaOrg_joda_time-426-Param-0",
    "old_comment_raw": "@param millis the new millis, from 1970-01-01T00:00:00Z",
    "old_code_raw": "    protected ReadableInstant create(long millis, Chronology chrono) {\n        // ignore chrono\n        if (millis == getMillis()) {\n            return this;\n        }\n        return new Instant(millis);\n    }\n",
    "new_code_raw": "    protected ReadableInstant create(long instant, Chronology chrono) {\n        // ignore chrono\n        if (instant == getMillis()) {\n            return this;\n        }\n        return new Instant(instant);\n    }\n"
  },
  {
    "id": "yanzhenjie_NoHttp-142-Param-4",
    "old_comment_raw": "@param isRange Whether the breakpoint continuingly",
    "old_code_raw": "    public static DownloadRequest createDownloadRequest(String url, RequestMethod requestMethod, String fileFloder, String filename, boolean isRange, boolean isDeleteOld) {\n        return new RestDownloadRequestor(url, requestMethod, fileFloder, filename, isRange, isDeleteOld);\n    }\n",
    "new_code_raw": "    public static DownloadRequest createDownloadRequest(String url, RequestMethod requestMethod, String fileFolder, String filename, boolean isRange, boolean isDeleteOld) {\n        return new RestDownloadRequestor(url, requestMethod, fileFolder, filename, isRange, isDeleteOld);\n    }\n"
  },
  {
    "id": "debezium_debezium-1265-Param-5",
    "old_comment_raw": "@param seconds a number of seconds from  ChronoUnit#MONTHS is used.",
    "old_code_raw": "    public static double durationNanos(int years, int months, int days, int hours, int minutes, double seconds) {\n        return durationNanos(years, months, days, hours, minutes, seconds, 0);\n    }\n",
    "new_code_raw": "    public static long durationNanos(int years, int months, int days, int hours, int minutes, long seconds) {\n        return durationNanos(years, months, days, hours, minutes, seconds, 0);\n    }\n"
  },
  {
    "id": "debezium_debezium-300-Param-1",
    "old_comment_raw": "@param preparer the function that supplied arguments to the prepared statement; may not be null",
    "old_code_raw": "    public JdbcConnection prepareQuery(String[] multiQuery, StatementPreparer preparer, MultiResultSetConsumer resultConsumer) throws SQLException {\n        final Connection conn = connection();\n        final ResultSet[] resultSets = new ResultSet[multiQuery.length];\n        final PreparedStatement[] preparedStatements = new PreparedStatement[multiQuery.length];\n\n        try {\n            for (int i = 0; i < multiQuery.length; i++) {\n                final String query = multiQuery[i];\n                if (LOGGER.isTraceEnabled()) {\n                    LOGGER.trace(\"running '{}'\", query);\n                }\n                final PreparedStatement statement = conn.prepareStatement(query);\n                preparedStatements[i] = statement;\n                preparer.accept(statement);\n                resultSets[i] = statement.executeQuery();\n            }\n            if (resultConsumer != null) {\n                resultConsumer.accept(resultSets);\n            }\n        }\n        finally {\n            for (ResultSet rs: resultSets) {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    }\n                    catch (Exception ei) {\n                    }\n                }\n            }\n            for (PreparedStatement ps: preparedStatements) {\n                if (ps != null) {\n                    try {\n                        ps.close();\n                    }\n                    catch (Exception ei) {\n                    }\n                }\n            }\n        }\n        return this;\n    }\n",
    "new_code_raw": "    public JdbcConnection prepareQuery(String[] multiQuery, StatementPreparer preparer, BlockingMultiResultSetConsumer resultConsumer) throws SQLException, InterruptedException {\n        final Connection conn = connection();\n        final ResultSet[] resultSets = new ResultSet[multiQuery.length];\n        final PreparedStatement[] preparedStatements = new PreparedStatement[multiQuery.length];\n\n        try {\n            for (int i = 0; i < multiQuery.length; i++) {\n                final String query = multiQuery[i];\n                if (LOGGER.isTraceEnabled()) {\n                    LOGGER.trace(\"running '{}'\", query);\n                }\n                final PreparedStatement statement = conn.prepareStatement(query);\n                preparedStatements[i] = statement;\n                preparer.accept(statement);\n                resultSets[i] = statement.executeQuery();\n            }\n            if (resultConsumer != null) {\n                resultConsumer.accept(resultSets);\n            }\n        }\n        finally {\n            for (ResultSet rs: resultSets) {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    }\n                    catch (Exception ei) {\n                    }\n                }\n            }\n            for (PreparedStatement ps: preparedStatements) {\n                if (ps != null) {\n                    try {\n                        ps.close();\n                    }\n                    catch (Exception ei) {\n                    }\n                }\n            }\n        }\n        return this;\n    }\n"
  },
  {
    "id": "apache_kylin-383-Param-0",
    "old_comment_raw": "@param sql",
    "old_code_raw": "    private SQLResponse execute(String sql, SQLRequest sqlRequest) throws Exception {\n        Connection conn = null;\n        Statement stat = null;\n        ResultSet resultSet = null;\n\n        List<List<String>> results = Lists.newArrayList();\n        List<SelectedColumnMeta> columnMetas = Lists.newArrayList();\n\n        try {\n            conn = cacheService.getOLAPDataSource(sqlRequest.getProject()).getConnection();\n\n            if (sqlRequest instanceof PrepareSqlRequest) {\n                PreparedStatement preparedState = conn.prepareStatement(sql);\n                processStatementAttr(preparedState, sqlRequest);\n\n                for (int i = 0; i < ((PrepareSqlRequest) sqlRequest).getParams().length; i++) {\n                    setParam(preparedState, i + 1, ((PrepareSqlRequest) sqlRequest).getParams()[i]);\n                }\n\n                resultSet = preparedState.executeQuery();\n            } else {\n                stat = conn.createStatement();\n                processStatementAttr(stat, sqlRequest);\n                resultSet = stat.executeQuery(sql);\n            }\n\n            ResultSetMetaData metaData = resultSet.getMetaData();\n            int columnCount = metaData.getColumnCount();\n\n            // Fill in selected column meta\n            for (int i = 1; i <= columnCount; ++i) {\n                columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i), metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i), metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i), metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i), metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i), metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i), metaData.isDefinitelyWritable(i)));\n            }\n\n            // fill in results\n            while (resultSet.next()) {\n                List<String> oneRow = Lists.newArrayListWithCapacity(columnCount);\n                for (int i = 0; i < columnCount; i++) {\n                    oneRow.add((resultSet.getString(i + 1)));\n                }\n\n                results.add(oneRow);\n            }\n        } finally {\n            close(resultSet, stat, conn);\n        }\n\n        boolean isPartialResult = false;\n        String cube = \"\";\n        StringBuilder sb = new StringBuilder(\"Scan count for each storageContext: \");\n        long totalScanCount = 0;\n        if (OLAPContext.getThreadLocalContexts() != null) { // contexts can be null in case of 'explain plan for'\n            for (OLAPContext ctx : OLAPContext.getThreadLocalContexts()) {\n                if (ctx.realization != null) {\n                    isPartialResult |= ctx.storageContext.isPartialResultReturned();\n                    cube = ctx.realization.getName();\n                    totalScanCount += ctx.storageContext.getTotalScanCount();\n                    sb.append(ctx.storageContext.getTotalScanCount() + \",\");\n                }\n            }\n        }\n        logger.info(sb.toString());\n\n        SQLResponse response = new SQLResponse(columnMetas, results, cube, 0, false, null, isPartialResult);\n        response.setTotalScanCount(totalScanCount);\n\n        return response;\n    }\n",
    "new_code_raw": "    private SQLResponse execute(String correctedSql, SQLRequest sqlRequest) throws Exception {\n        Connection conn = null;\n        Statement stat = null;\n        ResultSet resultSet = null;\n\n        List<List<String>> results = Lists.newArrayList();\n        List<SelectedColumnMeta> columnMetas = Lists.newArrayList();\n\n        try {\n            conn = cacheService.getOLAPDataSource(sqlRequest.getProject()).getConnection();\n\n            if (sqlRequest instanceof PrepareSqlRequest) {\n                PreparedStatement preparedState = conn.prepareStatement(correctedSql);\n                processStatementAttr(preparedState, sqlRequest);\n\n                for (int i = 0; i < ((PrepareSqlRequest) sqlRequest).getParams().length; i++) {\n                    setParam(preparedState, i + 1, ((PrepareSqlRequest) sqlRequest).getParams()[i]);\n                }\n\n                resultSet = preparedState.executeQuery();\n            } else {\n                stat = conn.createStatement();\n                processStatementAttr(stat, sqlRequest);\n                resultSet = stat.executeQuery(correctedSql);\n            }\n\n            ResultSetMetaData metaData = resultSet.getMetaData();\n            int columnCount = metaData.getColumnCount();\n\n            // Fill in selected column meta\n            for (int i = 1; i <= columnCount; ++i) {\n                columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i), metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i), metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i), metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i), metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i), metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i), metaData.isDefinitelyWritable(i)));\n            }\n\n            // fill in results\n            while (resultSet.next()) {\n                List<String> oneRow = Lists.newArrayListWithCapacity(columnCount);\n                for (int i = 0; i < columnCount; i++) {\n                    oneRow.add((resultSet.getString(i + 1)));\n                }\n\n                results.add(oneRow);\n            }\n        } finally {\n            close(resultSet, stat, conn);\n        }\n\n        boolean isPartialResult = false;\n        String cube = \"\";\n        StringBuilder sb = new StringBuilder(\"Scan count for each storageContext: \");\n        long totalScanCount = 0;\n        if (OLAPContext.getThreadLocalContexts() != null) { // contexts can be null in case of 'explain plan for'\n            for (OLAPContext ctx : OLAPContext.getThreadLocalContexts()) {\n                if (ctx.realization != null) {\n                    isPartialResult |= ctx.storageContext.isPartialResultReturned();\n                    cube = ctx.realization.getName();\n                    totalScanCount += ctx.storageContext.getTotalScanCount();\n                    sb.append(ctx.storageContext.getTotalScanCount() + \",\");\n                }\n            }\n        }\n        logger.info(sb.toString());\n\n        SQLResponse response = new SQLResponse(columnMetas, results, cube, 0, false, null, isPartialResult);\n        response.setTotalScanCount(totalScanCount);\n\n        return response;\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-286-Param-5",
    "old_comment_raw": "@param formParams The form parameters",
    "old_code_raw": "  public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n",
    "new_code_raw": "  public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n"
  },
  {
    "id": "querydsl_querydsl-1826-Param-1",
    "old_comment_raw": "@param args",
    "old_code_raw": "    public static BooleanOperation booleanOperation(Operator operation, Expression<?>... args) {\n        return predicate(operation, args);\n    }\n",
    "new_code_raw": "    public static BooleanOperation booleanOperation(Operator operator, Expression<?>... args) {\n        return predicate(operator, args);\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-345-Param-0",
    "old_comment_raw": "@param propertyName The name of the property",
    "old_code_raw": "\tpublic static Criterion between(String propertyName, Object lo, Object hi) {\n\t\treturn new BetweenExpression( propertyName, lo, hi );\n\t}\n",
    "new_code_raw": "\tpublic static Criterion between(String propertyName, Object low, Object high) {\n\t\treturn new BetweenExpression( propertyName, low, high );\n\t}\n"
  },
  {
    "id": "JodaOrg_joda_time-1106-Param-0",
    "old_comment_raw": "@param field a DateTimeField instance that is supported by this partial",
    "old_code_raw": "    public int get(DateTimeField field) {\n        for (int i = 0, isize = getFieldSize(); i < isize; i++) {\n            if (getField(i) == field) {\n                return getValue(i);\n            }\n        }\n        throw new IllegalArgumentException(\"Field '\" + field + \"' is not supported\");\n    }\n",
    "new_code_raw": "    public int get(DateTimeFieldType type) {\n        for (int i = 0, isize = size(); i < isize; i++) {\n            if (getFieldType(i) == type) {\n                return getValue(i);\n            }\n        }\n        throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\");\n    }\n"
  },
  {
    "id": "zaproxy_zaproxy-1174-Param-1",
    "old_comment_raw": "@param extension the extension that should be uninstalled",
    "old_code_raw": "    private static void installAddOnActiveScanRules(AddOn addOn) {\n        List<String> ascanNames = addOn.getAscanrules();\n        if (ascanNames != null) {\n            for (String name : ascanNames) {\n                logger.debug(\"Install ascanrule: \" + name);\n                if (!PluginFactory.loadedPlugin(name)) {\n                    logger.error(\"Failed to install ascanrule: \" + name);\n                }\n            }\n        }\n    }\n",
    "new_code_raw": "    private static void installAddOnActiveScanRules(AddOn addOn, AddOnClassLoader addOnClassLoader) {\n        List<AbstractPlugin> ascanrules = AddOnLoaderUtils.getActiveScanRules(addOn, addOnClassLoader);\n        if (!ascanrules.isEmpty()) {\n            for (AbstractPlugin ascanrule : ascanrules) {\n                String name = ascanrule.getClass().getCanonicalName();\n                logger.debug(\"Install ascanrule: \" + name);\n                PluginFactory.loadedPlugin(ascanrule);\n                if (!PluginFactory.isPluginLoaded(ascanrule)) {\n                    logger.error(\"Failed to install ascanrule: \" + name);\n                }\n            }\n        }\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-1113-Param-0",
    "old_comment_raw": "@param instant the instant to compare to",
    "old_code_raw": "    public int compareTo(ReadableInstant instant) {\n        if (instant == null) {\n            throw new IllegalArgumentException(\"The instant must not be null\");\n        }\n        int thisValue = get();\n        int otherValue = instant.get(getField());\n        if (thisValue < otherValue) {\n            return -1;\n        } else if (thisValue > otherValue) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n",
    "new_code_raw": "    public int compareTo(ReadablePartial partial) {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The instant must not be null\");\n        }\n        int thisValue = get();\n        int otherValue = partial.get(getFieldType());\n        if (thisValue < otherValue) {\n            return -1;\n        } else if (thisValue > otherValue) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n"
  },
  {
    "id": "apache_calcite-974-Param-1",
    "old_comment_raw": "@param relBuilder Builder for relational expressions",
    "old_code_raw": "  private void setCurrent(RelNode root, LogicalCorrelate corRel) {\n    currentRel = corRel;\n    if (corRel != null) {\n      cm = new CorelMapBuilder().build(Util.first(root, corRel));\n    }\n  }\n",
    "new_code_raw": "  private void setCurrent(RelNode root, Correlate corRel) {\n    currentRel = corRel;\n    if (corRel != null) {\n      cm = new CorelMapBuilder().build(Util.first(root, corRel));\n    }\n  }\n"
  },
  {
    "id": "zaproxy_zaproxy-2206-Param-0",
    "old_comment_raw": "@param siteTokens the tokens",
    "old_code_raw": "\tprivate HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final HttpSessionTokensSet siteTokens) {\n\n\t\treturn CookieBasedSessionManagementHelper.getMatchingHttpSession(sessions, cookies, siteTokens);\n\t}\n",
    "new_code_raw": "\tprivate HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final Set<String> tokens) {\n\n\t\t// Pre-checks\n\t\tif (sessions.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tList<HttpSession> matchingSessions = new LinkedList<>(sessions);\n\t\tfor (String token : tokens) {\n\t\t\t// Get the corresponding cookie from the cookies list\n\t\t\tHttpCookie matchingCookie = null;\n\t\t\tfor (HttpCookie cookie : cookies) {\n\t\t\t\tif (cookie.getName().equals(token)) {\n\t\t\t\t\tmatchingCookie = cookie;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Filter the sessions that do not match the cookie value\n\t\t\tIterator<HttpSession> it = matchingSessions.iterator();\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tif (!it.next().matchesToken(token, matchingCookie)) {\n\t\t\t\t\tit.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Return the matching session\n\t\tif (matchingSessions.size() >= 1) {\n\t\t\tif (matchingSessions.size() > 1) {\n\t\t\t\tlog.warn(\"Multiple sessions matching the cookies from response for site: \" + getSite()\n\t\t\t\t\t\t+ \". Using first one.\");\n\t\t\t}\n\t\t\treturn matchingSessions.get(0);\n\t\t}\n\t\treturn null;\n\n\t}\n"
  },
  {
    "id": "SeleniumHQ_selenium-861-Param-0",
    "old_comment_raw": "@param browser - the browserString (\"firefox\", \"iexplore\" or an executable path)",
    "old_code_raw": "  private URL determineSuiteUrl(String browserUrl, String suiteURL) throws IOException {\n    if (suiteURL.startsWith(\"https://\") || suiteURL.startsWith(\"http://\")) {\n      return verifySuiteUrl(new URL(suiteURL));\n    }\n\n    // Is the suiteURL a file?\n    Path path = Paths.get(suiteURL);\n    if (Files.exists(path)) {\n      // Not all drivers can read files from the disk, so we need to host the suite somewhere.\n      try (SocketLock lock = new SocketLock()) {\n        server = new Server();\n        HttpConfiguration httpConfig = new HttpConfiguration();\n\n        ServerConnector http = new ServerConnector(server, new HttpConnectionFactory(httpConfig));\n        int port = PortProber.findFreePort();\n        http.setPort(port);\n        http.setIdleTimeout(500000);\n        server.setConnectors(new Connector[]{http});\n\n        ResourceHandler handler = new ResourceHandler();\n        handler.setDirectoriesListed(true);\n        handler.setWelcomeFiles(new String[]{path.getFileName().toString(), \"index.html\"});\n        handler.setBaseResource(new PathResource(path.toFile().getParentFile().toPath().toRealPath()));\n\n        ContextHandler context = new ContextHandler(\"/tests\");\n        context.setHandler(handler);\n\n        server.setHandler(context);\n        server.start();\n\n        PortProber.waitForPortUp(port, 15, SECONDS);\n\n        URL serverUrl = server.getURI().toURL();\n        return new URL(serverUrl.getProtocol(), serverUrl.getHost(), serverUrl.getPort(),\n                       \"/tests/\");\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n\n    // Well then, it must be a URL relative to whatever the browserUrl. Probe and find out.\n    URL browser = new URL(browserUrl);\n    return verifySuiteUrl(new URL(browser, suiteURL));\n  }\n",
    "new_code_raw": "  private URL determineSuiteUrl(String startURL, String suiteURL) throws IOException {\n    if (suiteURL.startsWith(\"https://\") || suiteURL.startsWith(\"http://\")) {\n      return verifySuiteUrl(new URL(suiteURL));\n    }\n\n    // Is the suiteURL a file?\n    Path path = Paths.get(suiteURL);\n    if (Files.exists(path)) {\n      // Not all drivers can read files from the disk, so we need to host the suite somewhere.\n      try (SocketLock lock = new SocketLock()) {\n        server = new Server();\n        HttpConfiguration httpConfig = new HttpConfiguration();\n\n        ServerConnector http = new ServerConnector(server, new HttpConnectionFactory(httpConfig));\n        int port = PortProber.findFreePort();\n        http.setPort(port);\n        http.setIdleTimeout(500000);\n        server.setConnectors(new Connector[]{http});\n\n        ResourceHandler handler = new ResourceHandler();\n        handler.setDirectoriesListed(true);\n        handler.setWelcomeFiles(new String[]{path.getFileName().toString(), \"index.html\"});\n        handler.setBaseResource(new PathResource(path.toFile().getParentFile().toPath().toRealPath()));\n\n        ContextHandler context = new ContextHandler(\"/tests\");\n        context.setHandler(handler);\n\n        server.setHandler(context);\n        server.start();\n\n        PortProber.waitForPortUp(port, 15, SECONDS);\n\n        URL serverUrl = server.getURI().toURL();\n        return new URL(serverUrl.getProtocol(), serverUrl.getHost(), serverUrl.getPort(),\n                       \"/tests/\");\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n\n    // Well then, it must be a URL relative to whatever the browserUrl. Probe and find out.\n    URL browser = new URL(startURL);\n    return verifySuiteUrl(new URL(browser, suiteURL));\n  }\n"
  },
  {
    "id": "trygvis_jop-161-Associations-Param0",
    "old_comment_raw": "@param signature the signature to parse.",
    "old_code_raw": "    public static MemberID parse(String signature) {\n        return parse(signature, false, AppInfo.getSingleton().getClassPath());\n    }\n",
    "new_code_raw": "    public static MemberID parse(String memberID) {\n        return parse(memberID, false, AppInfo.getSingleton().getClassPath());\n    }\n\n"
  },
  {
    "id": "processing_processing-961-Param-2",
    "old_comment_raw": "@param offset - line start nonwhitespace offset",
    "old_code_raw": "  public ASTNode getASTNodeAt(int offset) {\n    Messages.log(\"* getASTNodeAt\");\n\n    PreprocessedSketch ps = errorCheckerService.latestResult;\n    int tabIndex = ps.sketch.getCodeIndex(editor.getCurrentTab());\n    int javaOffset = ps.tabOffsetToJavaOffset(tabIndex, offset);\n    ASTNode node = NodeFinder.perform(ps.compilationUnit, javaOffset, 0);\n\n    if (node == null) {\n      Messages.log(\"no node found\");\n      return null;\n    }\n\n    Messages.log(\"found \" + node.toString());\n    return node;\n  }\n",
    "new_code_raw": "  public ASTNode getASTNodeAt(int javaOffset) {\n    Messages.log(\"* getASTNodeAt\");\n\n    PreprocessedSketch ps = errorCheckerService.latestResult;\n    ASTNode node = NodeFinder.perform(ps.compilationUnit, javaOffset, 0);\n\n    if (node == null) {\n      Messages.log(\"no node found\");\n      return null;\n    }\n\n    Messages.log(\"found \" + node.toString());\n    return node;\n  }\n"
  },
  {
    "id": "RobotiumTech_robotium-1184-Param-0",
    "old_comment_raw": "@param search the string to be searched. The parameter will be interpreted as a regular expression.",
    "old_code_raw": "\tpublic boolean searchToggleButton(String search, int matches) {\n\t\tboolean found = searcher.searchToggleButton(search, matches);\n\t\treturn found;\n\n\t}\n",
    "new_code_raw": "\tpublic boolean searchToggleButton(String regex, int matches) {\n\t\tboolean found = searcher.searchToggleButton(regex, matches);\n\t\treturn found;\n\n\t}\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-1348-Param-1",
    "old_comment_raw": "@param tf the TreeFactory to be used to make new Tree nodes if needed",
    "old_code_raw": "  public Tree prune(Predicate<Tree> filter, TreeFactory tf) {\n    // is the current node to be pruned?\n    if ( ! filter.test(this)) {\n      return null;\n    }\n    // if not, recurse over all children\n    List<Tree> l = new ArrayList<>();\n    Tree[] kids = children();\n    for (Tree kid : kids) {\n      Tree prunedChild = kid.prune(filter, tf);\n      if (prunedChild != null) {\n        l.add(prunedChild);\n      }\n    }\n    // and check if this node has lost all its children\n    if (l.isEmpty() && !(kids.length == 0)) {\n      return null;\n    }\n    // if we're still ok, copy the node\n    if (isLeaf()) {\n      return tf.newLeaf(label());\n    }\n    return tf.newTreeNode(label(), l);\n  }\n",
    "new_code_raw": "  public Tree prune(Filter<Tree> filter, TreeFactory tf) {\n    // is the current node to be pruned?\n    if ( ! filter.accept(this)) {\n      return null;\n    }\n    // if not, recurse over all children\n    List<Tree> l = new ArrayList<Tree>();\n    Tree[] kids = children();\n    for (int i = 0; i < kids.length; i++) {\n      Tree prunedChild = kids[i].prune(filter, tf);\n      if (prunedChild != null) {\n        l.add(prunedChild);\n      }\n    }\n    // and check if this node has lost all its children\n    if (l.isEmpty() && !(kids.length == 0)) {\n      return null;\n    }\n    // if we're still ok, copy the node\n    if (isLeaf()) {\n      return tf.newLeaf(label());\n    }\n    return tf.newTreeNode(label(), l);\n  }\n"
  },
  {
    "id": "jenkinsci_scm-api-plugin-4-Associations-Param0",
    "old_comment_raw": "@param revision might be a branch name, a tag name, a cryptographic hash, a revision number, etc.",
    "old_code_raw": "    @CheckForNull\n    public final SCMRevision fetch(@NonNull String revision, @CheckForNull TaskListener listener)\n            throws IOException, InterruptedException {\n        return retrieve(revision, defaultListener(listener));\n    }\n",
    "new_code_raw": "    @CheckForNull\n    public final SCMRevision fetch(@NonNull String thingName, @CheckForNull TaskListener listener)\n            throws IOException, InterruptedException {\n        return retrieve(thingName, defaultListener(listener));\n    }\n\n"
  },
  {
    "id": "zaproxy_zaproxy-1141-Param-0",
    "old_comment_raw": "@param entity The current entity.",
    "old_code_raw": "    private String getChildSuffix(SiteNode node, boolean performRecursiveCheck) {\n\n        String resultSuffix = \"\";\n        String suffix = null;\n        SiteNode child = null;\n        HistoryReference ref = null;\n        try {\n\n            for (int i = 0; i < staticSuffixList.length; i++) {\n                suffix = staticSuffixList[i];\n                for (int j = 0; j < node.getChildCount(); j++) {\n                    child = (SiteNode) node.getChildAt(j);\n                    ref = child.getHistoryReference();\n                    try {\n                        if (ref.getURI().getPath().endsWith(suffix)) {\n                            return suffix;\n                        }\n                    } catch (Exception e) {\n                    }\n                }\n            }\n\n            if (performRecursiveCheck) {\n                for (int j = 0; j < node.getChildCount(); j++) {\n                    resultSuffix = getChildSuffix((SiteNode) node.getChildAt(j), performRecursiveCheck);\n                    if (!resultSuffix.equals(\"\")) {\n                        return resultSuffix;\n                    }\n                }\n            }\n\n        } catch (Exception e) {\n        }\n\n        return resultSuffix;\n    }\n",
    "new_code_raw": "    private String getChildSuffix(StructuralNode node, boolean performRecursiveCheck) {\n\n        String resultSuffix = \"\";\n        String suffix = null;\n        StructuralNode child = null;\n        try {\n\n            for (int i = 0; i < staticSuffixList.length; i++) {\n                suffix = staticSuffixList[i];\n                Iterator<StructuralNode> iter = node.getChildIterator();\n                while (iter.hasNext()) {\n                    child = iter.next();\n                    try {\n                        if (child.getURI().getPath().endsWith(suffix)) {\n                            return suffix;\n                        }\n                    } catch (Exception e) {\n                    }\n                }\n            }\n\n            if (performRecursiveCheck) {\n                Iterator<StructuralNode> iter = node.getChildIterator();\n                while (iter.hasNext()) {\n                    child = iter.next();\n                    resultSuffix = getChildSuffix(child, performRecursiveCheck);\n                    if (!resultSuffix.equals(\"\")) {\n                        return resultSuffix;\n                    }\n                }\n            }\n\n        } catch (Exception e) {\n        }\n\n        return resultSuffix;\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1652-Param-0",
    "old_comment_raw": "@param body order placed for purchasing the pet",
    "old_code_raw": "    public Order placeOrder(Order body, Map<String, Object> params) throws IOException {\n        HttpResponse response = placeOrderForHttpResponse(body, params);\n        TypeReference typeRef = new TypeReference<Order>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n",
    "new_code_raw": "    public Order placeOrder(Order order, Map<String, Object> params) throws IOException {\n        HttpResponse response = placeOrderForHttpResponse(order, params);\n        TypeReference typeRef = new TypeReference<Order>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n"
  },
  {
    "id": "SeleniumHQ_selenium-509-Param-0",
    "old_comment_raw": "@param timeout The timeout duration.",
    "old_code_raw": "  public FluentWait<T> withTimeout(java.time.Duration timeout) {\n    this.timeout = timeout;\n    return this;\n  }\n",
    "new_code_raw": "  public FluentWait<T> withTimeout(Duration timeout) {\n    this.timeout = timeout;\n    return this;\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2573-Param-0",
    "old_comment_raw": "@param property Property to get example string for",
    "old_code_raw": "    protected String getExample(Property property) {\n        if (property.getExample() != null) {\n            return property.getExample().toString();\n        } else if (property instanceof DateTimeProperty) {\n            return \"2000-01-23T04:56:07.000Z\";\n        } else if (property instanceof DateProperty) {\n            return \"2000-01-23\";\n        } else if (property instanceof BooleanProperty) {\n            return \"true\";\n        } else if (property instanceof LongProperty) {\n            return \"123456789\";\n        } else if (property instanceof DoubleProperty) { // derived from DecimalProperty so make sure this is first\n            return \"3.149\";\n        }  else if (property instanceof DecimalProperty) {\n            return \"1.3579\";\n        } else if (property instanceof PasswordProperty) {\n            return \"********\";\n        } else if (property instanceof UUIDProperty) {\n            return \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\";\n        // do these last in case the specific types above are derived from these classes\n        } else if (property instanceof StringProperty) {\n            return \"aeiou\";\n        } else if (property instanceof BaseIntegerProperty) {\n            return \"123\";\n        } else if (property instanceof AbstractNumericProperty) {\n            return \"1.23\";\n        }\n        LOGGER.warn(\"default example value not implemented for \" + property);\n        return \"\";\n    }\n",
    "new_code_raw": "    protected String getExample(Schema schema) {\n        if (schema.getExample() != null) {\n            return schema.getExample().toString();\n        } else if (ModelUtils.isDateTimeSchema(schema)) {\n            return \"2000-01-23T04:56:07.000Z\";\n        } else if (ModelUtils.isDateSchema(schema)) {\n            return \"2000-01-23\";\n        } else if (ModelUtils.isBooleanSchema(schema)) {\n            return \"true\";\n        } else if (ModelUtils.isNumberSchema(schema)) {\n            if (ModelUtils.isFloatSchema(schema)) { // float\n                return \"1.3579\";\n            } else { // double\n                return \"3.149\";\n            }\n        } else if (ModelUtils.isPasswordSchema(schema)) {\n            return \"********\";\n        } else if (ModelUtils.isUUIDSchema(schema)) {\n            return \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\";\n            // do these last in case the specific types above are derived from these classes\n        } else if (ModelUtils.isStringSchema(schema)) {\n            return \"aeiou\";\n        } else if (ModelUtils.isIntegerSchema(schema)) {\n            if (ModelUtils.isLongSchema(schema)) { // long\n                return \"123456789\";\n            } else { //integer\n                return \"123\";\n            }\n        } else {\n            LOGGER.debug(\"default example value not implemented for {}. Default to UNDEFINED_EXAMPLE_VALUE\", schema);\n            return \"UNDEFINED_EXAMPLE_VALUE\";\n        }\n    }\n"
  },
  {
    "id": "runelite_runelite-23-Param-4",
    "old_comment_raw": "@param zOffset offset from ground plane",
    "old_code_raw": "\tpublic static Point getCanvasTextLocation(Client client, Graphics2D graphics, Point localLocation, String text, int zOffset)\n\t{\n\t\tint plane = client.getPlane();\n\n\t\tPoint p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset);\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tFontMetrics fm = graphics.getFontMetrics();\n\t\tRectangle2D bounds = fm.getStringBounds(text, graphics);\n\t\tint xOffset = p.getX() - (int) (bounds.getWidth() / 2);\n\n\t\treturn new Point(xOffset, p.getY());\n\t}\n",
    "new_code_raw": "\tpublic static Point getCanvasTextLocation(Client client, Graphics2D graphics, LocalPoint localLocation, String text, int zOffset)\n\t{\n\t\tint plane = client.getPlane();\n\n\t\tPoint p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset);\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tFontMetrics fm = graphics.getFontMetrics();\n\t\tRectangle2D bounds = fm.getStringBounds(text, graphics);\n\t\tint xOffset = p.getX() - (int) (bounds.getWidth() / 2);\n\n\t\treturn new Point(xOffset, p.getY());\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2579-Param-0",
    "old_comment_raw": "@param body client model (required)",
    "old_code_raw": "  public Client testClassname(Client body) throws ApiException {\n    return testClassnameWithHttpInfo(body).getData();\n      }\n",
    "new_code_raw": "  public Client testClassname(Client client) throws ApiException {\n    return testClassnameWithHttpInfo(client).getData();\n      }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-324-Param-5",
    "old_comment_raw": "@param formParams The form parameters",
    "old_code_raw": "  public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n",
    "new_code_raw": "  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n"
  },
  {
    "id": "apache_lenya-8-Associations-Param0",
    "old_comment_raw": "@param url DOCUMENT ME!",
    "old_code_raw": "    public String createFileName(URL url) {\n        File file = new File(directory_prefix + File.separator + url.getFile());\n\n        return file.getAbsolutePath();\n    }\n",
    "new_code_raw": "    public String createFileName(URL url, String prefixSubstitute, String substituteReplacement) {\n        File file = new File(directory_prefix + File.separator + url.getFile());\n        return file.getAbsolutePath().replaceAll(prefixSubstitute, substituteReplacement);\n    }\n\n"
  },
  {
    "id": "querydsl_querydsl-770-Param-0",
    "old_comment_raw": "@param indexSupport",
    "old_code_raw": "    public MultiIterator init(IndexSupport indexSupport){\n        this.indexSupport = indexSupport;\n        this.iterators = new Iterator<?>[sources.size()];\n        this.lastEntry = new boolean[iterators.length];\n        this.values = new Object[iterators.length];\n        return this;\n    }\n",
    "new_code_raw": "    public MultiIterator init(IteratorSource iteratorSource){\n        this.iteratorSource = iteratorSource;\n        this.iterators = new Iterator<?>[sources.size()];\n        this.lastEntry = new boolean[iterators.length];\n        this.values = new Object[iterators.length];\n        return this;\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2672-Param-0",
    "old_comment_raw": "@param parameter",
    "old_code_raw": "   protected String getParameterDataType(Parameter parameter, Property property) {\n        return null;\n   }\n",
    "new_code_raw": "    protected String getParameterDataType(Parameter parameter, Schema schema) {\n        return null;\n    }\n"
  },
  {
    "id": "debezium_debezium-732-Param-0",
    "old_comment_raw": "@param oplogEvent the event; may not be null",
    "old_code_raw": "        public int recordEvent(Document oplogEvent, long timestamp) throws InterruptedException {\n            return recordEvent(oplogEvent, oplogEvent, timestamp, 0);\n        }\n",
    "new_code_raw": "        public int recordEvent(Document oplogEvent, Instant timestamp) throws InterruptedException {\n            return recordEvent(oplogEvent, oplogEvent, timestamp, 0);\n        }\n"
  },
  {
    "id": "morristech_gwt-5-Associations-Param0",
    "old_comment_raw": "@param resourceName the relative path to a resource in the module's classpath.",
    "old_code_raw": "  InputStream openSourceFile(String resourceName) throws IOException {\n    URL resource = recompiler.getResourceLoader().getResource(resourceName);\n    return resource == null ? null : resource.openStream();\n  }\n",
    "new_code_raw": "  InputStream openSourceFile(String path) throws IOException {\n\n    if (path.startsWith(\"gen/\")) {\n      // generated file?\n      String rest = path.substring(\"gen/\".length());\n      File fileInGenDir = new File(getGenDir(), rest);\n      if (!fileInGenDir.isFile()) {\n        return null;\n      }\n      return new BufferedInputStream(new FileInputStream(fileInGenDir));\n    } else {\n      // regular source file?\n      URL resource = recompiler.getResourceLoader().getResource(path);\n      if (resource == null) {\n        return null;\n      }\n      return resource.openStream();\n    }\n  }\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-1203-Param-0",
    "old_comment_raw": "@param currentState The current state of the entity (the state to be checked).",
    "old_code_raw": "\tpublic int[] findDirty(Object[] currentState, Object[] previousState, Object entity, SessionImplementor session)\n\t\t\tthrows HibernateException {\n\t\tint[] props = TypeHelper.findDirty(\n\t\t\t\tentityMetamodel.getProperties(),\n\t\t\t\tcurrentState,\n\t\t\t\tpreviousState,\n\t\t\t\tpropertyColumnUpdateable,\n\t\t\t\thasUninitializedLazyProperties( entity ),\n\t\t\t\tsession\n\t\t);\n\t\tif ( props == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tlogDirtyProperties( props );\n\t\t\treturn props;\n\t\t}\n\t}\n",
    "new_code_raw": "\tpublic int[] findDirty(Object[] currentState, Object[] previousState, Object entity, SharedSessionContractImplementor session)\n\t\t\tthrows HibernateException {\n\t\tint[] props = TypeHelper.findDirty(\n\t\t\t\tentityMetamodel.getProperties(),\n\t\t\t\tcurrentState,\n\t\t\t\tpreviousState,\n\t\t\t\tpropertyColumnUpdateable,\n\t\t\t\thasUninitializedLazyProperties( entity ),\n\t\t\t\tsession\n\t\t);\n\t\tif ( props == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tlogDirtyProperties( props );\n\t\t\treturn props;\n\t\t}\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1677-Param-0",
    "old_comment_raw": "@param body client model (required)",
    "old_code_raw": "    public Single<Client> rxTestClassname(Client body) {\n        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {\n            delegate.testClassname(body, fut);\n        }));\n    }\n",
    "new_code_raw": "    public Single<Client> rxTestClassname(Client client) {\n        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {\n            delegate.testClassname(client, fut);\n        }));\n    }\n"
  },
  {
    "id": "apache_calcite-545-Param-0",
    "old_comment_raw": "@param project LogicalProject on the LHS of the semijoin",
    "old_code_raw": "  private RexNode adjustCondition(LogicalProject project, SemiJoin semiJoin) {\n    // create two RexPrograms -- the bottom one representing a\n    // concatenation of the project and the RHS of the semijoin and the\n    // top one representing the semijoin condition\n\n    RexBuilder rexBuilder = project.getCluster().getRexBuilder();\n    RelDataTypeFactory typeFactory = rexBuilder.getTypeFactory();\n    RelNode rightChild = semiJoin.getRight();\n\n    // for the bottom RexProgram, the input is a concatenation of the\n    // child of the project and the RHS of the semijoin\n    RelDataType bottomInputRowType =\n        SqlValidatorUtil.deriveJoinRowType(\n            project.getInput().getRowType(),\n            rightChild.getRowType(),\n            JoinRelType.INNER,\n            typeFactory,\n            null,\n            semiJoin.getSystemFieldList());\n    RexProgramBuilder bottomProgramBuilder =\n        new RexProgramBuilder(bottomInputRowType, rexBuilder);\n\n    // add the project expressions, then add input references for the RHS\n    // of the semijoin\n    for (Pair<RexNode, String> pair : project.getNamedProjects()) {\n      bottomProgramBuilder.addProject(pair.left, pair.right);\n    }\n    int nLeftFields = project.getInput().getRowType().getFieldCount();\n    List<RelDataTypeField> rightFields =\n        rightChild.getRowType().getFieldList();\n    int nRightFields = rightFields.size();\n    for (int i = 0; i < nRightFields; i++) {\n      final RelDataTypeField field = rightFields.get(i);\n      RexNode inputRef =\n          rexBuilder.makeInputRef(\n              field.getType(), i + nLeftFields);\n      bottomProgramBuilder.addProject(inputRef, field.getName());\n    }\n    RexProgram bottomProgram = bottomProgramBuilder.getProgram();\n\n    // input rowtype into the top program is the concatenation of the\n    // project and the RHS of the semijoin\n    RelDataType topInputRowType =\n        SqlValidatorUtil.deriveJoinRowType(\n            project.getRowType(),\n            rightChild.getRowType(),\n            JoinRelType.INNER,\n            typeFactory,\n            null,\n            semiJoin.getSystemFieldList());\n    RexProgramBuilder topProgramBuilder =\n        new RexProgramBuilder(\n            topInputRowType,\n            rexBuilder);\n    topProgramBuilder.addIdentity();\n    topProgramBuilder.addCondition(semiJoin.getCondition());\n    RexProgram topProgram = topProgramBuilder.getProgram();\n\n    // merge the programs and expand out the local references to form\n    // the new semijoin condition; it now references a concatenation of\n    // the project's child and the RHS of the semijoin\n    RexProgram mergedProgram =\n        RexProgramBuilder.mergePrograms(\n            topProgram,\n            bottomProgram,\n            rexBuilder);\n\n    return mergedProgram.expandLocalRef(\n        mergedProgram.getCondition());\n  }\n",
    "new_code_raw": "  private RexNode adjustCondition(LogicalProject project, LogicalJoin semiJoin) {\n    // create two RexPrograms -- the bottom one representing a\n    // concatenation of the project and the RHS of the semijoin and the\n    // top one representing the semijoin condition\n\n    RexBuilder rexBuilder = project.getCluster().getRexBuilder();\n    RelDataTypeFactory typeFactory = rexBuilder.getTypeFactory();\n    RelNode rightChild = semiJoin.getRight();\n\n    // for the bottom RexProgram, the input is a concatenation of the\n    // child of the project and the RHS of the semijoin\n    RelDataType bottomInputRowType =\n        SqlValidatorUtil.deriveJoinRowType(\n            project.getInput().getRowType(),\n            rightChild.getRowType(),\n            JoinRelType.INNER,\n            typeFactory,\n            null,\n            semiJoin.getSystemFieldList());\n    RexProgramBuilder bottomProgramBuilder =\n        new RexProgramBuilder(bottomInputRowType, rexBuilder);\n\n    // add the project expressions, then add input references for the RHS\n    // of the semijoin\n    for (Pair<RexNode, String> pair : project.getNamedProjects()) {\n      bottomProgramBuilder.addProject(pair.left, pair.right);\n    }\n    int nLeftFields = project.getInput().getRowType().getFieldCount();\n    List<RelDataTypeField> rightFields =\n        rightChild.getRowType().getFieldList();\n    int nRightFields = rightFields.size();\n    for (int i = 0; i < nRightFields; i++) {\n      final RelDataTypeField field = rightFields.get(i);\n      RexNode inputRef =\n          rexBuilder.makeInputRef(\n              field.getType(), i + nLeftFields);\n      bottomProgramBuilder.addProject(inputRef, field.getName());\n    }\n    RexProgram bottomProgram = bottomProgramBuilder.getProgram();\n\n    // input rowtype into the top program is the concatenation of the\n    // project and the RHS of the semijoin\n    RelDataType topInputRowType =\n        SqlValidatorUtil.deriveJoinRowType(\n            project.getRowType(),\n            rightChild.getRowType(),\n            JoinRelType.INNER,\n            typeFactory,\n            null,\n            semiJoin.getSystemFieldList());\n    RexProgramBuilder topProgramBuilder =\n        new RexProgramBuilder(\n            topInputRowType,\n            rexBuilder);\n    topProgramBuilder.addIdentity();\n    topProgramBuilder.addCondition(semiJoin.getCondition());\n    RexProgram topProgram = topProgramBuilder.getProgram();\n\n    // merge the programs and expand out the local references to form\n    // the new semijoin condition; it now references a concatenation of\n    // the project's child and the RHS of the semijoin\n    RexProgram mergedProgram =\n        RexProgramBuilder.mergePrograms(\n            topProgram,\n            bottomProgram,\n            rexBuilder);\n\n    return mergedProgram.expandLocalRef(\n        mergedProgram.getCondition());\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1639-Param-1",
    "old_comment_raw": "@param body Updated user object",
    "old_code_raw": "  public void updateUser (String username, User body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = body;\n    // verify the required parameter 'username' is set\n    if (username == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'username' when calling updateUser\",\n        new ApiException(400, \"Missing the required parameter 'username' when calling updateUser\"));\n    }\n    // verify the required parameter 'body' is set\n    if (body == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'body' when calling updateUser\",\n        new ApiException(400, \"Missing the required parameter 'body' when calling updateUser\"));\n    }\n\n    // create path and map variables\n    String path = \"/user/{username}\".replaceAll(\"\\\\{\" + \"username\" + \"\\\\}\", apiInvoker.escapeString(username.toString()));\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n    }\n\n    String[] authNames = new String[] {  };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"PUT\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n",
    "new_code_raw": "  public void updateUser (String username, User user) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = user;\n    // verify the required parameter 'username' is set\n    if (username == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'username' when calling updateUser\",\n        new ApiException(400, \"Missing the required parameter 'username' when calling updateUser\"));\n    }\n    // verify the required parameter 'user' is set\n    if (user == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'user' when calling updateUser\",\n        new ApiException(400, \"Missing the required parameter 'user' when calling updateUser\"));\n    }\n\n    // create path and map variables\n    String path = \"/user/{username}\".replaceAll(\"\\\\{\" + \"username\" + \"\\\\}\", apiInvoker.escapeString(username.toString()));\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n      \"application/json\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n    }\n\n    String[] authNames = new String[] {  };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"PUT\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n"
  },
  {
    "id": "apache_drill-929-Param-1",
    "old_comment_raw": "@param base the table part of the expansion",
    "old_code_raw": "  public static TupleMetadata expandMetadata(TupleMetadata base, FileMetadataManager metadataProj, int dirCount) {\n    TupleMetadata metadataSchema = new TupleSchema();\n    for (ColumnMetadata col : base) {\n      metadataSchema.addColumn(col);\n    }\n    for (FileMetadataColumnDefn fileColDefn : metadataProj.fileMetadataColDefns()) {\n      metadataSchema.add(MaterializedField.create(fileColDefn.colName(), fileColDefn.dataType()));\n    }\n    for (int i = 0; i < dirCount; i++) {\n      metadataSchema.add(MaterializedField.create(metadataProj.partitionName(i),\n          PartitionColumn.dataType()));\n    }\n    return metadataSchema;\n  }\n",
    "new_code_raw": "  public static TupleMetadata expandMetadata(TupleMetadata base, ImplicitColumnManager metadataProj, int dirCount) {\n    TupleMetadata metadataSchema = new TupleSchema();\n    for (ColumnMetadata col : base) {\n      metadataSchema.addColumn(col);\n    }\n    for (FileMetadataColumnDefn fileColDefn : metadataProj.fileMetadataColDefns()) {\n      metadataSchema.add(MaterializedField.create(fileColDefn.colName(), fileColDefn.dataType()));\n    }\n    for (int i = 0; i < dirCount; i++) {\n      metadataSchema.add(MaterializedField.create(metadataProj.partitionName(i),\n          PartitionColumn.dataType()));\n    }\n    return metadataSchema;\n  }\n"
  },
  {
    "id": "RobotiumTech_robotium-1191-Param-0",
    "old_comment_raw": "@param search the search string to be searched",
    "old_code_raw": "\tpublic boolean searchEditText(String search) {\n\t\tboolean found = searcher.searchWithTimeoutFor(EditText.class, search, 1, true);\n\t\treturn found;\n\t}\n",
    "new_code_raw": "\tpublic boolean searchEditText(String text) {\n\t\tboolean found = searcher.searchWithTimeoutFor(EditText.class, text, 1, true);\n\t\treturn found;\n\t}\n"
  },
  {
    "id": "querydsl_querydsl-1437-Param-0",
    "old_comment_raw": "@param left",
    "old_code_raw": "    public static EBoolean startsWith(Expr<String> left, Expr<String> right, boolean caseSensitive) {\n        if (caseSensitive){\n            return startsWith(left, right);            \n        }else{\n            return operationFactory.createBoolean(Ops.STARTSWITH_IC, left, right);\n        }\n    }\n",
    "new_code_raw": "    public static EBoolean startsWith(Expr<String> left, Expr<String> right) {\n        return operationFactory.createBoolean(Ops.STARTSWITH, left, right);\n    }\n"
  },
  {
    "id": "trygvis_jop-162-Associations-Param1",
    "old_comment_raw": "@param isClassMember If the signature is ambiguous, if true always assume that the last simple member name is a method or field, else assume it is a class name.",
    "old_code_raw": "    public static MemberID parse(String signature, boolean isClassMember) {\n        return parse(signature, isClassMember, null);\n    }\n",
    "new_code_raw": "    public static MemberID parse(String memberID, boolean isClassMember) {\n        return parse(memberID, isClassMember, null);\n    }\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-1204-Param-1",
    "old_comment_raw": "@param current The current state of the entity.",
    "old_code_raw": "\tpublic int[] findModified(Object[] old, Object[] current, Object entity, SessionImplementor session)\n\t\t\tthrows HibernateException {\n\t\tint[] props = TypeHelper.findModified(\n\t\t\t\tentityMetamodel.getProperties(),\n\t\t\t\tcurrent,\n\t\t\t\told,\n\t\t\t\tpropertyColumnUpdateable,\n\t\t\t\thasUninitializedLazyProperties( entity ),\n\t\t\t\tsession\n\t\t);\n\t\tif ( props == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tlogDirtyProperties( props );\n\t\t\treturn props;\n\t\t}\n\t}\n",
    "new_code_raw": "\tpublic int[] findModified(Object[] old, Object[] current, Object entity, SharedSessionContractImplementor session)\n\t\t\tthrows HibernateException {\n\t\tint[] props = TypeHelper.findModified(\n\t\t\t\tentityMetamodel.getProperties(),\n\t\t\t\tcurrent,\n\t\t\t\told,\n\t\t\t\tpropertyColumnUpdateable,\n\t\t\t\thasUninitializedLazyProperties( entity ),\n\t\t\t\tsession\n\t\t);\n\t\tif ( props == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tlogDirtyProperties( props );\n\t\t\treturn props;\n\t\t}\n\t}\n"
  },
  {
    "id": "SeleniumHQ_selenium-852-Param-0",
    "old_comment_raw": "@param commandName command to execute",
    "old_code_raw": "  ChromeResponse execute(String commandName, Object... parameters) {\n    Command command = new Command(new SessionId(\"[No sessionId]\"),\n                                  new Context(\"[No context]\"),\n                                  commandName,\n                                  parameters);\n    try {\n      return executor.execute(command);\n    } catch (Exception e) {\n      if (e instanceof IllegalArgumentException ||\n          e instanceof FatalChromeException) {\n        //These exceptions may leave the extension hung, or in an\n        //inconsistent state, so we restart Chrome\n        /*if (e instanceof FatalChromeException) {\n          try { Thread.sleep(100000000); } catch (InterruptedException e2) {}\n        }*/\n        stopClient();\n        init();\n      }\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException)e;\n      } else {\n        throw new WebDriverException(e);\n      }\n    }\n  }\n",
    "new_code_raw": "  ChromeResponse execute(DriverCommand driverCommand, Object... parameters) {\n    Command command = new Command(new SessionId(\"[No sessionId]\"),\n                                  new Context(\"[No context]\"),\n                                  driverCommand,\n                                  parameters);\n    try {\n      return executor.execute(command);\n    } catch (Exception e) {\n      if (e instanceof IllegalArgumentException ||\n          e instanceof FatalChromeException) {\n        //These exceptions may leave the extension hung, or in an\n        //inconsistent state, so we restart Chrome\n        stopClient();\n        init();\n      }\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException)e;\n      } else {\n        throw new WebDriverException(e);\n      }\n    }\n  }\n"
  },
  {
    "id": "graphql_java_graphql_java-377-Param-1",
    "old_comment_raw": "@param selectionSet the selection set to collect on",
    "old_code_raw": "    private void collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet, List<String> visitedFragments, Map<String, MergedFields> fields) {\n\n        for (Selection selection : selectionSet.getSelections()) {\n            if (selection instanceof Field) {\n                collectField(parameters, fields, (Field) selection);\n            } else if (selection instanceof InlineFragment) {\n                collectInlineFragment(parameters, visitedFragments, fields, (InlineFragment) selection);\n            } else if (selection instanceof FragmentSpread) {\n                collectFragmentSpread(parameters, visitedFragments, fields, (FragmentSpread) selection);\n            }\n        }\n    }\n",
    "new_code_raw": "    public MergedSelectionSet collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet) {\n        Map<String, MergedFields> subFields = new LinkedHashMap<>();\n        List<String> visitedFragments = new ArrayList<>();\n        this.collectFields(parameters, selectionSet, visitedFragments, subFields);\n        return newMergedSelectionSet().subFields(subFields).build();\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2428-Param-1",
    "old_comment_raw": "@param selector The property of the sentence we are getting the mode of. For example, Sentence::posTags",
    "old_code_raw": "  public List<String> dependencyPathBetween(int start, int end, Function<Sentence, List<String>> selector) {\n    // Get paths from a node to the root of the sentence\n    LinkedList<Integer> rootToStart = new LinkedList<>();\n    LinkedList<Integer> rootToEnd = new LinkedList<>();\n    int startAncestor = start;\n    List<Optional<Integer>> governors = sentence.governors();\n    Set<Integer> seenVertices = new HashSet<>();\n    while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) {\n      if (seenVertices.contains(startAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(startAncestor);\n      rootToStart.addFirst(startAncestor);\n      startAncestor = governors.get(startAncestor).get();\n    }\n    if (startAncestor == -1) {\n      rootToStart.addFirst(-1);\n    }\n    int endAncestor = end;\n    seenVertices.clear();\n    while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) {\n      if (seenVertices.contains(endAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(endAncestor);\n      rootToEnd.addFirst(endAncestor);\n      endAncestor = governors.get(endAncestor).get();\n    }\n    if (endAncestor == -1) {\n      rootToEnd.addFirst(-1);\n    }\n\n    // Get least common node\n    int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0;\n    for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) {\n      if (rootToStart.get(i).equals(rootToEnd.get(i))) {\n        leastCommonNodeIndex = i;\n      }\n    }\n\n    // Construct the path\n    if (leastCommonNodeIndex < 0) {\n      return Collections.EMPTY_LIST;\n    }\n    List<String> path = new ArrayList<>();\n    for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) {\n      path.add(selector.apply(sentence).get(rootToStart.get(i)));\n      path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\");\n    }\n    path.add(selector.apply(sentence).get(rootToStart.get(leastCommonNodeIndex)));\n    for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) {\n      path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\");\n      path.add(selector.apply(sentence).get(rootToEnd.get(i)));\n    }\n    return path;\n  }\n",
    "new_code_raw": "  public List<String> dependencyPathBetween(int start, int end, Optional<Function<Sentence, List<String>>> selector) {\n    // Get paths from a node to the root of the sentence\n    LinkedList<Integer> rootToStart = new LinkedList<>();\n    LinkedList<Integer> rootToEnd = new LinkedList<>();\n    int startAncestor = start;\n    List<Optional<Integer>> governors = sentence.governors();\n    Set<Integer> seenVertices = new HashSet<>();\n    while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) {\n      if (seenVertices.contains(startAncestor)) {\n        // Found loopiness -- revert to BFS\n        return loopyDependencyPathBetween(start, end, selector);\n      }\n      seenVertices.add(startAncestor);\n      rootToStart.addFirst(startAncestor);\n      startAncestor = governors.get(startAncestor).get();\n    }\n    if (startAncestor == -1) {\n      rootToStart.addFirst(-1);\n    }\n    int endAncestor = end;\n    seenVertices.clear();\n    while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) {\n      if (seenVertices.contains(endAncestor)) {\n        // Found loopiness -- revert to BFS\n        return loopyDependencyPathBetween(start, end, selector);\n      }\n      seenVertices.add(endAncestor);\n      rootToEnd.addFirst(endAncestor);\n      endAncestor = governors.get(endAncestor).get();\n    }\n    if (endAncestor == -1) {\n      rootToEnd.addFirst(-1);\n    }\n\n    // Get least common node\n    int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0;\n    for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) {\n      if (rootToStart.get(i).equals(rootToEnd.get(i))) {\n        leastCommonNodeIndex = i;\n      }\n    }\n\n    // Construct the path\n    if (leastCommonNodeIndex < 0) {\n      return Collections.emptyList();\n    }\n    List<String> path = new ArrayList<>();\n    Optional<List<String>> words = selector.map(x -> x.apply(sentence));\n    for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) {\n      final int index = i;\n      words.ifPresent(x -> path.add(x.get(rootToStart.get(index))));\n      path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\");\n    }\n    if (words.isPresent()) {\n      path.add(words.get().get(rootToStart.get(leastCommonNodeIndex)));\n    }\n    for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) {\n      final int index = i;\n      path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\");\n      words.ifPresent(x -> path.add(x.get(rootToEnd.get(index))));\n    }\n    return path;\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-413-Param-0",
    "old_comment_raw": "@param orderId ID of pet that needs to be fetched",
    "old_code_raw": "  public Order  getOrderById (String orderId) throws ApiException {\n    Object postBody = null;\n    \n    // verify the required parameter 'orderId' is set\n    if (orderId == null) {\n       throw new ApiException(400, \"Missing the required parameter 'orderId' when calling getOrderById\");\n    }\n    \n\n    // create path and map variables\n    String path = \"/store/order/{orderId}\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"orderId\" + \"\\\\}\", apiInvoker.escapeString(orderId.toString()));\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n\n    \n\n    \n\n    String[] contentTypes = {\n      \n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder builder = MultipartEntityBuilder.create();\n      \n\n      HttpEntity httpEntity = builder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n      \n    }\n\n    try {\n      String response = apiInvoker.invokeAPI(basePath, path, \"GET\", queryParams, postBody, headerParams, formParams, contentType);\n      if(response != null){\n        return (Order) ApiInvoker.deserialize(response, \"\", Order.class);\n      }\n      else {\n        return null;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n",
    "new_code_raw": "  public Order  getOrderById (Long orderId) throws ApiException {\n    Object postBody = null;\n    \n    // verify the required parameter 'orderId' is set\n    if (orderId == null) {\n       throw new ApiException(400, \"Missing the required parameter 'orderId' when calling getOrderById\");\n    }\n    \n\n    // create path and map variables\n    String path = \"/store/order/{orderId}\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"orderId\" + \"\\\\}\", apiInvoker.escapeString(orderId.toString()));\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n\n    \n\n    \n\n    String[] contentTypes = {\n      \n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder builder = MultipartEntityBuilder.create();\n      \n\n      HttpEntity httpEntity = builder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n      \n    }\n\n    try {\n      String response = apiInvoker.invokeAPI(basePath, path, \"GET\", queryParams, postBody, headerParams, formParams, contentType);\n      if(response != null){\n        return (Order) ApiInvoker.deserialize(response, \"\", Order.class);\n      }\n      else {\n        return null;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n"
  },
  {
    "id": "zaproxy_zaproxy-2225-Param-0",
    "old_comment_raw": "@param destURL the url param of FindProxyForURL(url, host)",
    "old_code_raw": "    public String evaluate(String destURL, String destHost) throws ScriptException {\n        try {\n            return (String) pacImpl.invokeFunction(\"FindProxyForURL\", destURL, destHost);\n        } catch (NoSuchMethodException | ScriptAbuseException e) {\n            throw new ScriptException(e);\n        }\n    }\n",
    "new_code_raw": "    String evaluate(String url, String host) throws ScriptException {\n        try {\n            return (String) pacImpl.invokeFunction(\"FindProxyForURL\", url, host);\n        } catch (NoSuchMethodException | ScriptAbuseException e) {\n            throw new ScriptException(e);\n        }\n    }\n"
  },
  {
    "id": "alibaba_jstorm-12-Param-4",
    "old_comment_raw": "@param port",
    "old_code_raw": "\tpublic static void redirectOutput(String port) throws Exception {\n\n\t\tif (System.getenv(\"REDIRECT\") == null\n\t\t\t\t|| !System.getenv(\"REDIRECT\").equals(\"true\")) {\n\t\t\treturn;\n\t\t}\n\n\t\tString OUT_TARGET_FILE = JStormUtils.getLogFileName();\n\t\tif (OUT_TARGET_FILE == null) {\n\t\t\tOUT_TARGET_FILE = \"/dev/null\";\n\t\t} else {\n\t\t\tOUT_TARGET_FILE += \".out\";\n\t\t}\n\n\t\tJStormUtils.redirectOutput(OUT_TARGET_FILE);\n\n\t}\n",
    "new_code_raw": "\tpublic void redirectOutput(){\n\n\t\tif (System.getenv(\"REDIRECT\") == null\n\t\t\t\t|| !System.getenv(\"REDIRECT\").equals(\"true\")) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tString DEFAULT_OUT_TARGET_FILE = JStormUtils.getLogFileName();\n\t\tif (DEFAULT_OUT_TARGET_FILE == null) {\n\t\t\tDEFAULT_OUT_TARGET_FILE = \"/dev/null\";\n\t\t} else {\n\t\t\tDEFAULT_OUT_TARGET_FILE += \".out\";\n\t\t}\n\t\t\n\t\tString outputFile = ConfigExtension.getWorkerRedirectOutputFile(workerData.getStormConf());\n\t\tif (outputFile == null) {\n\t\t\toutputFile = DEFAULT_OUT_TARGET_FILE;\n\t\t}else {\n\t\t\ttry {\n\t\t\t\tFile file = new File(outputFile);\n\t\t\t\tif (file.exists() == false) {\n\t\t\t\t\tPathUtils.touch(outputFile);\n\t\t\t\t}else {\n\t\t\t\t\tif (file.isDirectory() == true) {\n\t\t\t\t\t\tLOG.warn(\"Failed to write \" + outputFile);\n\t\t\t\t\t\toutputFile = DEFAULT_OUT_TARGET_FILE;\n\t\t\t\t\t}else if (file.canWrite() == false) {\n\t\t\t\t\t\tLOG.warn(\"Failed to write \" + outputFile);\n\t\t\t\t\t\toutputFile = DEFAULT_OUT_TARGET_FILE;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}catch(Exception e) {\n\t\t\t\tLOG.warn(\"Failed to touch \" + outputFile, e);\n\t\t\t\toutputFile = DEFAULT_OUT_TARGET_FILE;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tJStormUtils.redirectOutput(outputFile);\n\t\t}catch(Exception e) {\n\t\t\tLOG.warn(\"Failed to redirect to \" + outputFile, e);\n\t\t}\n\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1676-Param-0",
    "old_comment_raw": "@param body order placed for purchasing the pet",
    "old_code_raw": "    public Order placeOrder(Order body) throws RestClientException {\n        Object postBody = body;\n        \n        // verify the required parameter 'body' is set\n        if (body == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling placeOrder\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"/store/order\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application/xml\", \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Order> returnType = new ParameterizedTypeReference<Order>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "new_code_raw": "    public Order placeOrder(Order order) throws RestClientException {\n        Object postBody = order;\n        \n        // verify the required parameter 'order' is set\n        if (order == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'order' when calling placeOrder\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"/store/order\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application/xml\", \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Order> returnType = new ParameterizedTypeReference<Order>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n"
  },
  {
    "id": "apache_flume-41-Param-0",
    "old_comment_raw": "@param event",
    "old_code_raw": "  private Object deserialize(Event event, Object reuse)\n      throws EventDeliveryException {\n    decoder = DecoderFactory.get().binaryDecoder(event.getBody(), decoder);\n    // no checked exception is thrown in the CacheLoader\n    ReflectDatumReader<Object> reader = readers.getUnchecked(schema(event));\n    try {\n      return reader.read(reuse, decoder);\n    } catch (IOException ex) {\n      throw new EventDeliveryException(\"Cannot deserialize event\", ex);\n    }\n  }\n",
    "new_code_raw": "  private GenericRecord deserialize(Event event, GenericRecord reuse)\n      throws EventDeliveryException {\n    decoder = DecoderFactory.get().binaryDecoder(event.getBody(), decoder);\n    // no checked exception is thrown in the CacheLoader\n    DatumReader<GenericRecord> reader = readers.getUnchecked(schema(event));\n    try {\n      return reader.read(reuse, decoder);\n    } catch (IOException ex) {\n      throw new EventDeliveryException(\"Cannot deserialize event\", ex);\n    }\n  }\n"
  },
  {
    "id": "runelite_runelite-105-Param-0",
    "old_comment_raw": "@param indexId",
    "old_code_raw": "\tpublic static DataFileReadResult decompress(byte[] b)\n\t{\n\t\tInputStream stream = new InputStream(b);\n\t\t\n\t\tint compression = stream.readUnsignedByte();\n\t\tint compressedLength = stream.readInt();\n\t\tif (compressedLength < 0 || compressedLength > 1000000)\n\t\t\tthrow new RuntimeException(\"Invalid data\");\n\t\t\n\t\tbyte[] data;\n\t\tint revision;\n\t\tswitch (compression)\n\t\t{\n\t\t\tcase CompressionType.NONE:\n\t\t\t\tdata = new byte[compressedLength];\n\t\t\t\trevision = checkRevision(stream, compressedLength);\n\t\t\t\tstream.readBytes(data, 0, compressedLength);\n\t\t\t\tbreak;\n\t\t\tcase CompressionType.BZ2:\n\t\t\t{\n\t\t\t\tint length = stream.readInt();\n\t\t\t\trevision = checkRevision(stream, compressedLength);\n\t\t\t\tdata = BZip2.decompress(stream.getRemaining(), compressedLength);\n\t\t\t\tassert data.length == length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CompressionType.GZ:\n\t\t\t{\n\t\t\t\tint length = stream.readInt();\n\t\t\t\trevision = checkRevision(stream, compressedLength);\n\t\t\t\tdata = GZip.decompress(stream.getRemaining(), compressedLength);\n\t\t\t\tassert data.length == length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException(\"Unknown decompression type\");\n\t\t}\n\t\t\n\t\tDataFileReadResult res = new DataFileReadResult();\n\t\tres.data = data;\n\t\tres.revision = revision;\n\t\tint length = revision != -1 ? b.length - 2 : b.length;\n\t\tres.crc = CRC32HGenerator.getHash(b, length);\n\t\tres.whirlpool = Whirlpool.getHash(b, length);\n\t\tres.compression = compression;\n\t\treturn res;\n\t}\n",
    "new_code_raw": "\tpublic static DataFileReadResult decompress(byte[] b, int[] keys)\n\t{\n\t\tInputStream stream = new InputStream(b);\n\t\t\n\t\tint compression = stream.readUnsignedByte();\n\t\tint compressedLength = stream.readInt();\n\t\tif (compressedLength < 0 || compressedLength > 1000000)\n\t\t\tthrow new RuntimeException(\"Invalid data\");\n\n\t\tCrc32 crc32 = new Crc32();\n\t\tcrc32.update(b, 0, 5); // compression + length\n\t\t\n\t\tbyte[] data;\n\t\tint revision = -1;\n\t\tswitch (compression)\n\t\t{\n\t\t\tcase CompressionType.NONE:\n\t\t\t{\n\t\t\t\tbyte[] encryptedData = new byte[compressedLength];\n\t\t\t\tstream.readBytes(encryptedData, 0, compressedLength);\n\n\t\t\t\tcrc32.update(encryptedData, 0, compressedLength);\n\t\t\t\tbyte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys);\n\n\t\t\t\tif (stream.remaining() >= 2)\n\t\t\t\t{\n\t\t\t\t\trevision = stream.readUnsignedShort();\n\t\t\t\t\tassert revision != -1;\n\t\t\t\t}\n\n\t\t\t\tdata = decryptedData;\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CompressionType.BZ2:\n\t\t\t{\n\t\t\t\tbyte[] encryptedData = new byte[compressedLength + 4];\n\t\t\t\tstream.readBytes(encryptedData);\n\n\t\t\t\tcrc32.update(encryptedData, 0, encryptedData.length);\n\t\t\t\tbyte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys);\n\n\t\t\t\tif (stream.remaining() >= 2)\n\t\t\t\t{\n\t\t\t\t\trevision = stream.readUnsignedShort();\n\t\t\t\t\tassert revision != -1;\n\t\t\t\t}\n\n\t\t\t\tstream = new InputStream(decryptedData);\n\n\t\t\t\tint decompressedLength = stream.readInt();\n\t\t\t\tdata = BZip2.decompress(stream.getRemaining(), compressedLength);\n\n\t\t\t\tif (data == null)\n\t\t\t\t{\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tassert data.length == decompressedLength;\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CompressionType.GZ:\n\t\t\t{\n\t\t\t\tbyte[] encryptedData = new byte[compressedLength + 4];\n\t\t\t\tstream.readBytes(encryptedData);\n\n\t\t\t\tcrc32.update(encryptedData, 0, encryptedData.length);\n\t\t\t\tbyte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys);\n\n\t\t\t\tif (stream.remaining() >= 2)\n\t\t\t\t{\n\t\t\t\t\trevision = stream.readUnsignedShort();\n\t\t\t\t\tassert revision != -1;\n\t\t\t\t}\n\n\t\t\t\tstream = new InputStream(decryptedData);\n\n\t\t\t\tint decompressedLength = stream.readInt();\n\t\t\t\tdata = GZip.decompress(stream.getRemaining(), compressedLength);\n\n\t\t\t\tif (data == null)\n\t\t\t\t{\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tassert data.length == decompressedLength;\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException(\"Unknown decompression type\");\n\t\t}\n\t\t\n\t\tDataFileReadResult res = new DataFileReadResult();\n\t\tres.data = data;\n\t\tres.revision = revision;\n\t\tint length = revision != -1 ? b.length - 2 : b.length;;\n\t\tres.crc = crc32.getHash();\n\t\tres.whirlpool = Whirlpool.getHash(b, length);\n\t\tres.compression = compression;\n\t\treturn res;\n\t}\n"
  },
  {
    "id": "querydsl_querydsl-787-Param-0",
    "old_comment_raw": "@param collection",
    "old_code_raw": "    public static EBoolean isNotEmpty(PCollection<?> collection) {\n        return operationFactory.createBoolean(Ops.COL_ISNOTEMPTY,(Expr<?>) collection);\n    }\n",
    "new_code_raw": "    public static EBoolean isNotEmpty(ECollection<?> collection) {\n        return operationFactory.createBoolean(Ops.COL_ISNOTEMPTY,(Expr<?>) collection);\n    }\n"
  },
  {
    "id": "trygvis_jop-162-Associations-Param0",
    "old_comment_raw": "@param signature the signature to parse.",
    "old_code_raw": "    public static MemberID parse(String signature, boolean isClassMember) {\n        return parse(signature, isClassMember, null);\n    }\n",
    "new_code_raw": "    public static MemberID parse(String memberID, boolean isClassMember) {\n        return parse(memberID, isClassMember, null);\n    }\n\n"
  },
  {
    "id": "apache_drill-753-Param-0",
    "old_comment_raw": "@param col - column for which non-null rowcount is desired",
    "old_code_raw": "  public Double getNNRowCount(String col) {\n    // Stats might not have materialized because of errors.\n    if (!materialized) {\n      return null;\n    }\n    final String upperCol = col.toUpperCase();\n    Long nnRowCntCol = nnRowCount.get(upperCol);\n    if (nnRowCntCol == null) {\n      nnRowCntCol = nnRowCount.get(SchemaPath.getSimplePath(upperCol).toString());\n    }\n    // Cap it at row count (just in case)\n    if (nnRowCntCol != null) {\n      return Math.min(nnRowCntCol, rowCount);\n    }\n    return null;\n  }\n",
    "new_code_raw": "  public Double getNNRowCount(SchemaPath col) {\n    // Stats might not have materialized because of errors.\n    if (!materialized) {\n      return null;\n    }\n    Long nnRowCntCol = nnRowCount.get(col);\n    // Cap it at row count (just in case)\n    if (nnRowCntCol != null) {\n      return Math.min(nnRowCntCol, rowCount);\n    }\n    return null;\n  }\n"
  },
  {
    "id": "querydsl_querydsl-1421-Param-1",
    "old_comment_raw": "@param template",
    "old_code_raw": "    public RelationalFunctionCall(Class<? extends T> type, String template, Expression<?>... args) {\n        super(type);\n        this.args = Arrays.asList(Assert.notNull(args,\"args\"));\n        this.template = TemplateFactory.DEFAULT.create(Assert.notNull(template,\"template\"));\n    }    \n",
    "new_code_raw": "    public RelationalFunctionCall(Class<? extends T> type, String function, Object... args) {\n        super(type);\n        this.args = normalizeArgs(args);\n        this.template = createTemplate(function, args.length);\n    }    \n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1556-Param-6",
    "old_comment_raw": "@param authNames The authentications to apply",
    "old_code_raw": "  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    final String url = buildUrl(path, queryParams);\n    final Request.Builder reqBuilder = new Request.Builder().url(url);\n    processHeaderParams(headerParams, reqBuilder);\n\n    String contentType = (String) headerParams.get(\"Content-Type\");\n    // ensuring a default content type\n    if (contentType == null) {\n      contentType = \"application/json\";\n    }\n\n    RequestBody reqBody;\n    if (!HttpMethod.permitsRequestBody(method)) {\n      reqBody = null;\n    } else if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n      reqBody = buildRequestBodyFormEncoding(formParams);\n    } else if (\"multipart/form-data\".equals(contentType)) {\n      reqBody = buildRequestBodyMultipart(formParams);\n    } else if (body == null) {\n      if (\"DELETE\".equals(method)) {\n        // allow calling DELETE without sending a request body\n        reqBody = null;\n      } else {\n        // use an empty request body (for POST, PUT and PATCH)\n        reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n      }\n    } else {\n      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));\n    }\n\n    Request request = null;\n\n    if(progressRequestListener != null && reqBody != null) {\n      ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener);\n      request = reqBuilder.method(method, progressRequestBody).build();\n    } else {\n      request = reqBuilder.method(method, reqBody).build();\n    }\n\n    return httpClient.newCall(request);\n  }\n",
    "new_code_raw": "  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    final String url = buildUrl(path, queryParams);\n    final Request.Builder reqBuilder = new Request.Builder().url(url);\n    processHeaderParams(headerParams, reqBuilder);\n\n    String contentType = (String) headerParams.get(\"Content-Type\");\n    // ensuring a default content type\n    if (contentType == null) contentType = \"application/json\";\n\n    RequestBody reqBody;\n    if (!HttpMethod.permitsRequestBody(method)) {\n      reqBody = null;\n    } else if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n      reqBody = buildRequestBodyFormEncoding(formParams);\n    } else if (\"multipart/form-data\".equals(contentType)) {\n      reqBody = buildRequestBodyMultipart(formParams);\n    } else if (body == null) {\n      if (\"DELETE\".equals(method)) {\n        // allow calling DELETE without sending a request body\n        reqBody = null;\n      } else {\n        // use an empty request body (for POST, PUT and PATCH)\n        reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n      }\n    } else {\n      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));\n    }\n\n    Request request = reqBuilder.method(method, reqBody).build();\n    return httpClient.newCall(request);\n  }\n"
  },
  {
    "id": "debezium_debezium-1264-Param-0",
    "old_comment_raw": "@param value the local or SQL date, time, or timestamp value; may not be null",
    "old_code_raw": "    public static long toMicroOfDay(Object value, TemporalAdjuster adjuster) {\n        // conversion to nanos is fine as TIME values won't exceed long range\n        if (value instanceof Duration) {\n            return ((Duration) value).toNanos() / 1_000;\n        }\n\n        LocalTime time = Conversions.toLocalTime(value);\n        if (adjuster != null) {\n            time = time.with(adjuster);\n        }\n        return Math.floorDiv(time.toNanoOfDay(), Conversions.NANOSECONDS_PER_MICROSECOND);\n    }\n",
    "new_code_raw": "    public static long toMicroOfDay(Object value, boolean acceptLargeValues) {\n        if (value instanceof Duration) {\n            Duration duration = (Duration) value;\n            if (!acceptLargeValues && (duration.isNegative() || duration.compareTo(ONE_DAY) > 0)) {\n                throw new IllegalArgumentException(\"Time values must be between 00:00:00 and 24:00:00 (inclusive): \" + duration);\n            }\n\n            // conversion to nanos is fine as TIME values won't exceed long range\n            return ((Duration) value).toNanos() / 1_000;\n        }\n\n        // TODO only needed for SQL Server/Oracle, where we don't produce Duration right away;\n        // this should go eventually, as the conversion to LocalTime is superfluous\n        LocalTime time = Conversions.toLocalTime(value);\n        return Math.floorDiv(time.toNanoOfDay(), Conversions.NANOSECONDS_PER_MICROSECOND);\n    }\n"
  },
  {
    "id": "SeleniumHQ_selenium-453-Param-0",
    "old_comment_raw": "@param browser",
    "old_code_raw": "  public static RemoteProxy getNewBasicRemoteProxy(String browser, String url, Registry registry) throws MalformedURLException {\n\n    GridNodeConfiguration config = new GridNodeConfiguration();\n    URL u = new URL(url);\n    config.host = u.getHost();\n    config.port = u.getPort();\n    config.role = \"webdriver\";\n    RegistrationRequest req = RegistrationRequest.build(config);\n    req.getConfiguration().capabilities.clear();\n\n    DesiredCapabilities capability = new DesiredCapabilities();\n    capability.setBrowserName(browser);\n    req.getConfiguration().capabilities.add(capability);\n\n    return createProxy(registry, req);\n\n  }\n",
    "new_code_raw": "  public static RemoteProxy getNewBasicRemoteProxy(String browser, String url, GridRegistry registry) throws MalformedURLException {\n\n    GridNodeConfiguration config = new GridNodeConfiguration();\n    URL u = new URL(url);\n    config.host = u.getHost();\n    config.port = u.getPort();\n    config.role = \"webdriver\";\n    RegistrationRequest req = RegistrationRequest.build(config);\n    req.getConfiguration().capabilities.clear();\n\n    DesiredCapabilities capability = new DesiredCapabilities();\n    capability.setBrowserName(browser);\n    req.getConfiguration().capabilities.add(capability);\n\n    return createProxy(registry, req);\n\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2577-Param-0",
    "old_comment_raw": "@param body Input boolean as post body (optional)",
    "old_code_raw": "  public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException {\n    return fakeOuterBooleanSerializeWithHttpInfo(body).getData();\n      }\n",
    "new_code_raw": "  public Boolean fakeOuterBooleanSerialize(Boolean booleanPostBody) throws ApiException {\n    return fakeOuterBooleanSerializeWithHttpInfo(booleanPostBody).getData();\n      }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1220-Param-4",
    "old_comment_raw": "@param version the item version number",
    "old_code_raw": "\tpublic boolean putFromLoad(SessionImplementor session, Object key, Object value, long txTimestamp, Object version, boolean minimalPutOverride)\n\t\t\tthrows CacheException {\n\t\tif ( !region.checkValid() ) {\n\t\t\tif ( TRACE_ENABLED ) {\n\t\t\t\tlog.tracef( \"Region %s not valid\", region.getName() );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// In theory, since putForExternalRead is already as minimal as it can\n\t\t// get, we shouldn't be need this check. However, without the check and\n\t\t// without https://issues.jboss.org/browse/ISPN-1986, it's impossible to\n\t\t// know whether the put actually occurred. Knowing this is crucial so\n\t\t// that Hibernate can expose accurate statistics.\n\t\tif ( minimalPutOverride && cache.containsKey( key ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tPutFromLoadValidator.Lock lock = putValidator.acquirePutFromLoadLock(session, key, txTimestamp);\n\t\tif ( lock == null) {\n\t\t\tif ( TRACE_ENABLED ) {\n\t\t\t\tlog.tracef( \"Put from load lock not acquired for key %s\", key );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\t\t\twriteCache.putForExternalRead( key, value );\n\t\t}\n\t\tfinally {\n\t\t\tputValidator.releasePutFromLoadLock( key, lock);\n\t\t}\n\n\t\treturn true;\n\t}\n",
    "new_code_raw": "\tpublic boolean putFromLoad(SharedSessionContractImplementor session, Object key, Object value, long txTimestamp, Object version, boolean minimalPutOverride)\n\t\t\tthrows CacheException {\n\t\tif ( !region.checkValid() ) {\n\t\t\tif ( TRACE_ENABLED ) {\n\t\t\t\tlog.tracef( \"Region %s not valid\", region.getName() );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// In theory, since putForExternalRead is already as minimal as it can\n\t\t// get, we shouldn't be need this check. However, without the check and\n\t\t// without https://issues.jboss.org/browse/ISPN-1986, it's impossible to\n\t\t// know whether the put actually occurred. Knowing this is crucial so\n\t\t// that Hibernate can expose accurate statistics.\n\t\tif ( minimalPutOverride && cache.containsKey( key ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tPutFromLoadValidator.Lock lock = putValidator.acquirePutFromLoadLock(session, key, txTimestamp);\n\t\tif ( lock == null) {\n\t\t\tif ( TRACE_ENABLED ) {\n\t\t\t\tlog.tracef( \"Put from load lock not acquired for key %s\", key );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\t\t\twriteCache.putForExternalRead( key, value );\n\t\t}\n\t\tfinally {\n\t\t\tputValidator.releasePutFromLoadLock( key, lock);\n\t\t}\n\n\t\treturn true;\n\t}\n"
  },
  {
    "id": "codehaus_cake-12-Associations-Param0",
    "old_comment_raw": "@param attributes an object containing an AttributeMap",
    "old_code_raw": "    public long get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n",
    "new_code_raw": "    public long get(WithAttributes withAttributes) {\r\n        return withAttributes.getAttributes().get(this);\r\n    }\r\n\n"
  },
  {
    "id": "apache_activemq-1068-Param-0",
    "old_comment_raw": "@param timeout",
    "old_code_raw": "    public boolean waitForSpace(long timeout) throws InterruptedException {\n        if (parent != null) {\n            if (!parent.waitForSpace(timeout)) {\n                return false;\n            }\n        }\n        synchronized (usageMutex) {\n            percentUsage=caclPercentUsage();\n            if (percentUsage >= 100) {\n                long deadline = timeout > 0 ? System.currentTimeMillis() + timeout : Long.MAX_VALUE;\n                long timeleft = deadline;\n                while (timeleft > 0) {\n                    percentUsage=caclPercentUsage();\n                    if (percentUsage >= 100) {\n                        usageMutex.wait(pollingTime);\n                        timeleft = deadline - System.currentTimeMillis();\n                    } else {\n                        break;\n                    }\n                }\n            }\n            return percentUsage < 100;\n        }\n    }\n",
    "new_code_raw": "    public boolean waitForSpace(long timeout, int highWaterMark) throws InterruptedException {\n        if (parent != null) {\n            if (!parent.waitForSpace(timeout, highWaterMark)) {\n                return false;\n            }\n        }\n        synchronized (usageMutex) {\n            percentUsage=caclPercentUsage();\n            if (percentUsage >= highWaterMark) {\n                long deadline = timeout > 0 ? System.currentTimeMillis() + timeout : Long.MAX_VALUE;\n                long timeleft = deadline;\n                while (timeleft > 0) {\n                    percentUsage=caclPercentUsage();\n                    if (percentUsage >= highWaterMark) {\n                        usageMutex.wait(pollingTime);\n                        timeleft = deadline - System.currentTimeMillis();\n                    } else {\n                        break;\n                    }\n                }\n            }\n            return percentUsage < highWaterMark;\n        }\n    }\n"
  },
  {
    "id": "zaproxy_zaproxy-2127-Param-0",
    "old_comment_raw": "@param channel",
    "old_code_raw": "\t\tprivate ByteBuffer read(SocketChannel channel, int length) throws IOException {\n\t\t\tByteBuffer buffer = ByteBuffer.allocate(length);\n\t\t\t\n\t\t\tint bytesRead = 0;\n\t\t\tdo {\n\t\t\t\tbytesRead += channel.read(buffer);\n\t\t\t} while (length != bytesRead);\n\t\t\t\n\t\t\tbuffer.flip();\n\t\t\t\n\t\t\tint freeSpace = currentFrame.capacity() - currentFrame.position();\n\t\t\tif (freeSpace < bytesRead) {\n\t\t\t\tcurrentFrame = reallocate(currentFrame, currentFrame.position() + bytesRead);\n\t\t\t}\n\n\t\t\t// add bytes to current frame and reset to be able to read again\n\t\t\tcurrentFrame.put(buffer);\n\t\t\tbuffer.rewind();\n\t\t\t\n\t\t\treturn buffer;\n\t\t}\n",
    "new_code_raw": "\t\tprivate byte[] read(InputStream in, int length) throws IOException {\n\t\t\tbyte[] buffer = new byte[length];\n\t\t\t\n\t\t\tint bytesRead = 0;\n\t\t\tdo {\n\t\t\t\tbytesRead += in.read(buffer);\n\t\t\t} while (length != bytesRead);\n\t\t\t\n\t\t\tint freeSpace = currentFrame.capacity() - currentFrame.position();\n\t\t\tif (freeSpace < bytesRead) {\n\t\t\t\tcurrentFrame = reallocate(currentFrame, currentFrame.position() + bytesRead);\n\t\t\t}\n\n\t\t\t// add bytes to current frame and reset to be able to read again\n\t\t\tcurrentFrame.put(buffer);\n\t\t\t\n\t\t\treturn buffer;\n\t\t}\n"
  },
  {
    "id": "RobotiumTech_robotium-1203-Param-1",
    "old_comment_raw": "@param timeout the amount of time in milliseconds to wait",
    "old_code_raw": "\tpublic boolean waitForActivity(Class<? extends Activity> clazz, int timeout){\n\t\tfinal long endTime = SystemClock.uptimeMillis() + timeout;\n\t\tActivity currentActivity = activityUtils.getCurrentActivity(false);\n\n\t\twhile(SystemClock.uptimeMillis() < endTime){\n\t\t\tif(currentActivity != null && currentActivity.getClass().equals(clazz))\n\t\t\t\treturn true;\n\n\t\t\tcurrentActivity = activityUtils.getCurrentActivity();\n\t\t}\n\t\treturn false;\n\t}\n",
    "new_code_raw": "\tpublic boolean waitForActivity(Class<? extends Activity> activityClass, int timeout){\n\t\tfinal long endTime = SystemClock.uptimeMillis() + timeout;\n\t\tActivity currentActivity = activityUtils.getCurrentActivity(false);\n\n\t\twhile(SystemClock.uptimeMillis() < endTime){\n\t\t\tif(currentActivity != null && currentActivity.getClass().equals(activityClass))\n\t\t\t\treturn true;\n\n\t\t\tcurrentActivity = activityUtils.getCurrentActivity();\n\t\t}\n\t\treturn false;\n\t}\n"
  },
  {
    "id": "hibernate_hibernate_orm-1910-Param-1",
    "old_comment_raw": "@param aliasedLockOptions a map of lock options indexed by aliased table names.",
    "old_code_raw": "\tpublic String applyLocksToSql(String sql, Map aliasedLockOptions, Map keyColumnNames) {\n\t\treturn sql + new ForUpdateFragment( this, aliasedLockOptions, keyColumnNames ).toFragmentString();\n\t}\n",
    "new_code_raw": "\tpublic String applyLocksToSql(String sql, LockOptions aliasedLockOptions, Map keyColumnNames) {\n\t\treturn sql + new ForUpdateFragment( this, aliasedLockOptions, keyColumnNames ).toFragmentString();\n\t}\n"
  },
  {
    "id": "querydsl_querydsl-1421-Param-0",
    "old_comment_raw": "@param type",
    "old_code_raw": "    public RelationalFunctionCall(Class<? extends T> type, String template, Expression<?>... args) {\n        super(type);\n        this.args = Arrays.asList(Assert.notNull(args,\"args\"));\n        this.template = TemplateFactory.DEFAULT.create(Assert.notNull(template,\"template\"));\n    }    \n",
    "new_code_raw": "    public RelationalFunctionCall(Class<? extends T> type, String function, Object... args) {\n        super(type);\n        this.args = normalizeArgs(args);\n        this.template = createTemplate(function, args.length);\n    }    \n"
  },
  {
    "id": "eclipse_rt.equinox.bundles-62-Associations-Param1",
    "old_comment_raw": "@param environment the current environment, which may affect the behavior of the expert. This parameter may be specified as null, in which case the  STextEnvironment#DEFAULT environment should be assumed.",
    "old_code_raw": "\tstatic public ISTextExpert getStatefulExpert(String type, STextEnvironment environment) {\n\t\tSTextTypeHandler handler = STextTypeHandlerFactory.getHandler(type);\n\t\tif (handler == null)\n\t\t\tthrow new IllegalArgumentException(\"Invalid type argument\"); //$NON-NLS-1$\n\t\treturn getStatefulExpert(handler, environment);\n\t}\n",
    "new_code_raw": "\tstatic public IStructuredTextExpert getStatefulExpert(String type, StructuredTextEnvironment environment) {\n\t\tStructuredTextTypeHandler handler = StructuredTextTypeHandlerFactory.getHandler(type);\n\t\tif (handler == null)\n\t\t\tthrow new IllegalArgumentException(\"Invalid type argument\"); //$NON-NLS-1$\n\t\treturn getStatefulExpert(handler, environment);\n\t}\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-919-Param-0",
    "old_comment_raw": "@param orderId ID of pet that needs to be fetched",
    "old_code_raw": "  public Order  getOrderById (String orderId) throws ApiException {\n    Object localVarPostBody = null;\n    \n    // verify the required parameter 'orderId' is set\n    if (orderId == null) {\n       throw new ApiException(400, \"Missing the required parameter 'orderId' when calling getOrderById\");\n    }\n    \n\n    // create path and map variables\n    String localVarPath = \"/store/order/{orderId}\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"orderId\" + \"\\\\}\", apiInvoker.escapeString(orderId.toString()));\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> localVarFormParams = new HashMap<String, String>();\n\n\n\n    String[] localVarContentTypes = {\n      \n    };\n    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application/json\";\n\n    if (localVarContentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      \n\n      localVarPostBody = localVarBuilder.build();\n    } else {\n      // normal form params\n          }\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);\n      if(localVarResponse != null){\n        return (Order) ApiInvoker.deserialize(localVarResponse, \"\", Order.class);\n      }\n      else {\n        return null;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n",
    "new_code_raw": "  public Order  getOrderById (Long orderId) throws ApiException {\n    Object localVarPostBody = null;\n    // verify the required parameter 'orderId' is set\n    if (orderId == null) {\n       throw new ApiException(400, \"Missing the required parameter 'orderId' when calling getOrderById\");\n    }\n\n    // create path and map variables\n    String localVarPath = \"/store/order/{orderId}\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"orderId\" + \"\\\\}\", apiInvoker.escapeString(orderId.toString()));\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> localVarFormParams = new HashMap<String, String>();\n\n\n\n    String[] localVarContentTypes = {\n      \n    };\n    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application/json\";\n\n    if (localVarContentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      \n\n      localVarPostBody = localVarBuilder.build();\n    } else {\n      // normal form params\n          }\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);\n      if(localVarResponse != null){\n        return (Order) ApiInvoker.deserialize(localVarResponse, \"\", Order.class);\n      }\n      else {\n        return null;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n"
  },
  {
    "id": "apache_axis1-java-111-Associations-Param0",
    "old_comment_raw": "@param te is the typeEntry from the Parameters object, which represents the parameter",
    "old_code_raw": "    public static QName getXSIType(TypeEntry te) {\n        QName xmlType = null;\n\n        // If the TypeEntry describes an Element, get\n        // the referenced Type.\n        if (te != null &&\n            te instanceof Element &&\n            te.getRefType() != null) {\n            te = te.getRefType();\n        } \n        // If the TypeEntry is a CollectionType, use\n        // the TypeEntry representing the component Type\n        // So for example a parameter that takes a \n        // collection type for\n        // <element name=\"A\" type=\"xsd:string\" maxOccurs=\"unbounded\"/>\n        // will be \n        // new ParameterDesc(<QName of A>, IN,\n        //                   <QName of xsd:string>,\n        //                   String[])\n        if (te != null &&\n            te instanceof CollectionType &&\n            te.getRefType() != null) {\n            te = te.getRefType();\n        }\n        if (te != null) {\n            xmlType = te.getQName();\n        }\n        return xmlType;\n    }\n",
    "new_code_raw": "    public static QName getXSIType(Parameter param) {\n        if (param.getMIMEType() != null) {\n            return getMIMETypeQName(param.getMIMEType());\n        }\n\n        QName xmlType = null;\n        TypeEntry te = param.getType();\n\n        // If the TypeEntry describes an Element, get\n        // the referenced Type.\n        if (te != null &&\n            te instanceof Element &&\n            te.getRefType() != null) {\n            te = te.getRefType();\n        } \n        // If the TypeEntry is a CollectionType, use\n        // the TypeEntry representing the component Type\n        // So for example a parameter that takes a \n        // collection type for\n        // <element name=\"A\" type=\"xsd:string\" maxOccurs=\"unbounded\"/>\n        // will be \n        // new ParameterDesc(<QName of A>, IN,\n        //                   <QName of xsd:string>,\n        //                   String[])\n        if (te != null &&\n            te instanceof CollectionType &&\n            te.getRefType() != null) {\n            te = te.getRefType();\n        }\n        if (te != null) {\n            xmlType = te.getQName();\n        }\n        return xmlType;\n    }\n\n"
  },
  {
    "id": "runelite_runelite-22-Param-2",
    "old_comment_raw": "@param size size of the area. Ex. Lizardman Shaman AoE is a 3x3, so size = 3",
    "old_code_raw": "\tpublic static Polygon getCanvasTileAreaPoly(Client client, Point localLocation, int size)\n\t{\n\t\tint plane = client.getPlane();\n\t\tint halfTile = LOCAL_TILE_SIZE / 2;\n\n\t\t// If the size is 5, we need to shift it up and left 2 units, then expand by 5 units to make a 5x5\n\t\tint aoeSize = size / 2;\n\n\t\t// Shift over one half tile as localLocation is the center point of the tile, and then shift the area size\n\t\tPoint topLeft = new Point(localLocation.getX() - (aoeSize * LOCAL_TILE_SIZE) - halfTile,\n\t\t\tlocalLocation.getY() - (aoeSize * LOCAL_TILE_SIZE) - halfTile);\n\t\t// expand by size\n\t\tPoint bottomRight = new Point(topLeft.getX() + size * LOCAL_TILE_SIZE - 1,\n\t\t\ttopLeft.getY() + size * LOCAL_TILE_SIZE - 1);\n\t\t// Take the x of top left and the y of bottom right to create bottom left\n\t\tPoint bottomLeft = new Point(topLeft.getX(), bottomRight.getY());\n\t\t// Similarly for top right\n\t\tPoint topRight = new Point(bottomRight.getX(), topLeft.getY());\n\n\t\tPoint p1 = worldToCanvas(client, topLeft.getX(), topLeft.getY(), plane);\n\t\tPoint p2 = worldToCanvas(client, topRight.getX(), topRight.getY(), plane);\n\t\tPoint p3 = worldToCanvas(client, bottomRight.getX(), bottomRight.getY(), plane);\n\t\tPoint p4 = worldToCanvas(client, bottomLeft.getX(), bottomLeft.getY(), plane);\n\n\t\tif (p1 == null || p2 == null || p3 == null || p4 == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tPolygon poly = new Polygon();\n\t\tpoly.addPoint(p1.getX(), p1.getY());\n\t\tpoly.addPoint(p2.getX(), p2.getY());\n\t\tpoly.addPoint(p3.getX(), p3.getY());\n\t\tpoly.addPoint(p4.getX(), p4.getY());\n\n\t\treturn poly;\n\t}\n",
    "new_code_raw": "\tpublic static Polygon getCanvasTileAreaPoly(Client client, LocalPoint localLocation, int size)\n\t{\n\t\tint plane = client.getPlane();\n\t\tint halfTile = LOCAL_TILE_SIZE / 2;\n\n\t\t// If the size is 5, we need to shift it up and left 2 units, then expand by 5 units to make a 5x5\n\t\tint aoeSize = size / 2;\n\n\t\t// Shift over one half tile as localLocation is the center point of the tile, and then shift the area size\n\t\tPoint topLeft = new Point(localLocation.getX() - (aoeSize * LOCAL_TILE_SIZE) - halfTile,\n\t\t\tlocalLocation.getY() - (aoeSize * LOCAL_TILE_SIZE) - halfTile);\n\t\t// expand by size\n\t\tPoint bottomRight = new Point(topLeft.getX() + size * LOCAL_TILE_SIZE - 1,\n\t\t\ttopLeft.getY() + size * LOCAL_TILE_SIZE - 1);\n\t\t// Take the x of top left and the y of bottom right to create bottom left\n\t\tPoint bottomLeft = new Point(topLeft.getX(), bottomRight.getY());\n\t\t// Similarly for top right\n\t\tPoint topRight = new Point(bottomRight.getX(), topLeft.getY());\n\n\t\tPoint p1 = worldToCanvas(client, topLeft.getX(), topLeft.getY(), plane);\n\t\tPoint p2 = worldToCanvas(client, topRight.getX(), topRight.getY(), plane);\n\t\tPoint p3 = worldToCanvas(client, bottomRight.getX(), bottomRight.getY(), plane);\n\t\tPoint p4 = worldToCanvas(client, bottomLeft.getX(), bottomLeft.getY(), plane);\n\n\t\tif (p1 == null || p2 == null || p3 == null || p4 == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tPolygon poly = new Polygon();\n\t\tpoly.addPoint(p1.getX(), p1.getY());\n\t\tpoly.addPoint(p2.getX(), p2.getY());\n\t\tpoly.addPoint(p3.getX(), p3.getY());\n\t\tpoly.addPoint(p4.getX(), p4.getY());\n\n\t\treturn poly;\n\t}\n"
  },
  {
    "id": "eclipse_tcf-94-Associations-Param0",
    "old_comment_raw": "@param object1 The first object to be tested.",
    "old_code_raw": "\tprivate boolean isAncestorOf(Object object1, Object object2) {\r\n\t\tif (object2 == null) return false;\r\n\t\tObject parent = getParent(object2);\r\n\t\tif (parent == object1) return true;\r\n\t\treturn isAncestorOf(object1, parent);\r\n   }\r\n",
    "new_code_raw": "\tprivate boolean isAncestorOf(Object node, Object target) {\r\n\t\tif (target == null) return false;\r\n\t\tObject parent = getParent(target);\r\n\t\tif (parent == node) return true;\r\n\t\treturn isAncestorOf(node, parent);\r\n   }\r\n\n"
  },
  {
    "id": "SeleniumHQ_selenium-179-Param-3",
    "old_comment_raw": "@param outputFile - The file to which we'll output the HTML results",
    "old_code_raw": "    public String runHTMLSuite(String browser, String browserURL, File suiteFile, File outputFile, int timeoutInSeconds, boolean multiWindow) throws IOException {\n        if (browser == null) throw new IllegalArgumentException(\"browser may not be null\");\n        if (!suiteFile.exists()) {\n    \t\tthrow new IOException(\"Can't find HTML Suite file:\" + suiteFile.getAbsolutePath());\n    \t}\n    \tif (!suiteFile.canRead()) {\n    \t\tthrow new IOException(\"Can't read HTML Suite file: \" + suiteFile.getAbsolutePath());\n    \t}\n    \tremoteControl.addNewStaticContent(suiteFile.getParentFile());\n        \n        // DGF this is a hack, but I can't find a better place to put it\n        String suiteURL;\n        if (browser.startsWith(\"*chrome\") || browser.startsWith(\"*firefox\") || browser.startsWith(\"*iehta\")  || browser.startsWith(\"*iexplore\") ) {\n            suiteURL = \"http://localhost:\" + remoteControl.getConfiguration().getPortDriversShouldContact() + \"/selenium-server/tests/\" + suiteFile.getName();\n        } else {\n          suiteURL = Urls.toProtocolHostAndPort(browserURL) + \"/selenium-server/tests/\" + suiteFile.getName();\n        }\n    \treturn runHTMLSuite(browser, browserURL, suiteURL, outputFile, timeoutInSeconds, multiWindow, \"info\");\n    }\n",
    "new_code_raw": "    public String runHTMLSuite(String browser, String browserURL, File suiteFile, File outputFile, long timeoutInSeconds, boolean multiWindow) throws IOException {\n        if (browser == null) throw new IllegalArgumentException(\"browser may not be null\");\n        if (!suiteFile.exists()) {\n    \t\tthrow new IOException(\"Can't find HTML Suite file:\" + suiteFile.getAbsolutePath());\n    \t}\n    \tif (!suiteFile.canRead()) {\n    \t\tthrow new IOException(\"Can't read HTML Suite file: \" + suiteFile.getAbsolutePath());\n    \t}\n    \tremoteControl.addNewStaticContent(suiteFile.getParentFile());\n        \n        // DGF this is a hack, but I can't find a better place to put it\n        String suiteURL;\n        if (browser.startsWith(\"*chrome\") || browser.startsWith(\"*firefox\") || browser.startsWith(\"*iehta\")  || browser.startsWith(\"*iexplore\") ) {\n            suiteURL = \"http://localhost:\" + remoteControl.getConfiguration().getPortDriversShouldContact() + \"/selenium-server/tests/\" + suiteFile.getName();\n        } else {\n          suiteURL = Urls.toProtocolHostAndPort(browserURL) + \"/selenium-server/tests/\" + suiteFile.getName();\n        }\n    \treturn runHTMLSuite(browser, browserURL, suiteURL, outputFile, timeoutInSeconds, multiWindow, \"info\");\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2608-Param-0",
    "old_comment_raw": "@param allSchemas all schemas",
    "old_code_raw": "    public static Schema unaliasSchema(Map<String, Schema> allSchemas, Schema schema) {\n        if (allSchemas == null || allSchemas.isEmpty()) {\n            // skip the warning as the spec can have no model defined\n            //LOGGER.warn(\"allSchemas cannot be null/empty in unaliasSchema. Returned 'schema'\");\n            return schema;\n        }\n\n        if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) {\n            Schema ref = allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()));\n            if (ref == null) {\n                LOGGER.warn(\"{} is not defined\", schema.get$ref());\n                return schema;\n            } else if (ref.getEnum() != null && !ref.getEnum().isEmpty()) {\n                // top-level enum class\n                return schema;\n            } else if (isArraySchema(ref)) {\n                if (generateAliasAsModel) {\n                    return schema; // generate a model extending array\n                } else {\n                    return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n                }\n            } else if (isComposedSchema(ref)) {\n                return schema;\n            } else if (isMapSchema(ref)) {\n                if (ref.getProperties() != null && !ref.getProperties().isEmpty()) // has at least one property\n                    return schema; // treat it as model\n                else {\n                    if (generateAliasAsModel) {\n                        return schema; // generate a model extending map\n                    } else {\n                        // treat it as a typical map\n                        return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n                    }\n                }\n            } else if (isObjectSchema(ref)) { // model\n                if (ref.getProperties() != null && !ref.getProperties().isEmpty()) { // has at least one property\n                    return schema;\n                } else { // free form object (type: object)\n                    return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n                }\n            } else {\n                return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n            }\n        }\n        return schema;\n    }\n",
    "new_code_raw": "    public static Schema unaliasSchema(OpenAPI openAPI, Schema schema) {\n        Map<String, Schema> allSchemas = getSchemas(openAPI);\n        if (allSchemas == null || allSchemas.isEmpty()) {\n            // skip the warning as the spec can have no model defined\n            //LOGGER.warn(\"allSchemas cannot be null/empty in unaliasSchema. Returned 'schema'\");\n            return schema;\n        }\n\n        if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) {\n            Schema ref = allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()));\n            if (ref == null) {\n                LOGGER.warn(\"{} is not defined\", schema.get$ref());\n                return schema;\n            } else if (ref.getEnum() != null && !ref.getEnum().isEmpty()) {\n                // top-level enum class\n                return schema;\n            } else if (isArraySchema(ref)) {\n                if (generateAliasAsModel) {\n                    return schema; // generate a model extending array\n                } else {\n                    return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n                }\n            } else if (isComposedSchema(ref)) {\n                return schema;\n            } else if (isMapSchema(ref)) {\n                if (ref.getProperties() != null && !ref.getProperties().isEmpty()) // has at least one property\n                    return schema; // treat it as model\n                else {\n                    if (generateAliasAsModel) {\n                        return schema; // generate a model extending map\n                    } else {\n                        // treat it as a typical map\n                        return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n                    }\n                }\n            } else if (isObjectSchema(ref)) { // model\n                if (ref.getProperties() != null && !ref.getProperties().isEmpty()) { // has at least one property\n                    return schema;\n                } else { // free form object (type: object)\n                    return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n                }\n            } else {\n                return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n            }\n        }\n        return schema;\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-708-Param-12",
    "old_comment_raw": "@param callback The callback to be executed when the API call finishes",
    "old_code_raw": "  public Call testEndpointParametersAsync(String number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password, final ApiCallback<Void> callback) throws ApiException {\n\n    ProgressResponseBody.ProgressListener progressListener = null;\n    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n    if (callback != null) {\n      progressListener = new ProgressResponseBody.ProgressListener() {\n        @Override\n        public void update(long bytesRead, long contentLength, boolean done) {\n          callback.onDownloadProgress(bytesRead, contentLength, done);\n        }\n      };\n\n      progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {\n        @Override\n        public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {\n          callback.onUploadProgress(bytesWritten, contentLength, done);\n        }\n      };\n    }\n\n    Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, progressListener, progressRequestListener);\n    apiClient.executeAsync(call, callback);\n    return call;\n  }\n",
    "new_code_raw": "  public Call testEndpointParametersAsync(BigDecimal number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password, final ApiCallback<Void> callback) throws ApiException {\n\n    ProgressResponseBody.ProgressListener progressListener = null;\n    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n    if (callback != null) {\n      progressListener = new ProgressResponseBody.ProgressListener() {\n        @Override\n        public void update(long bytesRead, long contentLength, boolean done) {\n          callback.onDownloadProgress(bytesRead, contentLength, done);\n        }\n      };\n\n      progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {\n        @Override\n        public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {\n          callback.onUploadProgress(bytesWritten, contentLength, done);\n        }\n      };\n    }\n\n    Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, progressListener, progressRequestListener);\n    apiClient.executeAsync(call, callback);\n    return call;\n  }\n"
  },
  {
    "id": "codehaus_picocontainer-10-Associations-Param0",
    "old_comment_raw": "@param key",
    "old_code_raw": "    public static ObjectName asObjectName(Object key) throws MalformedObjectNameException {\n        if (key == null) {\n            throw new NullPointerException(\"key cannot be null\");\n        }\n        if (key instanceof ObjectName) {\n            return (ObjectName) key;\n        }\n        if (key instanceof Class) {\n            Class clazz = (Class) key;\n            return new ObjectName(\"nanomx:type=\" + clazz.getName());\n        } else {\n            String text = key.toString();\n            // Fix, so it works under WebSphere ver. 5\n            if (text.indexOf(':') == -1) {\n                text = \"nanomx:type=\" + text;\n            }\n            return new ObjectName(text);\n        }\n    }\n",
    "new_code_raw": "    private static ObjectName asObjectName(Object componentKey) throws MalformedObjectNameException {\n        if (componentKey == null) {\n            throw new NullPointerException(\"componentKey cannot be null\");\n        }\n        if (componentKey instanceof ObjectName) {\n            return (ObjectName) componentKey;\n        }\n        if (componentKey instanceof Class) {\n            Class clazz = (Class) componentKey;\n            return new ObjectName(\"picomx:type=\" + clazz.getName());\n        } else {\n            String text = componentKey.toString();\n            // Fix, so it works under WebSphere ver. 5\n            if (text.indexOf(':') == -1) {\n                text = \"picomx:type=\" + text;\n            }\n            return new ObjectName(text);\n        }\n    }\n\n"
  },
  {
    "id": "querydsl_querydsl-1435-Param-0",
    "old_comment_raw": "@param left",
    "old_code_raw": "    public static EBoolean endsWith(Expr<String> left, String right, boolean caseSensitive) {\n        if (caseSensitive){\n            return endsWith(left, right);            \n        }else{\n            return operationFactory.createBoolean(Ops.ENDSWITH_IC, left, exprFactory.createConstant(right));\n        }                \n    }\n",
    "new_code_raw": "    public static EBoolean endsWith(Expr<String> left, String right) {\n        return operationFactory.createBoolean(Ops.ENDSWITH, left, exprFactory\n                .createConstant(right));\n    }\n"
  },
  {
    "id": "yanzhenjie_NoHttp-142-Param-2",
    "old_comment_raw": "@param fileFloder Folder to save file",
    "old_code_raw": "    public static DownloadRequest createDownloadRequest(String url, RequestMethod requestMethod, String fileFloder, String filename, boolean isRange, boolean isDeleteOld) {\n        return new RestDownloadRequestor(url, requestMethod, fileFloder, filename, isRange, isDeleteOld);\n    }\n",
    "new_code_raw": "    public static DownloadRequest createDownloadRequest(String url, RequestMethod requestMethod, String fileFolder, String filename, boolean isRange, boolean isDeleteOld) {\n        return new RestDownloadRequestor(url, requestMethod, fileFolder, filename, isRange, isDeleteOld);\n    }\n"
  },
  {
    "id": "processing_processing-961-Param-1",
    "old_comment_raw": "@param name",
    "old_code_raw": "  public ASTNode getASTNodeAt(int offset) {\n    Messages.log(\"* getASTNodeAt\");\n\n    PreprocessedSketch ps = errorCheckerService.latestResult;\n    int tabIndex = ps.sketch.getCodeIndex(editor.getCurrentTab());\n    int javaOffset = ps.tabOffsetToJavaOffset(tabIndex, offset);\n    ASTNode node = NodeFinder.perform(ps.compilationUnit, javaOffset, 0);\n\n    if (node == null) {\n      Messages.log(\"no node found\");\n      return null;\n    }\n\n    Messages.log(\"found \" + node.toString());\n    return node;\n  }\n",
    "new_code_raw": "  public ASTNode getASTNodeAt(int javaOffset) {\n    Messages.log(\"* getASTNodeAt\");\n\n    PreprocessedSketch ps = errorCheckerService.latestResult;\n    ASTNode node = NodeFinder.perform(ps.compilationUnit, javaOffset, 0);\n\n    if (node == null) {\n      Messages.log(\"no node found\");\n      return null;\n    }\n\n    Messages.log(\"found \" + node.toString());\n    return node;\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1671-Param-0",
    "old_comment_raw": "@param body client model",
    "old_code_raw": "    public Client testSpecialTags(Client body) throws RestClientException {\n        Object postBody = body;\n        \n        // verify the required parameter 'body' is set\n        if (body == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling testSpecialTags\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"/another-fake/dummy\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "new_code_raw": "    public Client testSpecialTags(Client client) throws RestClientException {\n        Object postBody = client;\n        \n        // verify the required parameter 'client' is set\n        if (client == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'client' when calling testSpecialTags\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"/another-fake/dummy\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n"
  },
  {
    "id": "apache_drill-767-Param-0",
    "old_comment_raw": "@param parent the parent (tuple, union or list) that holds this list",
    "old_code_raw": "  private ColumnState buildSimpleList(ContainerState parent, ColumnTransform outputCol) {\n    ColumnMetadata columnSchema = outputCol.outputSchema();\n\n    // The variant must have the one and only type.\n\n    assert columnSchema.variantSchema().size() == 1;\n    assert columnSchema.variantSchema().isSimple();\n\n    // Create the manager for the one and only column within the list.\n\n    final ListState listState = new ListState(parent.loader(),\n        parent.vectorCache().childCache(columnSchema.name()),\n        new ImpliedTupleRequest(true));\n\n    // Create the child vector, writer and state.\n\n    final ColumnMetadata memberSchema = columnSchema.variantSchema().listSubtype();\n    final ColumnState memberState = buildColumn(listState, memberSchema);\n    listState.setSubColumn(memberState);\n\n    // Create the list vector. Contains a single type.\n\n    final ListVector listVector = new ListVector(columnSchema.schema().cloneEmpty(),\n        parent.loader().allocator(), null);\n    listVector.setChildVector(memberState.vector());\n\n    // Create the list writer: an array of the one type.\n\n    final ListWriterImpl listWriter = new ListWriterImpl(columnSchema,\n        listVector, memberState.writer());\n    final AbstractObjectWriter listObjWriter = new ArrayObjectWriter(listWriter);\n\n    // Create the list vector state that tracks the list vector lifecycle.\n\n    final ListVectorState vectorState = new ListVectorState(listWriter,\n        memberState.writer().events(), listVector);\n\n    // Assemble it all into a union column state.\n\n    return new UnionColumnState(parent.loader(),\n        listObjWriter, vectorState, listState);\n  }\n",
    "new_code_raw": "  private ColumnState buildSimpleList(ContainerState parent, ColumnReadProjection colProj) {\n    ColumnMetadata columnSchema = colProj.providedSchema();\n\n    // The variant must have the one and only type.\n\n    assert columnSchema.variantSchema().size() == 1;\n    assert columnSchema.variantSchema().isSimple();\n\n    // Create the manager for the one and only column within the list.\n\n    final ListState listState = new ListState(parent.loader(),\n        parent.vectorCache().childCache(columnSchema.name()));\n\n    // Create the child vector, writer and state.\n\n    final ColumnMetadata memberSchema = columnSchema.variantSchema().listSubtype();\n    final ColumnState memberState = buildColumn(listState, memberSchema);\n    listState.setSubColumn(memberState);\n\n    // Create the list vector. Contains a single type.\n\n    final ListVector listVector = new ListVector(columnSchema.schema().cloneEmpty(),\n        parent.loader().allocator(), null);\n    listVector.setChildVector(memberState.vector());\n\n    // Create the list writer: an array of the one type.\n\n    final ListWriterImpl listWriter = new ListWriterImpl(columnSchema,\n        listVector, memberState.writer());\n    final AbstractObjectWriter listObjWriter = new ArrayObjectWriter(listWriter);\n\n    // Create the list vector state that tracks the list vector lifecycle.\n\n    final ListVectorState vectorState = new ListVectorState(listWriter,\n        memberState.writer().events(), listVector);\n\n    // Assemble it all into a union column state.\n\n    return new UnionColumnState(parent.loader(),\n        listObjWriter, vectorState, listState);\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1691-Param-1",
    "old_comment_raw": "@param file file to upload (required)",
    "old_code_raw": "  public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws ApiException {\n    Object localVarPostBody = null;\n    \n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n    }\n    \n    // verify the required parameter 'file' is set\n    if (file == null) {\n      throw new ApiException(400, \"Missing the required parameter 'file' when calling uploadFileWithRequiredFile\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake/{petId}/uploadImageWithRequiredFile\"\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString()));\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    if (additionalMetadata != null)\n      localVarFormParams.put(\"additionalMetadata\", additionalMetadata);\nif (file != null)\n      localVarFormParams.put(\"file\", file);\n\n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"multipart/form-data\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"petstore_auth\" };\n\n    GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException {\n    Object localVarPostBody = null;\n    \n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n    }\n    \n    // verify the required parameter 'requiredFile' is set\n    if (requiredFile == null) {\n      throw new ApiException(400, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake/{petId}/uploadImageWithRequiredFile\"\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString()));\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    if (additionalMetadata != null)\n      localVarFormParams.put(\"additionalMetadata\", additionalMetadata);\nif (requiredFile != null)\n      localVarFormParams.put(\"requiredFile\", requiredFile);\n\n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"multipart/form-data\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"petstore_auth\" };\n\n    GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "debezium_debezium-546-Param-0",
    "old_comment_raw": "@param schemaPrefix the prefix added to the table identifier to construct the schema names; may be null if there is no prefix",
    "old_code_raw": "    public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers, CustomKeyMapper keysMapper) {\n        if (schemaPrefix == null) {\n            schemaPrefix = \"\";\n        }\n\n        // Build the schemas ...\n        final TableId tableId = table.id();\n        final String tableIdStr = tableSchemaName(tableId);\n        final String schemaNamePrefix = schemaPrefix + tableIdStr;\n        LOGGER.debug(\"Mapping table '{}' to schemas under '{}'\", tableId, schemaNamePrefix);\n        SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Value\"));\n        SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Key\"));\n        AtomicBoolean hasPrimaryKey = new AtomicBoolean(false);\n        \n        Key tableKey = new Key.Builder(table).customKeyMapper(keysMapper).build();\n        tableKey.keyColumns().forEach(column -> {\n            addField(keySchemaBuilder, column, null);\n            hasPrimaryKey.set(true);\n        });\n        \n        table.columns()\n            .stream()\n            .filter(column -> filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name()))\n            .forEach(column -> {\n                ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column);\n                addField(valSchemaBuilder, column, mapper);\n            });\n        \n        Schema valSchema = valSchemaBuilder.optional().build();\n        Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null;\n\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Mapped primary key for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(keySchema));\n            LOGGER.debug(\"Mapped columns for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(valSchema));\n        }\n\n        Envelope envelope = Envelope.defineSchema()\n                .withName(schemaNameAdjuster.adjust(envelopSchemaName))\n                .withRecord(valSchema)\n                .withSource(sourceInfoSchema)\n                .build();\n\n\n        // Create the generators ...\n        Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, tableKey.keyColumns());\n        Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers);\n\n        // And the table schema ...\n        return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator);\n    }\n",
    "new_code_raw": "    public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers, KeyMapper keysMapper) {\n        if (schemaPrefix == null) {\n            schemaPrefix = \"\";\n        }\n\n        // Build the schemas ...\n        final TableId tableId = table.id();\n        final String tableIdStr = tableSchemaName(tableId);\n        final String schemaNamePrefix = schemaPrefix + tableIdStr;\n        LOGGER.debug(\"Mapping table '{}' to schemas under '{}'\", tableId, schemaNamePrefix);\n        SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Value\"));\n        SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Key\"));\n        AtomicBoolean hasPrimaryKey = new AtomicBoolean(false);\n\n        Key tableKey = new Key.Builder(table).customKeyMapper(keysMapper).build();\n        tableKey.keyColumns().forEach(column -> {\n            addField(keySchemaBuilder, column, null);\n            hasPrimaryKey.set(true);\n        });\n\n        table.columns()\n            .stream()\n            .filter(column -> filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name()))\n            .forEach(column -> {\n                ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column);\n                addField(valSchemaBuilder, column, mapper);\n            });\n\n        Schema valSchema = valSchemaBuilder.optional().build();\n        Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null;\n\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Mapped primary key for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(keySchema));\n            LOGGER.debug(\"Mapped columns for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(valSchema));\n        }\n\n        Envelope envelope = Envelope.defineSchema()\n                .withName(schemaNameAdjuster.adjust(envelopSchemaName))\n                .withRecord(valSchema)\n                .withSource(sourceInfoSchema)\n                .build();\n\n\n        // Create the generators ...\n        Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, tableKey.keyColumns());\n        Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers);\n\n        // And the table schema ...\n        return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator);\n    }\n"
  },
  {
    "id": "Letractively_prisms-17-Associations-Param0",
    "old_comment_raw": "@param manager The manager user (the one accessing the application)",
    "old_code_raw": "\tpublic static boolean canEdit(User manager, User toEdit)\r\n\t{\r\n\t\tif(isAdmin(manager))\r\n\t\t\treturn true;\r\n\t\tif(isAdmin(toEdit))\r\n\t\t\treturn false;\r\n\r\n\t\treturn getManagementLevel(manager) > getManagementLevel(toEdit);\r\n\t}\r\n",
    "new_code_raw": "\tpublic static boolean canEdit(Permissions perms, Permissions user2Perms)\r\n\t{\r\n\t\tif(isAdmin(perms))\r\n\t\t\treturn true;\r\n\t\tif(isAdmin(user2Perms))\r\n\t\t\treturn false;\r\n\r\n\t\treturn getManagementLevel(perms) > getManagementLevel(user2Perms);\r\n\t}\r\n\n"
  },
  {
    "id": "Atmosphere_atmosphere-317-Param-0",
    "old_comment_raw": "@param request  HttpServletRequest",
    "old_code_raw": "    public final static AtmosphereRequest cloneRequest(HttpServletRequest request, boolean loadInMemory, boolean copySession) {\n        Builder b;\n        HttpServletRequest r;\n        boolean isWrapped = false;\n        if (AtmosphereRequest.class.isAssignableFrom(request.getClass())) {\n            b = AtmosphereRequest.class.cast(request).b;\n            isWrapped = true;\n        } else {\n            b = new Builder();\n            b.request(request);\n        }\n\n        b.servletPath(request.getServletPath())\n                .pathInfo(request.getPathInfo())\n                .contextPath(request.getContextPath())\n                .requestURI(request.getRequestURI())\n                .requestURL(request.getRequestURL().toString())\n                .method(request.getMethod())\n                .serverName(request.getServerName())\n                .serverPort(request.getServerPort())\n                .destroyable(false)\n                .session(copySession ? new FakeHttpSession(request.getSession(true)) : null);\n\n        if (loadInMemory) {\n            r = new NoOpsRequest();\n            if (isWrapped) {\n                load(b.request, b);\n            } else {\n                load(request, b);\n            }\n            b.request(r);\n        }\n\n        return isWrapped ? AtmosphereRequest.class.cast(request) : b.build();\n    }\n",
    "new_code_raw": "    public final static AtmosphereRequest cloneRequest(HttpServletRequest request, boolean loadInMemory, boolean copySession, boolean isDestroyable) {\n        Builder b;\n        HttpServletRequest r;\n        boolean isWrapped = false;\n        if (AtmosphereRequest.class.isAssignableFrom(request.getClass())) {\n            b = AtmosphereRequest.class.cast(request).b;\n            isWrapped = true;\n        } else {\n            b = new Builder();\n            b.request(request);\n        }\n\n        b.servletPath(request.getServletPath())\n                .pathInfo(request.getPathInfo())\n                .contextPath(request.getContextPath())\n                .requestURI(request.getRequestURI())\n                .requestURL(request.getRequestURL().toString())\n                .method(request.getMethod())\n                .serverName(request.getServerName())\n                .serverPort(request.getServerPort())\n                .destroyable(isDestroyable)\n                .session(copySession ? new FakeHttpSession(request.getSession(true)) : null);\n\n        if (loadInMemory) {\n            r = new NoOpsRequest();\n            if (isWrapped) {\n                load(b.request, b);\n            } else {\n                load(request, b);\n            }\n            b.request(r);\n        }\n\n        return isWrapped ? AtmosphereRequest.class.cast(request) : b.build();\n    }\n"
  },
  {
    "id": "dustin_java-memcached-client-22-Associations-Param0",
    "old_comment_raw": "@param keys one more more keys to get",
    "old_code_raw": "\tpublic Future<Map<String, Object>> asyncGetBulk(String... keys) {\n\t\treturn asyncGetBulk(Arrays.asList(keys));\n\t}\n",
    "new_code_raw": "\tpublic Future<Map<String, Object>> asyncGetBulk(Collection<String> keys) {\n\t\treturn asyncGetBulk(keys, transcoder);\n\t}\n\n"
  },
  {
    "id": "iSoron_uhabits-66-Param-0",
    "old_comment_raw": "@param from timestamp for the oldest score",
    "old_code_raw": "    public List<Score> groupBy(DateUtils.TruncateField field)\n    {\n        computeAll();\n        HashMap<Timestamp, ArrayList<Double>> groups = getGroupedValues(field);\n        List<Score> scores = groupsToAvgScores(groups);\n        Collections.sort(scores, (s1, s2) -> s2.compareNewer(s1));\n        return scores;\n    }\n",
    "new_code_raw": "    public List<Score> groupBy(DateUtils.TruncateField field, int firstWeekday)\n    {\n        computeAll();\n        HashMap<Timestamp, ArrayList<Double>> groups = getGroupedValues(field, firstWeekday);\n        List<Score> scores = groupsToAvgScores(groups);\n        Collections.sort(scores, (s1, s2) -> s2.compareNewer(s1));\n        return scores;\n    }\n"
  },
  {
    "id": "apache_drill-1214-Param-0",
    "old_comment_raw": "@param planningSet",
    "old_code_raw": "  private static Set<Wrapper> constructFragmentDependencyGraph(PlanningSet planningSet) {\n\n    // Set up dependency of fragments based on the affinity of exchange that separates the fragments.\n    for (Wrapper currentFragmentWrapper : planningSet) {\n      ExchangeFragmentPair sendingExchange = currentFragmentWrapper.getNode().getSendingExchangePair();\n      if (sendingExchange != null) {\n        ParallelizationDependency dependency = sendingExchange.getExchange().getParallelizationDependency();\n        Wrapper receivingFragmentWrapper = planningSet.get(sendingExchange.getNode());\n\n        if (dependency == ParallelizationDependency.RECEIVER_DEPENDS_ON_SENDER) {\n          receivingFragmentWrapper.addFragmentDependency(currentFragmentWrapper);\n        } else if (dependency == ParallelizationDependency.SENDER_DEPENDS_ON_RECEIVER) {\n          currentFragmentWrapper.addFragmentDependency(receivingFragmentWrapper);\n        }\n      }\n    }\n\n    // Identify leaf fragments. Leaf fragments are fragments that have no other fragments depending on them for\n    // parallelization info. First assume all fragments are leaf fragments. Go through the fragments one by one and\n    // remove the fragment on which the current fragment depends.\n\n    final Set<Wrapper> roots = Sets.newHashSet();\n    for (Wrapper w : planningSet) {\n      roots.add(w);\n    }\n\n    for (Wrapper wrapper : planningSet) {\n      final List<Wrapper> fragmentDependencies = wrapper.getFragmentDependencies();\n      if (fragmentDependencies != null && fragmentDependencies.size() > 0) {\n        for (Wrapper dependency : fragmentDependencies) {\n          if (roots.contains(dependency)) {\n            roots.remove(dependency);\n          }\n        }\n      }\n    }\n\n    return roots;\n  }\n",
    "new_code_raw": "  private void constructFragmentDependencyGraph(Fragment rootFragment, PlanningSet planningSet) {\n\n    // Set up dependency of fragments based on the affinity of exchange that separates the fragments.\n    for(Wrapper currentFragment : planningSet) {\n      ExchangeFragmentPair sendingXchgForCurrFrag = currentFragment.getNode().getSendingExchangePair();\n      if (sendingXchgForCurrFrag != null) {\n        ParallelizationDependency dependency = sendingXchgForCurrFrag.getExchange().getParallelizationDependency();\n        Wrapper receivingFragmentWrapper = planningSet.get(sendingXchgForCurrFrag.getNode());\n\n        //Mostly Receivers of the current fragment depend on the sender of the child fragments. However there is a special case\n        //for DeMux Exchanges where the Sender of the current fragment depends on the receiver of the parent fragment.\n        if (dependency == ParallelizationDependency.RECEIVER_DEPENDS_ON_SENDER) {\n          receivingFragmentWrapper.addFragmentDependency(currentFragment);\n        } else if (dependency == ParallelizationDependency.SENDER_DEPENDS_ON_RECEIVER) {\n          currentFragment.addFragmentDependency(receivingFragmentWrapper);\n        }\n      }\n    }\n    planningSet.findRootWrapper(rootFragment);\n  }\n"
  },
  {
    "id": "debezium_debezium-1247-Param-0",
    "old_comment_raw": "@param tsSec the timestamp (in seconds) in the resulting offset.",
    "old_code_raw": "    private SourceRecord createSourceRecordWithTimestamp(long tsSec) {\n        Map<String, ?> offset = Collections.singletonMap(SourceInfo.TIMESTAMP_KEY, tsSec);\n        return new SourceRecord(null, offset, null, null, null);\n    }\n",
    "new_code_raw": "    private SourceRecord createSourceRecordWithTimestamp(Instant ts) {\n        Map<String, ?> offset = Collections.singletonMap(SourceInfo.TIMESTAMP_KEY, ts.getEpochSecond());\n        return new SourceRecord(null, offset, null, null, null);\n    }\n"
  },
  {
    "id": "debezium_debezium-142-Param-0",
    "old_comment_raw": "@param before the state of the record before the update; may be null",
    "old_code_raw": "    public Struct update(Struct before, Struct after, Struct source, Long timestamp) {\n        Struct struct = new Struct(schema);\n        struct.put(FieldName.OPERATION, Operation.UPDATE.code());\n        if (before != null) struct.put(FieldName.BEFORE, before);\n        struct.put(FieldName.AFTER, after);\n        if (source != null) struct.put(FieldName.SOURCE, source);\n        if (timestamp != null) struct.put(FieldName.TIMESTAMP, timestamp);\n        return struct;\n    }\n",
    "new_code_raw": "    public Struct update(Object before, Struct after, Struct source, Long timestamp) {\n        Struct struct = new Struct(schema);\n        struct.put(FieldName.OPERATION, Operation.UPDATE.code());\n        if (before != null) struct.put(FieldName.BEFORE, before);\n        struct.put(FieldName.AFTER, after);\n        if (source != null) struct.put(FieldName.SOURCE, source);\n        if (timestamp != null) struct.put(FieldName.TIMESTAMP, timestamp);\n        return struct;\n    }\n"
  },
  {
    "id": "hazelcast_hazelcast-588-Associations-Param0",
    "old_comment_raw": "@param pipeline",
    "old_code_raw": "    long getLoad(MigratablePipeline pipeline) {\n        return handlerLoadCounter.get(pipeline);\n    }\n",
    "new_code_raw": "    long getLoad(MigratableHandler handler) {\n        return handlerLoadCounter.get(handler);\n    }\n\n"
  },
  {
    "id": "LawnchairLauncher_Lawnchair-52-Param-0",
    "old_comment_raw": "@param launcher",
    "old_code_raw": "    private RectF drawBoxWithShadow(Canvas c, int width, int height) {\n        Resources res = mContext.getResources();\n\n        ShadowGenerator.Builder builder = new ShadowGenerator.Builder(Color.WHITE);\n        builder.shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);\n        builder.radius = res.getDimension(R.dimen.widget_preview_corner_radius);\n        builder.keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);\n\n        builder.bounds.set(builder.shadowBlur, builder.shadowBlur,\n                width - builder.shadowBlur,\n                height - builder.shadowBlur - builder.keyShadowDistance);\n        builder.drawShadow(c);\n        return builder.bounds;\n    }\n",
    "new_code_raw": "    private RectF drawBoxWithShadow(Canvas c, Paint p, int width, int height) {\n        Resources res = mContext.getResources();\n        float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);\n        float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);\n        float corner = res.getDimension(R.dimen.widget_preview_corner_radius);\n\n        RectF bounds = new RectF(shadowBlur, shadowBlur,\n                width - shadowBlur, height - shadowBlur - keyShadowDistance);\n        p.setColor(Color.WHITE);\n\n        // Key shadow\n        p.setShadowLayer(shadowBlur, 0, keyShadowDistance,\n                ShadowGenerator.KEY_SHADOW_ALPHA << 24);\n        c.drawRoundRect(bounds, corner, corner, p);\n\n        // Ambient shadow\n        p.setShadowLayer(shadowBlur, 0, 0,\n                ColorUtils.setAlphaComponent(Color.BLACK, ShadowGenerator.AMBIENT_SHADOW_ALPHA));\n        c.drawRoundRect(bounds, corner, corner, p);\n\n        p.clearShadowLayer();\n        return bounds;\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-1114-Param-0",
    "old_comment_raw": "@param periodToAdd the period to add to this one, null means zero",
    "old_code_raw": "    public DateTime withPeriodAdded(ReadablePeriod periodToAdd, int scalar) {\n        if (periodToAdd == null || scalar == 0) {\n            return this;\n        }\n        long instant = periodToAdd.addTo(getMillis(), scalar, getChronology());\n        return withMillis(instant);\n    }\n",
    "new_code_raw": "    public DateTime withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        long instant = getChronology().add(getMillis(), period, scalar);\n        return withMillis(instant);\n    }\n"
  },
  {
    "id": "SeleniumHQ_selenium-538-Param-0",
    "old_comment_raw": "@param headers Map with extra HTTP headers.",
    "old_code_raw": "  public static Command<Void> setExtraHTTPHeaders(Map<String, String> headers) {\n    Objects.requireNonNull(headers, \"headers must be set.\");\n    return new Command<>(DOMAIN_NAME + \".setExtraHTTPHeaders\", ImmutableMap.of(\"headers\", headers));\n  }\n",
    "new_code_raw": "  public static Command<Void> setExtraHTTPHeaders(Headers headers) {\n    Objects.requireNonNull(headers, \"headers must be set.\");\n    return new Command<>(DOMAIN_NAME + \".setExtraHTTPHeaders\", ImmutableMap.of(\"headers\", headers));\n  }\n"
  },
  {
    "id": "trygvis_jop-160-Associations-Param1",
    "old_comment_raw": "@param isClassMember If the signature is ambiguous, if true always assume that the last simple member name is a method or field, else assume it is a class name.",
    "old_code_raw": "    public static String getClassName(String signature, boolean isClassMember) {\n        int pos = signature.indexOf(ALT_MEMBER_SEPARATOR);\n        // uses alternative separator, easy\n        if (pos != -1) return signature.substring(0, pos);\n\n        pos = signature.indexOf('(');\n        if ( pos != -1 ) {\n            // has a descriptor, is a method signature, strip last member part\n            pos = signature.lastIndexOf('.', pos);\n            return pos != -1 ? signature.substring(0, pos) : \"\";\n        }\n\n        if (isClassMember) {\n            // field or class name, cannot decide, assume it is a field\n            pos = signature.lastIndexOf('.');\n            return pos != -1 ? signature.substring(0, pos) : \"\";\n        } else {\n            // assume it is a class name\n            return signature;\n        }\n    }\n",
    "new_code_raw": "    public static String getClassName(String memberID, boolean isClassMember) {\n        int pos = memberID.indexOf(ALT_MEMBER_SEPARATOR);\n        // uses alternative separator, easy\n        if (pos != -1) return memberID.substring(0, pos);\n\n        pos = memberID.indexOf('(');\n        if ( pos != -1 ) {\n            // has a descriptor, is a method ID, strip last member part\n            pos = memberID.lastIndexOf('.', pos);\n            return pos != -1 ? memberID.substring(0, pos) : \"\";\n        }\n\n        if (isClassMember) {\n            // field or class name, cannot decide, assume it is a field\n            pos = memberID.lastIndexOf('.');\n            return pos != -1 ? memberID.substring(0, pos) : \"\";\n        } else {\n            // assume it is a class name\n            return memberID;\n        }\n    }\n\n"
  },
  {
    "id": "apache_drill-767-Param-1",
    "old_comment_raw": "@param columnSchema metadata description of the list which must contain exactly one subtype",
    "old_code_raw": "  private ColumnState buildSimpleList(ContainerState parent, ColumnTransform outputCol) {\n    ColumnMetadata columnSchema = outputCol.outputSchema();\n\n    // The variant must have the one and only type.\n\n    assert columnSchema.variantSchema().size() == 1;\n    assert columnSchema.variantSchema().isSimple();\n\n    // Create the manager for the one and only column within the list.\n\n    final ListState listState = new ListState(parent.loader(),\n        parent.vectorCache().childCache(columnSchema.name()),\n        new ImpliedTupleRequest(true));\n\n    // Create the child vector, writer and state.\n\n    final ColumnMetadata memberSchema = columnSchema.variantSchema().listSubtype();\n    final ColumnState memberState = buildColumn(listState, memberSchema);\n    listState.setSubColumn(memberState);\n\n    // Create the list vector. Contains a single type.\n\n    final ListVector listVector = new ListVector(columnSchema.schema().cloneEmpty(),\n        parent.loader().allocator(), null);\n    listVector.setChildVector(memberState.vector());\n\n    // Create the list writer: an array of the one type.\n\n    final ListWriterImpl listWriter = new ListWriterImpl(columnSchema,\n        listVector, memberState.writer());\n    final AbstractObjectWriter listObjWriter = new ArrayObjectWriter(listWriter);\n\n    // Create the list vector state that tracks the list vector lifecycle.\n\n    final ListVectorState vectorState = new ListVectorState(listWriter,\n        memberState.writer().events(), listVector);\n\n    // Assemble it all into a union column state.\n\n    return new UnionColumnState(parent.loader(),\n        listObjWriter, vectorState, listState);\n  }\n",
    "new_code_raw": "  private ColumnState buildSimpleList(ContainerState parent, ColumnReadProjection colProj) {\n    ColumnMetadata columnSchema = colProj.providedSchema();\n\n    // The variant must have the one and only type.\n\n    assert columnSchema.variantSchema().size() == 1;\n    assert columnSchema.variantSchema().isSimple();\n\n    // Create the manager for the one and only column within the list.\n\n    final ListState listState = new ListState(parent.loader(),\n        parent.vectorCache().childCache(columnSchema.name()));\n\n    // Create the child vector, writer and state.\n\n    final ColumnMetadata memberSchema = columnSchema.variantSchema().listSubtype();\n    final ColumnState memberState = buildColumn(listState, memberSchema);\n    listState.setSubColumn(memberState);\n\n    // Create the list vector. Contains a single type.\n\n    final ListVector listVector = new ListVector(columnSchema.schema().cloneEmpty(),\n        parent.loader().allocator(), null);\n    listVector.setChildVector(memberState.vector());\n\n    // Create the list writer: an array of the one type.\n\n    final ListWriterImpl listWriter = new ListWriterImpl(columnSchema,\n        listVector, memberState.writer());\n    final AbstractObjectWriter listObjWriter = new ArrayObjectWriter(listWriter);\n\n    // Create the list vector state that tracks the list vector lifecycle.\n\n    final ListVectorState vectorState = new ListVectorState(listWriter,\n        memberState.writer().events(), listVector);\n\n    // Assemble it all into a union column state.\n\n    return new UnionColumnState(parent.loader(),\n        listObjWriter, vectorState, listState);\n  }\n"
  },
  {
    "id": "apache_calcite-961-Param-0",
    "old_comment_raw": "@param call Extract expression",
    "old_code_raw": "  public static boolean isValidTimeExtract(RexCall call) {\n    if (call.getKind() != SqlKind.EXTRACT) {\n      return false;\n    }\n    final RexLiteral flag = (RexLiteral) call.operands.get(0);\n    final TimeUnitRange timeUnit = (TimeUnitRange) flag.getValue();\n    return timeUnit != null && VALID_TIME_EXTRACT.contains(timeUnit);\n  }\n",
    "new_code_raw": "  public static boolean isValidTimeExtract(RexNode rexNode) {\n    if (rexNode.getKind() != SqlKind.EXTRACT) {\n      return false;\n    }\n    final RexCall call = (RexCall) rexNode;\n    final RexLiteral flag = (RexLiteral) call.operands.get(0);\n    final TimeUnitRange timeUnit = (TimeUnitRange) flag.getValue();\n    return timeUnit != null && VALID_TIME_EXTRACT.contains(timeUnit);\n  }\n"
  },
  {
    "id": "querydsl_querydsl-788-Param-0",
    "old_comment_raw": "@param collection",
    "old_code_raw": "    public static EBoolean isNotEmpty(PMap<?,?> map) {\n        return operationFactory.createBoolean(Ops.MAP_ISNOTEMPTY,(Expr<?>) map);\n    }\n",
    "new_code_raw": "    public static EBoolean isNotEmpty(EMap<?,?> map) {\n        return operationFactory.createBoolean(Ops.MAP_ISNOTEMPTY,(Expr<?>) map);\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-1087-Param-0",
    "old_comment_raw": "@param millis the time instant in millis to update.",
    "old_code_raw": "    public long set(long millis, int month) {\n        super.verifyValueBounds(month, MIN, MAX);\n        //\n        int thisYear = iChronology.year().get(millis);\n        //\n        int thisDom = iChronology.getDayOfMonth(millis, thisYear);\n        int maxDom = iChronology.getDaysInYearMonth(thisYear, month);\n        if (thisDom > maxDom) {\n            // Quietly force DOM to nearest sane value.\n            thisDom = maxDom;\n        }\n        // Return newly calculated millis value\n        return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n            iChronology.millisOfDay().get(millis);\n    }\n",
    "new_code_raw": "    public long set(long instant, int month) {\n        Utils.verifyValueBounds(this, month, MIN, MAX);\n        //\n        int thisYear = iChronology.year().get(instant);\n        //\n        int thisDom = iChronology.getDayOfMonth(instant, thisYear);\n        int maxDom = iChronology.getDaysInYearMonth(thisYear, month);\n        if (thisDom > maxDom) {\n            // Quietly force DOM to nearest sane value.\n            thisDom = maxDom;\n        }\n        // Return newly calculated millis value\n        return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n            iChronology.millisOfDay().get(instant);\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-1496-Param-0",
    "old_comment_raw": "@param by the By object e.g. By.id(\"id\");",
    "old_code_raw": "\tpublic WebElement searchForWebElement(final By by, int match, int timeout, boolean scroll){\n\n\t\tif(match < 1){\n\t\t\tmatch = 1;\n\t\t}\n\n\t\tList<WebElement> viewsFromScreen = webUtils.getCurrentWebElements(by);\n\t\taddViewsToList (webElements, viewsFromScreen);\n\n\t\treturn getViewFromList(webElements, match);\n\t}\n",
    "new_code_raw": "\tpublic WebElement searchForWebElement(final By by, int minimumNumberOfMatches, int timeout, boolean scroll){\n\n\t\tif(minimumNumberOfMatches < 1){\n\t\t\tminimumNumberOfMatches = 1;\n\t\t}\n\n\t\tList<WebElement> viewsFromScreen = webUtils.getCurrentWebElements(by);\n\t\taddViewsToList (webElements, viewsFromScreen);\n\n\t\treturn getViewFromList(webElements, minimumNumberOfMatches);\n\t}\n"
  },
  {
    "id": "debezium_debezium-9-Param-0",
    "old_comment_raw": "@param predicates the functions that attempt to validate the object; may be null",
    "old_code_raw": "    public Field withValidation(Predicate<String>... predicates) {\n        return new Field(name(), description(), defaultValueGenerator, (config, field, problems) -> {\n            String value = config.getString(field);\n            for (Predicate<String> predicate : predicates) {\n                if (predicate != null) {\n                    try {\n                        if (!predicate.test(value)) {\n                            problems.accept(\"The \" + field.name() + \" value '\" + value + \"' is not valid\");\n                            return 1;\n                        }\n                    } catch (Throwable t) {\n                        problems.accept(\"The \" + field.name() + \" value '\" + value + \"' is not allowed: \" + t.getMessage());\n                        return 1;\n                    }\n                }\n            }\n            return 0;\n        });\n    }\n",
    "new_code_raw": "    public Field withValidation(Validator... validators) {\n        Validator actualValidator = validator;\n        for (Validator validator : validators) {\n            if (validator != null) actualValidator = validator.and(actualValidator);\n        }\n        return new Field(name(), displayName(), type(), width(), description(), importance(), dependents,\n                defaultValueGenerator, actualValidator, recommender);\n    }\n"
  },
  {
    "id": "debezium_debezium-392-Param-2",
    "old_comment_raw": "@param txId the ID of the transaction that generated the transaction; may be null if this information nis not available",
    "old_code_raw": "    protected SourceInfo update(Long lsn, Long useconds, Long txId, TableId tableId) {\n        this.lsn = lsn;\n        this.useconds = useconds;\n        this.txId = txId;\n        if (tableId != null && tableId.schema() != null) {\n            this.schemaName = tableId.schema();\n        }\n        if (tableId != null && tableId.table() != null) {\n            this.tableName = tableId.table();\n        }\n        return this;\n    }\n",
    "new_code_raw": "    protected SourceInfo update(Long lsn, Instant commitTime, Long txId, TableId tableId) {\n        this.lsn = lsn;\n        this.useconds = Conversions.toEpochMicros(commitTime);\n        this.txId = txId;\n        if (tableId != null && tableId.schema() != null) {\n            this.schemaName = tableId.schema();\n        }\n        if (tableId != null && tableId.table() != null) {\n            this.tableName = tableId.table();\n        }\n        return this;\n    }\n"
  },
  {
    "id": "zaproxy_zaproxy-2117-Param-0",
    "old_comment_raw": "@param msg the response message where the uri was found",
    "old_code_raw": "\tprivate List<HttpCookie> prepareCookies(HttpMessage msg) {\n\t\tif (parent.getSpiderParam().isSendCookies()) {\n\t\t\tjava.net.URI uri = null;\n\t\t\ttry {\n\t\t\t\turi = new java.net.URI(msg.getRequestHeader().getURI().toString());\n\t\t\t} catch (URISyntaxException e) {\n\t\t\t\tlog.error(\"Error while preparing cookies. \", e);\n\t\t\t}\n\t\t\treturn parent.getCookieManager().getCookieStore().get(uri);\n\t\t}\n\t\treturn null;\n\t}\n",
    "new_code_raw": "\tprivate List<HttpCookie> prepareCookies(String uriS) {\n\t\tif (parent.getSpiderParam().isSendCookies()) {\n\t\t\tjava.net.URI uri = null;\n\t\t\ttry {\n\t\t\t\turi = new java.net.URI(uriS);\n\t\t\t} catch (URISyntaxException e) {\n\t\t\t\tlog.error(\"Error while preparing cookies. \", e);\n\t\t\t}\n\t\t\treturn parent.getCookieManager().getCookieStore().get(uri);\n\t\t}\n\t\treturn null;\n\t}\n"
  },
  {
    "id": "querydsl_querydsl-917-Param-0",
    "old_comment_raw": "@param right rhs of the comparison",
    "old_code_raw": "    public BooleanExpression goe(D right) {\n        return goe(new ConstantImpl(right));\n    }\n",
    "new_code_raw": "    public BooleanExpression goe(T right) {\n        return goe(new ConstantImpl(right));\n    }\n"
  },
  {
    "id": "Atmosphere_atmosphere-863-Param-1",
    "old_comment_raw": "@param response the  AtmosphereResponse",
    "old_code_raw": "    public Action timedout(AtmosphereRequest request, AtmosphereResponse response)\n            throws IOException, ServletException {\n\n        AtmosphereResourceImpl r = null;\n\n        try {\n            SessionTimeoutSupport.restoreTimeout(request);\n\n            if (trackActiveRequest) {\n                long l = (Long) request.getAttribute(MAX_INACTIVE);\n                if (l == -1) {\n                    // The closedDetector closed the connection.\n                    return timedoutAction;\n                }\n                request.setAttribute(MAX_INACTIVE, (long) -1);\n            }\n\n            logger.debug(\"Timing out the connection for request {}\", request);\n\n            // Something went wrong.\n            if (request == null || response == null) {\n                logger.warn(\"Invalid Request/Response: {}/{}\", request, response);\n                return timedoutAction;\n            }\n\n            r = (AtmosphereResourceImpl) request.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n\n            if (r != null && r.isCancelled()) {\n                return cancelledAction;\n            }\n\n            if (r == null) {\n                logger.debug(\"AtmosphereResource was null, failed to timeout AtmosphereRequest {}\", request);\n            }\n\n            if (r != null && r.getAtmosphereResourceEvent().isSuspended()) {\n                r.getAtmosphereResourceEvent().setIsResumedOnTimeout(true);\n\n                Broadcaster b = r.getBroadcaster();\n                if (b instanceof DefaultBroadcaster) {\n                    ((DefaultBroadcaster) b).broadcastOnResume(r);\n                }\n\n                if (request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT) != null) {\n                    r.getAtmosphereResourceEvent().setIsResumedOnTimeout(\n                            (Boolean) request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT));\n                }\n\n                invokeAtmosphereHandler(r);\n            }\n        } catch (Throwable t) {\n            logger.error(\"failed to timeout resource {}\", r, t);\n        } finally {\n            config.framework().notify(Action.TYPE.TIMEOUT, request, response);\n            try {\n                if (r != null) {\n                    r.notifyListeners();\n                    r.setIsInScope(false);\n                    r.cancel();\n                }\n            } catch (Throwable t) {\n                logger.trace(\"timedout\", t);\n            } finally {\n                try {\n                    response.getOutputStream().close();\n                } catch (Throwable t) {\n                    try {\n                        response.getWriter().close();\n                    } catch (Throwable t2) {\n                    }\n                }\n\n                if (r != null) {\n                    r._destroy();\n                }\n            }\n        }\n\n        return timedoutAction;\n    }\n",
    "new_code_raw": "    public Action timedout(AtmosphereRequest req, AtmosphereResponse res)\n            throws IOException, ServletException {\n\n        logger.trace(\"Timing out {}\", req);\n        if (trackActiveRequest(req) && completeLifecycle(req.resource(), false)) {\n            config.framework().notify(Action.TYPE.TIMEOUT, req, res);\n        }\n        return timedoutAction;\n    }\n"
  },
  {
    "id": "elastic_elasticsearch_hadoop-20-Param-1",
    "old_comment_raw": "@param parser",
    "old_code_raw": "    public static Token seek(String path, Parser parser) {\n        // return current token if no path is given\n        if (!StringUtils.hasText(path)) {\n            return null;\n        }\n\n        List<String> tokens = StringUtils.tokenize(path, \".\");\n        return seek(parser, tokens.toArray(new String[tokens.size()]));\n    }\n",
    "new_code_raw": "    public static Token seek(Parser parser, String path) {\n        // return current token if no path is given\n        if (!StringUtils.hasText(path)) {\n            return null;\n        }\n\n        List<String> tokens = StringUtils.tokenize(path, \".\");\n        return seek(parser, tokens.toArray(new String[tokens.size()]));\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-451-Param-0",
    "old_comment_raw": "@param index the index to remove",
    "old_code_raw": "    public InstantConverter removeInstantConverter(int index) throws SecurityException {\n        checkAlterInstantConverters();\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(index, removed);\n        return removed[0];\n    }\n",
    "new_code_raw": "    public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-700-Param-0",
    "old_comment_raw": "@param info The input data",
    "old_code_raw": "  private double[] makeDatumUsingEmbedding(List<IN> info, int loc, FeatureFactory<IN> featureFactory, PaddedList<IN> pInfo, List<String> featuresC, List<Clique> windowCliques) {\n    double[] featureValArr;\n    List<double[]> embeddingList = new ArrayList<double[]>();\n    int concatEmbeddingLen = 0;\n    String currentWord = null;\n    for (int currLoc = loc-2; currLoc <= loc+2; currLoc++) {\n      double[] embedding = null;\n      if (currLoc >=0 && currLoc < info.size()) {\n        currentWord = info.get(loc).get(CoreAnnotations.TextAnnotation.class);\n        String word = currentWord.toLowerCase();\n        word = word.replaceAll(\"(-)?\\\\d+(\\\\.\\\\d*)?\", \"0\");\n        if (embeddings.containsKey(word))\n          embedding = embeddings.get(word);\n        else\n          embedding = embeddings.get(\"UNKNOWN\");\n      } else {\n        embedding = embeddings.get(\"PADDING\");\n      }\n\n      for (int e = 0; e < embedding.length; e++) {\n        featuresC.add(\"EMBEDDING-(\" + (currLoc-loc) + \")-\" + e);\n      }\n\n      if (flags.addCapitalFeatures) {\n        int numOfCapitalFeatures = 4;\n        double[] newEmbedding = new double[embedding.length + numOfCapitalFeatures];\n        int currLen = embedding.length;\n        System.arraycopy(embedding, 0, newEmbedding, 0, currLen);\n        for (int e = 0; e < numOfCapitalFeatures; e++)\n          featuresC.add(\"CAPITAL-(\" + (currLoc-loc) + \")-\" + e);\n\n        if (currLoc >=0 && currLoc < info.size()) { // skip PADDING\n          // check if word is all caps\n          if (currentWord.toUpperCase().equals(currentWord))\n            newEmbedding[currLen] = 1;\n          else {\n            currLen += 1;\n            // check if word is all lower\n            if (currentWord.toLowerCase().equals(currentWord))\n              newEmbedding[currLen] = 1;\n            else {\n              currLen += 1;\n              // check first letter cap\n              if (Character.isUpperCase(currentWord.charAt(0)))\n                newEmbedding[currLen] = 1;\n              else {\n                currLen += 1;\n                // check if at least one non-initial letter is cap\n                String remainder = currentWord.substring(1);\n                if (!remainder.toLowerCase().equals(remainder))\n                  newEmbedding[currLen] = 1;\n              }\n            }\n          }\n        }\n        embedding = newEmbedding;\n      }\n\n      embeddingList.add(embedding);\n      concatEmbeddingLen += embedding.length;\n    }\n    double[] concatEmbedding = new double[concatEmbeddingLen];\n    int currPos = 0;\n    for (double[] em: embeddingList) {\n      System.arraycopy(em, 0, concatEmbedding, currPos, em.length);\n      currPos += em.length;\n    }\n\n    if (flags.prependEmbedding) {\n      int additionalFeatureCount = 0;\n      for (Clique c : windowCliques) {\n        Collection<String> fCol = featureFactory.getCliqueFeatures(pInfo, loc, c); //todo useless copy because of typing reasons\n        featuresC.addAll(fCol);\n        additionalFeatureCount += fCol.size();\n      }\n      featureValArr = new double[concatEmbedding.length + additionalFeatureCount];\n      System.arraycopy(concatEmbedding, 0, featureValArr, 0, concatEmbedding.length);\n      Arrays.fill(featureValArr, concatEmbedding.length, featureValArr.length, 1.0);\n    } else {\n      featureValArr = concatEmbedding;\n    }\n\n    if (flags.addBiasToEmbedding) {\n      featuresC.add(\"BIAS-FEATURE\");\n      double[] newFeatureValArr = new double[featureValArr.length + 1];\n      System.arraycopy(featureValArr, 0, newFeatureValArr, 0, featureValArr.length);\n      newFeatureValArr[newFeatureValArr.length-1] = 1;\n      featureValArr = newFeatureValArr;\n    }\n    return featureValArr;\n  }\n",
    "new_code_raw": "  private double[] makeDatumUsingEmbedding(List<IN> info, int loc, List<FeatureFactory<IN>> featureFactories, PaddedList<IN> pInfo, List<String> featuresC, List<Clique> windowCliques) {\n    double[] featureValArr;\n    List<double[]> embeddingList = new ArrayList<double[]>();\n    int concatEmbeddingLen = 0;\n    String currentWord = null;\n    for (int currLoc = loc-2; currLoc <= loc+2; currLoc++) {\n      double[] embedding = null;\n      if (currLoc >=0 && currLoc < info.size()) {\n        currentWord = info.get(loc).get(CoreAnnotations.TextAnnotation.class);\n        String word = currentWord.toLowerCase();\n        word = word.replaceAll(\"(-)?\\\\d+(\\\\.\\\\d*)?\", \"0\");\n        if (embeddings.containsKey(word))\n          embedding = embeddings.get(word);\n        else\n          embedding = embeddings.get(\"UNKNOWN\");\n      } else {\n        embedding = embeddings.get(\"PADDING\");\n      }\n\n      for (int e = 0; e < embedding.length; e++) {\n        featuresC.add(\"EMBEDDING-(\" + (currLoc-loc) + \")-\" + e);\n      }\n\n      if (flags.addCapitalFeatures) {\n        int numOfCapitalFeatures = 4;\n        double[] newEmbedding = new double[embedding.length + numOfCapitalFeatures];\n        int currLen = embedding.length;\n        System.arraycopy(embedding, 0, newEmbedding, 0, currLen);\n        for (int e = 0; e < numOfCapitalFeatures; e++)\n          featuresC.add(\"CAPITAL-(\" + (currLoc-loc) + \")-\" + e);\n\n        if (currLoc >=0 && currLoc < info.size()) { // skip PADDING\n          // check if word is all caps\n          if (currentWord.toUpperCase().equals(currentWord))\n            newEmbedding[currLen] = 1;\n          else {\n            currLen += 1;\n            // check if word is all lower\n            if (currentWord.toLowerCase().equals(currentWord))\n              newEmbedding[currLen] = 1;\n            else {\n              currLen += 1;\n              // check first letter cap\n              if (Character.isUpperCase(currentWord.charAt(0)))\n                newEmbedding[currLen] = 1;\n              else {\n                currLen += 1;\n                // check if at least one non-initial letter is cap\n                String remainder = currentWord.substring(1);\n                if (!remainder.toLowerCase().equals(remainder))\n                  newEmbedding[currLen] = 1;\n              }\n            }\n          }\n        }\n        embedding = newEmbedding;\n      }\n\n      embeddingList.add(embedding);\n      concatEmbeddingLen += embedding.length;\n    }\n    double[] concatEmbedding = new double[concatEmbeddingLen];\n    int currPos = 0;\n    for (double[] em: embeddingList) {\n      System.arraycopy(em, 0, concatEmbedding, currPos, em.length);\n      currPos += em.length;\n    }\n\n    if (flags.prependEmbedding) {\n      int additionalFeatureCount = 0;\n      for (Clique c : windowCliques) {\n        for (FeatureFactory featureFactory : featureFactories) {\n          Collection<String> fCol = featureFactory.getCliqueFeatures(pInfo, loc, c); //todo useless copy because of typing reasons\n          featuresC.addAll(fCol);\n          additionalFeatureCount += fCol.size();\n        }\n      }\n      featureValArr = new double[concatEmbedding.length + additionalFeatureCount];\n      System.arraycopy(concatEmbedding, 0, featureValArr, 0, concatEmbedding.length);\n      Arrays.fill(featureValArr, concatEmbedding.length, featureValArr.length, 1.0);\n    } else {\n      featureValArr = concatEmbedding;\n    }\n\n    if (flags.addBiasToEmbedding) {\n      featuresC.add(\"BIAS-FEATURE\");\n      double[] newFeatureValArr = new double[featureValArr.length + 1];\n      System.arraycopy(featureValArr, 0, newFeatureValArr, 0, featureValArr.length);\n      newFeatureValArr[newFeatureValArr.length-1] = 1;\n      featureValArr = newFeatureValArr;\n    }\n    return featureValArr;\n  }\n"
  },
  {
    "id": "apache_drill-1537-Param-1",
    "old_comment_raw": "@param table",
    "old_code_raw": "  public static Properties getPartitionMetadata(final Partition partition, final Table table) {\n    final Properties properties = MetaStoreUtils.getPartitionMetadata(partition, table);\n\n    // SerDe expects properties from Table, but above call doesn't add Table properties.\n    // Include Table properties in final list in order to not to break SerDes that depend on\n    // Table properties. For example AvroSerDe gets the schema from properties (passed as second argument)\n    for (Map.Entry<String, String> entry : table.getParameters().entrySet()) {\n      if (entry.getKey() != null && entry.getKey() != null) {\n        properties.put(entry.getKey(), entry.getValue());\n      }\n    }\n\n    return properties;\n  }\n",
    "new_code_raw": "  public static Properties getPartitionMetadata(final HivePartition partition, final HiveTableWithColumnCache table) {\n    final Properties properties;\n    restoreColumns(table, partition);\n    properties = MetaStoreUtils.getPartitionMetadata(partition, table);\n\n    // SerDe expects properties from Table, but above call doesn't add Table properties.\n    // Include Table properties in final list in order to not to break SerDes that depend on\n    // Table properties. For example AvroSerDe gets the schema from properties (passed as second argument)\n    for (Map.Entry<String, String> entry : table.getParameters().entrySet()) {\n      if (entry.getKey() != null && entry.getKey() != null) {\n        properties.put(entry.getKey(), entry.getValue());\n      }\n    }\n\n    return properties;\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1696-Param-2",
    "old_comment_raw": "@param additionalMetadata Additional data to pass to server",
    "old_code_raw": "    public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws RestClientException {\n        Object postBody = new Object();\n        \n        // verify the required parameter 'petId' is set\n        if (petId == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n        }\n        \n        // verify the required parameter 'file' is set\n        if (file == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'file' when calling uploadFileWithRequiredFile\");\n        }\n        \n        // create path and map variables\n        final Map<String, Object> uriVariables = new HashMap<String, Object>();\n        uriVariables.put(\"petId\", petId);\n        String path = UriComponentsBuilder.fromPath(\"/fake/{petId}/uploadImageWithRequiredFile\").buildAndExpand(uriVariables).toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n        \n        if (additionalMetadata != null)\n            formParams.add(\"additionalMetadata\", additionalMetadata);\n        if (file != null)\n            formParams.add(\"file\", new FileSystemResource(file));\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"multipart/form-data\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"petstore_auth\" };\n\n        ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "new_code_raw": "    public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws RestClientException {\n        Object postBody = new Object();\n        \n        // verify the required parameter 'petId' is set\n        if (petId == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n        }\n        \n        // verify the required parameter 'requiredFile' is set\n        if (requiredFile == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\");\n        }\n        \n        // create path and map variables\n        final Map<String, Object> uriVariables = new HashMap<String, Object>();\n        uriVariables.put(\"petId\", petId);\n        String path = UriComponentsBuilder.fromPath(\"/fake/{petId}/uploadImageWithRequiredFile\").buildAndExpand(uriVariables).toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n        \n        if (additionalMetadata != null)\n            formParams.add(\"additionalMetadata\", additionalMetadata);\n        if (requiredFile != null)\n            formParams.add(\"requiredFile\", new FileSystemResource(requiredFile));\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"multipart/form-data\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"petstore_auth\" };\n\n        ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n"
  },
  {
    "id": "zaproxy_zaproxy-2146-Param-1",
    "old_comment_raw": "@param scannerPackage the name of the scanner package",
    "old_code_raw": "\tprivate static String getSpecificQuality(String scannerName, String scannerPackage) {\n\n        String quality = \"\";\n        \n        if (BETA_REGEX.matcher(scannerPackage).matches())\n        \tquality = QUALITY_BETA;\n        else if (ALPHA_REGEX.matcher(scannerPackage).matches()) \n        \tquality = QUALITY_ALPHA;\n        else if (SCRIPT_RULES_REGEX.matcher(scannerPackage).matches()) \n        \tquality = QUALITY_SCRIPT_RULES;\n        else  // We haven't matched yet so it must be Release\n        \tquality = QUALITY_RELEASE;\n        \n        return quality;\n\t}\n",
    "new_code_raw": "\tprivate static String getSpecificQuality(String scannerName, Object scanner) {\n\n\t\tString scannerPackage=scanner.getClass().getCanonicalName();\n        String quality = \"\";\n        \n        if (BETA_REGEX.matcher(scannerPackage).matches())\n        \tquality = QUALITY_BETA;\n        else if (ALPHA_REGEX.matcher(scannerPackage).matches()) \n        \tquality = QUALITY_ALPHA;\n        else if (SCRIPT_RULES_REGEX.matcher(scannerName).matches()) \n        \tquality = QUALITY_SCRIPT_RULES;\n        else  // We haven't matched yet so it must be Release\n        \tquality = QUALITY_RELEASE;\n        \n        return quality;\n\t}\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-870-Param-0",
    "old_comment_raw": "@param includeExtras If true, the list of typed dependencies returned may include \"extras\", such as controlled subject links.",
    "old_code_raw": "  public List<TypedDependency> typedDependenciesCCprocessed(boolean includeExtras) {\n    List<TypedDependency> tdl = typedDependencies(includeExtras);\n    collapseDependencies(tdl, true, includeExtras);\n    return tdl;\n  }\n",
    "new_code_raw": "  public List<TypedDependency> typedDependenciesCCprocessed(Extras includeExtras) {\n    List<TypedDependency> tdl = typedDependencies(includeExtras);\n    collapseDependencies(tdl, true, includeExtras);\n    return tdl;\n  }\n"
  },
  {
    "id": "codehaus_cake-4-Associations-Param0",
    "old_comment_raw": "@param attributes an object containing an AttributeMap",
    "old_code_raw": "    public char get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n",
    "new_code_raw": "    public char get(WithAttributes withAttributes) {\r\n        return withAttributes.getAttributes().get(this);\r\n    }\r\n\n"
  },
  {
    "id": "elastic_elasticsearch_hadoop-4-Param-1",
    "old_comment_raw": "@param includes",
    "old_code_raw": "    public static boolean filter(String path, List<String> includes, List<String> excludes) {\n        includes = (includes == null ? Collections.<String> emptyList() : includes);\n        excludes = (excludes == null ? Collections.<String> emptyList() : excludes);\n\n        if (includes.isEmpty() && excludes.isEmpty()) {\n            return true;\n        }\n\n        if (Regex.simpleMatch(excludes, path)) {\n            return false;\n        }\n\n        boolean exactIncludeMatch = false; // true if the current position was specifically mentioned\n        boolean pathIsPrefixOfAnInclude = false; // true if potentially a sub scope can be included\n        if (includes.isEmpty()) {\n            // implied match anything\n            exactIncludeMatch = true;\n        }\n        else {\n            for (String include : includes) {\n                // check for prefix matches as well to see if we need to zero in, something like: obj1.arr1.* or *.field\n                // note, this does not work well with middle matches, like obj1.*.obj3\n                if (include.charAt(0) == '*') {\n                    if (Regex.simpleMatch(include, path)) {\n                        exactIncludeMatch = true;\n                        break;\n                    }\n                    pathIsPrefixOfAnInclude = true;\n                    continue;\n                }\n                if (include.startsWith(path)) {\n                    if (include.length() == path.length()) {\n                        exactIncludeMatch = true;\n                        break;\n                    }\n                    else if (include.length() > path.length() && include.charAt(path.length()) == '.') {\n                        // include might may match deeper paths. Dive deeper.\n                        pathIsPrefixOfAnInclude = true;\n                        continue;\n                    }\n                }\n                if (Regex.simpleMatch(include, path)) {\n                    exactIncludeMatch = true;\n                    break;\n                }\n            }\n        }\n\n        if (!(pathIsPrefixOfAnInclude || exactIncludeMatch)) {\n            // skip subkeys, not interesting.\n            return false;\n        }\n\n        else if (exactIncludeMatch) {\n            return true;\n        }\n        return true;\n    }\n",
    "new_code_raw": "    public static boolean filter(String path, Collection<String> includes, Collection<String> excludes) {\n        includes = (includes == null ? Collections.<String> emptyList() : includes);\n        excludes = (excludes == null ? Collections.<String> emptyList() : excludes);\n\n        if (includes.isEmpty() && excludes.isEmpty()) {\n            return true;\n        }\n\n        if (Regex.simpleMatch(excludes, path)) {\n            return false;\n        }\n\n        boolean exactIncludeMatch = false; // true if the current position was specifically mentioned\n        boolean pathIsPrefixOfAnInclude = false; // true if potentially a sub scope can be included\n        if (includes.isEmpty()) {\n            // implied match anything\n            exactIncludeMatch = true;\n        }\n        else {\n            for (String include : includes) {\n                // check for prefix matches as well to see if we need to zero in, something like: obj1.arr1.* or *.field\n                // note, this does not work well with middle matches, like obj1.*.obj3\n                if (include.charAt(0) == '*') {\n                    if (Regex.simpleMatch(include, path)) {\n                        exactIncludeMatch = true;\n                        break;\n                    }\n                    pathIsPrefixOfAnInclude = true;\n                    continue;\n                }\n                if (include.startsWith(path)) {\n                    if (include.length() == path.length()) {\n                        exactIncludeMatch = true;\n                        break;\n                    }\n                    else if (include.length() > path.length() && include.charAt(path.length()) == '.') {\n                        // include might may match deeper paths. Dive deeper.\n                        pathIsPrefixOfAnInclude = true;\n                        continue;\n                    }\n                }\n                if (Regex.simpleMatch(include, path)) {\n                    exactIncludeMatch = true;\n                    break;\n                }\n            }\n        }\n\n        if (!(pathIsPrefixOfAnInclude || exactIncludeMatch)) {\n            // skip subkeys, not interesting.\n            return false;\n        }\n\n        else if (exactIncludeMatch) {\n            return true;\n        }\n        return false;\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-429-Param-0",
    "old_comment_raw": "@param millis the time instant in millis to query",
    "old_code_raw": "    public String getAsText(long millis, Locale locale) {\n        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(get(millis));\n    }\n",
    "new_code_raw": "    public String getAsText(long instant, Locale locale) {\n        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(get(instant));\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-1506-Param-1",
    "old_comment_raw": "@param matches the number of matches expected to be found.  0 matches means that one or more matches are expected to be found",
    "old_code_raw": "\tpublic boolean searchText(String search, int matches, boolean scroll) {\n\t\treturn searcher.searchText(search, matches, scroll);\n\t}\n",
    "new_code_raw": "\tpublic boolean searchText(String regex, int matches, boolean scroll) {\n\t\treturn searcher.searchText(regex, matches, scroll);\n\t}\n"
  },
  {
    "id": "hibernate_hibernate_orm-333-Param-1",
    "old_comment_raw": "@param dialect The dialect in effect",
    "old_code_raw": "\tprotected QualifiedName determineGeneratorTableName(Properties params, Dialect dialect) {\n\t\tfinal ObjectNameNormalizer normalizer = (ObjectNameNormalizer) params.get( IDENTIFIER_NORMALIZER );\n\n\t\treturn QualifiedNameParser.INSTANCE.parse(\n\t\t\t\tConfigurationHelper.getString( TABLE_PARAM, params, DEF_TABLE ),\n\t\t\t\tnormalizer.normalizeIdentifierQuoting( params.getProperty( CATALOG ) ),\n\t\t\t\tnormalizer.normalizeIdentifierQuoting( params.getProperty( SCHEMA ) )\n\t\t);\n\t}\n",
    "new_code_raw": "\tprotected QualifiedName determineGeneratorTableName(Properties params, JdbcEnvironment jdbcEnvironment) {\n\t\tfinal String tableName = ConfigurationHelper.getString( TABLE_PARAM, params, DEF_TABLE );\n\n\t\tif ( tableName.contains( \".\" ) ) {\n\t\t\treturn QualifiedNameParser.INSTANCE.parse( tableName );\n\t\t}\n\t\telse {\n\t\t\t// todo : need to incorporate implicit catalog and schema names\n\t\t\tfinal Identifier catalog = jdbcEnvironment.getIdentifierHelper().toIdentifier(\n\t\t\t\t\tConfigurationHelper.getString( CATALOG, params )\n\t\t\t);\n\t\t\tfinal Identifier schema = jdbcEnvironment.getIdentifierHelper().toIdentifier(\n\t\t\t\t\tConfigurationHelper.getString( SCHEMA, params )\n\t\t\t);\n\t\t\treturn new QualifiedNameParser.NameParts(\n\t\t\t\t\tcatalog,\n\t\t\t\t\tschema,\n\t\t\t\t\tjdbcEnvironment.getIdentifierHelper().toIdentifier( tableName )\n\t\t\t);\n\t\t}\n\t}\n"
  },
  {
    "id": "debezium_debezium-728-Param-0",
    "old_comment_raw": "@param before the state of the record before the delete; may be null",
    "old_code_raw": "    public Struct delete(Object before, Struct source, Long timestamp) {\n        Struct struct = new Struct(schema);\n        struct.put(FieldName.OPERATION, Operation.DELETE.code());\n        if (before != null) {\n            struct.put(FieldName.BEFORE, before);\n        }\n        if (source != null) {\n            struct.put(FieldName.SOURCE, source);\n        }\n        if (timestamp != null) {\n            struct.put(FieldName.TIMESTAMP, timestamp);\n        }\n        return struct;\n    }\n",
    "new_code_raw": "    public Struct delete(Object before, Struct source, Instant timestamp) {\n        Struct struct = new Struct(schema);\n        struct.put(FieldName.OPERATION, Operation.DELETE.code());\n        if (before != null) {\n            struct.put(FieldName.BEFORE, before);\n        }\n        if (source != null) {\n            struct.put(FieldName.SOURCE, source);\n        }\n        if (timestamp != null) {\n            struct.put(FieldName.TIMESTAMP, timestamp.toEpochMilli());\n        }\n        return struct;\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1703-Param-0",
    "old_comment_raw": "@param client client model (required)",
    "old_code_raw": "  public Client call123testSpecialTags(Client client) throws ApiException {\n    Object localVarPostBody = client;\n    \n    // verify the required parameter 'client' is set\n    if (client == null) {\n      throw new ApiException(400, \"Missing the required parameter 'client' when calling call123testSpecialTags\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/another-fake/dummy\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public Client call123testSpecialTags(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling call123testSpecialTags\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/another-fake/dummy\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "querydsl_querydsl-933-Param-0",
    "old_comment_raw": "@param right rhs of the comparison",
    "old_code_raw": "    public BooleanExpression notIn(D... right) {\n        if (right.length == 1){\n            return ne(right[0]);\n        }else{\n            return in(right).not();\n        }\n    }\n",
    "new_code_raw": "    public BooleanExpression notIn(T... right) {\n        if (right.length == 1){\n            return ne(right[0]);\n        }else{\n            return in(right).not();\n        }\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1641-Param-0",
    "old_comment_raw": "@param body Input boolean as post body (optional)",
    "old_code_raw": "  public ApiResponse<Boolean> fakeOuterBooleanSerializeWithHttpInfo(Boolean body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/boolean\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public ApiResponse<Boolean> fakeOuterBooleanSerializeWithHttpInfo(Boolean booleanPostBody) throws ApiException {\n    Object localVarPostBody = booleanPostBody;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/boolean\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"*/*\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1216-Param-1",
    "old_comment_raw": "@param session The orginating session.",
    "old_code_raw": "\tprotected boolean isNull(Object owner, SessionImplementor session) {\n\t\treturn false;\n\t}\n",
    "new_code_raw": "\tprotected boolean isNull(Object owner, SharedSessionContractImplementor session) {\n\t\treturn false;\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1717-Param-0",
    "old_comment_raw": "@param client client model (required)",
    "old_code_raw": "    public Single<Client> rxCall123testSpecialTags(Client client) {\n        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {\n            delegate.call123testSpecialTags(client, fut);\n        }));\n    }\n",
    "new_code_raw": "    public Single<Client> rxCall123testSpecialTags(Client body) {\n        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {\n            delegate.call123testSpecialTags(body, fut);\n        }));\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-908-Param-0",
    "old_comment_raw": "@param includeExtras If true, the list of typed dependencies returned may include \"extras\", such as controlled subject links.",
    "old_code_raw": "  public List<TypedDependency> typedDependenciesCCprocessed(Extras includeExtras) {\n    List<TypedDependency> tdl = typedDependencies(includeExtras);\n    collapseDependencies(tdl, true, includeExtras);\n    return tdl;\n  }\n",
    "new_code_raw": "  public List<TypedDependency> typedDependenciesCCprocessed(boolean includeExtras) {\n    List<TypedDependency> tdl = typedDependencies(false);\n    // Adds stuff to the basic dependencies.\n    // We don't want to simply call typedDependencies with\n    // \"includeExtras\" because the collapseDependencies method may add\n    // the extras in a way that makes more logical sense.  For\n    // example, the English dependencies, when CC processed, have more\n    // nsubjs than they originally do.  If we wait until that occurs\n    // to add xsubj for xcomp dependencies, we get better coverage.\n    if (includeExtras) {\n      getTreeDeps(root(), tdl, new NoPunctTypedDependencyFilter(puncFilter), extraTreeDepFilter());\n    }\n    collapseDependencies(tdl, true, includeExtras);\n    return tdl;\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1670-Param-0",
    "old_comment_raw": "@param body order placed for purchasing the pet (required)",
    "old_code_raw": "  public Order placeOrder(Order body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling placeOrder\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/store/order\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/xml\", \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Order> localVarReturnType = new GenericType<Order>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public Order placeOrder(Order order) throws ApiException {\n    Object localVarPostBody = order;\n    \n    // verify the required parameter 'order' is set\n    if (order == null) {\n      throw new ApiException(400, \"Missing the required parameter 'order' when calling placeOrder\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/store/order\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/xml\", \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Order> localVarReturnType = new GenericType<Order>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "apache_drill-929-Param-2",
    "old_comment_raw": "@param dirCount number of partition directories",
    "old_code_raw": "  public static TupleMetadata expandMetadata(TupleMetadata base, FileMetadataManager metadataProj, int dirCount) {\n    TupleMetadata metadataSchema = new TupleSchema();\n    for (ColumnMetadata col : base) {\n      metadataSchema.addColumn(col);\n    }\n    for (FileMetadataColumnDefn fileColDefn : metadataProj.fileMetadataColDefns()) {\n      metadataSchema.add(MaterializedField.create(fileColDefn.colName(), fileColDefn.dataType()));\n    }\n    for (int i = 0; i < dirCount; i++) {\n      metadataSchema.add(MaterializedField.create(metadataProj.partitionName(i),\n          PartitionColumn.dataType()));\n    }\n    return metadataSchema;\n  }\n",
    "new_code_raw": "  public static TupleMetadata expandMetadata(TupleMetadata base, ImplicitColumnManager metadataProj, int dirCount) {\n    TupleMetadata metadataSchema = new TupleSchema();\n    for (ColumnMetadata col : base) {\n      metadataSchema.addColumn(col);\n    }\n    for (FileMetadataColumnDefn fileColDefn : metadataProj.fileMetadataColDefns()) {\n      metadataSchema.add(MaterializedField.create(fileColDefn.colName(), fileColDefn.dataType()));\n    }\n    for (int i = 0; i < dirCount; i++) {\n      metadataSchema.add(MaterializedField.create(metadataProj.partitionName(i),\n          PartitionColumn.dataType()));\n    }\n    return metadataSchema;\n  }\n"
  },
  {
    "id": "Atmosphere_atmosphere-854-Param-1",
    "old_comment_raw": "@param res the  HttpServletResponse",
    "old_code_raw": "    public Action suspended(HttpServletRequest req, HttpServletResponse res)\n            throws IOException, ServletException {\n        if (logger.isLoggable(Level.FINE)) {\n            logger.fine(\"(suspend) invoked:\\n HttpServletRequest: \" + req\n                    + \"\\n HttpServletResponse: \" + res);\n        }\n        return action(req, res);\n    }\n",
    "new_code_raw": "    public Action suspended(HttpServletRequest request, HttpServletResponse response)\n            throws IOException, ServletException {\n        logger.debug(\"(suspend) invoked:\\n HttpServletRequest: {}\\n HttpServletResponse: {}\", request, response);\n        return action(request, response);\n    }\n"
  },
  {
    "id": "querydsl_querydsl-1822-Param-0",
    "old_comment_raw": "@param name the name of the property whose value to return",
    "old_code_raw": "    public Object get(Object name) {\n        if ( bean != null ) {\n            Method method = getReadMethod( name );\n            if ( method != null ) {\n                try {\n                    return method.invoke( bean, NULL_ARGUMENTS );\n                }\n                catch (  IllegalAccessException e ) {\n                    logWarn( e );\n                }\n                catch ( IllegalArgumentException e ) {\n                    logWarn(  e );\n                }\n                catch ( InvocationTargetException e ) {\n                    logWarn(  e );\n                }\n                catch ( NullPointerException e ) {\n                    logWarn(  e );\n                }\n            }\n        }\n        return null;\n    }\n",
    "new_code_raw": "    public Object get(String name) {\n        if (bean != null) {\n            Method method = getReadMethod(name);\n            if (method != null) {\n                try {\n                    return method.invoke(bean, NULL_ARGUMENTS);\n                } catch (IllegalAccessException e) {\n                    logWarn(e);\n                } catch (IllegalArgumentException e) {\n                    logWarn(e);\n                } catch (InvocationTargetException e) {\n                    logWarn(e);\n                } catch (NullPointerException e) {\n                    logWarn(e);\n                }\n            }\n        }\n        return null;\n    }\n"
  },
  {
    "id": "Atmosphere_atmosphere-836-Param-0",
    "old_comment_raw": "@param closedAtmosphereThinkTime",
    "old_code_raw": "    public String getInitParameter(String closedAtmosphereThinkTime, String defaultValue) {\n        String s = getInitParameter(closedAtmosphereThinkTime);\n        if (s == null) {\n            return defaultValue;\n        }\n        return s;\n    }\n",
    "new_code_raw": "    public String getInitParameter(String key, String defaultValue) {\n        String s = getInitParameter(key);\n        if (s == null) {\n            return defaultValue;\n        }\n        return s;\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-233-Param-2",
    "old_comment_raw": "@param expectedMinimumNumberOfMatches the minimum number of matches expected to be found.  0 matches means that one or more matches are expected to be found",
    "old_code_raw": "\tpublic boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll) {\n\t\tfinal long endTime = System.currentTimeMillis() + TIMEOUT;\n\n\t\twhile (System.currentTimeMillis() < endTime) {\n\t\t\tsleeper.sleep();\n\t\t\tfinal boolean foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, scroll);\n\t\t\tif (foundAnyMatchingView){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n",
    "new_code_raw": "\tpublic boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll, boolean visible) {\n\t\tfinal long endTime = System.currentTimeMillis() + TIMEOUT;\n\n\t\twhile (System.currentTimeMillis() < endTime) {\n\t\t\tsleeper.sleep();\n\t\t\tfinal boolean foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, scroll, visible);\n\t\t\tif (foundAnyMatchingView){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-264-Param-1",
    "old_comment_raw": "@param labelFormatter Formatting routine for how to print a Label",
    "old_code_raw": "  public StringBuilder toStringBuilder(StringBuilder sb, Function<Label,String> labelFormatter) {\n    if (isLeaf()) {\n      if (label() != null) {\n        sb.append(labelFormatter.apply(label()));\n      }\n      return sb;\n    } else {\n      sb.append('(');\n      if (label() != null) {\n        sb.append(labelFormatter.apply(label()));\n      }\n      Tree[] kids = children();\n      if (kids != null) {\n        for (Tree kid : kids) {\n          sb.append(' ');\n          kid.toStringBuilder(sb, labelFormatter);\n        }\n      }\n      return sb.append(')');\n    }\n  }\n",
    "new_code_raw": "  public StringBuilder toStringBuilder(StringBuilder sb, boolean printOnlyLabelValue) {\n    if (isLeaf()) {\n      if (label() != null) {\n        if(printOnlyLabelValue) {\n          sb.append(label().value());\n        } else {\n          sb.append(label());\n        }\n      }\n      return sb;\n    } else {\n      sb.append('(');\n      if (label() != null) {\n        if (printOnlyLabelValue) {\n          if (value() != null) {\n            sb.append(label().value());\n          }\n          // don't print a null, just nothing!\n        } else {\n          sb.append(label());\n        }\n      }\n      Tree[] kids = children();\n      if (kids != null) {\n        for (Tree kid : kids) {\n          sb.append(' ');\n          kid.toStringBuilder(sb, printOnlyLabelValue);\n        }\n      }\n      return sb.append(')');\n    }\n  }\n"
  },
  {
    "id": "LawnchairLauncher_Lawnchair-52-Param-1",
    "old_comment_raw": "@param info information about the widget",
    "old_code_raw": "    private RectF drawBoxWithShadow(Canvas c, int width, int height) {\n        Resources res = mContext.getResources();\n\n        ShadowGenerator.Builder builder = new ShadowGenerator.Builder(Color.WHITE);\n        builder.shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);\n        builder.radius = res.getDimension(R.dimen.widget_preview_corner_radius);\n        builder.keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);\n\n        builder.bounds.set(builder.shadowBlur, builder.shadowBlur,\n                width - builder.shadowBlur,\n                height - builder.shadowBlur - builder.keyShadowDistance);\n        builder.drawShadow(c);\n        return builder.bounds;\n    }\n",
    "new_code_raw": "    private RectF drawBoxWithShadow(Canvas c, Paint p, int width, int height) {\n        Resources res = mContext.getResources();\n        float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);\n        float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);\n        float corner = res.getDimension(R.dimen.widget_preview_corner_radius);\n\n        RectF bounds = new RectF(shadowBlur, shadowBlur,\n                width - shadowBlur, height - shadowBlur - keyShadowDistance);\n        p.setColor(Color.WHITE);\n\n        // Key shadow\n        p.setShadowLayer(shadowBlur, 0, keyShadowDistance,\n                ShadowGenerator.KEY_SHADOW_ALPHA << 24);\n        c.drawRoundRect(bounds, corner, corner, p);\n\n        // Ambient shadow\n        p.setShadowLayer(shadowBlur, 0, 0,\n                ColorUtils.setAlphaComponent(Color.BLACK, ShadowGenerator.AMBIENT_SHADOW_ALPHA));\n        c.drawRoundRect(bounds, corner, corner, p);\n\n        p.clearShadowLayer();\n        return bounds;\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-345-Param-2",
    "old_comment_raw": "@param hi The high value",
    "old_code_raw": "\tpublic static Criterion between(String propertyName, Object lo, Object hi) {\n\t\treturn new BetweenExpression( propertyName, lo, hi );\n\t}\n",
    "new_code_raw": "\tpublic static Criterion between(String propertyName, Object low, Object high) {\n\t\treturn new BetweenExpression( propertyName, low, high );\n\t}\n"
  },
  {
    "id": "SeleniumHQ_selenium-856-Param-2",
    "old_comment_raw": "@param registry",
    "old_code_raw": "  public static RemoteProxy getNewBasicRemoteProxy(Map<String, Object> cap, String url, Registry registry) {\n    RegistrationRequest req = RegistrationRequest.build(\"-role\", \"webdriver\");\n    req.getCapabilities().clear();\n    req.addDesiredCapabilitiy(cap);\n    req.getConfiguration().put(RegistrationRequest.REMOTE_URL, url);\n    return new RemoteProxy(req, registry);\n\n  }\n",
    "new_code_raw": "  public static RemoteProxy getNewBasicRemoteProxy(String browser, String url, Registry registry) {\n\n    RegistrationRequest req = RegistrationRequest.build(\"-role\", \"webdriver\");\n    req.getCapabilities().clear();\n\n    DesiredCapabilities capability = new DesiredCapabilities();\n    capability.setBrowserName(browser);\n    req.addDesiredCapabilitiy(capability);\n\n    Map<String, Object> config = new HashMap<String, Object>();\n    config.put(\"url\", url);\n    req.setConfiguration(config);\n    return new RemoteProxy(req, registry);\n\n  }\n"
  },
  {
    "id": "graphql_java_graphql_java-460-Param-0",
    "old_comment_raw": "@param schemaTransformer the non null schema transformer to add",
    "old_code_raw": "        public Builder transformer(SchemaTransformer schemaTransformer) {\n            this.schemaTransformers.add(assertNotNull(schemaTransformer));\n            return this;\n        }\n",
    "new_code_raw": "        public Builder transformer(SchemaGeneratorPostProcessing schemaGeneratorPostProcessing) {\n            this.schemaGeneratorPostProcessings.add(assertNotNull(schemaGeneratorPostProcessing));\n            return this;\n        }\n"
  },
  {
    "id": "apache_calcite-348-Param-0",
    "old_comment_raw": "@param rel Relational expression being implemented",
    "old_code_raw": "    public Builder builder(JdbcRel rel, Clause... clauses) {\n      final Clause maxClause = maxClause();\n      boolean needNew = false;\n      for (Clause clause : clauses) {\n        if (maxClause.ordinal() >= clause.ordinal()) {\n          needNew = true;\n        }\n      }\n      SqlSelect select;\n      Expressions.FluentList<Clause> clauseList = Expressions.list();\n      if (needNew) {\n        select = subSelect();\n      } else {\n        select = asSelect();\n        clauseList.addAll(this.clauses);\n      }\n      clauseList.appendAll(clauses);\n      Context newContext;\n      final SqlNodeList selectList = select.getSelectList();\n      if (selectList != null) {\n        newContext = new Context(selectList.size()) {\n          @Override public SqlNode field(int ordinal) {\n            final SqlNode selectItem = selectList.get(ordinal);\n            switch (selectItem.getKind()) {\n            case AS:\n              return ((SqlCall) selectItem).operand(0);\n            }\n            return selectItem;\n          }\n        };\n      } else {\n        newContext = aliasContext(aliases, aliases.size() > 1);\n      }\n      return new Builder(rel, clauseList, select, newContext);\n    }\n",
    "new_code_raw": "    public Builder builder(RelNode rel, Clause... clauses) {\n      final Clause maxClause = maxClause();\n      boolean needNew = false;\n      // If old and new clause are equal and belong to below set,\n      // then new SELECT wrap is not required\n      Set<Clause> nonWrapSet = ImmutableSet.of(Clause.SELECT);\n      for (Clause clause : clauses) {\n        if (maxClause.ordinal() > clause.ordinal()\n            || (maxClause.equals(clause) && !nonWrapSet.contains(clause))) {\n          needNew = true;\n        }\n      }\n      SqlSelect select;\n      Expressions.FluentList<Clause> clauseList = Expressions.list();\n      if (needNew) {\n        select = subSelect();\n      } else {\n        select = asSelect();\n        clauseList.addAll(this.clauses);\n      }\n      clauseList.appendAll(clauses);\n      Context newContext;\n      final SqlNodeList selectList = select.getSelectList();\n      if (selectList != null) {\n        newContext = new Context(selectList.size()) {\n          public SqlNode field(int ordinal) {\n            final SqlNode selectItem = selectList.get(ordinal);\n            switch (selectItem.getKind()) {\n            case AS:\n              return ((SqlCall) selectItem).operand(0);\n            }\n            return selectItem;\n          }\n        };\n      } else {\n        newContext = aliasContext(aliases, aliases.size() > 1);\n      }\n      return new Builder(rel, clauseList, select, newContext);\n    }\n"
  },
  {
    "id": "apache_drill-969-Param-0",
    "old_comment_raw": "@param context - shared state used during planning, currently used here to gain access to the fucntion registry described above.",
    "old_code_raw": "  public static RuleSet getDrillBasicRules(QueryContext context) {\n    if (DRILL_BASIC_RULES == null) {\n\n      DRILL_BASIC_RULES = new DrillRuleSet(ImmutableSet.<RelOptRule> builder().add( //\n      // Add support for Distinct Union (by using Union-All followed by Distinct)\n      UnionToDistinctRule.INSTANCE,\n\n      // Add support for WHERE style joins.\n      DrillFilterJoinRules.DRILL_FILTER_ON_JOIN,\n      DrillFilterJoinRules.DRILL_JOIN,\n      // End support for WHERE style joins.\n\n      /*\n       Filter push-down related rules\n       */\n      DrillPushFilterPastProjectRule.INSTANCE,\n      FilterSetOpTransposeRule.INSTANCE,\n\n      FilterMergeRule.INSTANCE,\n      AggregateRemoveRule.INSTANCE,\n      ProjectRemoveRule.NAME_CALC_INSTANCE,\n      SortRemoveRule.INSTANCE,\n\n      DrillMergeProjectRule.getInstance(true, RelFactories.DEFAULT_PROJECT_FACTORY, context.getFunctionRegistry()),\n      AggregateExpandDistinctAggregatesRule.INSTANCE,\n      DrillReduceAggregatesRule.INSTANCE,\n\n      /*\n       Projection push-down related rules\n       */\n      DrillPushProjectPastFilterRule.INSTANCE,\n      DrillPushProjectPastJoinRule.INSTANCE,\n      DrillPushProjIntoScan.INSTANCE,\n      DrillProjectSetOpTransposeRule.INSTANCE,\n\n      PruneScanRule.getFilterOnProject(context),\n      PruneScanRule.getFilterOnScan(context),\n      PruneScanRule.getFilterOnProjectParquet(context),\n      PruneScanRule.getFilterOnScanParquet(context),\n\n      /*\n       Convert from Calcite Logical to Drill Logical Rules.\n       */\n      ExpandConversionRule.INSTANCE,\n      DrillScanRule.INSTANCE,\n      DrillFilterRule.INSTANCE,\n      DrillProjectRule.INSTANCE,\n      DrillWindowRule.INSTANCE,\n      DrillAggregateRule.INSTANCE,\n\n      DrillLimitRule.INSTANCE,\n      DrillSortRule.INSTANCE,\n      DrillJoinRule.INSTANCE,\n      DrillUnionAllRule.INSTANCE,\n      DrillValuesRule.INSTANCE\n      )\n      .build());\n    }\n\n    return DRILL_BASIC_RULES;\n  }\n",
    "new_code_raw": "  public static RuleSet getDrillBasicRules(OptimizerRulesContext optimizerRulesContext) {\n    if (DRILL_BASIC_RULES == null) {\n\n      DRILL_BASIC_RULES = new DrillRuleSet(ImmutableSet.<RelOptRule> builder().add( //\n      // Add support for Distinct Union (by using Union-All followed by Distinct)\n      UnionToDistinctRule.INSTANCE,\n\n      // Add support for WHERE style joins.\n      DrillFilterJoinRules.DRILL_FILTER_ON_JOIN,\n      DrillFilterJoinRules.DRILL_JOIN,\n      // End support for WHERE style joins.\n\n      /*\n       Filter push-down related rules\n       */\n      DrillPushFilterPastProjectRule.INSTANCE,\n      FilterSetOpTransposeRule.INSTANCE,\n\n      FilterMergeRule.INSTANCE,\n      AggregateRemoveRule.INSTANCE,\n      ProjectRemoveRule.NAME_CALC_INSTANCE,\n      SortRemoveRule.INSTANCE,\n\n      DrillMergeProjectRule.getInstance(true, RelFactories.DEFAULT_PROJECT_FACTORY,\n          optimizerRulesContext.getFunctionRegistry()),\n      AggregateExpandDistinctAggregatesRule.INSTANCE,\n      DrillReduceAggregatesRule.INSTANCE,\n\n      /*\n       Projection push-down related rules\n       */\n      DrillPushProjectPastFilterRule.INSTANCE,\n      DrillPushProjectPastJoinRule.INSTANCE,\n      DrillPushProjIntoScan.INSTANCE,\n      DrillProjectSetOpTransposeRule.INSTANCE,\n\n      PruneScanRule.getFilterOnProject(optimizerRulesContext),\n      PruneScanRule.getFilterOnScan(optimizerRulesContext),\n      PruneScanRule.getFilterOnProjectParquet(optimizerRulesContext),\n      PruneScanRule.getFilterOnScanParquet(optimizerRulesContext),\n\n      /*\n       Convert from Calcite Logical to Drill Logical Rules.\n       */\n      ExpandConversionRule.INSTANCE,\n      DrillScanRule.INSTANCE,\n      DrillFilterRule.INSTANCE,\n      DrillProjectRule.INSTANCE,\n      DrillWindowRule.INSTANCE,\n      DrillAggregateRule.INSTANCE,\n\n      DrillLimitRule.INSTANCE,\n      DrillSortRule.INSTANCE,\n      DrillJoinRule.INSTANCE,\n      DrillUnionAllRule.INSTANCE,\n      DrillValuesRule.INSTANCE\n      )\n      .build());\n    }\n\n    return DRILL_BASIC_RULES;\n  }\n"
  },
  {
    "id": "SeleniumHQ_selenium-653-Param-1",
    "old_comment_raw": "@param url",
    "old_code_raw": "\tpublic static RemoteProxy getNewBasicRemoteProxy(List<Map<String, Object>> caps, String url) {\n\n\t\tRegistrationRequest req = new RegistrationRequest();\n\n\t\treq.setCapabilities(caps);\n\n\t\tMap<String, Object> config = new HashMap<String, Object>();\n\t\tconfig.put(\"url\", url);\n\t\treq.setConfiguration(config);\n\t\treturn new RemoteProxy(req);\n\n\t}\n",
    "new_code_raw": "\tpublic static RemoteProxy getNewBasicRemoteProxy(List<Map<String, Object>> caps, String url,Registry registry) {\n\n\t\tRegistrationRequest req = new RegistrationRequest();\n\n\t\treq.setCapabilities(caps);\n\n\t\tMap<String, Object> config = new HashMap<String, Object>();\n\t\tconfig.put(\"url\", url);\n\t\treq.setConfiguration(config);\n\t\treturn new RemoteProxy(req,registry);\n\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1655-Param-0",
    "old_comment_raw": "@param body Input composite as post body (optional)",
    "old_code_raw": "  public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/composite\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws ApiException {\n    Object localVarPostBody = outerComposite;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/composite\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"*/*\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "SeleniumHQ_selenium-861-Param-3",
    "old_comment_raw": "@param outputFile - The file to which we'll output the HTML results",
    "old_code_raw": "  private URL determineSuiteUrl(String browserUrl, String suiteURL) throws IOException {\n    if (suiteURL.startsWith(\"https://\") || suiteURL.startsWith(\"http://\")) {\n      return verifySuiteUrl(new URL(suiteURL));\n    }\n\n    // Is the suiteURL a file?\n    Path path = Paths.get(suiteURL);\n    if (Files.exists(path)) {\n      // Not all drivers can read files from the disk, so we need to host the suite somewhere.\n      try (SocketLock lock = new SocketLock()) {\n        server = new Server();\n        HttpConfiguration httpConfig = new HttpConfiguration();\n\n        ServerConnector http = new ServerConnector(server, new HttpConnectionFactory(httpConfig));\n        int port = PortProber.findFreePort();\n        http.setPort(port);\n        http.setIdleTimeout(500000);\n        server.setConnectors(new Connector[]{http});\n\n        ResourceHandler handler = new ResourceHandler();\n        handler.setDirectoriesListed(true);\n        handler.setWelcomeFiles(new String[]{path.getFileName().toString(), \"index.html\"});\n        handler.setBaseResource(new PathResource(path.toFile().getParentFile().toPath().toRealPath()));\n\n        ContextHandler context = new ContextHandler(\"/tests\");\n        context.setHandler(handler);\n\n        server.setHandler(context);\n        server.start();\n\n        PortProber.waitForPortUp(port, 15, SECONDS);\n\n        URL serverUrl = server.getURI().toURL();\n        return new URL(serverUrl.getProtocol(), serverUrl.getHost(), serverUrl.getPort(),\n                       \"/tests/\");\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n\n    // Well then, it must be a URL relative to whatever the browserUrl. Probe and find out.\n    URL browser = new URL(browserUrl);\n    return verifySuiteUrl(new URL(browser, suiteURL));\n  }\n",
    "new_code_raw": "  private URL determineSuiteUrl(String startURL, String suiteURL) throws IOException {\n    if (suiteURL.startsWith(\"https://\") || suiteURL.startsWith(\"http://\")) {\n      return verifySuiteUrl(new URL(suiteURL));\n    }\n\n    // Is the suiteURL a file?\n    Path path = Paths.get(suiteURL);\n    if (Files.exists(path)) {\n      // Not all drivers can read files from the disk, so we need to host the suite somewhere.\n      try (SocketLock lock = new SocketLock()) {\n        server = new Server();\n        HttpConfiguration httpConfig = new HttpConfiguration();\n\n        ServerConnector http = new ServerConnector(server, new HttpConnectionFactory(httpConfig));\n        int port = PortProber.findFreePort();\n        http.setPort(port);\n        http.setIdleTimeout(500000);\n        server.setConnectors(new Connector[]{http});\n\n        ResourceHandler handler = new ResourceHandler();\n        handler.setDirectoriesListed(true);\n        handler.setWelcomeFiles(new String[]{path.getFileName().toString(), \"index.html\"});\n        handler.setBaseResource(new PathResource(path.toFile().getParentFile().toPath().toRealPath()));\n\n        ContextHandler context = new ContextHandler(\"/tests\");\n        context.setHandler(handler);\n\n        server.setHandler(context);\n        server.start();\n\n        PortProber.waitForPortUp(port, 15, SECONDS);\n\n        URL serverUrl = server.getURI().toURL();\n        return new URL(serverUrl.getProtocol(), serverUrl.getHost(), serverUrl.getPort(),\n                       \"/tests/\");\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n\n    // Well then, it must be a URL relative to whatever the browserUrl. Probe and find out.\n    URL browser = new URL(startURL);\n    return verifySuiteUrl(new URL(browser, suiteURL));\n  }\n"
  },
  {
    "id": "Omegaphora_dalvik-547-Associations-Param0",
    "old_comment_raw": "@param v the long to examine.",
    "old_code_raw": "    public static int bitCount(long v) {\n        // Combines techniques from several sources\n        v -=  (v >>> 1) & 0x5555555555555555L;\n        v = (v & 0x3333333333333333L) + ((v >> 2) & 0x3333333333333333L);\n        int i =  ((int)(v >>> 32)) + (int) v;\n        i = (i & 0x0F0F0F0F) + ((i >> 4) & 0x0F0F0F0F);\n        i += i >>> 8;\n        i += i >>> 16;\n        return i  & 0x0000007F;\n    }\n",
    "new_code_raw": "    public static int bitCount(long lng) {\n        lng = (lng & 0x5555555555555555L) + ((lng >> 1) & 0x5555555555555555L);\n        lng = (lng & 0x3333333333333333L) + ((lng >> 2) & 0x3333333333333333L);\n        // adjust for 64-bit integer\n        int i = (int) ((lng >>> 32) + lng);\n        i = (i & 0x0F0F0F0F) + ((i >> 4) & 0x0F0F0F0F);\n        i = (i & 0x00FF00FF) + ((i >> 8) & 0x00FF00FF);\n        i = (i & 0x0000FFFF) + ((i >> 16) & 0x0000FFFF);\n        return i;\n    }\n\n"
  },
  {
    "id": "RobotiumTech_robotium-1193-Param-1",
    "old_comment_raw": "@param minimumNumberOfMatches the minimum number of matches expected to be found.  0 matches means that one or more matches are expected to be found",
    "old_code_raw": "\tpublic boolean searchButton(String text, int minimumNumberOfMatches, boolean visible) {\n\t\tboolean found = searcher.searchWithTimeoutFor(Button.class, text, minimumNumberOfMatches, true, visible);\n\t\treturn found;\n\t}\n",
    "new_code_raw": "\tpublic boolean searchButton(String text, int minimumNumberOfMatches, boolean onlyVisible) {\n\t\tboolean found = searcher.searchWithTimeoutFor(Button.class, text, minimumNumberOfMatches, true, onlyVisible);\n\t\treturn found;\n\t}\n"
  },
  {
    "id": "timyates_groovy-stream-0-Associations-Param0",
    "old_comment_raw": "@param  The type of the array.",
    "old_code_raw": "    @SuppressWarnings(\"unchecked\")\n    public static <T> Stream<T> from( T[] array ) {\n        return new Stream<T>( primitiveArrayToList( array ).iterator(), null ) ;\n    }\n",
    "new_code_raw": "    public static <T> Stream<T> from( T object ) {\n        return new Stream<T>( new RepeatingObjectIterator<T>( object ), null ) ;\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1728-Param-0",
    "old_comment_raw": "@param path The sub-path of the HTTP URL",
    "old_code_raw": "    public Request buildRequest(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n        updateParamsForAuth(authNames, queryParams, headerParams);\n\n        final String url = buildUrl(path, queryParams, collectionQueryParams);\n        final Request.Builder reqBuilder = new Request.Builder().url(url);\n        processHeaderParams(headerParams, reqBuilder);\n\n        String contentType = (String) headerParams.get(\"Content-Type\");\n        // ensuring a default content type\n        if (contentType == null) {\n            contentType = \"application/json\";\n        }\n\n        RequestBody reqBody;\n        if (!HttpMethod.permitsRequestBody(method)) {\n            reqBody = null;\n        } else if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n            reqBody = buildRequestBodyFormEncoding(formParams);\n        } else if (\"multipart/form-data\".equals(contentType)) {\n            reqBody = buildRequestBodyMultipart(formParams);\n        } else if (body == null) {\n            if (\"DELETE\".equals(method)) {\n                // allow calling DELETE without sending a request body\n                reqBody = null;\n            } else {\n                // use an empty request body (for POST, PUT and PATCH)\n                reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n            }\n        } else {\n            reqBody = serialize(body, contentType);\n        }\n\n        Request request = null;\n\n        if(progressRequestListener != null && reqBody != null) {\n            ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener);\n            request = reqBuilder.method(method, progressRequestBody).build();\n        } else {\n            request = reqBuilder.method(method, reqBody).build();\n        }\n\n        return request;\n    }\n",
    "new_code_raw": "    public Request buildRequest(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {\n        updateParamsForAuth(authNames, queryParams, headerParams);\n\n        final String url = buildUrl(path, queryParams, collectionQueryParams);\n        final Request.Builder reqBuilder = new Request.Builder().url(url);\n        processHeaderParams(headerParams, reqBuilder);\n\n        String contentType = (String) headerParams.get(\"Content-Type\");\n        // ensuring a default content type\n        if (contentType == null) {\n            contentType = \"application/json\";\n        }\n\n        RequestBody reqBody;\n        if (!HttpMethod.permitsRequestBody(method)) {\n            reqBody = null;\n        } else if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n            reqBody = buildRequestBodyFormEncoding(formParams);\n        } else if (\"multipart/form-data\".equals(contentType)) {\n            reqBody = buildRequestBodyMultipart(formParams);\n        } else if (body == null) {\n            if (\"DELETE\".equals(method)) {\n                // allow calling DELETE without sending a request body\n                reqBody = null;\n            } else {\n                // use an empty request body (for POST, PUT and PATCH)\n                reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n            }\n        } else {\n            reqBody = serialize(body, contentType);\n        }\n\n        // Associate callback with request (if not null) so interceptor can\n        // access it when creating ProgressResponseBody\n        reqBuilder.tag(callback);\n\n        Request request = null;\n\n        if (callback != null && reqBody != null) {\n            ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, callback);\n            request = reqBuilder.method(method, progressRequestBody).build();\n        } else {\n            request = reqBuilder.method(method, reqBody).build();\n        }\n\n        return request;\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-1199-Param-0",
    "old_comment_raw": "@param onlyFullyVisible if only fully visible views should be returned",
    "old_code_raw": "\tpublic ArrayList<View> getAllViews(boolean onlyFullyVisible)\n\t{\n\t\tActivity activity = activityUtils.getCurrentActivity(false);\n\t\tfinal View [] views = getWindowDecorViews();\n\t\tfinal ArrayList<View> allViews = new ArrayList<View>();\n\t\tfinal View [] nonDecorViews = getNonDecorViews(views);\n\t\tif(views !=null && views.length > 0)\n\t\t{\n\t\t\tif(!activity.hasWindowFocus()){\n\t\t\t\tfor(View view : views){\n\t\t\t\t\tif(!activity.getWindow().getDecorView().equals(view)){\n\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\taddChildren(allViews,(ViewGroup) view, onlyFullyVisible);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ignored) {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(View view : nonDecorViews){\n\t\t\t\t\ttry{\n\t\t\t\t\t\taddChildren(allViews,(ViewGroup) view, onlyFullyVisible);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ignored) {}\n\t\t\t\t}\t\n\t\t\t\ttry{\n\t\t\t\t\taddChildren(allViews,(ViewGroup) getRecentDecorView(views), onlyFullyVisible);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ignored) {}\n\t\t\t}\n\t\t}\n\t\treturn allViews;\n\t}\n",
    "new_code_raw": "\tpublic ArrayList<View> getAllViews(boolean onlySufficientlyVisible)\n\t{\n\t\tActivity activity = activityUtils.getCurrentActivity(false);\n\t\tfinal View [] views = getWindowDecorViews();\n\t\tfinal ArrayList<View> allViews = new ArrayList<View>();\n\t\tfinal View [] nonDecorViews = getNonDecorViews(views);\n\t\tif(views !=null && views.length > 0)\n\t\t{\n\t\t\tif(!activity.hasWindowFocus()){\n\t\t\t\tfor(View view : views){\n\t\t\t\t\tif(!activity.getWindow().getDecorView().equals(view)){\n\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\taddChildren(allViews,(ViewGroup) view, onlySufficientlyVisible);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ignored) {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(View view : nonDecorViews){\n\t\t\t\t\ttry{\n\t\t\t\t\t\taddChildren(allViews,(ViewGroup) view, onlySufficientlyVisible);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ignored) {}\n\t\t\t\t}\t\n\t\t\t\ttry{\n\t\t\t\t\taddChildren(allViews,(ViewGroup) getRecentDecorView(views), onlySufficientlyVisible);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ignored) {}\n\t\t\t}\n\t\t}\n\t\treturn allViews;\n\t}\n"
  },
  {
    "id": "querydsl_querydsl-713-Param-0",
    "old_comment_raw": "@param target",
    "old_code_raw": "    public CloseableIterator<T> iterate() {\n        try {\n            Expression<T> projection = (Expression<T>)queryMixin.getMetadata().getProjection();\n            return new IteratorAdapter<T>(queryEngine.list(getMetadata(), iterables, projection).iterator());\n        } finally {\n            reset();\n        }\n    }\n",
    "new_code_raw": "    public CloseableIterator<Tuple> iterate(Expression<?>... args) {\n        return iterate(queryMixin.createProjection(args));\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1709-Param-0",
    "old_comment_raw": "@param user (User) Updated user object (required)",
    "old_code_raw": "        public UpdateUserOper body(User user) {\n            reqSpec.setBody(user);\n            return this;\n        }\n",
    "new_code_raw": "        public UpdateUserOper body(User body) {\n            reqSpec.setBody(body);\n            return this;\n        }\n"
  },
  {
    "id": "hibernate_hibernate_orm-442-Param-1",
    "old_comment_raw": "@param offset Offset of the first row to be returned by the query (zero-based)",
    "old_code_raw": "\tpublic String getLimitString(String querySqlString, int offset, int limit) {\n\t\tStringBuilder sb = new StringBuilder(querySqlString.trim().toLowerCase());\n\n\t\tint orderByIndex = sb.indexOf(\"order by\");\n\t\tCharSequence orderby = orderByIndex > 0 ? sb.subSequence(orderByIndex, sb.length())\n\t\t\t\t: \"ORDER BY CURRENT_TIMESTAMP\";\n\n\t\t// Delete the order by clause at the end of the query\n\t\tif (orderByIndex > 0) {\n\t\t\tsb.delete(orderByIndex, orderByIndex + orderby.length());\n\t\t}\n\n\t\t// HHH-5715 bug fix\n\t\treplaceDistinctWithGroupBy(sb);\n\n\t\tinsertRowNumberFunction(sb, orderby);\n\n\t\t// Wrap the query within a with statement:\n\t\tsb.insert(0, \"WITH query AS (\").append(\") SELECT * FROM query \");\n\t\tsb.append(\"WHERE __hibernate_row_nr__ BETWEEN \").append(offset + 1).append(\" AND \").append(limit);\n\n\t\treturn sb.toString();\n\t}\n",
    "new_code_raw": "\tpublic String getLimitString(String querySqlString, boolean hasOffset) {\n\t\tStringBuilder sb = new StringBuilder(querySqlString.trim().toLowerCase());\n\n\t\tint orderByIndex = sb.indexOf(\"order by\");\n\t\tCharSequence orderby = orderByIndex > 0 ? sb.subSequence(orderByIndex, sb.length())\n\t\t\t\t: \"ORDER BY CURRENT_TIMESTAMP\";\n\n\t\t// Delete the order by clause at the end of the query\n\t\tif (orderByIndex > 0) {\n\t\t\tsb.delete(orderByIndex, orderByIndex + orderby.length());\n\t\t}\n\n\t\t// HHH-5715 bug fix\n\t\treplaceDistinctWithGroupBy(sb);\n\n\t\tinsertRowNumberFunction(sb, orderby);\n\n\t\t// Wrap the query within a with statement:\n\t\tsb.insert(0, \"WITH query AS (\").append(\") SELECT * FROM query \");\n\t\t//sb.append(\"WHERE __hibernate_row_nr__ BETWEEN \").append(offset + 1).append(\" AND \").append(limit);\n\t\tsb.append(\"WHERE __hibernate_row_nr__ BETWEEN ? AND ?\");\n\n\t\treturn sb.toString();\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1631-Param-0",
    "old_comment_raw": "@param body List of user object",
    "old_code_raw": "  public void  createUsersWithListInput (List<User> body) throws ApiException {\n    Object localVarPostBody = body;\n    // verify the required parameter 'body' is set\n    if (body == null) {\n       throw new ApiException(400, \"Missing the required parameter 'body' when calling createUsersWithListInput\");\n    }\n\n    // create path and map variables\n    String localVarPath = \"/user/createWithList\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> localVarFormParams = new HashMap<String, String>();\n\n\n\n    String[] localVarContentTypes = {\n      \n    };\n    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application/json\";\n\n    if (localVarContentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      \n\n      localVarPostBody = localVarBuilder.build();\n    } else {\n      // normal form params\n          }\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);\n      if(localVarResponse != null){\n        return ;\n      }\n      else {\n        return ;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n",
    "new_code_raw": "  public void  createUsersWithListInput (List<User> user) throws ApiException {\n    Object localVarPostBody = user;\n    // verify the required parameter 'user' is set\n    if (user == null) {\n       throw new ApiException(400, \"Missing the required parameter 'user' when calling createUsersWithListInput\");\n    }\n\n    // create path and map variables\n    String localVarPath = \"/user/createWithList\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> localVarFormParams = new HashMap<String, String>();\n\n\n\n    String[] localVarContentTypes = {\n      \n    };\n    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application/json\";\n\n    if (localVarContentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      \n\n      localVarPostBody = localVarBuilder.build();\n    } else {\n      // normal form params\n          }\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);\n      if(localVarResponse != null){\n        return ;\n      }\n      else {\n        return ;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n"
  },
  {
    "id": "processing_processing-955-Param-0",
    "old_comment_raw": "@param code code without comments",
    "old_code_raw": "  static public Mode parseMode(String code) {\n\n    // See if we can find any function in the global scope\n    if (findInCurrentScope(FUNCTION_DECL, code) != null) {\n      return Mode.ACTIVE;\n    }\n\n    // See if we can find any public class extending PApplet\n    if (findInCurrentScope(PUBLIC_CLASS, code) != null) {\n      return Mode.JAVA;\n    }\n\n    return Mode.STATIC;\n  }\n",
    "new_code_raw": "  static public Mode parseMode(CharSequence code) {\n\n    // See if we can find any function in the global scope\n    if (findInCurrentScope(FUNCTION_DECL, code) != null) {\n      return Mode.ACTIVE;\n    }\n\n    // See if we can find any public class extending PApplet\n    if (findInCurrentScope(PUBLIC_CLASS, code) != null) {\n      return Mode.JAVA;\n    }\n\n    return Mode.STATIC;\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-457-Param-0",
    "old_comment_raw": "@param length the new length",
    "old_code_raw": "    public Duration withMillis(long length) {\n        if (length == getMillis()) {\n            return this;\n        }\n        return new Duration(length);\n    }\n",
    "new_code_raw": "    public Duration withMillis(long duration) {\n        if (duration == getMillis()) {\n            return this;\n        }\n        return new Duration(duration);\n    }\n"
  },
  {
    "id": "yanzhenjie_NoHttp-143-Param-1",
    "old_comment_raw": "@param threadPoolSize request the number of concurrent.",
    "old_code_raw": "    public static RequestQueue newRequestQueue(ImplRestConnection implRestConnection, int threadPoolSize) {\n        return newRequestQueue(HttpRestParser.getInstance(implRestConnection), threadPoolSize);\n    }\n",
    "new_code_raw": "    public static RequestQueue newRequestQueue(IRestProtocol implRestConnection, int threadPoolSize) {\n        return newRequestQueue(RestParser.getInstance(implRestConnection), threadPoolSize);\n    }\n"
  },
  {
    "id": "timyates_groovy-stream-0-Associations-Param1",
    "old_comment_raw": "@param array An array of Object to iterate",
    "old_code_raw": "    @SuppressWarnings(\"unchecked\")\n    public static <T> Stream<T> from( T[] array ) {\n        return new Stream<T>( primitiveArrayToList( array ).iterator(), null ) ;\n    }\n",
    "new_code_raw": "    public static <T> Stream<T> from( T object ) {\n        return new Stream<T>( new RepeatingObjectIterator<T>( object ), null ) ;\n    }\n\n"
  },
  {
    "id": "apache_calcite-943-Param-0",
    "old_comment_raw": "@param rel the relational expression",
    "old_code_raw": "  public static Boolean areColumnsUnique(RelNode rel, BitSet columns) {\n    final BuiltInMetadata.ColumnUniqueness metadata =\n        rel.metadata(BuiltInMetadata.ColumnUniqueness.class);\n    return metadata.areColumnsUnique(columns, false);\n  }\n",
    "new_code_raw": "  public static Boolean areColumnsUnique(RelNode rel, ImmutableBitSet columns) {\n    final BuiltInMetadata.ColumnUniqueness metadata =\n        rel.metadata(BuiltInMetadata.ColumnUniqueness.class);\n    return metadata.areColumnsUnique(columns, false);\n  }\n"
  },
  {
    "id": "trygvis_jop-160-Associations-Param0",
    "old_comment_raw": "@param signature the signature to parse.",
    "old_code_raw": "    public static String getClassName(String signature, boolean isClassMember) {\n        int pos = signature.indexOf(ALT_MEMBER_SEPARATOR);\n        // uses alternative separator, easy\n        if (pos != -1) return signature.substring(0, pos);\n\n        pos = signature.indexOf('(');\n        if ( pos != -1 ) {\n            // has a descriptor, is a method signature, strip last member part\n            pos = signature.lastIndexOf('.', pos);\n            return pos != -1 ? signature.substring(0, pos) : \"\";\n        }\n\n        if (isClassMember) {\n            // field or class name, cannot decide, assume it is a field\n            pos = signature.lastIndexOf('.');\n            return pos != -1 ? signature.substring(0, pos) : \"\";\n        } else {\n            // assume it is a class name\n            return signature;\n        }\n    }\n",
    "new_code_raw": "    public static String getClassName(String memberID, boolean isClassMember) {\n        int pos = memberID.indexOf(ALT_MEMBER_SEPARATOR);\n        // uses alternative separator, easy\n        if (pos != -1) return memberID.substring(0, pos);\n\n        pos = memberID.indexOf('(');\n        if ( pos != -1 ) {\n            // has a descriptor, is a method ID, strip last member part\n            pos = memberID.lastIndexOf('.', pos);\n            return pos != -1 ? memberID.substring(0, pos) : \"\";\n        }\n\n        if (isClassMember) {\n            // field or class name, cannot decide, assume it is a field\n            pos = memberID.lastIndexOf('.');\n            return pos != -1 ? memberID.substring(0, pos) : \"\";\n        } else {\n            // assume it is a class name\n            return memberID;\n        }\n    }\n\n"
  },
  {
    "id": "fossasia_phimpme_android-1-Param-0",
    "old_comment_raw": "@param s Name of the account from accountList e.g. Twitter",
    "old_code_raw": "    public boolean checkAlreadyExist(String s) {\n\n        // Query in the realm database\n        RealmQuery<AccountDatabase> query = realm.where(AccountDatabase.class);\n\n        // Checking if string equals to is exist or not\n        query.equalTo(\"name\", s);\n        RealmResults<AccountDatabase> result1 = query.findAll();\n\n        // Here checking if count of that values is greater than zero\n        return (result1.size() > 0) ? true : false;\n    }\n",
    "new_code_raw": "    public boolean checkAlreadyExist(AccountDatabase.AccountName s) {\n\n        // Query in the realm database\n        RealmQuery<AccountDatabase> query = realm.where(AccountDatabase.class);\n\n        // Checking if string equals to is exist or not\n        query.equalTo(\"name\", s.toString());\n        RealmResults<AccountDatabase> result1 = query.findAll();\n\n        // Here checking if count of that values is greater than zero\n        return (result1.size() > 0) ? true : false;\n    }\n"
  },
  {
    "id": "codehaus_cake-10-Associations-Param0",
    "old_comment_raw": "@param attributes an object containing an AttributeMap",
    "old_code_raw": "    public int get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n",
    "new_code_raw": "    public int get(WithAttributes withAttributes) {\r\n        return withAttributes.getAttributes().get(this);\r\n    }\r\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-183-Param-7",
    "old_comment_raw": "@param contentType The request's Content-Type header",
    "old_code_raw": "  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n",
    "new_code_raw": "  public String invokeAPI(String path, String method, Set<QueryParam> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (QueryParam queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2673-Param-0",
    "old_comment_raw": "@param arr",
    "old_code_raw": "    private String getArrayTypeDeclaration(ArrayProperty arr) {\n        // TODO: collection type here should be fully qualified namespace to avoid model conflicts\n        // This supports arrays of arrays.\n        String arrayType = typeMapping.get(\"array\");\n        StringBuilder instantiationType = new StringBuilder(arrayType);\n        Property items = arr.getItems();\n        String nestedType = getTypeDeclaration(items);\n        // TODO: We may want to differentiate here between generics and primitive arrays.\n        instantiationType.append(\"<\").append(nestedType).append(\">\");\n        return instantiationType.toString();\n    }\n",
    "new_code_raw": "    private String getArrayTypeDeclaration(ArraySchema arr) {\n        // TODO: collection type here should be fully qualified namespace to avoid model conflicts\n        // This supports arrays of arrays.\n        String arrayType = typeMapping.get(\"array\");\n        StringBuilder instantiationType = new StringBuilder(arrayType);\n        Schema items = arr.getItems();\n        String nestedType = getTypeDeclaration(items);\n        // TODO: We may want to differentiate here between generics and primitive arrays.\n        instantiationType.append(\"<\").append(nestedType).append(\">\");\n        return instantiationType.toString();\n    }\n"
  },
  {
    "id": "lingochamp_FileDownloader-10-Param-0",
    "old_comment_raw": "@param willRemoveDownload",
    "old_code_raw": "    public boolean remove(final BaseFileDownloadInternal willRemoveDownload, final int removeByStatus) {\n        boolean succeed;\n        synchronized (list) {\n            succeed = list.remove(willRemoveDownload);\n        }\n\n        if (succeed) {\n            // \u00e6\u008a\u009b\u00e6\u00b6\u0088\u00e6\u0081\u00af\n            switch (removeByStatus) {\n                case FileDownloadStatus.warn:\n                    willRemoveDownload.getDriver().notifyWarn();\n                    break;\n                case FileDownloadStatus.error:\n                    willRemoveDownload.getDriver().notifyError();\n                    break;\n                case FileDownloadStatus.paused:\n                    willRemoveDownload.getDriver().notifyPaused();\n                    break;\n                case FileDownloadStatus.completed:\n                    Throwable ex = null;\n                    try{\n                        willRemoveDownload.getDriver().notifyBlockComplete();\n                    }catch (Throwable e){\n                        ex = e;\n                    }\n\n                    if (ex != null) {\n                        willRemoveDownload.setStatus(FileDownloadStatus.error);\n                        willRemoveDownload.setEx(ex);\n                        willRemoveDownload.getDriver().notifyError();\n                    } else {\n                        willRemoveDownload.getDriver().notifyCompleted();\n                    }\n                    break;\n            }\n\n        } else {\n            FileDownloadLog.e(this, \"remove error, not exist: %s\", willRemoveDownload);\n        }\n\n        return succeed;\n    }\n",
    "new_code_raw": "    public boolean remove(final BaseDownloadTask willRemoveDownload, final int removeByStatus) {\n        boolean succeed;\n        synchronized (list) {\n            succeed = list.remove(willRemoveDownload);\n        }\n\n        if (succeed) {\n            // \u00e6\u008a\u009b\u00e6\u00b6\u0088\u00e6\u0081\u00af\n            switch (removeByStatus) {\n                case FileDownloadStatus.warn:\n                    willRemoveDownload.getDriver().notifyWarn();\n                    break;\n                case FileDownloadStatus.error:\n                    willRemoveDownload.getDriver().notifyError();\n                    break;\n                case FileDownloadStatus.paused:\n                    willRemoveDownload.getDriver().notifyPaused();\n                    break;\n                case FileDownloadStatus.completed:\n                    Throwable ex = null;\n                    try{\n                        willRemoveDownload.getDriver().notifyBlockComplete();\n                    }catch (Throwable e){\n                        ex = e;\n                    }\n\n                    if (ex != null) {\n                        willRemoveDownload.setStatus(FileDownloadStatus.error);\n                        willRemoveDownload.setEx(ex);\n                        willRemoveDownload.getDriver().notifyError();\n                    } else {\n                        willRemoveDownload.getDriver().notifyCompleted();\n                    }\n                    break;\n            }\n\n        } else {\n            FileDownloadLog.e(this, \"remove error, not exist: %s\", willRemoveDownload);\n        }\n\n        return succeed;\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1654-Param-0",
    "old_comment_raw": "@param body Input boolean as post body (optional)",
    "old_code_raw": "  public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/boolean\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public Boolean fakeOuterBooleanSerialize(Boolean booleanPostBody) throws ApiException {\n    Object localVarPostBody = booleanPostBody;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/boolean\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"*/*\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2130-Param-2",
    "old_comment_raw": "@param  The type of the element we are getting.",
    "old_code_raw": "  public List<String> dependencyPathBetween(int start, int end) {\n    // Get paths from a node to the root of the sentence\n    LinkedList<Integer> rootToStart = new LinkedList<>();\n    LinkedList<Integer> rootToEnd = new LinkedList<>();\n    int startAncestor = start;\n    while (sentence.governor(startAncestor).isPresent() && sentence.governor(startAncestor).get() >= 0) {\n      rootToStart.addFirst(startAncestor);\n      startAncestor = sentence.governor(startAncestor).get();\n    }\n    if (startAncestor == -1) {\n      rootToStart.addFirst(-1);\n    }\n    int endAncestor = start;\n    while (sentence.governor(endAncestor).isPresent() && sentence.governor(endAncestor).get() >= 0) {\n      rootToEnd.addFirst(endAncestor);\n      endAncestor = sentence.governor(endAncestor).get();\n    }\n    if (endAncestor == -1) {\n      rootToEnd.addFirst(-1);\n    }\n\n    // Get least common node\n    return null;   // TODO(gabor) write me!\n\n\n  }\n",
    "new_code_raw": "  public List<String> dependencyPathBetween(int start, int end, Function<Sentence, List<String>> selector) {\n    // Get paths from a node to the root of the sentence\n    LinkedList<Integer> rootToStart = new LinkedList<>();\n    LinkedList<Integer> rootToEnd = new LinkedList<>();\n    int startAncestor = start;\n    while (sentence.governor(startAncestor).isPresent() && sentence.governor(startAncestor).get() >= 0) {\n      rootToStart.addFirst(startAncestor);\n      startAncestor = sentence.governor(startAncestor).get();\n    }\n    if (startAncestor == -1) {\n      rootToStart.addFirst(-1);\n    }\n    int endAncestor = end;\n    while (sentence.governor(endAncestor).isPresent() && sentence.governor(endAncestor).get() >= 0) {\n      rootToEnd.addFirst(endAncestor);\n      endAncestor = sentence.governor(endAncestor).get();\n    }\n    if (endAncestor == -1) {\n      rootToEnd.addFirst(-1);\n    }\n\n    // Get least common node\n    int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0;\n    for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) {\n      if (rootToStart.get(i).equals(rootToEnd.get(i))) {\n        leastCommonNodeIndex = i;\n      }\n    }\n\n    // Construct the path\n    if (leastCommonNodeIndex < 0) {\n      return Collections.EMPTY_LIST;\n    }\n    List<String> path = new ArrayList<>();\n    for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) {\n      path.add(selector.apply(sentence).get(rootToStart.get(i)));\n      path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\");\n    }\n    path.add(selector.apply(sentence).get(rootToStart.get(leastCommonNodeIndex)));\n    for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) {\n      path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\");\n      path.add(selector.apply(sentence).get(rootToEnd.get(i)));\n    }\n    return path;\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-1147-Param-0",
    "old_comment_raw": "@param partial an object to check against",
    "old_code_raw": "    public int compareTo(Object partial) {\n        if (this == partial) {\n            return 0;\n        }\n        ReadablePartial other = (ReadablePartial) partial;\n        if (size() != other.size()) {\n            throw new ClassCastException(\"ReadablePartial objects must have matching field types\");\n        }\n        for (int i = 0, isize = size(); i < isize; i++) {\n            if (getFieldType(i) != other.getFieldType(i)) {\n                throw new ClassCastException(\"ReadablePartial objects must have matching field types\");\n            }\n        }\n        // fields are ordered largest first\n        for (int i = 0, isize = size(); i < isize; i++) {\n            if (getValue(i) > other.getValue(i)) {\n                return 1;\n            }\n            if (getValue(i) < other.getValue(i)) {\n                return -1;\n            }\n        }\n        return 0;\n    }\n",
    "new_code_raw": "    public int compareTo(ReadablePartial other) {\n        if (this == other) {\n            return 0;\n        }\n        if (size() != other.size()) {\n            throw new ClassCastException(\"ReadablePartial objects must have matching field types\");\n        }\n        for (int i = 0, isize = size(); i < isize; i++) {\n            if (getFieldType(i) != other.getFieldType(i)) {\n                throw new ClassCastException(\"ReadablePartial objects must have matching field types\");\n            }\n        }\n        // fields are ordered largest first\n        for (int i = 0, isize = size(); i < isize; i++) {\n            if (getValue(i) > other.getValue(i)) {\n                return 1;\n            }\n            if (getValue(i) < other.getValue(i)) {\n                return -1;\n            }\n        }\n        return 0;\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1200-Param-2",
    "old_comment_raw": "@param queryParameters The query parameters specified by the user.",
    "old_code_raw": "\tprivate static EntityKey getOptionalObjectKey(QueryParameters queryParameters, SessionImplementor session) {\n\t\tfinal Object optionalObject = queryParameters.getOptionalObject();\n\t\tfinal Serializable optionalId = queryParameters.getOptionalId();\n\t\tfinal String optionalEntityName = queryParameters.getOptionalEntityName();\n\n\t\tif ( optionalObject != null && optionalEntityName != null ) {\n\t\t\treturn session.generateEntityKey(\n\t\t\t\t\toptionalId, session.getEntityPersister(\n\t\t\t\t\t\t\toptionalEntityName,\n\t\t\t\t\t\t\toptionalObject\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\n\t}\n",
    "new_code_raw": "\tprivate static EntityKey getOptionalObjectKey(QueryParameters queryParameters, SharedSessionContractImplementor session) {\n\t\tfinal Object optionalObject = queryParameters.getOptionalObject();\n\t\tfinal Serializable optionalId = queryParameters.getOptionalId();\n\t\tfinal String optionalEntityName = queryParameters.getOptionalEntityName();\n\n\t\tif ( optionalObject != null && optionalEntityName != null ) {\n\t\t\treturn session.generateEntityKey(\n\t\t\t\t\toptionalId, session.getEntityPersister(\n\t\t\t\t\t\t\toptionalEntityName,\n\t\t\t\t\t\t\toptionalObject\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1643-Param-0",
    "old_comment_raw": "@param body client model (required)",
    "old_code_raw": "  public ApiResponse<Client> testClientModelWithHttpInfo(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling testClientModel\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public ApiResponse<Client> testClientModelWithHttpInfo(Client client) throws ApiException {\n    Object localVarPostBody = client;\n    \n    // verify the required parameter 'client' is set\n    if (client == null) {\n      throw new ApiException(400, \"Missing the required parameter 'client' when calling testClientModel\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1215-Param-1",
    "old_comment_raw": "@param session The session from which the request is originating.",
    "old_code_raw": "\tpublic Object getCollection(Serializable key, SessionImplementor session, Object owner) {\n\n\t\tCollectionPersister persister = getPersister( session );\n\t\tfinal PersistenceContext persistenceContext = session.getPersistenceContext();\n\t\tfinal EntityMode entityMode = persister.getOwnerEntityPersister().getEntityMode();\n\n\t\t// check if collection is currently being loaded\n\t\tPersistentCollection collection = persistenceContext.getLoadContexts().locateLoadingCollection( persister, key );\n\t\t\n\t\tif ( collection == null ) {\n\t\t\t\n\t\t\t// check if it is already completely loaded, but unowned\n\t\t\tcollection = persistenceContext.useUnownedCollection( new CollectionKey(persister, key, entityMode) );\n\t\t\t\n\t\t\tif ( collection == null ) {\n\n\t\t\t\tcollection = persistenceContext.getCollection( new CollectionKey(persister, key, entityMode) );\n\n\t\t\t\tif ( collection == null ) {\n\t\t\t\t\t// create a new collection wrapper, to be initialized later\n\t\t\t\t\tcollection = instantiate( session, persister, key );\n\n\t\t\t\t\tcollection.setOwner( owner );\n\n\t\t\t\t\tpersistenceContext.addUninitializedCollection( persister, collection, key );\n\n\t\t\t\t\t// some collections are not lazy:\n\t\t\t\t\tif ( initializeImmediately() ) {\n\t\t\t\t\t\tsession.initializeCollection( collection, false );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( !persister.isLazy() ) {\n\t\t\t\t\t\tpersistenceContext.addNonLazyCollection( collection );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasHolder() ) {\n\t\t\t\t\t\tsession.getPersistenceContext().addCollectionHolder( collection );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracef( \"Created collection wrapper: %s\",\n\t\t\t\t\t\tMessageHelper.collectionInfoString( persister, collection,\n\t\t\t\t\t\t\t\tkey, session ) );\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tcollection.setOwner(owner);\n\n\t\treturn collection.getValue();\n\t}\n",
    "new_code_raw": "\tpublic Object getCollection(Serializable key, SharedSessionContractImplementor session, Object owner) {\n\n\t\tCollectionPersister persister = getPersister( session );\n\t\tfinal PersistenceContext persistenceContext = session.getPersistenceContext();\n\t\tfinal EntityMode entityMode = persister.getOwnerEntityPersister().getEntityMode();\n\n\t\t// check if collection is currently being loaded\n\t\tPersistentCollection collection = persistenceContext.getLoadContexts().locateLoadingCollection( persister, key );\n\t\t\n\t\tif ( collection == null ) {\n\t\t\t\n\t\t\t// check if it is already completely loaded, but unowned\n\t\t\tcollection = persistenceContext.useUnownedCollection( new CollectionKey(persister, key, entityMode) );\n\t\t\t\n\t\t\tif ( collection == null ) {\n\n\t\t\t\tcollection = persistenceContext.getCollection( new CollectionKey(persister, key, entityMode) );\n\n\t\t\t\tif ( collection == null ) {\n\t\t\t\t\t// create a new collection wrapper, to be initialized later\n\t\t\t\t\tcollection = instantiate( session, persister, key );\n\n\t\t\t\t\tcollection.setOwner( owner );\n\n\t\t\t\t\tpersistenceContext.addUninitializedCollection( persister, collection, key );\n\n\t\t\t\t\t// some collections are not lazy:\n\t\t\t\t\tif ( initializeImmediately() ) {\n\t\t\t\t\t\tsession.initializeCollection( collection, false );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( !persister.isLazy() ) {\n\t\t\t\t\t\tpersistenceContext.addNonLazyCollection( collection );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasHolder() ) {\n\t\t\t\t\t\tsession.getPersistenceContext().addCollectionHolder( collection );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracef( \"Created collection wrapper: %s\",\n\t\t\t\t\t\tMessageHelper.collectionInfoString( persister, collection,\n\t\t\t\t\t\t\t\tkey, session ) );\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tcollection.setOwner(owner);\n\n\t\treturn collection.getValue();\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1642-Param-0",
    "old_comment_raw": "@param body Input composite as post body (optional)",
    "old_code_raw": "  public ApiResponse<OuterComposite> fakeOuterCompositeSerializeWithHttpInfo(OuterComposite body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/composite\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public ApiResponse<OuterComposite> fakeOuterCompositeSerializeWithHttpInfo(OuterComposite outerComposite) throws ApiException {\n    Object localVarPostBody = outerComposite;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/composite\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"*/*\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "apache_drill-1010-Param-0",
    "old_comment_raw": "@param statuses list of file statuses",
    "old_code_raw": "  public static FileSelection create(final List<FileStatus> statuses, final List<String> files, final String root) {\n    return FileSelection.create(statuses, files, root, null, false);\n  }\n",
    "new_code_raw": "  public static FileSelection create(List<FileStatus> statuses, List<Path> files, Path root) {\n    return FileSelection.create(statuses, files, root, null, false);\n  }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2348-Param-0",
    "old_comment_raw": "@param t Target for finding dependents of t related by this GR",
    "old_code_raw": "  public Collection<Tree> getRelatedNodes(Tree t, Tree root, HeadFinder headFinder) {\n    Set<Tree> nodeList = new ArraySet<Tree>();\n    for (TregexPattern p : targetPatterns) {    // cdm: I deleted: && nodeList.isEmpty()\n      // Initialize the TregexMatcher with the HeadFinder so that we\n      // can use the same HeadFinder through the entire process of\n      // building the dependencies\n      TregexMatcher m = p.matcher(root, headFinder);\n      while (m.findAt(t)) {\n        nodeList.add(m.getNode(\"target\"));\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\"))\n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n",
    "new_code_raw": "  public Collection<Tree> getRelatedNodes(Tree t, Tree root) {\n    if (root.value() == null) {\n      root.setValue(\"ROOT\");  // todo: cdm: it doesn't seem like this line should be here\n    }\n    Set<Tree> nodeList = new LinkedHashSet<Tree>();\n    for (TregexPattern p : targetPatterns) {    // cdm: I deleted: && nodeList.isEmpty()\n      TregexMatcher m = p.matcher(root);\n      while (m.findAt(t)) {\n        nodeList.add(m.getNode(\"target\"));\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\")) \n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n"
  },
  {
    "id": "debezium_debezium-512-Param-2",
    "old_comment_raw": "@param table the table definition; may not be null",
    "old_code_raw": "    public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, Predicate<ColumnId> filter, ColumnMappers mappers) {\n        if (schemaPrefix == null) {\n            schemaPrefix = \"\";\n        }\n        // Build the schemas ...\n        final TableId tableId = table.id();\n        final String tableIdStr = tableSchemaName(tableId);\n        final String schemaNamePrefix = schemaPrefix + tableIdStr;\n        LOGGER.debug(\"Mapping table '{}' to schemas under '{}'\", tableId, schemaNamePrefix);\n        SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Value\"));\n        SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Key\"));\n        AtomicBoolean hasPrimaryKey = new AtomicBoolean(false);\n        table.columns().forEach(column -> {\n            if (table.isPrimaryKeyColumn(column.name())) {\n                // The column is part of the primary key, so ALWAYS add it to the PK schema ...\n                addField(keySchemaBuilder, column, null);\n                hasPrimaryKey.set(true);\n            }\n            if (filter == null || filter.test(new ColumnId(tableId, column.name()))) {\n                // Add the column to the value schema only if the column has not been filtered ...\n                ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column);\n                addField(valSchemaBuilder, column, mapper);\n            }\n        });\n        Schema valSchema = valSchemaBuilder.optional().build();\n        Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null;\n\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Mapped primary key for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(keySchema));\n            LOGGER.debug(\"Mapped columns for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(valSchema));\n        }\n\n        Envelope envelope = Envelope.defineSchema()\n                .withName(schemaNameAdjuster.adjust(envelopSchemaName))\n                .withRecord(valSchema)\n                .withSource(sourceInfoSchema)\n                .build();\n\n\n        // Create the generators ...\n        Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, table.primaryKeyColumns());\n        Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers);\n\n        // And the table schema ...\n        return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator);\n    }\n",
    "new_code_raw": "    public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers) {\n        if (schemaPrefix == null) {\n            schemaPrefix = \"\";\n        }\n\n        // Build the schemas ...\n        final TableId tableId = table.id();\n        final String tableIdStr = tableSchemaName(tableId);\n        final String schemaNamePrefix = schemaPrefix + tableIdStr;\n        LOGGER.debug(\"Mapping table '{}' to schemas under '{}'\", tableId, schemaNamePrefix);\n        SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Value\"));\n        SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Key\"));\n        AtomicBoolean hasPrimaryKey = new AtomicBoolean(false);\n        table.columns().forEach(column -> {\n            if (table.isPrimaryKeyColumn(column.name())) {\n                // The column is part of the primary key, so ALWAYS add it to the PK schema ...\n                addField(keySchemaBuilder, column, null);\n                hasPrimaryKey.set(true);\n            }\n            if (filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name())) {\n                // Add the column to the value schema only if the column has not been filtered ...\n                ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column);\n                addField(valSchemaBuilder, column, mapper);\n            }\n        });\n        Schema valSchema = valSchemaBuilder.optional().build();\n        Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null;\n\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Mapped primary key for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(keySchema));\n            LOGGER.debug(\"Mapped columns for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(valSchema));\n        }\n\n        Envelope envelope = Envelope.defineSchema()\n                .withName(schemaNameAdjuster.adjust(envelopSchemaName))\n                .withRecord(valSchema)\n                .withSource(sourceInfoSchema)\n                .build();\n\n\n        // Create the generators ...\n        Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, table.primaryKeyColumns());\n        Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers);\n\n        // And the table schema ...\n        return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator);\n    }\n"
  },
  {
    "id": "facebook_fresco-227-Param-0",
    "old_comment_raw": "@param dataBufferRef Next set of bytes received by the caller",
    "old_code_raw": "  public boolean parseMoreData(final CloseableReference<PooledByteBuffer> dataBufferRef) {\n    if (mParserState == NOT_A_JPEG) {\n      return false;\n    }\n\n    final PooledByteBuffer dataBuffer = dataBufferRef.get();\n    final int dataBufferSize = dataBuffer.size();\n\n    // Is there any new data to parse?\n    // mBytesParsed might be greater than size of dataBuffer - that happens when\n    // we skip more data than is available to read inside doParseMoreData method\n    if (dataBufferSize <= mBytesParsed) {\n      return false;\n    }\n\n    final InputStream bufferedDataStream = new PooledByteArrayBufferedInputStream(\n        new PooledByteBufferInputStream(dataBuffer),\n        mByteArrayPool.get(BUFFER_SIZE),\n        mByteArrayPool);\n    try {\n      StreamUtil.skip(bufferedDataStream, mBytesParsed);\n      return doParseMoreData(bufferedDataStream);\n    } catch (IOException ioe) {\n      // Does not happen - streams returned by PooledByteBuffers do not throw IOExceptions\n      Throwables.propagate(ioe);\n      return false;\n    } finally {\n      Closeables.closeQuietly(bufferedDataStream);\n    }\n  }\n",
    "new_code_raw": "  public boolean parseMoreData(final EncodedImage encodedImage) {\n    if (mParserState == NOT_A_JPEG) {\n      return false;\n    }\n\n    final int dataBufferSize = encodedImage.getSize();\n\n    // Is there any new data to parse?\n    // mBytesParsed might be greater than size of dataBuffer - that happens when\n    // we skip more data than is available to read inside doParseMoreData method\n    if (dataBufferSize <= mBytesParsed) {\n      return false;\n    }\n\n    final InputStream bufferedDataStream = new PooledByteArrayBufferedInputStream(\n        encodedImage.getInputStream(),\n        mByteArrayPool.get(BUFFER_SIZE),\n        mByteArrayPool);\n    try {\n      StreamUtil.skip(bufferedDataStream, mBytesParsed);\n      return doParseMoreData(bufferedDataStream);\n    } catch (IOException ioe) {\n      // Does not happen - streams returned by PooledByteBuffers do not throw IOExceptions\n      Throwables.propagate(ioe);\n      return false;\n    } finally {\n      Closeables.closeQuietly(bufferedDataStream);\n    }\n  }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-907-Param-0",
    "old_comment_raw": "@param includeExtras If true, the list of typed dependencies returned may include \"extras\", like controlling subjects",
    "old_code_raw": "  public List<TypedDependency> typedDependenciesCollapsed(Extras includeExtras) {\n    List<TypedDependency> tdl = typedDependencies(includeExtras);\n    collapseDependencies(tdl, false, includeExtras);\n    return tdl;\n  }\n",
    "new_code_raw": "  public List<TypedDependency> typedDependenciesCollapsed(boolean includeExtras) {\n    List<TypedDependency> tdl = typedDependencies(false);\n    // Adds stuff to the basic dependencies.\n    // We don't want to simply call typedDependencies with\n    // \"includeExtras\" because the collapseDependencies method may add\n    // the extras in a way that makes more logical sense.  For\n    // example, the English dependencies, when CC processed, have more\n    // nsubjs than they originally do.  If we wait until that occurs\n    // to add xsubj for xcomp dependencies, we get better coverage.\n    if (includeExtras) {\n      getTreeDeps(root(), tdl, new NoPunctTypedDependencyFilter(puncFilter), extraTreeDepFilter());\n    }\n    collapseDependencies(tdl, false, includeExtras);\n    return tdl;\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1684-Param-0",
    "old_comment_raw": "@param booleanPostBody Input boolean as post body",
    "old_code_raw": "    public Boolean fakeOuterBooleanSerialize(Boolean booleanPostBody) throws RestClientException {\n        Object postBody = booleanPostBody;\n        \n        String path = UriComponentsBuilder.fromPath(\"/fake/outer/boolean\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"*/*\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Boolean> returnType = new ParameterizedTypeReference<Boolean>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "new_code_raw": "    public Boolean fakeOuterBooleanSerialize(Boolean body) throws RestClientException {\n        Object postBody = body;\n        \n        String path = UriComponentsBuilder.fromPath(\"/fake/outer/boolean\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"*/*\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Boolean> returnType = new ParameterizedTypeReference<Boolean>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2359-Param-1",
    "old_comment_raw": "@param root The root of the Tree",
    "old_code_raw": "  public Collection<TreeGraphNode> getRelatedNodes(TreeGraphNode t, TreeGraphNode root, HeadFinder headFinder) {\n    Set<TreeGraphNode> nodeList = new ArraySet<TreeGraphNode>();\n    for (TregexPattern p : targetPatterns) {    // cdm: I deleted: && nodeList.isEmpty()\n      // Initialize the TregexMatcher with the HeadFinder so that we\n      // can use the same HeadFinder through the entire process of\n      // building the dependencies\n      TregexMatcher m = p.matcher(root, headFinder);\n      while (m.findAt(t)) {\n        TreeGraphNode target = (TreeGraphNode) m.getNode(\"target\");\n        if (target == null) {\n          throw new AssertionError(\"Expression has no target: \" + p);\n        }\n        nodeList.add(target);\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \"-\" + t.headWordNode() + \", \" + m.getNode(\"target\") + \"-\" + ((TreeGraphNode) m.getNode(\"target\")).headWordNode() + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\"))\n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n",
    "new_code_raw": "  public Collection<Tree> getRelatedNodes(Tree t, Tree root) {\n    if (root.value() == null) {\n      root.setValue(\"ROOT\");  // todo: cdm: it doesn't seem like this line should be here\n    }\n    Set<Tree> nodeList = new LinkedHashSet<Tree>();\n    for (TregexPattern p : targetPatterns) {    // cdm: I deleted: && nodeList.isEmpty()\n      TregexMatcher m = p.matcher(root);\n      while (m.findAt(t)) {\n        nodeList.add(m.getNode(\"target\"));\n        //System.out.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p);\n      }\n    }\n    return nodeList;\n  }\n"
  },
  {
    "id": "bobmcwhirter_microcontainer-21-Associations-Param0",
    "old_comment_raw": "@param optionString type",
    "old_code_raw": "   public static FromContext getInstance(String optionString)\r\n   {\r\n      if (NAME.getFromString().equalsIgnoreCase(optionString))\r\n         return NAME;\r\n      else if (METADATA.getFromString().equalsIgnoreCase(optionString))\r\n         return METADATA;\r\n      else if (SCOPE.getFromString().equalsIgnoreCase(optionString))\r\n         return SCOPE;\r\n      else if (ID.getFromString().equalsIgnoreCase(optionString))\r\n         return ID;\r\n      else\r\n         return new DynamicFromContext(optionString);\r\n   }\r\n",
    "new_code_raw": "   public static FromContext getInstance(String fromString)\r\n   {\r\n      if (NAME.getFromString().equalsIgnoreCase(fromString))\r\n         return NAME;\r\n      else if (ALIAS.getFromString().equalsIgnoreCase(fromString))\r\n         return ALIAS;\r\n      else if (METADATA.getFromString().equalsIgnoreCase(fromString))\r\n         return METADATA;\r\n      else if (BEANINFO.getFromString().equalsIgnoreCase(fromString))\r\n         return BEANINFO;\r\n      else if (SCOPE.getFromString().equalsIgnoreCase(fromString))\r\n         return SCOPE;\r\n      else if (ID.getFromString().equalsIgnoreCase(fromString))\r\n         return ID;\r\n      else\r\n         return new DynamicFromContext(fromString);\r\n   }\r\n\n"
  },
  {
    "id": "MilosKozak_AndroidAPS-126-Param-0",
    "old_comment_raw": "@param request",
    "old_code_raw": "    public PumpEnactResult applyAPSRequest(APSResult request) {\n        request.rate = applyBasalConstraints(request.rate);\n        PumpEnactResult result;\n\n        if (!isInitialized()) {\n            result = new PumpEnactResult();\n            result.comment = MainApp.sResources.getString(R.string.pumpNotInitialized);\n            result.enacted = false;\n            result.success = false;\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpNotInitialized));\n            return result;\n        }\n\n        if (isSuspended()) {\n            result = new PumpEnactResult();\n            result.comment = MainApp.sResources.getString(R.string.pumpsuspended);\n            result.enacted = false;\n            result.success = false;\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpsuspended));\n            return result;\n        }\n\n        if (Config.logCongigBuilderActions)\n            log.debug(\"applyAPSRequest: \" + request.toString());\n        if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - getBaseBasalRate()) < getPumpDescription().basalStep) {\n            if (isTempBasalInProgress()) {\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: cancelTempBasal()\");\n                result = cancelTempBasal(false);\n            } else {\n                result = new PumpEnactResult();\n                result.absolute = request.rate;\n                result.duration = 0;\n                result.enacted = false;\n                result.comment = \"Basal set correctly\";\n                result.success = true;\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: Basal set correctly\");\n            }\n        } else if (isTempBasalInProgress()\n                && getTempBasalRemainingMinutesFromHistory() > 5\n                && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < getPumpDescription().basalStep) {\n            result = new PumpEnactResult();\n            result.absolute = getTempBasalAbsoluteRateHistory();\n            result.duration = getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes();\n            result.enacted = false;\n            result.comment = \"Temp basal set correctly\";\n            result.success = true;\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: Temp basal set correctly\");\n        } else {\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: setTempBasalAbsolute()\");\n            result = setTempBasalAbsolute(request.rate, request.duration);\n        }\n        return result;\n    }\n",
    "new_code_raw": "    public boolean applyAPSRequest(APSResult request, Callback callback) {\n        PumpInterface pump = getActivePump();\n        request.rate = applyBasalConstraints(request.rate);\n        PumpEnactResult result;\n\n        if (!pump.isInitialized()) {\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpNotInitialized));\n            if (callback != null) {\n                callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpNotInitialized)).enacted(false).success(false)).run();\n            }\n            return false;\n        }\n\n        if (pump.isSuspended()) {\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpsuspended));\n            if (callback != null) {\n                callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpsuspended)).enacted(false).success(false)).run();\n            }\n            return false;\n        }\n\n        if (Config.logCongigBuilderActions)\n            log.debug(\"applyAPSRequest: \" + request.toString());\n        if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - pump.getBaseBasalRate()) < pump.getPumpDescription().basalStep) {\n            if (isTempBasalInProgress()) {\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: cancelTempBasal()\");\n                getCommandQueue().cancelTempBasal(false, callback);\n                return true;\n            } else {\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: Basal set correctly\");\n                if (callback != null) {\n                    callback.result(new PumpEnactResult().absolute(request.rate).duration(0).enacted(false).success(true).comment(\"Basal set correctly\")).run();\n                }\n                return false;\n            }\n        } else if (isTempBasalInProgress()\n                && getTempBasalRemainingMinutesFromHistory() > 5\n                && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < pump.getPumpDescription().basalStep) {\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: Temp basal set correctly\");\n            if (callback != null) {\n                callback.result(new PumpEnactResult().absolute(getTempBasalAbsoluteRateHistory()).duration(getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes()).enacted(false).success(true).comment(\"Temp basal set correctly\")).run();\n            }\n            return false;\n        } else {\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: setTempBasalAbsolute()\");\n            getCommandQueue().tempBasalAbsolute(request.rate, request.duration, false, callback);\n            return true;\n        }\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1628-Param-0",
    "old_comment_raw": "@param body order placed for purchasing the pet",
    "old_code_raw": "  public Order  placeOrder (Order body) throws ApiException {\n    Object localVarPostBody = body;\n    // verify the required parameter 'body' is set\n    if (body == null) {\n       throw new ApiException(400, \"Missing the required parameter 'body' when calling placeOrder\");\n    }\n\n    // create path and map variables\n    String localVarPath = \"/store/order\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> localVarFormParams = new HashMap<String, String>();\n\n\n\n    String[] localVarContentTypes = {\n      \n    };\n    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application/json\";\n\n    if (localVarContentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      \n\n      localVarPostBody = localVarBuilder.build();\n    } else {\n      // normal form params\n          }\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);\n      if(localVarResponse != null){\n        return (Order) ApiInvoker.deserialize(localVarResponse, \"\", Order.class);\n      }\n      else {\n        return null;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n",
    "new_code_raw": "  public Order  placeOrder (Order order) throws ApiException {\n    Object localVarPostBody = order;\n    // verify the required parameter 'order' is set\n    if (order == null) {\n       throw new ApiException(400, \"Missing the required parameter 'order' when calling placeOrder\");\n    }\n\n    // create path and map variables\n    String localVarPath = \"/store/order\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> localVarFormParams = new HashMap<String, String>();\n\n\n\n    String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application/json\";\n\n    if (localVarContentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      \n\n      localVarPostBody = localVarBuilder.build();\n    } else {\n      // normal form params\n          }\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);\n      if(localVarResponse != null){\n        return (Order) ApiInvoker.deserialize(localVarResponse, \"\", Order.class);\n      }\n      else {\n        return null;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n"
  },
  {
    "id": "apache_kylin-379-Param-2",
    "old_comment_raw": "@param nameList List of column names to join on",
    "old_code_raw": "    private RexNode convertUsing(RelNode leftRel, RelNode rightRel, List<String> nameList) {\n        final List<RexNode> list = Lists.newArrayList();\n        for (String name : nameList) {\n            final RelDataType leftRowType = leftRel.getRowType();\n            RelDataTypeField leftField = catalogReader.field(leftRowType, name);\n            RexNode left = rexBuilder.makeInputRef(leftField.getType(), leftField.getIndex());\n            final RelDataType rightRowType = rightRel.getRowType();\n            RelDataTypeField rightField = catalogReader.field(rightRowType, name);\n            RexNode right = rexBuilder.makeInputRef(rightField.getType(), leftRowType.getFieldList().size() + rightField.getIndex());\n            RexNode equalsCall = rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, left, right);\n            list.add(equalsCall);\n        }\n        return RexUtil.composeConjunction(rexBuilder, list, false);\n    }\n",
    "new_code_raw": "    private RexNode convertUsing(SqlValidatorNamespace leftNamespace, SqlValidatorNamespace rightNamespace, List<String> nameList) {\n        final List<RexNode> list = Lists.newArrayList();\n        for (String name : nameList) {\n            List<RexNode> operands = new ArrayList<>();\n            int offset = 0;\n            for (SqlValidatorNamespace n : ImmutableList.of(leftNamespace, rightNamespace)) {\n                final RelDataType rowType = n.getRowType();\n                final RelDataTypeField field = catalogReader.field(rowType, name);\n                operands.add(rexBuilder.makeInputRef(field.getType(), offset + field.getIndex()));\n                offset += rowType.getFieldList().size();\n            }\n            list.add(rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, operands));\n        }\n        return RexUtil.composeConjunction(rexBuilder, list, false);\n    }\n"
  },
  {
    "id": "apache_drill-1537-Param-0",
    "old_comment_raw": "@param partition",
    "old_code_raw": "  public static Properties getPartitionMetadata(final Partition partition, final Table table) {\n    final Properties properties = MetaStoreUtils.getPartitionMetadata(partition, table);\n\n    // SerDe expects properties from Table, but above call doesn't add Table properties.\n    // Include Table properties in final list in order to not to break SerDes that depend on\n    // Table properties. For example AvroSerDe gets the schema from properties (passed as second argument)\n    for (Map.Entry<String, String> entry : table.getParameters().entrySet()) {\n      if (entry.getKey() != null && entry.getKey() != null) {\n        properties.put(entry.getKey(), entry.getValue());\n      }\n    }\n\n    return properties;\n  }\n",
    "new_code_raw": "  public static Properties getPartitionMetadata(final HivePartition partition, final HiveTableWithColumnCache table) {\n    final Properties properties;\n    restoreColumns(table, partition);\n    properties = MetaStoreUtils.getPartitionMetadata(partition, table);\n\n    // SerDe expects properties from Table, but above call doesn't add Table properties.\n    // Include Table properties in final list in order to not to break SerDes that depend on\n    // Table properties. For example AvroSerDe gets the schema from properties (passed as second argument)\n    for (Map.Entry<String, String> entry : table.getParameters().entrySet()) {\n      if (entry.getKey() != null && entry.getKey() != null) {\n        properties.put(entry.getKey(), entry.getValue());\n      }\n    }\n\n    return properties;\n  }\n"
  },
  {
    "id": "Netflix_eureka-85-Param-1",
    "old_comment_raw": "@param myZone the zone where this instance is in",
    "old_code_raw": "    public Collection<String> getCandidateEIPs(String myInstanceId, String myZone, String myPublicIP) {\n\n        if (myZone == null) {\n            myZone = \"us-east-1d\";\n            myPublicIP = \"us-east-1d\";\n        }\n        Collection<String> eipCandidates = (DiscoveryManager.getInstance()\n                .getEurekaClientConfig().shouldUseDnsForFetchingServiceUrls() ? getEIPsForZoneFromDNS(myZone)\n                        : getEIPsForZoneFromConfig(myZone));\n\n        if (eipCandidates == null || eipCandidates.size() == 0) {\n            throw new RuntimeException(\n                    \"Could not get any elastic ips from the EIP pool for zone :\"\n                    + myZone);\n        }\n       \n        return eipCandidates;\n    }\n",
    "new_code_raw": "    public Collection<String> getCandidateEIPs(String myInstanceId, String myZone) {\n\n        if (myZone == null) {\n            myZone = \"us-east-1d\";\n       }\n        Collection<String> eipCandidates = (DiscoveryManager.getInstance()\n                .getEurekaClientConfig().shouldUseDnsForFetchingServiceUrls() ? getEIPsForZoneFromDNS(myZone)\n                        : getEIPsForZoneFromConfig(myZone));\n\n        if (eipCandidates == null || eipCandidates.size() == 0) {\n            throw new RuntimeException(\n                    \"Could not get any elastic ips from the EIP pool for zone :\"\n                    + myZone);\n        }\n       \n        return eipCandidates;\n    }\n"
  },
  {
    "id": "SeleniumHQ_selenium-836-Param-0",
    "old_comment_raw": "@param onElement Element to release the mouse button above.",
    "old_code_raw": "  public Actions release(WebElement onElement) {\n    action.addAction(new ButtonReleaseAction(mouse, (Locatable) onElement));\n    return this;\n  }\n",
    "new_code_raw": "  public Actions release(WebElement target) {\n    if (isBuildingActions()) {\n      action.addAction(new ButtonReleaseAction(jsonMouse, (Locatable) target));\n      return this;\n    }\n    return moveToElement(target).release();\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1596-Param-0",
    "old_comment_raw": "@param orderId ID of pet that needs to be fetched (required)",
    "old_code_raw": "  public ApiResponse<Order> getOrderByIdWithHttpInfo(Long orderId) throws ApiException {\n    Call call = getOrderByIdCall(orderId, null, null);\n    Type localVarReturnType = new TypeToken<Order>(){}.getType();\n    return apiClient.execute(call, localVarReturnType);\n  }\n",
    "new_code_raw": "  public ApiResponse<Order> getOrderByIdWithHttpInfo(String orderId) throws ApiException {\n    Call call = getOrderByIdCall(orderId, null, null);\n    Type localVarReturnType = new TypeToken<Order>(){}.getType();\n    return apiClient.execute(call, localVarReturnType);\n  }\n"
  },
  {
    "id": "RobotiumTech_robotium-1507-Param-0",
    "old_comment_raw": "@param regex the text to search for. The parameter will be interpreted as a regular expression.",
    "old_code_raw": "\tpublic boolean searchText(String regex, int expectedMinimumNumberOfMatches, boolean scroll) {\n\t\treturn searcher.searchWithTimeoutFor(TextView.class, regex, expectedMinimumNumberOfMatches, scroll);\n\t}\n",
    "new_code_raw": "\tpublic boolean searchText(String text, int minimumNumberOfMatches, boolean scroll) {\n\t\treturn searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, scroll);\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1727-Param-1",
    "old_comment_raw": "@param method The request method, one of \"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\", \"PATCH\" and \"DELETE\"",
    "old_code_raw": "    public Call buildCall(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n        Request request = buildRequest(path, method, queryParams, collectionQueryParams, body, headerParams, formParams, authNames, progressRequestListener);\n\n        return httpClient.newCall(request);\n    }\n",
    "new_code_raw": "    public Call buildCall(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {\n        Request request = buildRequest(path, method, queryParams, collectionQueryParams, body, headerParams, formParams, authNames, callback);\n\n        return httpClient.newCall(request);\n    }\n"
  },
  {
    "id": "apache_activemq-70-Associations-Param1",
    "old_comment_raw": "@param message - if this is an ObjectMessage, it will be transformed to a TextMessage",
    "old_code_raw": "    protected Message objectToText(Session session, Message message) throws JMSException {\n        if (message instanceof ObjectMessage) {\n            TextMessage answer = session.createTextMessage(marshall(session, (ObjectMessage) message));\n            copyProperties(message, answer);\n            return answer;\n        }\n        return message;\n\t}\n",
    "new_code_raw": "    protected TextMessage objectToText(Session session, ObjectMessage objectMessage) throws JMSException {\n        TextMessage answer = session.createTextMessage(marshall(session, objectMessage));\n        copyProperties(objectMessage, answer);\n        return answer;\n\t}\n\n"
  },
  {
    "id": "runelite_runelite-21-Param-1",
    "old_comment_raw": "@param localLocation local location of the tile",
    "old_code_raw": "\tpublic static Polygon getCanvasTilePoly(Client client, Point localLocation)\n\t{\n\t\treturn getCanvasTileAreaPoly(client, localLocation, 1);\n\t}\n",
    "new_code_raw": "\tpublic static Polygon getCanvasTilePoly(Client client, LocalPoint localLocation)\n\t{\n\t\treturn getCanvasTileAreaPoly(client, localLocation, 1);\n\t}\n"
  },
  {
    "id": "RobotiumTech_robotium-1181-Param-0",
    "old_comment_raw": "@param search the string to be searched. The parameter will be interpreted as a regular expression.",
    "old_code_raw": "\tpublic boolean searchButton(String search, int matches) {\n\t\t\n        long now = System.currentTimeMillis();\n        final long endTime = now + TIMEOUT;\n        while (!searchForButton(search, matches) && now < endTime)\n        {\n        \tnow = System.currentTimeMillis();\n        }\n        if(now < endTime)\n        \treturn true;\n        else\n        \treturn false;\n\t}\n",
    "new_code_raw": "\tpublic boolean searchButton(String regex, int matches) {\n\t\t\n        long now = System.currentTimeMillis();\n        final long endTime = now + TIMEOUT;\n        while (!searchForButton(regex, matches) && now < endTime)\n        {\n        \tnow = System.currentTimeMillis();\n        }\n        if(now < endTime)\n        \treturn true;\n        else\n        \treturn false;\n\t}\n"
  },
  {
    "id": "LawnchairLauncher_Lawnchair-86-Param-2",
    "old_comment_raw": "@param info The data structure describing the shortcut.",
    "old_code_raw": "    View createShortcut(int layoutResId, ViewGroup parent, ApplicationInfo info) {\n        TextView favorite = (TextView) mInflater.inflate(layoutResId, parent, false);\n\n        if (info.icon == null) {\n            info.icon = AppInfoCache.getIconDrawable(getPackageManager(), info);\n        }\n        if (!info.filtered) {\n            info.icon = Utilities.createIconThumbnail(info.icon, this);\n            info.filtered = true;\n        }\n\n        favorite.setCompoundDrawablesWithIntrinsicBounds(null, info.icon, null, null);\n        favorite.setText(info.title);\n        favorite.setTag(info);\n        favorite.setOnClickListener(this);\n\n        return favorite;\n    }\n",
    "new_code_raw": "    View createShortcut(int layoutResId, ViewGroup parent, ShortcutInfo info) {\n        TextView favorite = (TextView) mInflater.inflate(layoutResId, parent, false);\n\n        favorite.setCompoundDrawablesWithIntrinsicBounds(null,\n                new FastBitmapDrawable(info.getIcon(mIconCache)),\n                null, null);\n        favorite.setText(info.title);\n        favorite.setTag(info);\n        favorite.setOnClickListener(this);\n\n        return favorite;\n    }\n"
  },
  {
    "id": "querydsl_querydsl-678-Param-1",
    "old_comment_raw": "@param args",
    "old_code_raw": "    public static StringExpression stringTemplate(Template template, Object... args) {\n        return new StringTemplate(template, ImmutableList.copyOf(args));\n    }\n",
    "new_code_raw": "    public static StringTemplate stringTemplate(String template, ImmutableList<?> args) {\n        return new StringTemplate(createTemplate(template), args);\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1971-Param-0",
    "old_comment_raw": "@param inputStream",
    "old_code_raw": "\tpublic static byte[] readByteCode(InputStream inputStream) throws IOException {\n\t\tif ( inputStream == null ) {\n\t\t\tthrow new IOException( \"null input stream\" );\n\t\t}\n\n\t\tbyte[] buffer = new byte[409600];\n\t\tbyte[] classBytes = new byte[0];\n\t\tint r = 0;\n\n\t\ttry {\n\t\t\tr = inputStream.read( buffer );\n\t\t\twhile ( r >= buffer.length ) {\n\t\t\t\tbyte[] temp = new byte[ classBytes.length + buffer.length ];\n\t\t\t\tSystem.arraycopy( classBytes, 0, temp, 0, classBytes.length );\n\t\t\t\tSystem.arraycopy( buffer, 0, temp, classBytes.length, buffer.length );\n\t\t\t\tclassBytes = temp;\n\t\t\t}\n\t\t\tif ( r != -1 ) {\n\t\t\t\tbyte[] temp = new byte[ classBytes.length + r ];\n\t\t\t\tSystem.arraycopy( classBytes, 0, temp, 0, classBytes.length );\n\t\t\t\tSystem.arraycopy( buffer, 0, temp, classBytes.length, r );\n\t\t\t\tclassBytes = temp;\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tinputStream.close();\n\t\t\t}\n\t\t\tcatch (IOException ignore) {\n\t\t\t\t// intentionally empty\n\t\t\t}\n\t\t}\n\n\t\treturn classBytes;\n\t}\n",
    "new_code_raw": "\tpublic static byte[] readByteCode(ZipInputStream zip) throws IOException {\n        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n        InputStream in = new BufferedInputStream( zip );\n        int b;\n        while ( ( b = in.read() ) != -1 ) {\n            bout.write( b );\n        }\n        return bout.toByteArray();\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-183-Param-3",
    "old_comment_raw": "@param body The request body object",
    "old_code_raw": "  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n",
    "new_code_raw": "  public String invokeAPI(String path, String method, Set<QueryParam> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (QueryParam queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n"
  },
  {
    "id": "apache_kylin-528-Param-0",
    "old_comment_raw": "@param that",
    "old_code_raw": "    public int compareTo(final byte[] that) {\n        return WritableComparator.compareBytes(this.data, this.offset, this.length, that, 0, that.length);\n    }\n",
    "new_code_raw": "    public int compareTo(ByteArrayWritable that) {\n        return WritableComparator.compareBytes(this.data, this.offset, this.length, that.data, that.offset,\n                that.length);\n    }\n"
  },
  {
    "id": "Atmosphere_atmosphere-503-Param-0",
    "old_comment_raw": "@param o The object to introspect.",
    "old_code_raw": "    public BroadcastAction filter(Object originalMessage, Object o) {\n        if (o instanceof String) {\n            String message = (String) o;\n\n            StringBuffer buffer = new StringBuffer(message.length());\n\n            for (int i = 0; i < message.length(); i++) {\n                char c = message.charAt(i);\n                switch (c) {\n                    case '\\b':\n                        buffer.append(\"\\\\b\");\n                        break;\n                    case '\\f':\n                        buffer.append(\"\\\\f\");\n                        break;\n                    case '\\n':\n                        buffer.append(\"<br />\");\n                        break;\n                    case '\\r':\n                        // ignore\n                        break;\n                    case '\\t':\n                        buffer.append(\"\\\\t\");\n                        break;\n                    case '\\'':\n                        buffer.append(\"\\\\'\");\n                        break;\n                    case '\\\"':\n                        buffer.append(\"\\\\\\\"\");\n                        break;\n                    case '\\\\':\n                        buffer.append(\"\\\\\\\\\");\n                        break;\n                    case '<':\n                        buffer.append(\"&lt;\");\n                        break;\n                    case '>':\n                        buffer.append(\"&gt;\");\n                        break;\n                    case '&':\n                        buffer.append(\"&amp;\");\n                        break;\n                    default:\n                        buffer.append(c);\n                }\n            }\n            return new BroadcastAction(buffer.toString());\n        } else {\n            return new BroadcastAction(o);\n        }\n    }\n",
    "new_code_raw": "    public BroadcastAction filter(String broadcasterId, Object originalMessage, Object o) {\n        if (o instanceof String) {\n            String message = (String) o;\n\n            StringBuffer buffer = new StringBuffer(message.length());\n\n            for (int i = 0; i < message.length(); i++) {\n                char c = message.charAt(i);\n                switch (c) {\n                    case '\\b':\n                        buffer.append(\"\\\\b\");\n                        break;\n                    case '\\f':\n                        buffer.append(\"\\\\f\");\n                        break;\n                    case '\\n':\n                        buffer.append(\"<br />\");\n                        break;\n                    case '\\r':\n                        // ignore\n                        break;\n                    case '\\t':\n                        buffer.append(\"\\\\t\");\n                        break;\n                    case '\\'':\n                        buffer.append(\"\\\\'\");\n                        break;\n                    case '\\\"':\n                        buffer.append(\"\\\\\\\"\");\n                        break;\n                    case '\\\\':\n                        buffer.append(\"\\\\\\\\\");\n                        break;\n                    case '<':\n                        buffer.append(\"&lt;\");\n                        break;\n                    case '>':\n                        buffer.append(\"&gt;\");\n                        break;\n                    case '&':\n                        buffer.append(\"&amp;\");\n                        break;\n                    default:\n                        buffer.append(c);\n                }\n            }\n            return new BroadcastAction(buffer.toString());\n        } else {\n            return new BroadcastAction(o);\n        }\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1500-Param-0",
    "old_comment_raw": "@param key The key of the item to get",
    "old_code_raw": "   protected Object suspendAndGet(Object key, Flag opt, boolean suppressTimeout) throws CacheException {\n       Transaction tx = suspend();\n       try {\n           if (suppressTimeout)\n               return CacheHelper.getAllowingTimeout(cache, key);\n           else\n               return CacheHelper.get(cache, key);\n       } finally {\n           resume(tx);\n       }\n   }\n",
    "new_code_raw": "   protected Object suspendAndGet(Object key, FlagAdapter opt, boolean suppressTimeout) throws CacheException {\n       Transaction tx = suspend();\n       try {\n           if (suppressTimeout)\n               return cacheAdapter.getAllowingTimeout(key);\n           else\n               return cacheAdapter.get(key);\n       } finally {\n           resume(tx);\n       }\n   }\n"
  },
  {
    "id": "apache_kylin-68-Associations-Param1",
    "old_comment_raw": "@param lockPath the zookeeper node path of segment",
    "old_code_raw": "\n    private boolean isKeepLock(String serverName, String lockPath) {\n        try {\n            if (zkClient.checkExists().forPath(lockPath) != null) {\n                byte[] data = zkClient.getData().forPath(lockPath);\n                String lockServerName = new String(data, Charset.forName(\"UTF-8\"));\n                return lockServerName.equalsIgnoreCase(serverName);\n            }\n        } catch (Exception e) {\n            logger.error(\"fail to get the serverName for the path: \" + lockPath, e);\n        }\n        return false;\n    }\n",
    "new_code_raw": "\n    private boolean isKeepLock(String lockClient, String lockPath) {\n        try {\n            if (zkClient.checkExists().forPath(lockPath) != null) {\n                byte[] data = zkClient.getData().forPath(lockPath);\n                String lockServerName = new String(data, Charset.forName(\"UTF-8\"));\n                return lockServerName.equalsIgnoreCase(lockClient);\n            }\n        } catch (Exception e) {\n            logger.error(\"fail to get the lockClient for the path: \" + lockPath, e);\n        }\n        return false;\n    }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-53-Param-1",
    "old_comment_raw": "@param fieldIndex the index of this field in the instant",
    "old_code_raw": "    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {\n        int current = values[fieldIndex];\n        int wrapped = FieldUtils.getWrappedValue\n            (current, valueToAdd, getMinimumValue(instant), getMaximumValue(instant));\n        return set(instant, fieldIndex, values, wrapped);  // adjusts smaller fields\n    }\n",
    "new_code_raw": "    public int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n        int current = values[fieldIndex];\n        int wrapped = FieldUtils.getWrappedValue\n            (current, valueToAdd, getMinimumValue(instant), getMaximumValue(instant));\n        return set(instant, fieldIndex, values, wrapped);  // adjusts smaller fields\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1722-Param-0",
    "old_comment_raw": "@param client client model",
    "old_code_raw": "    public Mono<Client> testClassname(Client client) throws RestClientException {\n        Object postBody = client;\n        \n        // verify the required parameter 'client' is set\n        if (client == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'client' when calling testClassname\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"/fake_classname_test\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"api_key_query\" };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "new_code_raw": "    public Mono<Client> testClassname(Client body) throws RestClientException {\n        Object postBody = body;\n        \n        // verify the required parameter 'body' is set\n        if (body == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling testClassname\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"/fake_classname_test\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"api_key_query\" };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n"
  },
  {
    "id": "graphql_java_graphql_java-229-Param-0",
    "old_comment_raw": "@param newType the new type to be",
    "old_code_raw": "    public ExecutionStepInfo changeTypeWithPreservedNonNull(GraphQLType newType) {\n        assertTrue(!GraphQLTypeUtil.isNonNull(newType), \"newType can't be non null\");\n        if (isNonNullType()) {\n            return new ExecutionStepInfo(GraphQLNonNull.nonNull(newType), fieldDefinition, field, path, this.parent, arguments);\n        } else {\n            return new ExecutionStepInfo(newType, fieldDefinition, field, path, this.parent, arguments);\n        }\n    }\n",
    "new_code_raw": "    public ExecutionStepInfo changeTypeWithPreservedNonNull(GraphQLOutputType newType) {\n        assertTrue(!GraphQLTypeUtil.isNonNull(newType), \"newType can't be non null\");\n        if (isNonNullType()) {\n            return new ExecutionStepInfo(GraphQLNonNull.nonNull(newType), fieldDefinition, field, path, this.parent, arguments);\n        } else {\n            return new ExecutionStepInfo(newType, fieldDefinition, field, path, this.parent, arguments);\n        }\n    }\n"
  },
  {
    "id": "facebook_fresco-78-Param-1",
    "old_comment_raw": "@param limitY whether to apply the limit on the y-axis",
    "old_code_raw": "  private boolean limitTranslation(Matrix transform, boolean limitX, boolean limitY) {\n    RectF bounds = mTempRect;\n    bounds.set(mImageBounds);\n    transform.mapRect(bounds);\n    float offsetLeft = limitX ?\n        getOffset(bounds.left, bounds.right, mViewBounds.left, mViewBounds.right) : 0;\n    float offsetTop = limitY ?\n        getOffset(bounds.top, bounds.bottom, mViewBounds.top, mViewBounds.bottom) : 0;\n    if (offsetLeft != 0 || offsetTop != 0) {\n      transform.postTranslate(offsetLeft, offsetTop);\n      return true;\n    }\n    return false;\n  }\n",
    "new_code_raw": "  private boolean limitTranslation(Matrix transform, boolean shouldLimitX, boolean shouldLimitY) {\n    if (!shouldLimitX && !shouldLimitY) {\n      return false;\n    }\n    RectF b = mTempRect;\n    b.set(mImageBounds);\n    transform.mapRect(b);\n    float offsetLeft = !shouldLimitX ? 0 :\n        getOffset(b.left, b.right, mViewBounds.left, mViewBounds.right, mImageBounds.centerX());\n    float offsetTop = !shouldLimitY ? 0 :\n        getOffset(b.top, b.bottom, mViewBounds.top, mViewBounds.bottom, mImageBounds.centerY());\n    if (offsetLeft != 0 || offsetTop != 0) {\n      transform.postTranslate(offsetLeft, offsetTop);\n      return true;\n    }\n    return false;\n  }\n"
  },
  {
    "id": "scribejava_scribejava-47-Param-0",
    "old_comment_raw": "@param requestToken the request token you need to authorize",
    "old_code_raw": "    public String getAuthorizationUrl(Token requestToken) {\n        return api.getAuthorizationUrl(requestToken);\n    }\n",
    "new_code_raw": "    public String getAuthorizationUrl(OAuth1RequestToken requestToken) {\n        return api.getAuthorizationUrl(requestToken);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1720-Param-0",
    "old_comment_raw": "@param outerComposite Input composite as post body",
    "old_code_raw": "    public Mono<OuterComposite> fakeOuterCompositeSerialize(OuterComposite outerComposite) throws RestClientException {\n        Object postBody = outerComposite;\n        \n        String path = UriComponentsBuilder.fromPath(\"/fake/outer/composite\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"*/*\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<OuterComposite> returnType = new ParameterizedTypeReference<OuterComposite>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "new_code_raw": "    public Mono<OuterComposite> fakeOuterCompositeSerialize(OuterComposite body) throws RestClientException {\n        Object postBody = body;\n        \n        String path = UriComponentsBuilder.fromPath(\"/fake/outer/composite\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"*/*\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<OuterComposite> returnType = new ParameterizedTypeReference<OuterComposite>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n"
  },
  {
    "id": "apache_activemq-69-Param-0",
    "old_comment_raw": "@param dataIn",
    "old_code_raw": "    public Object readPayload(DataInputStream dataIn) throws IOException{\n        return dataIn.readUTF();\n    }\n",
    "new_code_raw": "    public Object readPayload(DataInput dataIn) throws IOException{\n        return dataIn.readUTF();\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1630-Param-0",
    "old_comment_raw": "@param body List of user object",
    "old_code_raw": "  public void  createUsersWithArrayInput (List<User> body) throws ApiException {\n    Object localVarPostBody = body;\n    // verify the required parameter 'body' is set\n    if (body == null) {\n       throw new ApiException(400, \"Missing the required parameter 'body' when calling createUsersWithArrayInput\");\n    }\n\n    // create path and map variables\n    String localVarPath = \"/user/createWithArray\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> localVarFormParams = new HashMap<String, String>();\n\n\n\n    String[] localVarContentTypes = {\n      \n    };\n    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application/json\";\n\n    if (localVarContentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      \n\n      localVarPostBody = localVarBuilder.build();\n    } else {\n      // normal form params\n          }\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);\n      if(localVarResponse != null){\n        return ;\n      }\n      else {\n        return ;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n",
    "new_code_raw": "  public void  createUsersWithArrayInput (List<User> user) throws ApiException {\n    Object localVarPostBody = user;\n    // verify the required parameter 'user' is set\n    if (user == null) {\n       throw new ApiException(400, \"Missing the required parameter 'user' when calling createUsersWithArrayInput\");\n    }\n\n    // create path and map variables\n    String localVarPath = \"/user/createWithArray\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> localVarFormParams = new HashMap<String, String>();\n\n\n\n    String[] localVarContentTypes = {\n      \n    };\n    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application/json\";\n\n    if (localVarContentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      \n\n      localVarPostBody = localVarBuilder.build();\n    } else {\n      // normal form params\n          }\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);\n      if(localVarResponse != null){\n        return ;\n      }\n      else {\n        return ;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1963-Param-5",
    "old_comment_raw": "@param initialValue The initial value.",
    "old_code_raw": "\tpublic Serializable generate(SessionImplementor session, Object object) throws HibernateException {\n\t\treturn optimizer.generate( databaseStructure.buildCallback( session ) );\n\t}\n",
    "new_code_raw": "\tpublic Serializable generate(SharedSessionContractImplementor session, Object object) throws HibernateException {\n\t\treturn optimizer.generate( databaseStructure.buildCallback( session ) );\n\t}\n"
  },
  {
    "id": "lingochamp_FileDownloader-84-Param-1",
    "old_comment_raw": "@param path Use to judge whether has already completed downloading.",
    "old_code_raw": "    public byte getStatus(final int downloadId, final String path) {\n        byte status;\n        BaseDownloadTask.IRunningTask task = FileDownloadList.getImpl().get(downloadId);\n        if (task == null) {\n            status = FileDownloadServiceProxy.getImpl().getStatus(downloadId);\n        } else {\n            status = task.getOrigin().getStatus();\n        }\n\n        if (path != null && status == FileDownloadStatus.INVALID_STATUS) {\n            if (FileDownloadUtils.isFilenameConverted(FileDownloadHelper.getAppContext()) &&\n                    new File(path).exists()) {\n                status = FileDownloadStatus.completed;\n            }\n        }\n\n        return status;\n    }\n",
    "new_code_raw": "    public byte getStatus(final int id, final String path) {\n        byte status;\n        BaseDownloadTask.IRunningTask task = FileDownloadList.getImpl().get(id);\n        if (task == null) {\n            status = FileDownloadServiceProxy.getImpl().getStatus(id);\n        } else {\n            status = task.getOrigin().getStatus();\n        }\n\n        if (path != null && status == FileDownloadStatus.INVALID_STATUS) {\n            if (FileDownloadUtils.isFilenameConverted(FileDownloadHelper.getAppContext()) &&\n                    new File(path).exists()) {\n                status = FileDownloadStatus.completed;\n            }\n        }\n\n        return status;\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-275-Param-0",
    "old_comment_raw": "@param direction the direction to be scrolled",
    "old_code_raw": "\tprivate boolean scrollScrollView(Direction direction, ArrayList<ScrollView> scrollViews){\n\t\tint yStart = 0;\n\t\tint yEnd = 0;\n\t\tint[] xy = new int[2];\n\t\tint x = activityUtils.getCurrentActivity(false).getWindowManager()\n\t\t.getDefaultDisplay().getWidth() / 2;\n\t\tScrollView scroll = viewFetcher.getView(ScrollView.class, scrollViews, 0);\n\t\tscroll.getLocationOnScreen(xy);\n\n\t\tif (direction == Direction.DOWN) {\n\t\t\tyStart = ((xy[1] + scroll.getHeight()) - 20);\n\t\t\tyEnd = (xy[1] + 30);\n\t\t}\n\t\telse if (direction == Direction.UP){\n\t\t\tyStart = (xy[1] + 20);\n\t\t\tyEnd = ((xy[1] + scroll.getHeight()) - 30);\n\t\t}\n\n\t\tscrollAmount = scroll.getScrollY();\n\t\tdrag(x, x,getDragablePosition(yStart, direction), yEnd, 40);\n\t\tif (scrollAmount == scroll.getScrollY()) {\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t\treturn true;\n\t}\n",
    "new_code_raw": "\tprivate boolean scrollScrollView(int direction, ArrayList<ScrollView> scrollViews){\n\t\tint[] xy = new int[2];\n\t\tScrollView scroll = viewFetcher.getView(ScrollView.class, scrollViews, 0);\n\t\tscroll.getLocationOnScreen(xy);\n\t\tint height = scroll.getHeight();\n\t\tint to = 0;\n\n\t\tif (direction == DOWN) {\n\t\t\tto = (height);\n\t\t}\n\n\t\telse if (direction == UP) {\n\t\t\tto = (-height);\n\t\t}\n\t\tscrollAmount = scroll.getScrollY();\n\t\tscrollScrollViewTo(scroll,0, to);\n\t\tif (scrollAmount == scroll.getScrollY()) {\n\t\t\treturn false;\n\t\t}\n\t\telse{\n\t\t\treturn true;\n\t\t}\n\t}\n"
  },
  {
    "id": "facebook_fresco-78-Param-0",
    "old_comment_raw": "@param limitX whether to apply the limit on the x-axis",
    "old_code_raw": "  private boolean limitTranslation(Matrix transform, boolean limitX, boolean limitY) {\n    RectF bounds = mTempRect;\n    bounds.set(mImageBounds);\n    transform.mapRect(bounds);\n    float offsetLeft = limitX ?\n        getOffset(bounds.left, bounds.right, mViewBounds.left, mViewBounds.right) : 0;\n    float offsetTop = limitY ?\n        getOffset(bounds.top, bounds.bottom, mViewBounds.top, mViewBounds.bottom) : 0;\n    if (offsetLeft != 0 || offsetTop != 0) {\n      transform.postTranslate(offsetLeft, offsetTop);\n      return true;\n    }\n    return false;\n  }\n",
    "new_code_raw": "  private boolean limitTranslation(Matrix transform, boolean shouldLimitX, boolean shouldLimitY) {\n    if (!shouldLimitX && !shouldLimitY) {\n      return false;\n    }\n    RectF b = mTempRect;\n    b.set(mImageBounds);\n    transform.mapRect(b);\n    float offsetLeft = !shouldLimitX ? 0 :\n        getOffset(b.left, b.right, mViewBounds.left, mViewBounds.right, mImageBounds.centerX());\n    float offsetTop = !shouldLimitY ? 0 :\n        getOffset(b.top, b.bottom, mViewBounds.top, mViewBounds.bottom, mImageBounds.centerY());\n    if (offsetLeft != 0 || offsetTop != 0) {\n      transform.postTranslate(offsetLeft, offsetTop);\n      return true;\n    }\n    return false;\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1216-Param-0",
    "old_comment_raw": "@param id The entity id to resolve",
    "old_code_raw": "\tprotected boolean isNull(Object owner, SessionImplementor session) {\n\t\treturn false;\n\t}\n",
    "new_code_raw": "\tprotected boolean isNull(Object owner, SharedSessionContractImplementor session) {\n\t\treturn false;\n\t}\n"
  },
  {
    "id": "RobotiumTech_robotium-1493-Param-1",
    "old_comment_raw": "@param listIndex the index of the list. 1 if two lists are available",
    "old_code_raw": "\tpublic ArrayList<TextView> clickInList(int line, int listIndex) {\n\t\treturn clicker.clickInList(line, listIndex);\n\t}\n",
    "new_code_raw": "\tpublic ArrayList<TextView> clickInList(int line, int index) {\n\t\treturn clicker.clickInList(line, index);\n\t}\n"
  },
  {
    "id": "SeleniumHQ_selenium-864-Param-0",
    "old_comment_raw": "@param cap - Capability",
    "old_code_raw": "  public static String getConsoleIconPath(DesiredCapabilities cap, Registry registry) {\n    String name = consoleIconName(cap, registry);\n    String path = \"org/openqa/grid/images/\";\n    InputStream in =\n        Thread.currentThread().getContextClassLoader()\n            .getResourceAsStream(path + name + \".png\");\n    if (in == null) {\n      return null;\n    }\n    return \"/grid/resources/\" + path + name + \".png\";\n  }\n",
    "new_code_raw": "  public static String getConsoleIconPath(DesiredCapabilities cap, GridRegistry registry) {\n    String name = consoleIconName(cap, registry);\n    String path = \"org/openqa/grid/images/\";\n    InputStream in =\n        Thread.currentThread().getContextClassLoader()\n            .getResourceAsStream(path + name + \".png\");\n    if (in == null) {\n      return null;\n    }\n    return \"/grid/resources/\" + path + name + \".png\";\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-1119-Param-0",
    "old_comment_raw": "@param field field should operate in UTC or be time zone agnostic",
    "old_code_raw": "    public DateTimeFormatterBuilder appendShortText(final DateTimeField field) {\n        return append0(new TextField(iChrono, field, iLocale, true));\n    }\n",
    "new_code_raw": "    public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        DateTimeField field = fieldType.getField(iChronoUTC);\n        return append0(new TextField(iChrono, field, iLocale, true));\n    }\n"
  },
  {
    "id": "apache_activemq-597-Param-0",
    "old_comment_raw": "@param next The next Transport layer in the Transport stack.",
    "old_code_raw": "    public TransportLogger createTransportLogger(Transport next, Log log) throws IOException {\n        return createTransportLogger(next, getNextId(), log, defaultLogWriterName, defaultDynamicManagement, defaultInitialBehavior, defaultJmxPort);\n    }\n",
    "new_code_raw": "    public TransportLogger createTransportLogger(Transport next, Logger log) throws IOException {\n        return createTransportLogger(next, getNextId(), log, defaultLogWriterName, defaultDynamicManagement, defaultInitialBehavior, defaultJmxPort);\n    }\n"
  },
  {
    "id": "Atmosphere_atmosphere-823-Param-1",
    "old_comment_raw": "@param res the  HttpServletResponse",
    "old_code_raw": "    Action action(HttpServletRequest req, HttpServletResponse res)\n            throws IOException, ServletException {\n\n        boolean webSocketEnabled = false;\n        if (req.getHeaders(\"Connection\") != null && req.getHeaders(\"Connection\").hasMoreElements()) {\n            String[] e = req.getHeaders(\"Connection\").nextElement().toString().split(\",\");\n            for (String upgrade : e) {\n                if (upgrade.equalsIgnoreCase(\"Upgrade\")) {\n                    webSocketEnabled = true;\n                    break;\n                }\n            }\n        }\n\n        if (webSocketEnabled && !supportWebSocket()) {\n            res.setStatus(501);\n            res.addHeader(X_ATMOSPHERE_ERROR, \"Websocket protocol not supported\");\n            res.flushBuffer();\n            return new Action();\n        }\n\n        if (config.handlers().isEmpty()) {\n            logger.error(\"No AtmosphereHandler found. Make sure you define it inside META-INF/atmosphere.xml\");\n            throw new AtmosphereMappingException(\"No AtmosphereHandler found. Make sure you define it inside META-INF/atmosphere.xml\");\n        }\n\n        if (supportSession()) {\n            // Create the session needed to support the Resume\n            // operation from disparate requests.\n            HttpSession session = req.getSession(true);\n            // Do not allow times out.\n            if (session.getMaxInactiveInterval() == DEFAULT_SESSION_TIMEOUT) {\n                session.setMaxInactiveInterval(-1);\n            }\n        }\n\n        req.setAttribute(FrameworkConfig.SUPPORT_SESSION, supportSession());\n\n        AtmosphereHandlerWrapper handlerWrapper = map(req);\n        // Check Broadcaster state. If destroyed, replace it.\n        Broadcaster b = handlerWrapper.broadcaster;\n        if (b.isDestroyed()) {\n            synchronized (handlerWrapper) {\n                config.getBroadcasterFactory().remove(b, b.getID());\n                handlerWrapper.broadcaster = config.getBroadcasterFactory().get(b.getID());\n            }\n        }\n        AtmosphereResourceImpl resource = new AtmosphereResourceImpl(config, handlerWrapper.broadcaster, req, res, this, handlerWrapper.atmosphereHandler);\n\n        req.setAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE, resource);\n        req.setAttribute(FrameworkConfig.ATMOSPHERE_HANDLER, handlerWrapper.atmosphereHandler);\n\n        try {\n            handlerWrapper.atmosphereHandler.onRequest(resource);\n        } catch (IOException t) {\n            resource.onThrowable(t);\n            throw t;\n        }\n\n        if (trackActiveRequest && resource.getAtmosphereResourceEvent().isSuspended() && req.getAttribute(FrameworkConfig.CANCEL_SUSPEND_OPERATION) == null) {\n            req.setAttribute(MAX_INACTIVE, System.currentTimeMillis());\n            aliveRequests.put(req, resource);\n        }\n        return resource.action();\n    }\n",
    "new_code_raw": "    Action action(AtmosphereRequest req, AtmosphereResponse res)\n            throws IOException, ServletException {\n\n        boolean webSocketEnabled = false;\n        if (req.getHeaders(\"Connection\") != null && req.getHeaders(\"Connection\").hasMoreElements()) {\n            String[] e = req.getHeaders(\"Connection\").nextElement().toString().split(\",\");\n            for (String upgrade : e) {\n                if (upgrade.equalsIgnoreCase(\"Upgrade\")) {\n                    webSocketEnabled = true;\n                    break;\n                }\n            }\n        }\n\n        if (webSocketEnabled && !supportWebSocket()) {\n            res.setStatus(501);\n            res.addHeader(X_ATMOSPHERE_ERROR, \"Websocket protocol not supported\");\n            res.flushBuffer();\n            return new Action();\n        }\n\n        if (config.handlers().isEmpty()) {\n            logger.error(\"No AtmosphereHandler found. Make sure you define it inside META-INF/atmosphere.xml\");\n            throw new AtmosphereMappingException(\"No AtmosphereHandler found. Make sure you define it inside META-INF/atmosphere.xml\");\n        }\n\n        if (supportSession()) {\n            // Create the session needed to support the Resume\n            // operation from disparate requests.\n            HttpSession session = req.getSession(true);\n            // Do not allow times out.\n            if (session.getMaxInactiveInterval() == DEFAULT_SESSION_TIMEOUT) {\n                session.setMaxInactiveInterval(-1);\n            }\n        }\n\n        req.setAttribute(FrameworkConfig.SUPPORT_SESSION, supportSession());\n\n        AtmosphereHandlerWrapper handlerWrapper = map(req);\n        // Check Broadcaster state. If destroyed, replace it.\n        Broadcaster b = handlerWrapper.broadcaster;\n        if (b.isDestroyed()) {\n            synchronized (handlerWrapper) {\n                config.getBroadcasterFactory().remove(b, b.getID());\n                handlerWrapper.broadcaster = config.getBroadcasterFactory().get(b.getID());\n            }\n        }\n        AtmosphereResourceImpl resource = new AtmosphereResourceImpl(config, handlerWrapper.broadcaster, req, res, this, handlerWrapper.atmosphereHandler);\n\n        req.setAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE, resource);\n        req.setAttribute(FrameworkConfig.ATMOSPHERE_HANDLER, handlerWrapper.atmosphereHandler);\n\n        try {\n            handlerWrapper.atmosphereHandler.onRequest(resource);\n        } catch (IOException t) {\n            resource.onThrowable(t);\n            throw t;\n        }\n\n        if (trackActiveRequest && resource.getAtmosphereResourceEvent().isSuspended() && req.getAttribute(FrameworkConfig.CANCEL_SUSPEND_OPERATION) == null) {\n            req.setAttribute(MAX_INACTIVE, System.currentTimeMillis());\n            aliveRequests.put(req, resource);\n        }\n        return resource.action();\n    }\n"
  },
  {
    "id": "debezium_debezium-123-Param-0",
    "old_comment_raw": "@param query the SQL query",
    "old_code_raw": "    public JdbcConnection query(String query, Consumer<ResultSet> resultConsumer) throws SQLException {\n        Connection conn = connection();\n        conn.setAutoCommit(false);\n        try (Statement statement = conn.createStatement();) {\n            ResultSet resultSet = statement.executeQuery(query);\n            if (resultConsumer != null) resultConsumer.accept(resultSet);\n        }\n        return this;\n    }\n",
    "new_code_raw": "    public JdbcConnection query(String query, ResultSetConsumer resultConsumer) throws SQLException {\n        Connection conn = connection();\n        try (Statement statement = conn.createStatement();) {\n            try (ResultSet resultSet = statement.executeQuery(query);) {\n                if (resultConsumer != null) {\n                    resultConsumer.accept(resultSet);\n                }\n            }\n        }\n        return this;\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-308-Param-0",
    "old_comment_raw": "@param mappingFileNames the file names of the xml files to parse",
    "old_code_raw": "\tpublic Index parseAndUpdateIndex(Set<String> mappingFileNames, Index annotationIndex) {\n\t\tClassLoaderService classLoaderService = meta.getServiceRegistry().getService( ClassLoaderService.class );\n\t\tSet<InputStream> mappingStreams = new HashSet<InputStream>();\n\t\tfor ( String fileName : mappingFileNames ) {\n\n\t\t\tXMLEntityMappings entityMappings;\n\t\t\ttry {\n\t\t\t\tentityMappings = XmlHelper.unmarshallXml(\n\t\t\t\t\t\tfileName, ORM2_MAPPING_XSD, XMLEntityMappings.class, classLoaderService\n\t\t\t\t).getRoot();\n\t\t\t}\n\t\t\tcatch ( JAXBException orm2Exception ) {\n\t\t\t\t// if we cannot parse against orm_2_0.xsd we try orm_1_0.xsd for backwards compatibility\n\t\t\t\ttry {\n\t\t\t\t\tentityMappings = XmlHelper.unmarshallXml(\n\t\t\t\t\t\t\tfileName, ORM1_MAPPING_XSD, XMLEntityMappings.class, classLoaderService\n\t\t\t\t\t).getRoot();\n\t\t\t\t}\n\t\t\t\tcatch ( JAXBException orm1Exception ) {\n\t\t\t\t\tthrow new AnnotationException( \"Unable to parse xml configuration.\", orm1Exception );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentityMappings.toString();\n\t\t}\n\n\t\treturn null;\n\t}\n",
    "new_code_raw": "\tpublic Index parseAndUpdateIndex(List<JaxbRoot<XMLEntityMappings>> mappings, Index annotationIndex) {\n\t\tfor ( JaxbRoot<XMLEntityMappings> root : mappings ) {\n\t\t\troot.getRoot().toString();\n\t\t}\n\t\treturn annotationIndex;\n\t}\n"
  },
  {
    "id": "SeleniumHQ_selenium-849-Param-0",
    "old_comment_raw": "@param commandResult - the reply from the previous command, or null",
    "old_code_raw": "    public SeleneseCommand handleCommandResult(String commandResult, FrameAddress frameAddress, String uniqueId) {\n        SeleneseQueue queue;\n        if (!SeleniumServer.isProxyInjectionMode()) {\n            queue = getSeleneseQueue();\n        }\n        else {\n            if (frameAddress.getWindowName().equals(SELENIUM_WINDOW_NAME_UNKNOWN_POPUP)) {\n                boolean foundFrameAddressOfUnknownPopup = false;\n                for (FrameAddress f : frameAddressToSeleneseQueue.keySet()) {\n                    // the situation being handled here: a pop-up window has either just loaded or reloaded, and therefore\n                    // doesn't know its name.  It uses SELENIUM_WINDOW_NAME_UNKNOWN_POPUP as a placeholder.\n                    // Meanwhile, on the selenium server-side, a thread is waiting for this result.\n                    //\n                    // To determine if this has happened, we cycle through all of the SeleneseQueue objects,\n                    // looking for ones with a matching local frame address (e.g., top.frames[1]), is also a\n                    // pop-up, and which has a thread waiting on a result.  If all of these conditions hold,\n                    // then we figure this queue is the one that we want:\n                    if (f.getLocalFrameAddress().equals(frameAddress.getLocalFrameAddress())\n                            && !f.getWindowName().equals(DEFAULT_SELENIUM_WINDOW_NAME)\n                            && frameAddressToSeleneseQueue.get(f).getCommandResultHolder().hasBlockedGetter()) {\n                        frameAddress = f;\n                        foundFrameAddressOfUnknownPopup = true;\n                        break;\n                    }\n                }\n                if (!foundFrameAddressOfUnknownPopup) {\n                    SeleniumServer.log(\"WARNING: unknown popup \" + frameAddress + \" was not resolved\");\n                }\n            }\n            queue = getSeleneseQueue(frameAddress);\n        }\n        queue.setUniqueId(uniqueId);\n        return queue.handleCommandResult(commandResult);\n    }\n",
    "new_code_raw": "    public SeleneseCommand handleCommandResult(String commandResult, FrameAddress incomingFrameAddress, String uniqueId) {\n        SeleneseQueue queue;\n        if (!SeleniumServer.isProxyInjectionMode()) {\n            queue = getSeleneseQueue();\n        }\n        else {\n            if (incomingFrameAddress.getWindowName().equals(SELENIUM_WINDOW_NAME_UNKNOWN_POPUP)) {\n                boolean foundFrameAddressOfUnknownPopup = false;\n                for (FrameAddress knownFrameAddress : frameAddressToSeleneseQueue.keySet()) {\n                    // the situation being handled here: a pop-up window has either just loaded or reloaded, and therefore\n                    // doesn't know its name.  It uses SELENIUM_WINDOW_NAME_UNKNOWN_POPUP as a placeholder.\n                    // Meanwhile, on the selenium server-side, a thread is waiting for this result.\n                    //\n                    // To determine if this has happened, we cycle through all of the SeleneseQueue objects,\n                    // looking for ones with a matching local frame address (e.g., top.frames[1]), is also a\n                    // pop-up, and which has a thread waiting on a result.  If all of these conditions hold,\n                    // then we figure this queue is the one that we want:\n                    if (knownFrameAddress.getLocalFrameAddress().equals(incomingFrameAddress.getLocalFrameAddress())\n                            && !knownFrameAddress.getWindowName().equals(DEFAULT_SELENIUM_WINDOW_NAME)\n                            && frameAddressToSeleneseQueue.get(knownFrameAddress).getCommandResultHolder().hasBlockedGetter()) {\n                        incomingFrameAddress = knownFrameAddress;\n                        foundFrameAddressOfUnknownPopup = true;\n                        break;\n                    }\n                }\n                if (!foundFrameAddressOfUnknownPopup) {\n                    SeleniumServer.log(\"WARNING: unknown popup \" + incomingFrameAddress + \" was not resolved\");\n                }\n            }\n            queue = getSeleneseQueue(incomingFrameAddress);\n        }\n        queue.setUniqueId(uniqueId);\n        return queue.handleCommandResult(commandResult);\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-1188-Param-2",
    "old_comment_raw": "@param matches the number of matches expected to be found.  0 matches means that one or more matches are expected to be found",
    "old_code_raw": "\tpublic boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int matches, boolean scroll) {\n\t\tfinal long endTime = System.currentTimeMillis() + TIMEOUT;\n\n\t\twhile (System.currentTimeMillis() < endTime) {\n\t\t\tsleeper.sleep();\n\t\t\tfinal boolean foundAnyMatchingView = searchFor(viewClass, regex, matches, scroll);\n\t\t\tif (foundAnyMatchingView){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n",
    "new_code_raw": "\tpublic boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll) {\n\t\tfinal long endTime = System.currentTimeMillis() + TIMEOUT;\n\n\t\twhile (System.currentTimeMillis() < endTime) {\n\t\t\tsleeper.sleep();\n\t\t\tfinal boolean foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, scroll);\n\t\t\tif (foundAnyMatchingView){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n"
  },
  {
    "id": "graphql_java_graphql_java-378-Param-0",
    "old_comment_raw": "@param parameters the parameters to this method",
    "old_code_raw": "    public MergedSelectionSet collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet) {\n        Map<String, MergedFields> subFields = new LinkedHashMap<>();\n        List<String> visitedFragments = new ArrayList<>();\n        this.collectFields(parameters, selectionSet, visitedFragments, subFields);\n        return newMergedSelectionSet().subFields(subFields).build();\n    }\n",
    "new_code_raw": "    private void collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet, List<String> visitedFragments, Map<String, List<Field>> fields) {\n\n        for (Selection selection : selectionSet.getSelections()) {\n            if (selection instanceof Field) {\n                collectField(parameters, fields, (Field) selection);\n            } else if (selection instanceof InlineFragment) {\n                collectInlineFragment(parameters, visitedFragments, fields, (InlineFragment) selection);\n            } else if (selection instanceof FragmentSpread) {\n                collectFragmentSpread(parameters, visitedFragments, fields, (FragmentSpread) selection);\n            }\n        }\n    }\n"
  },
  {
    "id": "apache_calcite-942-Param-0",
    "old_comment_raw": "@param project ProjectRel on the LHS of the semijoin",
    "old_code_raw": "  private RexNode adjustCondition(ProjectRel project, SemiJoinRel semiJoin) {\n    // create two RexPrograms -- the bottom one representing a\n    // concatenation of the project and the RHS of the semijoin and the\n    // top one representing the semijoin condition\n\n    RexBuilder rexBuilder = project.getCluster().getRexBuilder();\n    RelDataTypeFactory typeFactory = rexBuilder.getTypeFactory();\n    RelNode rightChild = semiJoin.getRight();\n\n    // for the bottom RexProgram, the input is a concatenation of the\n    // child of the project and the RHS of the semijoin\n    RelDataType bottomInputRowType =\n        JoinRelBase.deriveJoinRowType(\n            project.getChild().getRowType(),\n            rightChild.getRowType(),\n            JoinRelType.INNER,\n            typeFactory,\n            null,\n            semiJoin.getSystemFieldList());\n    RexProgramBuilder bottomProgramBuilder =\n        new RexProgramBuilder(bottomInputRowType, rexBuilder);\n\n    // add the project expressions, then add input references for the RHS\n    // of the semijoin\n    for (Pair<RexNode, String> pair : project.getNamedProjects()) {\n      bottomProgramBuilder.addProject(pair.left, pair.right);\n    }\n    int nLeftFields = project.getChild().getRowType().getFieldCount();\n    List<RelDataTypeField> rightFields =\n        rightChild.getRowType().getFieldList();\n    int nRightFields = rightFields.size();\n    for (int i = 0; i < nRightFields; i++) {\n      final RelDataTypeField field = rightFields.get(i);\n      RexNode inputRef =\n          rexBuilder.makeInputRef(\n              field.getType(), i + nLeftFields);\n      bottomProgramBuilder.addProject(inputRef, field.getName());\n    }\n    RexProgram bottomProgram = bottomProgramBuilder.getProgram();\n\n    // input rowtype into the top program is the concatenation of the\n    // project and the RHS of the semijoin\n    RelDataType topInputRowType =\n        JoinRelBase.deriveJoinRowType(\n            project.getRowType(),\n            rightChild.getRowType(),\n            JoinRelType.INNER,\n            typeFactory,\n            null,\n            semiJoin.getSystemFieldList());\n    RexProgramBuilder topProgramBuilder =\n        new RexProgramBuilder(\n            topInputRowType,\n            rexBuilder);\n    topProgramBuilder.addIdentity();\n    topProgramBuilder.addCondition(semiJoin.getCondition());\n    RexProgram topProgram = topProgramBuilder.getProgram();\n\n    // merge the programs and expand out the local references to form\n    // the new semijoin condition; it now references a concatenation of\n    // the project's child and the RHS of the semijoin\n    RexProgram mergedProgram =\n        RexProgramBuilder.mergePrograms(\n            topProgram,\n            bottomProgram,\n            rexBuilder);\n\n    return mergedProgram.expandLocalRef(\n        mergedProgram.getCondition());\n  }\n",
    "new_code_raw": "  private RexNode adjustCondition(LogicalProject project, SemiJoin semiJoin) {\n    // create two RexPrograms -- the bottom one representing a\n    // concatenation of the project and the RHS of the semijoin and the\n    // top one representing the semijoin condition\n\n    RexBuilder rexBuilder = project.getCluster().getRexBuilder();\n    RelDataTypeFactory typeFactory = rexBuilder.getTypeFactory();\n    RelNode rightChild = semiJoin.getRight();\n\n    // for the bottom RexProgram, the input is a concatenation of the\n    // child of the project and the RHS of the semijoin\n    RelDataType bottomInputRowType =\n        Join.deriveJoinRowType(\n            project.getInput().getRowType(),\n            rightChild.getRowType(),\n            JoinRelType.INNER,\n            typeFactory,\n            null,\n            semiJoin.getSystemFieldList());\n    RexProgramBuilder bottomProgramBuilder =\n        new RexProgramBuilder(bottomInputRowType, rexBuilder);\n\n    // add the project expressions, then add input references for the RHS\n    // of the semijoin\n    for (Pair<RexNode, String> pair : project.getNamedProjects()) {\n      bottomProgramBuilder.addProject(pair.left, pair.right);\n    }\n    int nLeftFields = project.getInput().getRowType().getFieldCount();\n    List<RelDataTypeField> rightFields =\n        rightChild.getRowType().getFieldList();\n    int nRightFields = rightFields.size();\n    for (int i = 0; i < nRightFields; i++) {\n      final RelDataTypeField field = rightFields.get(i);\n      RexNode inputRef =\n          rexBuilder.makeInputRef(\n              field.getType(), i + nLeftFields);\n      bottomProgramBuilder.addProject(inputRef, field.getName());\n    }\n    RexProgram bottomProgram = bottomProgramBuilder.getProgram();\n\n    // input rowtype into the top program is the concatenation of the\n    // project and the RHS of the semijoin\n    RelDataType topInputRowType =\n        Join.deriveJoinRowType(\n            project.getRowType(),\n            rightChild.getRowType(),\n            JoinRelType.INNER,\n            typeFactory,\n            null,\n            semiJoin.getSystemFieldList());\n    RexProgramBuilder topProgramBuilder =\n        new RexProgramBuilder(\n            topInputRowType,\n            rexBuilder);\n    topProgramBuilder.addIdentity();\n    topProgramBuilder.addCondition(semiJoin.getCondition());\n    RexProgram topProgram = topProgramBuilder.getProgram();\n\n    // merge the programs and expand out the local references to form\n    // the new semijoin condition; it now references a concatenation of\n    // the project's child and the RHS of the semijoin\n    RexProgram mergedProgram =\n        RexProgramBuilder.mergePrograms(\n            topProgram,\n            bottomProgram,\n            rexBuilder);\n\n    return mergedProgram.expandLocalRef(\n        mergedProgram.getCondition());\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-183-Param-8",
    "old_comment_raw": "@param authNames The authentications to apply",
    "old_code_raw": "  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n",
    "new_code_raw": "  public String invokeAPI(String path, String method, Set<QueryParam> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (QueryParam queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-309-Param-0",
    "old_comment_raw": "@param mappings list of  XMLEntityMappings created from the specified orm xml files",
    "old_code_raw": "\tpublic Index parseAndUpdateIndex(List<JaxbRoot<XMLEntityMappings>> mappings, Index annotationIndex) {\n\t\tfor ( JaxbRoot<XMLEntityMappings> root : mappings ) {\n\t\t\troot.getRoot().toString();\n\t\t}\n\t\treturn annotationIndex;\n\t}\n",
    "new_code_raw": "\tpublic Index parseAndUpdateIndex(Set<String> mappingFileNames, Index annotationIndex) {\n\t\tClassLoaderService classLoaderService = meta.getServiceRegistry().getService( ClassLoaderService.class );\n\t\tSet<InputStream> mappingStreams = new HashSet<InputStream>();\n\t\tfor ( String fileName : mappingFileNames ) {\n\n\t\t\tEntityMappings entityMappings;\n\t\t\ttry {\n\t\t\t\tentityMappings = XmlHelper.unmarshallXml(\n\t\t\t\t\t\tfileName, ORM2_MAPPING_XSD, EntityMappings.class, classLoaderService\n\t\t\t\t).getRoot();\n\t\t\t}\n\t\t\tcatch ( JAXBException orm2Exception ) {\n\t\t\t\t// if we cannot parse against orm_2_0.xsd we try orm_1_0.xsd for backwards compatibility\n\t\t\t\ttry {\n\t\t\t\t\tentityMappings = XmlHelper.unmarshallXml(\n\t\t\t\t\t\t\tfileName, ORM1_MAPPING_XSD, EntityMappings.class, classLoaderService\n\t\t\t\t\t).getRoot();\n\t\t\t\t}\n\t\t\t\tcatch ( JAXBException orm1Exception ) {\n\t\t\t\t\tthrow new AnnotationException( \"Unable to parse xml configuration.\", orm1Exception );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentityMappings.toString();\n\t\t}\n\n\t\treturn null;\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1058-Param-0",
    "old_comment_raw": "@param swagger The base object containing the global description through \"Info\" class",
    "old_code_raw": "    private void preparHtmlForGlobalDescription(Swagger swagger) {\n        String currentDescription = swagger.getInfo().getDescription();\n        if (currentDescription != null && !currentDescription.isEmpty()) {\n            Markdown markInstance = new Markdown();\n            swagger.getInfo().setDescription( markInstance.toHtml(currentDescription) );\n        } else {\n            LOGGER.error(\"Swagger object description is empty [\" + swagger.getInfo().getTitle() + \"]\");\n        }\n    }\n",
    "new_code_raw": "    private void preparHtmlForGlobalDescription(OpenAPI openAPI) {\n        if (openAPI.getInfo() == null) {\n            return;\n        }\n\n        String currentDescription = openAPI.getInfo().getDescription();\n        if (currentDescription != null && !currentDescription.isEmpty()) {\n            Markdown markInstance = new Markdown();\n            openAPI.getInfo().setDescription( markInstance.toHtml(currentDescription) );\n        } else {\n            LOGGER.error(\"OpenAPI object description is empty [\" + openAPI.getInfo().getTitle() + \"]\");\n        }\n    }\n"
  },
  {
    "id": "apache_activemq-1306-Param-0",
    "old_comment_raw": "@param msg",
    "old_code_raw": "    public ProtonJMessage convert(Message msg) throws JMSException, UnsupportedEncodingException {\n        Header header = new Header();\n        Properties props = new Properties();\n        HashMap<Symbol, Object> daMap = null;\n        HashMap<Symbol, Object> maMap = null;\n        HashMap apMap = null;\n        Section body = null;\n        HashMap footerMap = null;\n        if (msg instanceof BytesMessage) {\n            BytesMessage m = (BytesMessage) msg;\n            byte data[] = new byte[(int) m.getBodyLength()];\n            m.readBytes(data);\n            m.reset(); // Need to reset after readBytes or future readBytes\n                       // calls (ex: redeliveries) will fail and return -1\n            body = new Data(new Binary(data));\n        }\n        if (msg instanceof TextMessage) {\n            body = new AmqpValue(((TextMessage) msg).getText());\n        }\n        if (msg instanceof MapMessage) {\n            final HashMap<String, Object> map = new HashMap<String, Object>();\n            final MapMessage m = (MapMessage) msg;\n            final Enumeration<String> names = m.getMapNames();\n            while (names.hasMoreElements()) {\n                String key = names.nextElement();\n                map.put(key, m.getObject(key));\n            }\n            body = new AmqpValue(map);\n        }\n        if (msg instanceof StreamMessage) {\n            ArrayList<Object> list = new ArrayList<Object>();\n            final StreamMessage m = (StreamMessage) msg;\n            try {\n                while (true) {\n                    list.add(m.readObject());\n                }\n            } catch (MessageEOFException e) {\n            }\n            body = new AmqpSequence(list);\n        }\n        if (msg instanceof ObjectMessage) {\n            body = new AmqpValue(((ObjectMessage) msg).getObject());\n        }\n\n        header.setDurable(msg.getJMSDeliveryMode() == DeliveryMode.PERSISTENT ? true : false);\n        header.setPriority(new UnsignedByte((byte) msg.getJMSPriority()));\n        if (msg.getJMSType() != null) {\n            props.setSubject(msg.getJMSType());\n        }\n        if (msg.getJMSMessageID() != null) {\n            ActiveMQMessage amqMsg = (ActiveMQMessage) msg;\n\n            MessageId msgId = amqMsg.getMessageId();\n            if (msgId.getTextView() != null) {\n                try {\n                    props.setMessageId(AMQPMessageIdHelper.INSTANCE.toIdObject(msgId.getTextView()));\n                } catch (AmqpProtocolException e) {\n                    props.setMessageId(msgId.getTextView().toString());\n                }\n            } else {\n                props.setMessageId(msgId.toString());\n            }\n        }\n        if (msg.getJMSDestination() != null) {\n            props.setTo(vendor.toAddress(msg.getJMSDestination()));\n            if (maMap == null) {\n                maMap = new HashMap<Symbol, Object>();\n            }\n            maMap.put(JMS_DEST_TYPE_MSG_ANNOTATION, destinationType(msg.getJMSDestination()));\n\n            // Deprecated: used by legacy QPid AMQP 1.0 JMS client\n            maMap.put(LEGACY_JMS_DEST_TYPE_MSG_ANNOTATION, destinationAttributes(msg.getJMSDestination()));\n        }\n        if (msg.getJMSReplyTo() != null) {\n            props.setReplyTo(vendor.toAddress(msg.getJMSReplyTo()));\n            if (maMap == null) {\n                maMap = new HashMap<Symbol, Object>();\n            }\n            maMap.put(JMS_REPLY_TO_TYPE_MSG_ANNOTATION, destinationType(msg.getJMSReplyTo()));\n\n            // Deprecated: used by legacy QPid AMQP 1.0 JMS client\n            maMap.put(LEGACY_JMS_REPLY_TO_TYPE_MSG_ANNOTATION, destinationAttributes(msg.getJMSReplyTo()));\n        }\n        if (msg.getJMSCorrelationID() != null) {\n            String correlationId = msg.getJMSCorrelationID();\n            try {\n                props.setCorrelationId(AMQPMessageIdHelper.INSTANCE.toIdObject(correlationId));\n            } catch (AmqpProtocolException e) {\n                props.setCorrelationId(correlationId);\n            }\n        }\n        if (msg.getJMSExpiration() != 0) {\n            long ttl = msg.getJMSExpiration() - System.currentTimeMillis();\n            if (ttl < 0) {\n                ttl = 1;\n            }\n            header.setTtl(new UnsignedInteger((int) ttl));\n\n            props.setAbsoluteExpiryTime(new Date(msg.getJMSExpiration()));\n        }\n        if (msg.getJMSTimestamp() != 0) {\n            props.setCreationTime(new Date(msg.getJMSTimestamp()));\n        }\n\n        final Enumeration<String> keys = msg.getPropertyNames();\n        while (keys.hasMoreElements()) {\n            String key = keys.nextElement();\n            if (key.equals(messageFormatKey) || key.equals(nativeKey)) {\n                // skip..\n            } else if (key.equals(firstAcquirerKey)) {\n                header.setFirstAcquirer(msg.getBooleanProperty(key));\n            } else if (key.startsWith(\"JMSXDeliveryCount\")) {\n                // The AMQP delivery-count field only includes prior failed delivery attempts,\n                // whereas JMSXDeliveryCount includes the first/current delivery attempt.\n                int amqpDeliveryCount = msg.getIntProperty(key) - 1;\n                if (amqpDeliveryCount > 0) {\n                    header.setDeliveryCount(new UnsignedInteger(amqpDeliveryCount));\n                }\n            } else if (key.startsWith(\"JMSXUserID\")) {\n                String value = msg.getStringProperty(key);\n                props.setUserId(new Binary(value.getBytes(\"UTF-8\")));\n            } else if (key.startsWith(\"JMSXGroupID\")) {\n                String value = msg.getStringProperty(key);\n                props.setGroupId(value);\n                if (apMap == null) {\n                    apMap = new HashMap();\n                }\n                apMap.put(key, value);\n            } else if (key.startsWith(\"JMSXGroupSeq\")) {\n                UnsignedInteger value = new UnsignedInteger(msg.getIntProperty(key));\n                props.setGroupSequence(value);\n                if (apMap == null) {\n                    apMap = new HashMap();\n                }\n                apMap.put(key, value);\n            } else if (key.startsWith(prefixDeliveryAnnotationsKey)) {\n                if (daMap == null) {\n                    daMap = new HashMap<Symbol, Object>();\n                }\n                String name = key.substring(prefixDeliveryAnnotationsKey.length());\n                daMap.put(Symbol.valueOf(name), msg.getObjectProperty(key));\n            } else if (key.startsWith(prefixMessageAnnotationsKey)) {\n                if (maMap == null) {\n                    maMap = new HashMap<Symbol, Object>();\n                }\n                String name = key.substring(prefixMessageAnnotationsKey.length());\n                maMap.put(Symbol.valueOf(name), msg.getObjectProperty(key));\n            } else if (key.equals(contentTypeKey)) {\n                props.setContentType(Symbol.getSymbol(msg.getStringProperty(key)));\n            } else if (key.equals(contentEncodingKey)) {\n                props.setContentEncoding(Symbol.getSymbol(msg.getStringProperty(key)));\n            } else if (key.equals(replyToGroupIDKey)) {\n                props.setReplyToGroupId(msg.getStringProperty(key));\n            } else if (key.startsWith(prefixFooterKey)) {\n                if (footerMap == null) {\n                    footerMap = new HashMap();\n                }\n                String name = key.substring(prefixFooterKey.length());\n                footerMap.put(name, msg.getObjectProperty(key));\n            } else {\n                if (apMap == null) {\n                    apMap = new HashMap();\n                }\n                apMap.put(key, msg.getObjectProperty(key));\n            }\n        }\n\n        MessageAnnotations ma = null;\n        if (maMap != null) {\n            ma = new MessageAnnotations(maMap);\n        }\n        DeliveryAnnotations da = null;\n        if (daMap != null) {\n            da = new DeliveryAnnotations(daMap);\n        }\n        ApplicationProperties ap = null;\n        if (apMap != null) {\n            ap = new ApplicationProperties(apMap);\n        }\n        Footer footer = null;\n        if (footerMap != null) {\n            footer = new Footer(footerMap);\n        }\n\n        return (ProtonJMessage) org.apache.qpid.proton.message.Message.Factory.create(header, da, ma, props, ap, body, footer);\n    }\n",
    "new_code_raw": "    public ProtonJMessage convert(Message message) throws JMSException, UnsupportedEncodingException {\n        Header header = new Header();\n        Properties props = new Properties();\n\n        Map<Symbol, Object> daMap = null;\n        Map<Symbol, Object> maMap = null;\n        Map<String,Object> apMap = null;\n        Map<Object, Object> footerMap = null;\n        Section body = null;\n\n        body = convertBody(message);\n\n        header.setDurable(message.getJMSDeliveryMode() == DeliveryMode.PERSISTENT ? true : false);\n        header.setPriority(new UnsignedByte((byte) message.getJMSPriority()));\n        if (message.getJMSType() != null) {\n            props.setSubject(message.getJMSType());\n        }\n        if (message.getJMSMessageID() != null) {\n            props.setMessageId(vendor.getOriginalMessageId(message));\n        }\n        if (message.getJMSDestination() != null) {\n            props.setTo(vendor.toAddress(message.getJMSDestination()));\n            if (maMap == null) {\n                maMap = new HashMap<Symbol, Object>();\n            }\n            maMap.put(JMS_DEST_TYPE_MSG_ANNOTATION, destinationType(message.getJMSDestination()));\n\n            // Deprecated: used by legacy QPid AMQP 1.0 JMS client\n            maMap.put(LEGACY_JMS_DEST_TYPE_MSG_ANNOTATION, destinationAttributes(message.getJMSDestination()));\n        }\n        if (message.getJMSReplyTo() != null) {\n            props.setReplyTo(vendor.toAddress(message.getJMSReplyTo()));\n            if (maMap == null) {\n                maMap = new HashMap<Symbol, Object>();\n            }\n            maMap.put(JMS_REPLY_TO_TYPE_MSG_ANNOTATION, destinationType(message.getJMSReplyTo()));\n\n            // Deprecated: used by legacy QPid AMQP 1.0 JMS client\n            maMap.put(LEGACY_JMS_REPLY_TO_TYPE_MSG_ANNOTATION, destinationAttributes(message.getJMSReplyTo()));\n        }\n        if (message.getJMSCorrelationID() != null) {\n            String correlationId = message.getJMSCorrelationID();\n            try {\n                props.setCorrelationId(AMQPMessageIdHelper.INSTANCE.toIdObject(correlationId));\n            } catch (AmqpProtocolException e) {\n                props.setCorrelationId(correlationId);\n            }\n        }\n        if (message.getJMSExpiration() != 0) {\n            long ttl = message.getJMSExpiration() - System.currentTimeMillis();\n            if (ttl < 0) {\n                ttl = 1;\n            }\n            header.setTtl(new UnsignedInteger((int) ttl));\n\n            props.setAbsoluteExpiryTime(new Date(message.getJMSExpiration()));\n        }\n        if (message.getJMSTimestamp() != 0) {\n            props.setCreationTime(new Date(message.getJMSTimestamp()));\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final Enumeration<String> keys = message.getPropertyNames();\n\n        while (keys.hasMoreElements()) {\n            String key = keys.nextElement();\n            if (key.equals(messageFormatKey) || key.equals(nativeKey) || key.equals(AMQP_ORIGINAL_ENCODING_KEY)) {\n                // skip transformer appended properties\n            } else if (key.equals(firstAcquirerKey)) {\n                header.setFirstAcquirer(message.getBooleanProperty(key));\n            } else if (key.startsWith(\"JMSXDeliveryCount\")) {\n                // The AMQP delivery-count field only includes prior failed delivery attempts,\n                // whereas JMSXDeliveryCount includes the first/current delivery attempt.\n                int amqpDeliveryCount = message.getIntProperty(key) - 1;\n                if (amqpDeliveryCount > 0) {\n                    header.setDeliveryCount(new UnsignedInteger(amqpDeliveryCount));\n                }\n            } else if (key.startsWith(\"JMSXUserID\")) {\n                String value = message.getStringProperty(key);\n                props.setUserId(new Binary(value.getBytes(\"UTF-8\")));\n            } else if (key.startsWith(\"JMSXGroupID\")) {\n                String value = message.getStringProperty(key);\n                props.setGroupId(value);\n                if (apMap == null) {\n                    apMap = new HashMap<String, Object>();\n                }\n                apMap.put(key, value);\n            } else if (key.startsWith(\"JMSXGroupSeq\")) {\n                UnsignedInteger value = new UnsignedInteger(message.getIntProperty(key));\n                props.setGroupSequence(value);\n                if (apMap == null) {\n                    apMap = new HashMap<String, Object>();\n                }\n                apMap.put(key, value);\n            } else if (key.startsWith(prefixDeliveryAnnotationsKey)) {\n                if (daMap == null) {\n                    daMap = new HashMap<Symbol, Object>();\n                }\n                String name = key.substring(prefixDeliveryAnnotationsKey.length());\n                daMap.put(Symbol.valueOf(name), message.getObjectProperty(key));\n            } else if (key.startsWith(prefixMessageAnnotationsKey)) {\n                if (maMap == null) {\n                    maMap = new HashMap<Symbol, Object>();\n                }\n                String name = key.substring(prefixMessageAnnotationsKey.length());\n                maMap.put(Symbol.valueOf(name), message.getObjectProperty(key));\n            } else if (key.equals(contentTypeKey)) {\n                props.setContentType(Symbol.getSymbol(message.getStringProperty(key)));\n            } else if (key.equals(contentEncodingKey)) {\n                props.setContentEncoding(Symbol.getSymbol(message.getStringProperty(key)));\n            } else if (key.equals(replyToGroupIDKey)) {\n                props.setReplyToGroupId(message.getStringProperty(key));\n            } else if (key.startsWith(prefixFooterKey)) {\n                if (footerMap == null) {\n                    footerMap = new HashMap<Object, Object>();\n                }\n                String name = key.substring(prefixFooterKey.length());\n                footerMap.put(name, message.getObjectProperty(key));\n            } else {\n                if (apMap == null) {\n                    apMap = new HashMap<String, Object>();\n                }\n                apMap.put(key, message.getObjectProperty(key));\n            }\n        }\n\n        MessageAnnotations ma = null;\n        if (maMap != null) {\n            ma = new MessageAnnotations(maMap);\n        }\n        DeliveryAnnotations da = null;\n        if (daMap != null) {\n            da = new DeliveryAnnotations(daMap);\n        }\n        ApplicationProperties ap = null;\n        if (apMap != null) {\n            ap = new ApplicationProperties(apMap);\n        }\n        Footer footer = null;\n        if (footerMap != null) {\n            footer = new Footer(footerMap);\n        }\n\n        return (ProtonJMessage) org.apache.qpid.proton.message.Message.Factory.create(header, da, ma, props, ap, body, footer);\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-824-Param-0",
    "old_comment_raw": "@param constituentsSet set of constituents to add results of bracketing this tree to",
    "old_code_raw": "  private int constituents(Set<Constituent> constituentsSet, int left, ConstituentFactory cf, boolean charLevel, Filter<Tree> filter, int maxDepth, int depth) {\n\n    if(isPreTerminal())\n      return left + ((charLevel) ? firstChild().value().length() : 1);\n\n    int position = left;\n\n    // System.err.println(\"In bracketing trees left is \" + left);\n    // System.err.println(\"  label is \" + label() +\n    //                       \"; num daughters: \" + children().length);\n    Tree[] kids = children();\n    for (Tree kid : kids) {\n      position = kid.constituents(constituentsSet, position, cf, charLevel, filter, maxDepth, depth + 1);\n      // System.err.println(\"  position went to \" + position);\n    }\n\n    if ((filter == null || filter.accept(this)) &&\n        (maxDepth < 0 || depth <= maxDepth)) {\n      //Compute span of entire tree at the end of recursion\n      constituentsSet.add(cf.newConstituent(left, position - 1, label(), score()));\n    }\n    // System.err.println(\"  added \" + label());\n    return position;\n  }\n",
    "new_code_raw": "  private int constituents(Set<Constituent> constituentsSet, int left, ConstituentFactory cf, boolean charLevel, Predicate<Tree> filter, int maxDepth, int depth) {\n\n    if(isPreTerminal())\n      return left + ((charLevel) ? firstChild().value().length() : 1);\n\n    int position = left;\n\n    // System.err.println(\"In bracketing trees left is \" + left);\n    // System.err.println(\"  label is \" + label() +\n    //                       \"; num daughters: \" + children().length);\n    Tree[] kids = children();\n    for (Tree kid : kids) {\n      position = kid.constituents(constituentsSet, position, cf, charLevel, filter, maxDepth, depth + 1);\n      // System.err.println(\"  position went to \" + position);\n    }\n\n    if ((filter == null || filter.test(this)) &&\n        (maxDepth < 0 || depth <= maxDepth)) {\n      //Compute span of entire tree at the end of recursion\n      constituentsSet.add(cf.newConstituent(left, position - 1, label(), score()));\n    }\n    // System.err.println(\"  added \" + label());\n    return position;\n  }\n"
  },
  {
    "id": "RobotiumTech_robotium-1485-Param-0",
    "old_comment_raw": "@param search the string to be searched. The parameter will be interpreted as a regular expression.",
    "old_code_raw": "\tprivate boolean searchForButton(String search, int matches) {\n\t\tsleeper.sleep();\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(search);\n\t\tMatcher matcher;\n\t\tArrayList<Button> buttonList = viewFetcher.getCurrentViews(Button.class);\n\t\tif(matches == 0)\n\t\t\tmatches = 1;\n\t\tfor(Button button : buttonList){\n\t\t\tmatcher = p.matcher(button.getText().toString());\n\t\t\tif(matcher.find()){\t\n\t\t\t\tcountMatches++;\n\t\t\t}\n\t\t\tif (countMatches == matches) {\n\t\t\t\tcountMatches = 0;\n\t\t\t\treturn true;\n\t\t\t} \t\n\t\t}\n\n\t\tif (scroller.scroll(Scroller.Direction.DOWN))\n\t\t{\n\t\t\treturn searchForButton(search, matches);\n\t\t} else {\n\t\t\tif (countMatches > 0)\n\t\t\t\tLog.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + search);\n\t\t\tcountMatches = 0;\n\t\t\treturn false;\n\t\t}\n\n\t}\n",
    "new_code_raw": "\tprivate boolean searchForButton(String regex, int matches) {\n\t\tsleeper.sleep();\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(regex);\n\t\tMatcher matcher;\n\t\tArrayList<Button> buttonList = viewFetcher.getCurrentViews(Button.class);\n\t\tif(matches == 0)\n\t\t\tmatches = 1;\n\t\tfor(Button button : buttonList){\n\t\t\tmatcher = p.matcher(button.getText().toString());\n\t\t\tif(matcher.find()){\t\n\t\t\t\tcountMatches++;\n\t\t\t}\n\t\t\tif (countMatches == matches) {\n\t\t\t\tcountMatches = 0;\n\t\t\t\treturn true;\n\t\t\t} \t\n\t\t}\n\n\t\tif (scroller.scroll(Scroller.Direction.DOWN))\n\t\t{\n\t\t\treturn searchForButton(regex, matches);\n\t\t} else {\n\t\t\tif (countMatches > 0)\n\t\t\t\tLog.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + regex);\n\t\t\tcountMatches = 0;\n\t\t\treturn false;\n\t\t}\n\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1639-Param-0",
    "old_comment_raw": "@param username name that need to be deleted",
    "old_code_raw": "  public void updateUser (String username, User body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = body;\n    // verify the required parameter 'username' is set\n    if (username == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'username' when calling updateUser\",\n        new ApiException(400, \"Missing the required parameter 'username' when calling updateUser\"));\n    }\n    // verify the required parameter 'body' is set\n    if (body == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'body' when calling updateUser\",\n        new ApiException(400, \"Missing the required parameter 'body' when calling updateUser\"));\n    }\n\n    // create path and map variables\n    String path = \"/user/{username}\".replaceAll(\"\\\\{\" + \"username\" + \"\\\\}\", apiInvoker.escapeString(username.toString()));\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n    }\n\n    String[] authNames = new String[] {  };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"PUT\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n",
    "new_code_raw": "  public void updateUser (String username, User user) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = user;\n    // verify the required parameter 'username' is set\n    if (username == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'username' when calling updateUser\",\n        new ApiException(400, \"Missing the required parameter 'username' when calling updateUser\"));\n    }\n    // verify the required parameter 'user' is set\n    if (user == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'user' when calling updateUser\",\n        new ApiException(400, \"Missing the required parameter 'user' when calling updateUser\"));\n    }\n\n    // create path and map variables\n    String path = \"/user/{username}\".replaceAll(\"\\\\{\" + \"username\" + \"\\\\}\", apiInvoker.escapeString(username.toString()));\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n      \"application/json\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n    }\n\n    String[] authNames = new String[] {  };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"PUT\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-333-Param-0",
    "old_comment_raw": "@param params The params supplied in the generator config (plus some standard useful extras).",
    "old_code_raw": "\tprotected QualifiedName determineGeneratorTableName(Properties params, Dialect dialect) {\n\t\tfinal ObjectNameNormalizer normalizer = (ObjectNameNormalizer) params.get( IDENTIFIER_NORMALIZER );\n\n\t\treturn QualifiedNameParser.INSTANCE.parse(\n\t\t\t\tConfigurationHelper.getString( TABLE_PARAM, params, DEF_TABLE ),\n\t\t\t\tnormalizer.normalizeIdentifierQuoting( params.getProperty( CATALOG ) ),\n\t\t\t\tnormalizer.normalizeIdentifierQuoting( params.getProperty( SCHEMA ) )\n\t\t);\n\t}\n",
    "new_code_raw": "\tprotected QualifiedName determineGeneratorTableName(Properties params, JdbcEnvironment jdbcEnvironment) {\n\t\tfinal String tableName = ConfigurationHelper.getString( TABLE_PARAM, params, DEF_TABLE );\n\n\t\tif ( tableName.contains( \".\" ) ) {\n\t\t\treturn QualifiedNameParser.INSTANCE.parse( tableName );\n\t\t}\n\t\telse {\n\t\t\t// todo : need to incorporate implicit catalog and schema names\n\t\t\tfinal Identifier catalog = jdbcEnvironment.getIdentifierHelper().toIdentifier(\n\t\t\t\t\tConfigurationHelper.getString( CATALOG, params )\n\t\t\t);\n\t\t\tfinal Identifier schema = jdbcEnvironment.getIdentifierHelper().toIdentifier(\n\t\t\t\t\tConfigurationHelper.getString( SCHEMA, params )\n\t\t\t);\n\t\t\treturn new QualifiedNameParser.NameParts(\n\t\t\t\t\tcatalog,\n\t\t\t\t\tschema,\n\t\t\t\t\tjdbcEnvironment.getIdentifierHelper().toIdentifier( tableName )\n\t\t\t);\n\t\t}\n\t}\n"
  },
  {
    "id": "RobotiumTech_robotium-1182-Param-0",
    "old_comment_raw": "@param search the string to be searched. The parameter will be interpreted as a regular expression.",
    "old_code_raw": "\tpublic boolean searchToggleButton(String search, int matches) {\n        long now = System.currentTimeMillis();\n        final long endTime = now + TIMEOUT;\n        while (!searchForToggleButton(search, matches) && now < endTime)\n        {\n        \tnow = System.currentTimeMillis();\n        }\n        if(now < endTime)\n        \treturn true;\n        else\n        \treturn false;\n\t}\n",
    "new_code_raw": "\tpublic boolean searchToggleButton(String regex, int matches) {\n        long now = System.currentTimeMillis();\n        final long endTime = now + TIMEOUT;\n        while (!searchForToggleButton(regex, matches) && now < endTime)\n        {\n        \tnow = System.currentTimeMillis();\n        }\n        if(now < endTime)\n        \treturn true;\n        else\n        \treturn false;\n\t}\n"
  },
  {
    "id": "Atmosphere_atmosphere-48-Param-1",
    "old_comment_raw": "@param object the broadcasted object.",
    "old_code_raw": "    protected BroadcastAction filter(HttpServletRequest request, Object object) {\n        BroadcastAction transformed = new BroadcastAction(object);\n        for (PerRequestBroadcastFilter mf : perRequestFilters) {\n            transformed = mf.filter(request, transformed.message());\n            if (transformed == null || transformed.action() == BroadcastAction.ACTION.ABORT) {\n                return transformed;\n            }\n        }\n        return transformed;\n    }\n",
    "new_code_raw": "    protected BroadcastAction filter(HttpServletRequest request, HttpServletResponse response, Object object) {\n        BroadcastAction transformed = new BroadcastAction(object);\n        for (PerRequestBroadcastFilter mf : perRequestFilters) {\n            transformed = mf.filter(request, response, transformed.message());\n            if (transformed == null || transformed.action() == BroadcastAction.ACTION.ABORT) {\n                return transformed;\n            }\n        }\n        return transformed;\n    }\n"
  },
  {
    "id": "dropwizard_dropwizard-35-Associations-Param0",
    "old_comment_raw": "@param name the servlet's name",
    "old_code_raw": "    public ServletRegistration.Dynamic addServlet(String name, Class<? extends Servlet> klass) {\n        final ServletHolder holder = new ServletHolder(checkNotNull(klass));\n        holder.setName(name);\n        handler.getServletHandler().addServlet(holder);\n        return holder.getRegistration();\n    }\n",
    "new_code_raw": "    public ServletBuilder addServlet(Class<? extends Servlet> klass,\n                                     String urlPattern) {\n        final ServletHolder holder = new ServletHolder(checkNotNull(klass));\n        final ServletBuilder builder = new ServletBuilder(holder, handler);\n        builder.addUrlPattern(checkNotNull(urlPattern));\n        return builder;\n    }\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-310-Param-1",
    "old_comment_raw": "@param annotationIndex the annotation index based on scanned annotations",
    "old_code_raw": "\tpublic Index parseAndUpdateIndex(List<JaxbRoot<XMLEntityMappings>> mappings, Index annotationIndex) {\n\t\tList<XMLEntityMappings> list = new ArrayList<XMLEntityMappings>( mappings.size() );\n\t\tfor ( JaxbRoot<XMLEntityMappings> jaxbRoot : mappings ) {\n\t\t\tlist.add( jaxbRoot.getRoot() );\n\t\t}\n\t\treturn new EntityMappingsMocker(\n\t\t\t\tlist, annotationIndex, meta.getServiceRegistry()\n\t\t).mockNewIndex();\n\t}\n",
    "new_code_raw": "\tpublic Index parseAndUpdateIndex(Set<String> mappingFileNames, Index annotationIndex) {\n\t\tClassLoaderService classLoaderService = meta.getServiceRegistry().getService( ClassLoaderService.class );\n\t\tSet<InputStream> mappingStreams = new HashSet<InputStream>();\n\t\tfor ( String fileName : mappingFileNames ) {\n\n\t\t\tEntityMappings entityMappings;\n\t\t\ttry {\n\t\t\t\tentityMappings = XmlHelper.unmarshallXml(\n\t\t\t\t\t\tfileName, ORM2_MAPPING_XSD, EntityMappings.class, classLoaderService\n\t\t\t\t).getRoot();\n\t\t\t}\n\t\t\tcatch ( JAXBException orm2Exception ) {\n\t\t\t\t// if we cannot parse against orm_2_0.xsd we try orm_1_0.xsd for backwards compatibility\n\t\t\t\ttry {\n\t\t\t\t\tentityMappings = XmlHelper.unmarshallXml(\n\t\t\t\t\t\t\tfileName, ORM1_MAPPING_XSD, EntityMappings.class, classLoaderService\n\t\t\t\t\t).getRoot();\n\t\t\t\t}\n\t\t\t\tcatch ( JAXBException orm1Exception ) {\n\t\t\t\t\tthrow new AnnotationException( \"Unable to parse xml configuration.\", orm1Exception );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentityMappings.toString();\n\t\t}\n\n\t\treturn null;\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1637-Param-0",
    "old_comment_raw": "@param body List of user object",
    "old_code_raw": "  public void createUsersWithArrayInput (List<User> body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = body;\n    // verify the required parameter 'body' is set\n    if (body == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'body' when calling createUsersWithArrayInput\",\n        new ApiException(400, \"Missing the required parameter 'body' when calling createUsersWithArrayInput\"));\n    }\n\n    // create path and map variables\n    String path = \"/user/createWithArray\";\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n    }\n\n    String[] authNames = new String[] {  };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n",
    "new_code_raw": "  public void createUsersWithArrayInput (List<User> user) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = user;\n    // verify the required parameter 'user' is set\n    if (user == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'user' when calling createUsersWithArrayInput\",\n        new ApiException(400, \"Missing the required parameter 'user' when calling createUsersWithArrayInput\"));\n    }\n\n    // create path and map variables\n    String path = \"/user/createWithArray\";\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n    }\n\n    String[] authNames = new String[] {  };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n"
  },
  {
    "id": "zaproxy_zaproxy-2001-Param-0",
    "old_comment_raw": "@param url the url to start the spider scan",
    "old_code_raw": "\tprivate int scanURL(String url, User user) throws ApiException {\n\t\tlog.debug(\"API Spider scanning url: \" + url);\n\n\t\tURI startURI;\n\t\ttry {\n\t\t\t// Try to build uri\n\t\t\tstartURI = new URI(url, true);\n\t\t} catch (URIException e) {\n\t\t\tthrow new ApiException(ApiException.Type.BAD_FORMAT);\n\t\t}\n\n\t\tSiteNode startNode = Model.getSingleton().getSession().getSiteTree().findNode(startURI);\n\t\tString scheme = startURI.getScheme();\n\t\tif (scheme == null || (!scheme.equalsIgnoreCase(\"http\") && !scheme.equalsIgnoreCase(\"https\"))) {\n\t\t\tthrow new ApiException(ApiException.Type.BAD_FORMAT);\n\t\t}\n\t\tTarget target = new Target(startNode);\n\t\ttarget.setRecurse(true);\n\t\treturn extension.startScan(target.getDisplayName(), target, user, null);\n\t}\n",
    "new_code_raw": "\tprivate int scanURL(String url, User user, int maxChildren) throws ApiException {\n\t\tlog.debug(\"API Spider scanning url: \" + url);\n\n\t\tURI startURI;\n\t\ttry {\n\t\t\t// Try to build uri\n\t\t\tstartURI = new URI(url, true);\n\t\t} catch (URIException e) {\n\t\t\tthrow new ApiException(ApiException.Type.BAD_FORMAT);\n\t\t}\n\n\t\tSiteNode startNode = Model.getSingleton().getSession().getSiteTree().findNode(startURI);\n\t\tString scheme = startURI.getScheme();\n\t\tif (scheme == null || (!scheme.equalsIgnoreCase(\"http\") && !scheme.equalsIgnoreCase(\"https\"))) {\n\t\t\tthrow new ApiException(ApiException.Type.BAD_FORMAT);\n\t\t}\n\t\tTarget target = new Target(startNode);\n\t\ttarget.setRecurse(true);\n\t\t\n\t\tObject[] objs = null;\n\t\tif (maxChildren > 0) {\n    \t\t// Add the filters to filter on maximum number of children\n    \t\tMaxChildrenFetchFilter maxChildrenFetchFilter = new MaxChildrenFetchFilter();\n    \t\tmaxChildrenFetchFilter.setMaxChildren(maxChildren);\n    \t\tmaxChildrenFetchFilter.setModel(extension.getModel());\n    \t\t\n    \t\tMaxChildrenParseFilter maxChildrenParseFilter = new MaxChildrenParseFilter();\n    \t\tmaxChildrenParseFilter.setMaxChildren(maxChildren);\n    \t\tmaxChildrenParseFilter.setModel(extension.getModel());\n\t\t\tobjs = new Object[] {\n\t\t\t\t\tmaxChildrenFetchFilter,\n\t\t\t\t\tmaxChildrenParseFilter\n\t\t\t};\n\t\t}\n\t\t\n\t\treturn extension.startScan(target.getDisplayName(), target, user, objs);\n\t}\n"
  },
  {
    "id": "apache_drill-1528-Param-1",
    "old_comment_raw": "@param pos the position of the error",
    "old_code_raw": "  static String formatSQLParsingError(String sql, SqlParserPos pos) {\n    if (pos == null) {\n      return sql;\n    }\n    StringBuilder sb = new StringBuilder();\n    String[] lines = sql.split(\"\\n\");\n    for (int i = 0; i < lines.length; i++) {\n      String line = lines[i];\n      sb.append(line).append(\"\\n\");\n      if (i == (pos.getLineNum() - 1)) {\n        for (int j = 0; j < pos.getColumnNum() - 1; j++) {\n          sb.append(\" \");\n        }\n        sb.append(\"^\\n\");\n      }\n    }\n    return sb.toString();\n  }\n",
    "new_code_raw": "  static String formatSQLParsingError(String sql, DrillSqlParseException ex) {\n    final String sqlErrorMessageHeader = \"SQL Query: \";\n    final SqlParserPos pos = ex.getPos();\n\n    if (pos != null) {\n      int issueLineNumber = pos.getLineNum() - 1;  // recalculates to base 0\n      int issueColumnNumber = pos.getColumnNum() - 1;  // recalculates to base 0\n      int messageHeaderLength = sqlErrorMessageHeader.length();\n\n      // If the issue happens on the first line, header width should be calculated alongside with the sql query\n      int shiftLength = (issueLineNumber == 0) ? issueColumnNumber + messageHeaderLength : issueColumnNumber;\n\n      StringBuilder sb = new StringBuilder();\n      String[] lines = sql.split(DrillParserUtil.EOL);\n\n      for (int i = 0; i < lines.length; i++) {\n        sb.append(lines[i]);\n\n        if (i == issueLineNumber) {\n          sb\n              .append(DrillParserUtil.EOL)\n              .append(StringUtils.repeat(' ', shiftLength))\n              .append(\"^\");\n        }\n        if (i < lines.length - 1) {\n          sb.append(DrillParserUtil.EOL);\n        }\n      }\n      sql = sb.toString();\n    }\n    return sqlErrorMessageHeader + sql;\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-347-Param-0",
    "old_comment_raw": "@param path The sub-path of the HTTP URL",
    "old_code_raw": "  public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getStatusInfo() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getStatusInfo().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getStatusInfo().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n",
    "new_code_raw": "  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n"
  },
  {
    "id": "runelite_runelite-128-Param-0",
    "old_comment_raw": "@param setMessage chat message",
    "old_code_raw": "\tprivate HiscoreLookup getCorrectLookupFor(final SetMessage setMessage)\n\t{\n\t\tfinal String player;\n\t\tfinal HiscoreEndpoint ironmanStatus;\n\n\t\tif (setMessage.getType().equals(ChatMessageType.PRIVATE_MESSAGE_SENT))\n\t\t{\n\t\t\tplayer = client.getLocalPlayer().getName();\n\t\t\tironmanStatus = hiscoreEndpoint;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tplayer = sanitize(setMessage.getName());\n\n\t\t\tif (player.equals(client.getLocalPlayer().getName()))\n\t\t\t{\n\t\t\t\t// Get ironman status from for the local player\n\t\t\t\tironmanStatus = hiscoreEndpoint;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Get ironman status from their icon in chat\n\t\t\t\tironmanStatus = getHiscoreEndpointByName(setMessage.getName());\n\t\t\t}\n\t\t}\n\n\t\treturn new HiscoreLookup(player, ironmanStatus);\n\t}\n",
    "new_code_raw": "\tprivate HiscoreLookup getCorrectLookupFor(final ChatMessage chatMessage)\n\t{\n\t\tfinal String player;\n\t\tfinal HiscoreEndpoint ironmanStatus;\n\n\t\tif (chatMessage.getType().equals(ChatMessageType.PRIVATE_MESSAGE_SENT))\n\t\t{\n\t\t\tplayer = client.getLocalPlayer().getName();\n\t\t\tironmanStatus = hiscoreEndpoint;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tplayer = sanitize(chatMessage.getName());\n\n\t\t\tif (player.equals(client.getLocalPlayer().getName()))\n\t\t\t{\n\t\t\t\t// Get ironman status from for the local player\n\t\t\t\tironmanStatus = hiscoreEndpoint;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Get ironman status from their icon in chat\n\t\t\t\tironmanStatus = getHiscoreEndpointByName(chatMessage.getName());\n\t\t\t}\n\t\t}\n\n\t\treturn new HiscoreLookup(player, ironmanStatus);\n\t}\n"
  },
  {
    "id": "hibernate_hibernate_orm-321-Param-0",
    "old_comment_raw": "@param clazz The class to check.",
    "old_code_raw": "\tprivate static Method getMethod(Class<?> clazz, String methodName) {\n\t\ttry {\n\t\t\tchar string[] = methodName.toCharArray();\n\t\t\tstring[0] = Character.toUpperCase( string[0] );\n\t\t\tmethodName = new String( string );\n\t\t\ttry {\n\t\t\t\treturn clazz.getDeclaredMethod( \"get\" + methodName );\n\t\t\t}\n\t\t\tcatch ( NoSuchMethodException e ) {\n\t\t\t\treturn clazz.getDeclaredMethod( \"is\" + methodName );\n\t\t\t}\n\t\t}\n\t\tcatch ( NoSuchMethodException e ) {\n\t\t\treturn null;\n\t\t}\n\t}\n",
    "new_code_raw": "\tprivate static Method getMethod(Class<?> clazz, String attributeName) {\n\t\ttry {\n\t\t\tchar string[] = attributeName.toCharArray();\n\t\t\tstring[0] = Character.toUpperCase( string[0] );\n\t\t\tString casedAttributeName = new String( string );\n\t\t\ttry {\n\t\t\t\treturn clazz.getDeclaredMethod( \"get\" + casedAttributeName );\n\t\t\t}\n\t\t\tcatch ( NoSuchMethodException e ) {\n\t\t\t\treturn clazz.getDeclaredMethod( \"is\" + casedAttributeName );\n\t\t\t}\n\t\t}\n\t\tcatch ( NoSuchMethodException e ) {\n\t\t\treturn null;\n\t\t}\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1668-Param-0",
    "old_comment_raw": "@param body client model (required)",
    "old_code_raw": "  public Client testClientModel(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling testClientModel\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public Client testClientModel(Client client) throws ApiException {\n    Object localVarPostBody = client;\n    \n    // verify the required parameter 'client' is set\n    if (client == null) {\n      throw new ApiException(400, \"Missing the required parameter 'client' when calling testClientModel\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "apache_activemq-394-Param-0",
    "old_comment_raw": "@param clientId",
    "old_code_raw": "    public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize) {\n        return new VMPendingMessageCursor();\n    }\n",
    "new_code_raw": "    public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize, Subscription sub) {\n        return new VMPendingMessageCursor();\n    }\n"
  },
  {
    "id": "Atmosphere_atmosphere-827-Param-0",
    "old_comment_raw": "@param request the  HttpServletRequest",
    "old_code_raw": "    public Action resumed(HttpServletRequest request, HttpServletResponse response)\n            throws IOException, ServletException {\n        return action(request, response);\n    }\n",
    "new_code_raw": "    public Action resumed(AtmosphereRequest request, AtmosphereResponse response)\n            throws IOException, ServletException {\n        return action(request, response);\n    }\n"
  },
  {
    "id": "Netflix_eureka-85-Param-2",
    "old_comment_raw": "@param myPublicIP the public ip of this instance",
    "old_code_raw": "    public Collection<String> getCandidateEIPs(String myInstanceId, String myZone, String myPublicIP) {\n\n        if (myZone == null) {\n            myZone = \"us-east-1d\";\n            myPublicIP = \"us-east-1d\";\n        }\n        Collection<String> eipCandidates = (DiscoveryManager.getInstance()\n                .getEurekaClientConfig().shouldUseDnsForFetchingServiceUrls() ? getEIPsForZoneFromDNS(myZone)\n                        : getEIPsForZoneFromConfig(myZone));\n\n        if (eipCandidates == null || eipCandidates.size() == 0) {\n            throw new RuntimeException(\n                    \"Could not get any elastic ips from the EIP pool for zone :\"\n                    + myZone);\n        }\n       \n        return eipCandidates;\n    }\n",
    "new_code_raw": "    public Collection<String> getCandidateEIPs(String myInstanceId, String myZone) {\n\n        if (myZone == null) {\n            myZone = \"us-east-1d\";\n       }\n        Collection<String> eipCandidates = (DiscoveryManager.getInstance()\n                .getEurekaClientConfig().shouldUseDnsForFetchingServiceUrls() ? getEIPsForZoneFromDNS(myZone)\n                        : getEIPsForZoneFromConfig(myZone));\n\n        if (eipCandidates == null || eipCandidates.size() == 0) {\n            throw new RuntimeException(\n                    \"Could not get any elastic ips from the EIP pool for zone :\"\n                    + myZone);\n        }\n       \n        return eipCandidates;\n    }\n"
  },
  {
    "id": "Omegaphora_dalvik-546-Associations-Param0",
    "old_comment_raw": "@param v the long to examine.",
    "old_code_raw": "    public static int numberOfTrailingZeros(long v) {\n        int low = (int) v;\n        return low !=0 ? Integer.numberOfTrailingZeros(low)\n                       : 32 + Integer.numberOfTrailingZeros((int) (v >>> 32));\n    }\n",
    "new_code_raw": "    public static int numberOfTrailingZeros(long lng) {\n        return bitCount((lng & -lng) - 1);\n    }\n\n"
  },
  {
    "id": "dropwizard_dropwizard-114-Param-0",
    "old_comment_raw": "@param registry the SchemeRegistry",
    "old_code_raw": "    protected InstrumentedClientConnManager createConnectionManager(SchemeRegistry registry) {\n        final long ttl = configuration.getTimeToLive().toMilliseconds();\n        final InstrumentedClientConnManager manager =\n                new InstrumentedClientConnManager(registry, ttl, TimeUnit.MILLISECONDS);\n        manager.setDefaultMaxPerRoute(configuration.getMaxConnectionsPerRoute());\n        manager.setMaxTotal(configuration.getMaxConnections());\n        return manager;\n    }\n",
    "new_code_raw": "    protected InstrumentedClientConnManager createConnectionManager(SchemeRegistry registry, DnsResolver resolver) {\n        final long ttl = configuration.getTimeToLive().toMilliseconds();\n        final InstrumentedClientConnManager manager =\n                new InstrumentedClientConnManager(Metrics.defaultRegistry(), registry, ttl, TimeUnit.MILLISECONDS, resolver);\n        manager.setDefaultMaxPerRoute(configuration.getMaxConnectionsPerRoute());\n        manager.setMaxTotal(configuration.getMaxConnections());\n        return manager;\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-453-Param-0",
    "old_comment_raw": "@param index the index to remove",
    "old_code_raw": "    public IntervalConverter removeIntervalConverter(int index) throws SecurityException {\n        checkAlterIntervalConverters();\n        IntervalConverter[] removed = new IntervalConverter[1];\n        iIntervalConverters = iIntervalConverters.remove(index, removed);\n        return removed[0];\n    }\n",
    "new_code_raw": "    public IntervalConverter removeIntervalConverter(IntervalConverter converter)\n            throws SecurityException {\n        \n        checkAlterIntervalConverters();\n        if (converter == null) {\n            return null;\n        }\n        IntervalConverter[] removed = new IntervalConverter[1];\n        iIntervalConverters = iIntervalConverters.remove(converter, removed);\n        return removed[0];\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-416-Param-0",
    "old_comment_raw": "@param entry",
    "old_code_raw": "  private static int findStartIndex(Entry entry, List<CoreLabel> document, int searchStart, Set<String> myLabels) {\n    List<Pattern> regex = entry.regex;\n    for (int start = searchStart; start <= document.size() - regex.size(); start++) {\n      boolean failed = false;\n      for (int i = 0; i < regex.size(); i++) {\n        Pattern pattern = regex.get(i);\n        CoreLabel token = document.get(start + i);\n        String NERType = token.get(CoreAnnotations.NamedEntityTagAnnotation.class);\n        String currentType = token.get(CoreAnnotations.AnswerAnnotation.class);\n\n        if (! pattern.matcher(token.word()).matches() ||\n            currentType != null ||\n            ! (entry.overwritableTypes.contains(NERType) ||\n               myLabels.contains(NERType) ||\n               NERType.equals(\"O\"))) {\n          failed = true;\n          break;\n        }\n      }\n      if(! failed) {\n        //System.err.print(\"MATCHED REGEX:\");\n        //for(int i = start; i < start + regex.size(); i ++) System.err.print(\" \" + document.get(i).word());\n        //System.err.println();\n        return start;\n      }\n    }\n    return -1;\n  }\n",
    "new_code_raw": "  private static int findStartIndex(Entry entry, List<CoreLabel> document, int searchStart, Set<String> myLabels, boolean ignoreCase) {\n    List<Pattern> regex = entry.regex;\n    for (int start = searchStart; start <= document.size() - regex.size(); start++) {\n      boolean failed = false;\n      for (int i = 0; i < regex.size(); i++) {\n        Pattern pattern = regex.get(i);\n        String exact = entry.exact.get(i);\n        CoreLabel token = document.get(start + i);\n        String NERType = token.get(CoreAnnotations.NamedEntityTagAnnotation.class);\n        String currentType = token.get(CoreAnnotations.AnswerAnnotation.class);\n\n        if (\n            currentType != null ||\n            (exact != null && ! (ignoreCase ? exact.equalsIgnoreCase(token.word()) : exact.equals(token.word()))) ||\n            ! (entry.overwritableTypes.contains(NERType) ||\n                myLabels.contains(NERType) ||\n                NERType.equals(\"O\"))  ||\n            ! pattern.matcher(token.word()).matches()  // last, as this is likely the expensive operation\n            ) {\n          failed = true;\n          break;\n        }\n      }\n      if(! failed) {\n        //System.err.print(\"MATCHED REGEX:\");\n        //for(int i = start; i < start + regex.size(); i ++) System.err.print(\" \" + document.get(i).word());\n        //System.err.println();\n        return start;\n      }\n    }\n    return -1;\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-310-Param-0",
    "old_comment_raw": "@param mappings list of  XMLEntityMappings created from the specified orm xml files",
    "old_code_raw": "\tpublic Index parseAndUpdateIndex(List<JaxbRoot<XMLEntityMappings>> mappings, Index annotationIndex) {\n\t\tList<XMLEntityMappings> list = new ArrayList<XMLEntityMappings>( mappings.size() );\n\t\tfor ( JaxbRoot<XMLEntityMappings> jaxbRoot : mappings ) {\n\t\t\tlist.add( jaxbRoot.getRoot() );\n\t\t}\n\t\treturn new EntityMappingsMocker(\n\t\t\t\tlist, annotationIndex, meta.getServiceRegistry()\n\t\t).mockNewIndex();\n\t}\n",
    "new_code_raw": "\tpublic Index parseAndUpdateIndex(Set<String> mappingFileNames, Index annotationIndex) {\n\t\tClassLoaderService classLoaderService = meta.getServiceRegistry().getService( ClassLoaderService.class );\n\t\tSet<InputStream> mappingStreams = new HashSet<InputStream>();\n\t\tfor ( String fileName : mappingFileNames ) {\n\n\t\t\tEntityMappings entityMappings;\n\t\t\ttry {\n\t\t\t\tentityMappings = XmlHelper.unmarshallXml(\n\t\t\t\t\t\tfileName, ORM2_MAPPING_XSD, EntityMappings.class, classLoaderService\n\t\t\t\t).getRoot();\n\t\t\t}\n\t\t\tcatch ( JAXBException orm2Exception ) {\n\t\t\t\t// if we cannot parse against orm_2_0.xsd we try orm_1_0.xsd for backwards compatibility\n\t\t\t\ttry {\n\t\t\t\t\tentityMappings = XmlHelper.unmarshallXml(\n\t\t\t\t\t\t\tfileName, ORM1_MAPPING_XSD, EntityMappings.class, classLoaderService\n\t\t\t\t\t).getRoot();\n\t\t\t\t}\n\t\t\t\tcatch ( JAXBException orm1Exception ) {\n\t\t\t\t\tthrow new AnnotationException( \"Unable to parse xml configuration.\", orm1Exception );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentityMappings.toString();\n\t\t}\n\n\t\treturn null;\n\t}\n"
  },
  {
    "id": "zaproxy_zaproxy-1144-Param-0",
    "old_comment_raw": "@param node the starting node",
    "old_code_raw": "    private int getNodeInScopeCount(SiteNode node, boolean incRelatedSiblings) {\n        if (node == null) {\n            return 0;\n        }\n        \n        int nodeCount = 1;\n        if (parentScanner.scanChildren()) {\n            \n            Set<SiteNode> parentNodes = new HashSet<>();\n            parentNodes.add(node);\n                        \n            if (incRelatedSiblings) {\n                // Also match siblings with the same hierarchic name\n                // If we dont do this http://localhost/start might match the GET variant in the Sites tree and miss the hierarchic node\n                // note that this is only done for the top level.\n                SiteNode sibling = node;\n                while ((sibling = (SiteNode) sibling.getPreviousSibling()) != null) {\n                    if (node.getHierarchicNodeName().equals(sibling.getHierarchicNodeName())) {\n                        // count also sibling\n                        parentNodes.add(sibling);\n                        nodeCount++;\n                    }\n                }\n\n                sibling = node;\n                while ((sibling = (SiteNode) sibling.getNextSibling()) != null) {\n                    if (node.getHierarchicNodeName().equals(sibling.getHierarchicNodeName())) {\n                        // count also sibling\n                        parentNodes.add(sibling);\n                        nodeCount++;\n                    }\n                }\n            }\n            \n            for (SiteNode pNode : parentNodes) {\n                \n                for (int i = 0; i < pNode.getChildCount(); i++) {\n                    nodeCount += getNodeInScopeCount((SiteNode)pNode.getChildAt(i), false);\n                }\n            }\n        }\n        \n        return nodeCount;\n    }\n",
    "new_code_raw": "    private int getNodeInScopeCount(StructuralNode node, boolean incRelatedSiblings) {\n        if (node == null) {\n            return 0;\n        }\n        \n        int nodeCount = 1;\n        if (parentScanner.scanChildren()) {\n            \n            Set<StructuralNode> parentNodes = new HashSet<>();\n            parentNodes.add(node);\n                        \n            if (incRelatedSiblings) {\n                // Also match siblings with the same hierarchic name\n                // If we dont do this http://localhost/start might match the GET variant in the Sites tree and miss the hierarchic node\n                // note that this is only done for the top level.\n                try {\n\t\t\t\t\tIterator<StructuralNode> iter = node.getParent().getChildIterator();\n\t\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\t    StructuralNode sibling = iter.next();\n\t\t\t\t\t\tif (! node.isSameAs(sibling) && ! node.getName().equals(sibling.getName())) {\n\t\t\t\t\t        parentNodes.add(sibling);\n\t\t\t\t\t        nodeCount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (DatabaseException e) {\n\t\t\t\t\t// Ignore - if we cant connect to the db there will be plenty of other errors logged ;)\n\t\t\t\t}\n            }\n            \n            for (StructuralNode pNode : parentNodes) {\n                Iterator<StructuralNode> iter = pNode.getChildIterator();\n                while (iter.hasNext()) {\n                    nodeCount += getNodeInScopeCount(iter.next(), false);\n                }\n            }\n        }\n        \n        return nodeCount;\n    }\n"
  },
  {
    "id": "zaproxy_zaproxy-2307-Param-0",
    "old_comment_raw": "@param msg",
    "old_code_raw": "    protected String setEscapedParameter(HttpMessage msg, String param, String value) {\n        return variant.setEscapedParameter(msg, originalPair, param, value);\n    }\n",
    "new_code_raw": "    protected String setEscapedParameter(HttpMessage message, String param, String value) {\n        return variant.setEscapedParameter(message, originalPair, param, value);\n    }\n"
  },
  {
    "id": "SeleniumHQ_selenium-177-Param-5",
    "old_comment_raw": "@param multiWindow TODO",
    "old_code_raw": "    public String runHTMLSuite(String browser, String browserURL, String suiteURL, File outputFile, int timeoutInSeconds, boolean multiWindow) throws IOException {\n        return runHTMLSuite(browser, browserURL, suiteURL, outputFile,\n                timeoutInSeconds, multiWindow, \"info\");\n    }\n",
    "new_code_raw": "    public String runHTMLSuite(String browser, String browserURL, String suiteURL, File outputFile, long timeoutInSeconds, boolean multiWindow) throws IOException {\n        return runHTMLSuite(browser, browserURL, suiteURL, outputFile,\n                timeoutInSeconds, multiWindow, \"info\");\n    }\n"
  },
  {
    "id": "apache_drill-968-Param-0",
    "old_comment_raw": "@param queryContext - used to get the list of planner settings, other rules may also in the future need to get other query state from this, such as the available list of UDFs (as is used by the DrillMergeProjectRule created in getDrillBasicRules())",
    "old_code_raw": "  public static RuleSet getDrillUserConfigurableLogicalRules(QueryContext queryContext) {\n    PlannerSettings ps = queryContext.getPlannerSettings();\n\n    // This list is used to store rules that can be turned on an off\n    // by user facing planning options\n    Builder userConfigurableRules = ImmutableSet.<RelOptRule>builder();\n\n    if (ps.isConstantFoldingEnabled()) {\n      // TODO - DRILL-2218\n      userConfigurableRules.add(ReduceExpressionsRule.PROJECT_INSTANCE);\n\n      userConfigurableRules.add(DrillReduceExpressionsRule.FILTER_INSTANCE_DRILL);\n      userConfigurableRules.add(DrillReduceExpressionsRule.CALC_INSTANCE_DRILL);\n    }\n\n    return new DrillRuleSet(userConfigurableRules.build());\n  }\n",
    "new_code_raw": "  public static RuleSet getDrillUserConfigurableLogicalRules(OptimizerRulesContext optimizerRulesContext) {\n    PlannerSettings ps = optimizerRulesContext.getPlannerSettings();\n\n    // This list is used to store rules that can be turned on an off\n    // by user facing planning options\n    Builder userConfigurableRules = ImmutableSet.<RelOptRule>builder();\n\n    if (ps.isConstantFoldingEnabled()) {\n      // TODO - DRILL-2218\n      userConfigurableRules.add(ReduceExpressionsRule.PROJECT_INSTANCE);\n\n      userConfigurableRules.add(DrillReduceExpressionsRule.FILTER_INSTANCE_DRILL);\n      userConfigurableRules.add(DrillReduceExpressionsRule.CALC_INSTANCE_DRILL);\n    }\n\n    return new DrillRuleSet(userConfigurableRules.build());\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-707-Param-7",
    "old_comment_raw": "@param _float None (optional)",
    "old_code_raw": "  public ApiResponse<Void> testEndpointParametersWithHttpInfo(String number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password) throws ApiException {\n    Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, null, null);\n    return apiClient.execute(call);\n  }\n",
    "new_code_raw": "  public ApiResponse<Void> testEndpointParametersWithHttpInfo(BigDecimal number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password) throws ApiException {\n    Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, null, null);\n    return apiClient.execute(call);\n  }\n"
  },
  {
    "id": "apache_calcite-858-Param-1",
    "old_comment_raw": "@param mayBeNull If false, if expression is definitely not null at runtime. Therefore we can optimize. For example, we can cast to int using x.intValue().",
    "old_code_raw": "    private Expression translate0(RexNode expr, boolean mayBeNull) {\n        if (expr instanceof RexInputRef) {\n            final int index = ((RexInputRef) expr).getIndex();\n            return inputGetter.field(list, index);\n        }\n        if (expr instanceof RexLocalRef) {\n            return translate(\n                program.getExprList().get(((RexLocalRef) expr).getIndex()),\n                mayBeNull);\n        }\n        if (expr instanceof RexLiteral) {\n            return translateLiteral(expr, null, typeFactory);\n        }\n        if (expr instanceof RexCall) {\n            final RexCall call = (RexCall) expr;\n            final SqlOperator operator = call.getOperator();\n            RexImpTable.CallImplementor implementor =\n                RexImpTable.INSTANCE.get(operator);\n            if (implementor != null) {\n                return implementor.implement(this, call, mayBeNull);\n            }\n        }\n        switch (expr.getKind()) {\n        default:\n            throw new RuntimeException(\n                \"cannot translate expression \" + expr);\n        }\n    }\n",
    "new_code_raw": "    private Expression translate0(RexNode expr, RexImpTable.NullAs nullAs) {\n        if (expr instanceof RexInputRef) {\n            final int index = ((RexInputRef) expr).getIndex();\n            Expression x = inputGetter.field(list, index);\n            return nullAs.handle(list.append(\"v\", x));\n        }\n        if (expr instanceof RexLocalRef) {\n            return translate(\n                program.getExprList().get(((RexLocalRef) expr).getIndex()),\n                nullAs);\n        }\n        if (expr instanceof RexLiteral) {\n            return translateLiteral(expr, null, typeFactory, nullAs);\n        }\n        if (expr instanceof RexCall) {\n            final RexCall call = (RexCall) expr;\n            final SqlOperator operator = call.getOperator();\n            RexImpTable.CallImplementor implementor =\n                RexImpTable.INSTANCE.get(operator);\n            if (implementor != null) {\n                return implementor.implement(this, call, nullAs);\n            }\n        }\n        switch (expr.getKind()) {\n        default:\n            throw new RuntimeException(\n                \"cannot translate expression \" + expr);\n        }\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1195-Param-1",
    "old_comment_raw": "@param session The session",
    "old_code_raw": "\tpublic int performExecuteUpdate(QueryParameters queryParameters, SessionImplementor session)\n\t\t\tthrows HibernateException {\n\t\tif ( traceEnabled ) {\n\t\t\tLOG.tracev( \"Execute update: {0}\", getSourceQuery() );\n\t\t\tqueryParameters.traceParameters( session.getFactory() );\n\t\t}\n\t\tif ( translators.length != 1 ) {\n\t\t\tLOG.splitQueries( getSourceQuery(), translators.length );\n\t\t}\n\t\tint result = 0;\n\t\tfor ( QueryTranslator translator : translators ) {\n\t\t\tresult += translator.executeUpdate( queryParameters, session );\n\t\t}\n\t\treturn result;\n\t}\n",
    "new_code_raw": "\tpublic int performExecuteUpdate(QueryParameters queryParameters, SharedSessionContractImplementor session)\n\t\t\tthrows HibernateException {\n\t\tif ( traceEnabled ) {\n\t\t\tLOG.tracev( \"Execute update: {0}\", getSourceQuery() );\n\t\t\tqueryParameters.traceParameters( session.getFactory() );\n\t\t}\n\t\tif ( translators.length != 1 ) {\n\t\t\tLOG.splitQueries( getSourceQuery(), translators.length );\n\t\t}\n\t\tint result = 0;\n\t\tfor ( QueryTranslator translator : translators ) {\n\t\t\tresult += translator.executeUpdate( queryParameters, session );\n\t\t}\n\t\treturn result;\n\t}\n"
  },
  {
    "id": "RobotiumTech_robotium-1508-Param-1",
    "old_comment_raw": "@param expectedMinimumNumberOfMatches the minimum number of matches of text that must be shown.  0 means any number of matches",
    "old_code_raw": "\tpublic boolean waitForText(String text, int expectedMinimumNumberOfMatches, long timeout) {\n       return robotiumUtils.waitForText(text, expectedMinimumNumberOfMatches, timeout);\n    }\n",
    "new_code_raw": "\tpublic boolean waitForText(String text, int minimumNumberOfMatches, long timeout) {\n       return robotiumUtils.waitForText(text, minimumNumberOfMatches, timeout);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1652-Param-1",
    "old_comment_raw": "@param params Map of query params. A collection will be interpreted as passing in multiple instances of the same query param.",
    "old_code_raw": "    public Order placeOrder(Order body, Map<String, Object> params) throws IOException {\n        HttpResponse response = placeOrderForHttpResponse(body, params);\n        TypeReference typeRef = new TypeReference<Order>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n",
    "new_code_raw": "    public Order placeOrder(Order order, Map<String, Object> params) throws IOException {\n        HttpResponse response = placeOrderForHttpResponse(order, params);\n        TypeReference typeRef = new TypeReference<Order>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n"
  },
  {
    "id": "nelsonsilva_vaadin-42-Associations-Param0",
    "old_comment_raw": "@param prefix the Filter prefix",
    "old_code_raw": "\t\tpublic ArrayList filterContent(String prefix) {\n\t\t\t// prefix MUST be in lowercase\n\t\t\tif (\"\".equals(prefix)) {\n\t\t\t\tthis.filteredItemsBuffer = new ArrayList(getItemIds());\n\t\t\t\treturn this.filteredItemsBuffer;\n\n\t\t\t} else if (items != null) { \n\t\t\t\t// all items will be iterated and tested.\n\t\t\t\t// SLOW when there are lot of items.\n\t\t\t\t// TODO Should we add \n\t\t\t\tthis.filteredItemsBuffer = new ArrayList();\n\t\t\t\tfor (Iterator iter = items.getItemIds().iterator(); iter\n\t\t\t\t\t\t.hasNext();) {\n\t\t\t\t\tObject id = iter.next();\n\n\t\t\t\t\tItem item = getItem(id);\n\t\t\t\t\tString test = \"\";\n\t\t\t\t\tif (getItemCaptionMode() == ITEM_CAPTION_MODE_PROPERTY)\n\t\t\t\t\t\ttest = item.getItemProperty(getItemCaptionPropertyId())\n\t\t\t\t\t\t\t\t.getValue().toString().trim();\n\t\t\t\t\telse\n\t\t\t\t\t\ttest = String.valueOf(id);\n\n\t\t\t\t\tif (test.toLowerCase().startsWith(prefix)) {\n\t\t\t\t\t\tthis.filteredItemsBuffer.add(id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.filteredItemsBuffer;\n\t\t}\n",
    "new_code_raw": "\t\tpublic ArrayList filterContent(String key) {\n\t\t\treturn this.of.filter(key);\n\t\t}\n\n"
  },
  {
    "id": "yanzhenjie_NoHttp-95-Param-0",
    "old_comment_raw": "@param context ApplicationContext",
    "old_code_raw": "\tpublic static DownloadQueue newDownloadQueue(Context context) {\n\t\treturn newDownloadQueue(context, 2);\n\t}\n",
    "new_code_raw": "\tpublic static DownloadQueue newDownloadQueue() {\n\t\treturn newDownloadQueue(2);\n\t}\n"
  },
  {
    "id": "apache_calcite-872-Param-0",
    "old_comment_raw": "@param rootRel Relational expression that is at the root of the tree",
    "old_code_raw": "  protected RelNode trimUnusedFields(RelNode rootRel) {\n    final SqlToRelConverter converter =\n        getSqlToRelConverter(\n            getSqlValidator(), catalogReader);\n    converter.setTrimUnusedFields(shouldTrim(rootRel));\n    return converter.trimUnusedFields(ordered, rootRel);\n  }\n",
    "new_code_raw": "  protected RelRoot trimUnusedFields(RelRoot root) {\n    final SqlToRelConverter converter =\n        getSqlToRelConverter(\n            getSqlValidator(), catalogReader);\n    converter.setTrimUnusedFields(shouldTrim(root.rel));\n    final boolean ordered = !root.collation.getFieldCollations().isEmpty();\n    final boolean dml = SqlKind.DML.contains(root.kind);\n    return root.withRel(converter.trimUnusedFields(dml || ordered, root.rel));\n  }\n"
  },
  {
    "id": "apache_kylin-383-Param-1",
    "old_comment_raw": "@param sqlRequest",
    "old_code_raw": "    private SQLResponse execute(String sql, SQLRequest sqlRequest) throws Exception {\n        Connection conn = null;\n        Statement stat = null;\n        ResultSet resultSet = null;\n\n        List<List<String>> results = Lists.newArrayList();\n        List<SelectedColumnMeta> columnMetas = Lists.newArrayList();\n\n        try {\n            conn = cacheService.getOLAPDataSource(sqlRequest.getProject()).getConnection();\n\n            if (sqlRequest instanceof PrepareSqlRequest) {\n                PreparedStatement preparedState = conn.prepareStatement(sql);\n                processStatementAttr(preparedState, sqlRequest);\n\n                for (int i = 0; i < ((PrepareSqlRequest) sqlRequest).getParams().length; i++) {\n                    setParam(preparedState, i + 1, ((PrepareSqlRequest) sqlRequest).getParams()[i]);\n                }\n\n                resultSet = preparedState.executeQuery();\n            } else {\n                stat = conn.createStatement();\n                processStatementAttr(stat, sqlRequest);\n                resultSet = stat.executeQuery(sql);\n            }\n\n            ResultSetMetaData metaData = resultSet.getMetaData();\n            int columnCount = metaData.getColumnCount();\n\n            // Fill in selected column meta\n            for (int i = 1; i <= columnCount; ++i) {\n                columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i), metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i), metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i), metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i), metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i), metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i), metaData.isDefinitelyWritable(i)));\n            }\n\n            // fill in results\n            while (resultSet.next()) {\n                List<String> oneRow = Lists.newArrayListWithCapacity(columnCount);\n                for (int i = 0; i < columnCount; i++) {\n                    oneRow.add((resultSet.getString(i + 1)));\n                }\n\n                results.add(oneRow);\n            }\n        } finally {\n            close(resultSet, stat, conn);\n        }\n\n        boolean isPartialResult = false;\n        String cube = \"\";\n        StringBuilder sb = new StringBuilder(\"Scan count for each storageContext: \");\n        long totalScanCount = 0;\n        if (OLAPContext.getThreadLocalContexts() != null) { // contexts can be null in case of 'explain plan for'\n            for (OLAPContext ctx : OLAPContext.getThreadLocalContexts()) {\n                if (ctx.realization != null) {\n                    isPartialResult |= ctx.storageContext.isPartialResultReturned();\n                    cube = ctx.realization.getName();\n                    totalScanCount += ctx.storageContext.getTotalScanCount();\n                    sb.append(ctx.storageContext.getTotalScanCount() + \",\");\n                }\n            }\n        }\n        logger.info(sb.toString());\n\n        SQLResponse response = new SQLResponse(columnMetas, results, cube, 0, false, null, isPartialResult);\n        response.setTotalScanCount(totalScanCount);\n\n        return response;\n    }\n",
    "new_code_raw": "    private SQLResponse execute(String correctedSql, SQLRequest sqlRequest) throws Exception {\n        Connection conn = null;\n        Statement stat = null;\n        ResultSet resultSet = null;\n\n        List<List<String>> results = Lists.newArrayList();\n        List<SelectedColumnMeta> columnMetas = Lists.newArrayList();\n\n        try {\n            conn = cacheService.getOLAPDataSource(sqlRequest.getProject()).getConnection();\n\n            if (sqlRequest instanceof PrepareSqlRequest) {\n                PreparedStatement preparedState = conn.prepareStatement(correctedSql);\n                processStatementAttr(preparedState, sqlRequest);\n\n                for (int i = 0; i < ((PrepareSqlRequest) sqlRequest).getParams().length; i++) {\n                    setParam(preparedState, i + 1, ((PrepareSqlRequest) sqlRequest).getParams()[i]);\n                }\n\n                resultSet = preparedState.executeQuery();\n            } else {\n                stat = conn.createStatement();\n                processStatementAttr(stat, sqlRequest);\n                resultSet = stat.executeQuery(correctedSql);\n            }\n\n            ResultSetMetaData metaData = resultSet.getMetaData();\n            int columnCount = metaData.getColumnCount();\n\n            // Fill in selected column meta\n            for (int i = 1; i <= columnCount; ++i) {\n                columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i), metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i), metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i), metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i), metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i), metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i), metaData.isDefinitelyWritable(i)));\n            }\n\n            // fill in results\n            while (resultSet.next()) {\n                List<String> oneRow = Lists.newArrayListWithCapacity(columnCount);\n                for (int i = 0; i < columnCount; i++) {\n                    oneRow.add((resultSet.getString(i + 1)));\n                }\n\n                results.add(oneRow);\n            }\n        } finally {\n            close(resultSet, stat, conn);\n        }\n\n        boolean isPartialResult = false;\n        String cube = \"\";\n        StringBuilder sb = new StringBuilder(\"Scan count for each storageContext: \");\n        long totalScanCount = 0;\n        if (OLAPContext.getThreadLocalContexts() != null) { // contexts can be null in case of 'explain plan for'\n            for (OLAPContext ctx : OLAPContext.getThreadLocalContexts()) {\n                if (ctx.realization != null) {\n                    isPartialResult |= ctx.storageContext.isPartialResultReturned();\n                    cube = ctx.realization.getName();\n                    totalScanCount += ctx.storageContext.getTotalScanCount();\n                    sb.append(ctx.storageContext.getTotalScanCount() + \",\");\n                }\n            }\n        }\n        logger.info(sb.toString());\n\n        SQLResponse response = new SQLResponse(columnMetas, results, cube, 0, false, null, isPartialResult);\n        response.setTotalScanCount(totalScanCount);\n\n        return response;\n    }\n"
  },
  {
    "id": "codehaus_cake-14-Associations-Param0",
    "old_comment_raw": "@param attributes an object containing an AttributeMap",
    "old_code_raw": "    public short get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n",
    "new_code_raw": "    public short get(WithAttributes withAttributes) {\r\n        return withAttributes.getAttributes().get(this);\r\n    }\r\n\n"
  },
  {
    "id": "querydsl_querydsl-1443-Param-0",
    "old_comment_raw": "@param path",
    "old_code_raw": "    public static BooleanExpression fuzzyLike(Path<String> path, String value, float minimumSimilarity) {\n        Term term = new Term(path.getMetadata().getName(), value);\n        return new QueryElement(new FuzzyQuery(term, minimumSimilarity));\n    }\n",
    "new_code_raw": "    public static BooleanExpression fuzzyLike(Path<String> path, String value, int maxEdits) {\n        Term term = new Term(path.getMetadata().getName(), value);\n        return new QueryElement(new FuzzyQuery(term, maxEdits));\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-1496-Param-1",
    "old_comment_raw": "@param match if multiple objects match the text, this determines which one will be clicked",
    "old_code_raw": "\tpublic WebElement searchForWebElement(final By by, int match, int timeout, boolean scroll){\n\n\t\tif(match < 1){\n\t\t\tmatch = 1;\n\t\t}\n\n\t\tList<WebElement> viewsFromScreen = webUtils.getCurrentWebElements(by);\n\t\taddViewsToList (webElements, viewsFromScreen);\n\n\t\treturn getViewFromList(webElements, match);\n\t}\n",
    "new_code_raw": "\tpublic WebElement searchForWebElement(final By by, int minimumNumberOfMatches, int timeout, boolean scroll){\n\n\t\tif(minimumNumberOfMatches < 1){\n\t\t\tminimumNumberOfMatches = 1;\n\t\t}\n\n\t\tList<WebElement> viewsFromScreen = webUtils.getCurrentWebElements(by);\n\t\taddViewsToList (webElements, viewsFromScreen);\n\n\t\treturn getViewFromList(webElements, minimumNumberOfMatches);\n\t}\n"
  },
  {
    "id": "JodaOrg_joda_time-57-Param-0",
    "old_comment_raw": "@param instant the partial instant to query",
    "old_code_raw": "    public int getMaximumValue(PartialInstant instant, int[] values) {\n        return getMaximumValue(instant);\n    }\n",
    "new_code_raw": "    public int getMaximumValue(ReadablePartial instant, int[] values) {\n        return getMaximumValue(instant);\n    }\n"
  },
  {
    "id": "apache_drill-963-Param-0",
    "old_comment_raw": "@param buffer ByteBuf to read from",
    "old_code_raw": "    public static int readVInt(ByteBuf buffer, int start, int end) {\n      long n = readVLong(buffer, start, end);\n      if ((n > Integer.MAX_VALUE) || (n < Integer.MIN_VALUE)) {\n        throw new NumberFormatException(\"Value \" + n + \" too long to fit in integer\");\n      }\n      return (int)n;\n    }\n",
    "new_code_raw": "    public static int readVInt(DrillBuf buffer, int start, int end) {\n      long n = readVLong(buffer, start, end);\n      if ((n > Integer.MAX_VALUE) || (n < Integer.MIN_VALUE)) {\n        throw new NumberFormatException(\"Value \" + n + \" too long to fit in integer\");\n      }\n      return (int)n;\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1727-Param-3",
    "old_comment_raw": "@param collectionQueryParams The collection query parameters",
    "old_code_raw": "    public Call buildCall(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n        Request request = buildRequest(path, method, queryParams, collectionQueryParams, body, headerParams, formParams, authNames, progressRequestListener);\n\n        return httpClient.newCall(request);\n    }\n",
    "new_code_raw": "    public Call buildCall(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {\n        Request request = buildRequest(path, method, queryParams, collectionQueryParams, body, headerParams, formParams, authNames, callback);\n\n        return httpClient.newCall(request);\n    }\n"
  },
  {
    "id": "runelite_runelite-119-Param-1",
    "old_comment_raw": "@param x the ground coordinate on the x axis",
    "old_code_raw": "\tpublic static int getTileHeight(Client client, int x, int y, int plane)\n\t{\n\t\tint var3 = x >> 7;\n\t\tint var4 = y >> 7;\n\t\tif (var3 >= 0 && var4 >= 0 && var3 <= 103 && var4 <= 103)\n\t\t{\n\t\t\tbyte[][][] tileSettings = client.getTileSettings();\n\t\t\tint[][][] tileHeights = client.getTileHeights();\n\n\t\t\tint var5 = plane;\n\t\t\tif (plane < 3 && (tileSettings[1][var3][var4] & 2) == 2)\n\t\t\t{\n\t\t\t\tvar5 = plane + 1;\n\t\t\t}\n\n\t\t\tint var6 = x & 127;\n\t\t\tint var7 = y & 127;\n\t\t\tint var8 = var6 * tileHeights[var5][var3 + 1][var4] + (128 - var6) * tileHeights[var5][var3][var4] >> 7;\n\t\t\tint var9 = tileHeights[var5][var3][var4 + 1] * (128 - var6) + var6 * tileHeights[var5][var3 + 1][var4 + 1] >> 7;\n\t\t\treturn (128 - var7) * var8 + var7 * var9 >> 7;\n\t\t}\n\n\t\treturn 0;\n\t}\n",
    "new_code_raw": "\tpublic static int getTileHeight(Client client, int localX, int localY, int plane)\n\t{\n\t\tint sceneX = localX >> LOCAL_COORD_BITS;\n\t\tint sceneY = localY >> LOCAL_COORD_BITS;\n\t\tif (sceneX >= 0 && sceneY >= 0 && sceneX <= 103 && sceneY <= 103)\n\t\t{\n\t\t\tbyte[][][] tileSettings = client.getTileSettings();\n\t\t\tint[][][] tileHeights = client.getTileHeights();\n\n\t\t\tint var5 = plane;\n\t\t\tif (plane < 3 && (tileSettings[1][sceneX][sceneY] & 2) == 2)\n\t\t\t{\n\t\t\t\tvar5 = plane + 1;\n\t\t\t}\n\n\t\t\tint var6 = localX & 127;\n\t\t\tint var7 = localY & 127;\n\t\t\tint var8 = var6 * tileHeights[var5][sceneX + 1][sceneY] + (128 - var6) * tileHeights[var5][sceneX][sceneY] >> 7;\n\t\t\tint var9 = tileHeights[var5][sceneX][sceneY + 1] * (128 - var6) + var6 * tileHeights[var5][sceneX + 1][sceneY + 1] >> 7;\n\t\t\treturn (128 - var7) * var8 + var7 * var9 >> 7;\n\t\t}\n\n\t\treturn 0;\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-673-Param-2",
    "old_comment_raw": "@param status Updated status of the pet (optional)",
    "old_code_raw": "  public Call updatePetWithFormAsync(String petId, String name, String status, final ApiCallback<Void> callback) throws ApiException {\n\n    ProgressResponseBody.ProgressListener progressListener = null;\n    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n    if (callback != null) {\n      progressListener = new ProgressResponseBody.ProgressListener() {\n        @Override\n        public void update(long bytesRead, long contentLength, boolean done) {\n          callback.onDownloadProgress(bytesRead, contentLength, done);\n        }\n      };\n\n      progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {\n        @Override\n        public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {\n          callback.onUploadProgress(bytesWritten, contentLength, done);\n        }\n      };\n    }\n\n    Call call = updatePetWithFormCall(petId, name, status, progressListener, progressRequestListener);\n    apiClient.executeAsync(call, callback);\n    return call;\n  }\n",
    "new_code_raw": "  public Call updatePetWithFormAsync(Long petId, String name, String status, final ApiCallback<Void> callback) throws ApiException {\n\n    ProgressResponseBody.ProgressListener progressListener = null;\n    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n    if (callback != null) {\n      progressListener = new ProgressResponseBody.ProgressListener() {\n        @Override\n        public void update(long bytesRead, long contentLength, boolean done) {\n          callback.onDownloadProgress(bytesRead, contentLength, done);\n        }\n      };\n\n      progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {\n        @Override\n        public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {\n          callback.onUploadProgress(bytesWritten, contentLength, done);\n        }\n      };\n    }\n\n    Call call = updatePetWithFormCall(petId, name, status, progressListener, progressRequestListener);\n    apiClient.executeAsync(call, callback);\n    return call;\n  }\n"
  },
  {
    "id": "apache_ant-ivy-47-Associations-Param1",
    "old_comment_raw": "@param file2 The other file for which the common base directory should be returned, may be null.",
    "old_code_raw": "    File getBaseDir(final File file1, final File file2) {\n        if (file1 == null || file2 == null) {\n            return null;\n        }\n        final Iterator file1Parents = getParents(file1).iterator();\n        final Iterator file2Parents = getParents(file2.getAbsoluteFile()).iterator();\n        File result = null;\n        while (file1Parents.hasNext() && file2Parents.hasNext()) {\n            File next = (File) file1Parents.next();\n            if (next.equals(file2Parents.next())) {\n                result = next;\n            } else {\n                break;\n            }\n        }\n        return result;\n    }\n",
    "new_code_raw": "    File getBaseDir(File base, File file) {\n        if (base == null) {\n            return file.getParentFile().getAbsoluteFile();\n        } else {\n            Iterator bases = getParents(base).iterator();\n            Iterator fileParents = getParents(file.getAbsoluteFile()).iterator();\n            File result = null;\n            while (bases.hasNext() && fileParents.hasNext()) {\n                File next = (File) bases.next();\n                if (next.equals(fileParents.next())) {\n                    result = next;\n                } else {\n                    break;\n                }\n            }\n            return result;\n        }\n    }\n\n"
  },
  {
    "id": "debezium_debezium-734-Param-0",
    "old_comment_raw": "@param collectionId the identifier of the collection to be copied; may not be null",
    "old_code_raw": "    protected long copyCollection(CollectionId collectionId, long timestamp) throws InterruptedException {\n        AtomicLong docCount = new AtomicLong();\n        primaryClient.executeBlocking(\"sync '\" + collectionId + \"'\", primary -> {\n            docCount.set(copyCollection(primary, collectionId, timestamp));\n        });\n        return docCount.get();\n    }\n",
    "new_code_raw": "    protected long copyCollection(CollectionId collectionId, Instant timestamp) throws InterruptedException {\n        AtomicLong docCount = new AtomicLong();\n        primaryClient.executeBlocking(\"sync '\" + collectionId + \"'\", primary -> {\n            docCount.set(copyCollection(primary, collectionId, timestamp));\n        });\n        return docCount.get();\n    }\n"
  },
  {
    "id": "apache_empire-db-64-Associations-Param0",
    "old_comment_raw": "@param value the int value",
    "old_code_raw": "    public DBCompareColExpr in(Object value)\n    {\n        return cmp(DBCmpType.IN, listToArray(value));\n    }\n",
    "new_code_raw": "    public final DBCompareColExpr in(Collection<?> values)\n    {\n        if (values==null || values.isEmpty())\n            return cmp(DBCmpType.EQUAL, null);\n        // create expression\n        return cmp(DBCmpType.IN, values);\n    }\n\n"
  },
  {
    "id": "apache_drill-281-Param-1",
    "old_comment_raw": "@param metaFilePath metadata cache file path",
    "old_code_raw": "  private void init() throws IOException {\n    if (entries.size() == 1 && parquetTableMetadata == null) {\n      Path p = Path.getPathWithoutSchemeAndAuthority(new Path(entries.get(0).getPath()));\n      Path metaPath = null;\n      if (fs.isDirectory(p)) {\n        // Using the metadata file makes sense when querying a directory; otherwise\n        // if querying a single file we can look up the metadata directly from the file\n        metaPath = new Path(p, Metadata.METADATA_FILENAME);\n      }\n      if (metaPath != null && fs.exists(metaPath)) {\n        usedMetadataCache = true;\n        parquetTableMetadata = Metadata.readBlockMeta(fs, metaPath.toString());\n      } else {\n        parquetTableMetadata = Metadata.getParquetTableMetadata(fs, p.toString());\n      }\n    } else {\n      Path p = Path.getPathWithoutSchemeAndAuthority(new Path(selectionRoot));\n      Path metaPath = new Path(p, Metadata.METADATA_FILENAME);\n      if (fs.isDirectory(new Path(selectionRoot)) && fs.exists(metaPath)) {\n        usedMetadataCache = true;\n        if (parquetTableMetadata == null) {\n          parquetTableMetadata = Metadata.readBlockMeta(fs, metaPath.toString());\n        }\n        if (fileSet != null) {\n          parquetTableMetadata = removeUnneededRowGroups(parquetTableMetadata);\n        }\n      } else {\n        final List<FileStatus> fileStatuses = Lists.newArrayList();\n        for (ReadEntryWithPath entry : entries) {\n          getFiles(entry.getPath(), fileStatuses);\n        }\n        parquetTableMetadata = Metadata.getParquetTableMetadata(fs, fileStatuses);\n      }\n    }\n\n    if (fileSet == null) {\n      fileSet = Sets.newHashSet();\n      for (ParquetFileMetadata file : parquetTableMetadata.getFiles()) {\n        fileSet.add(file.getPath());\n      }\n    }\n\n    Map<String, DrillbitEndpoint> hostEndpointMap = Maps.newHashMap();\n\n    for (DrillbitEndpoint endpoint : formatPlugin.getContext().getBits()) {\n      hostEndpointMap.put(endpoint.getAddress(), endpoint);\n    }\n\n    rowGroupInfos = Lists.newArrayList();\n    for (ParquetFileMetadata file : parquetTableMetadata.getFiles()) {\n      int rgIndex = 0;\n      for (RowGroupMetadata rg : file.getRowGroups()) {\n        RowGroupInfo rowGroupInfo =\n            new RowGroupInfo(file.getPath(), rg.getStart(), rg.getLength(), rgIndex, rg.getRowCount());\n        EndpointByteMap endpointByteMap = new EndpointByteMapImpl();\n        for (String host : rg.getHostAffinity().keySet()) {\n          if (hostEndpointMap.containsKey(host)) {\n            endpointByteMap\n                .add(hostEndpointMap.get(host), (long) (rg.getHostAffinity().get(host) * rg.getLength()));\n          }\n        }\n        rowGroupInfo.setEndpointByteMap(endpointByteMap);\n        rgIndex++;\n        rowGroupInfos.add(rowGroupInfo);\n      }\n    }\n\n    this.endpointAffinities = AffinityCreator.getAffinityMap(rowGroupInfos);\n\n    columnValueCounts = Maps.newHashMap();\n    this.rowCount = 0;\n    boolean first = true;\n    for (ParquetFileMetadata file : parquetTableMetadata.getFiles()) {\n      for (RowGroupMetadata rowGroup : file.getRowGroups()) {\n        long rowCount = rowGroup.getRowCount();\n        for (ColumnMetadata column : rowGroup.getColumns()) {\n          SchemaPath schemaPath = SchemaPath.getCompoundPath(column.getName());\n          Long previousCount = columnValueCounts.get(schemaPath);\n          if (previousCount != null) {\n            if (previousCount != GroupScan.NO_COLUMN_STATS) {\n              if (column.getNulls() != null) {\n                Long newCount = rowCount - column.getNulls();\n                columnValueCounts.put(schemaPath, columnValueCounts.get(schemaPath) + newCount);\n              }\n            }\n          } else {\n            if (column.getNulls() != null) {\n              Long newCount = rowCount - column.getNulls();\n              columnValueCounts.put(schemaPath, newCount);\n            } else {\n              columnValueCounts.put(schemaPath, GroupScan.NO_COLUMN_STATS);\n            }\n          }\n          boolean partitionColumn = checkForPartitionColumn(column, first);\n          if (partitionColumn) {\n            Map<SchemaPath, Object> map = partitionValueMap.get(file.getPath());\n            if (map == null) {\n              map = Maps.newHashMap();\n              partitionValueMap.put(file.getPath(), map);\n            }\n            Object value = map.get(schemaPath);\n            Object currentValue = column.getMaxValue();\n            if (value != null) {\n              if (value != currentValue) {\n                columnTypeMap.remove(schemaPath);\n              }\n            } else {\n              map.put(schemaPath, currentValue);\n            }\n          } else {\n            columnTypeMap.remove(schemaPath);\n          }\n        }\n        this.rowCount += rowGroup.getRowCount();\n        first = false;\n      }\n    }\n  }\n",
    "new_code_raw": "  private void init(MetadataContext metaContext) throws IOException {\n    if (entries.size() == 1 && parquetTableMetadata == null) {\n      Path p = Path.getPathWithoutSchemeAndAuthority(new Path(entries.get(0).getPath()));\n      Path metaPath = null;\n      if (fs.isDirectory(p)) {\n        // Using the metadata file makes sense when querying a directory; otherwise\n        // if querying a single file we can look up the metadata directly from the file\n        metaPath = new Path(p, Metadata.METADATA_FILENAME);\n      }\n      if (metaPath != null && fs.exists(metaPath)) {\n        usedMetadataCache = true;\n        parquetTableMetadata = Metadata.readBlockMeta(fs, metaPath.toString(), metaContext);\n      } else {\n        parquetTableMetadata = Metadata.getParquetTableMetadata(fs, p.toString());\n      }\n    } else {\n      Path p = Path.getPathWithoutSchemeAndAuthority(new Path(selectionRoot));\n      Path metaPath = new Path(p, Metadata.METADATA_FILENAME);\n      if (fs.isDirectory(new Path(selectionRoot)) && fs.exists(metaPath)) {\n        usedMetadataCache = true;\n        if (parquetTableMetadata == null) {\n          parquetTableMetadata = Metadata.readBlockMeta(fs, metaPath.toString(), metaContext);\n        }\n        if (fileSet != null) {\n          parquetTableMetadata = removeUnneededRowGroups(parquetTableMetadata);\n        }\n      } else {\n        final List<FileStatus> fileStatuses = Lists.newArrayList();\n        for (ReadEntryWithPath entry : entries) {\n          getFiles(entry.getPath(), fileStatuses);\n        }\n        parquetTableMetadata = Metadata.getParquetTableMetadata(fs, fileStatuses);\n      }\n    }\n\n    if (fileSet == null) {\n      fileSet = Sets.newHashSet();\n      for (ParquetFileMetadata file : parquetTableMetadata.getFiles()) {\n        fileSet.add(file.getPath());\n      }\n    }\n\n    Map<String, DrillbitEndpoint> hostEndpointMap = Maps.newHashMap();\n\n    for (DrillbitEndpoint endpoint : formatPlugin.getContext().getBits()) {\n      hostEndpointMap.put(endpoint.getAddress(), endpoint);\n    }\n\n    rowGroupInfos = Lists.newArrayList();\n    for (ParquetFileMetadata file : parquetTableMetadata.getFiles()) {\n      int rgIndex = 0;\n      for (RowGroupMetadata rg : file.getRowGroups()) {\n        RowGroupInfo rowGroupInfo =\n            new RowGroupInfo(file.getPath(), rg.getStart(), rg.getLength(), rgIndex, rg.getRowCount());\n        EndpointByteMap endpointByteMap = new EndpointByteMapImpl();\n        for (String host : rg.getHostAffinity().keySet()) {\n          if (hostEndpointMap.containsKey(host)) {\n            endpointByteMap\n                .add(hostEndpointMap.get(host), (long) (rg.getHostAffinity().get(host) * rg.getLength()));\n          }\n        }\n        rowGroupInfo.setEndpointByteMap(endpointByteMap);\n        rgIndex++;\n        rowGroupInfos.add(rowGroupInfo);\n      }\n    }\n\n    this.endpointAffinities = AffinityCreator.getAffinityMap(rowGroupInfos);\n\n    columnValueCounts = Maps.newHashMap();\n    this.rowCount = 0;\n    boolean first = true;\n    for (ParquetFileMetadata file : parquetTableMetadata.getFiles()) {\n      for (RowGroupMetadata rowGroup : file.getRowGroups()) {\n        long rowCount = rowGroup.getRowCount();\n        for (ColumnMetadata column : rowGroup.getColumns()) {\n          SchemaPath schemaPath = SchemaPath.getCompoundPath(column.getName());\n          Long previousCount = columnValueCounts.get(schemaPath);\n          if (previousCount != null) {\n            if (previousCount != GroupScan.NO_COLUMN_STATS) {\n              if (column.getNulls() != null) {\n                Long newCount = rowCount - column.getNulls();\n                columnValueCounts.put(schemaPath, columnValueCounts.get(schemaPath) + newCount);\n              }\n            }\n          } else {\n            if (column.getNulls() != null) {\n              Long newCount = rowCount - column.getNulls();\n              columnValueCounts.put(schemaPath, newCount);\n            } else {\n              columnValueCounts.put(schemaPath, GroupScan.NO_COLUMN_STATS);\n            }\n          }\n          boolean partitionColumn = checkForPartitionColumn(column, first);\n          if (partitionColumn) {\n            Map<SchemaPath, Object> map = partitionValueMap.get(file.getPath());\n            if (map == null) {\n              map = Maps.newHashMap();\n              partitionValueMap.put(file.getPath(), map);\n            }\n            Object value = map.get(schemaPath);\n            Object currentValue = column.getMaxValue();\n            if (value != null) {\n              if (value != currentValue) {\n                columnTypeMap.remove(schemaPath);\n              }\n            } else {\n              map.put(schemaPath, currentValue);\n            }\n          } else {\n            columnTypeMap.remove(schemaPath);\n          }\n        }\n        this.rowCount += rowGroup.getRowCount();\n        first = false;\n      }\n    }\n  }\n"
  },
  {
    "id": "Omegaphora_dalvik-553-Associations-Param0",
    "old_comment_raw": "@param v the long to examine.",
    "old_code_raw": "    public static int numberOfLeadingZeros(long v) {\n        // After Hacker's Delight, Figure 5-6\n        if (v < 0) {\n            return 0;\n        }\n        if (v == 0) {\n            return 64;\n        }\n        // On a 64-bit VM, the two previous tests should probably be replaced by\n        // if (v <= 0) return ((int) (~v >> 57)) & 64;\n\n        int n = 1;\n        int i = (int) (v >>> 32);\n        if (i == 0) {\n            n +=  32;\n            i = (int) v;\n        }\n        if (i >>> 16 == 0) {\n            n +=  16;\n            i <<= 16;\n        }\n        if (i >>> 24 == 0) {\n            n +=  8;\n            i <<= 8;\n        }\n        if (i >>> 28 == 0) {\n            n +=  4;\n            i <<= 4;\n        }\n        if (i >>> 30 == 0) {\n            n +=  2;\n            i <<= 2;\n        }\n        return n - (i >>> 31);\n    }\n",
    "new_code_raw": "    public static int numberOfLeadingZeros(long lng) {\n        lng |= lng >> 1;\n        lng |= lng >> 2;\n        lng |= lng >> 4;\n        lng |= lng >> 8;\n        lng |= lng >> 16;\n        lng |= lng >> 32;\n        return bitCount(~lng);\n    }\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-1203-Param-1",
    "old_comment_raw": "@param previousState The previous state of the entity (the state to be checked against).",
    "old_code_raw": "\tpublic int[] findDirty(Object[] currentState, Object[] previousState, Object entity, SessionImplementor session)\n\t\t\tthrows HibernateException {\n\t\tint[] props = TypeHelper.findDirty(\n\t\t\t\tentityMetamodel.getProperties(),\n\t\t\t\tcurrentState,\n\t\t\t\tpreviousState,\n\t\t\t\tpropertyColumnUpdateable,\n\t\t\t\thasUninitializedLazyProperties( entity ),\n\t\t\t\tsession\n\t\t);\n\t\tif ( props == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tlogDirtyProperties( props );\n\t\t\treturn props;\n\t\t}\n\t}\n",
    "new_code_raw": "\tpublic int[] findDirty(Object[] currentState, Object[] previousState, Object entity, SharedSessionContractImplementor session)\n\t\t\tthrows HibernateException {\n\t\tint[] props = TypeHelper.findDirty(\n\t\t\t\tentityMetamodel.getProperties(),\n\t\t\t\tcurrentState,\n\t\t\t\tpreviousState,\n\t\t\t\tpropertyColumnUpdateable,\n\t\t\t\thasUninitializedLazyProperties( entity ),\n\t\t\t\tsession\n\t\t);\n\t\tif ( props == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tlogDirtyProperties( props );\n\t\t\treturn props;\n\t\t}\n\t}\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2428-Param-0",
    "old_comment_raw": "@param span The span of the sentence to find the mode element in. This must be entirely contained in the sentence.",
    "old_code_raw": "  public List<String> dependencyPathBetween(int start, int end, Function<Sentence, List<String>> selector) {\n    // Get paths from a node to the root of the sentence\n    LinkedList<Integer> rootToStart = new LinkedList<>();\n    LinkedList<Integer> rootToEnd = new LinkedList<>();\n    int startAncestor = start;\n    List<Optional<Integer>> governors = sentence.governors();\n    Set<Integer> seenVertices = new HashSet<>();\n    while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) {\n      if (seenVertices.contains(startAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(startAncestor);\n      rootToStart.addFirst(startAncestor);\n      startAncestor = governors.get(startAncestor).get();\n    }\n    if (startAncestor == -1) {\n      rootToStart.addFirst(-1);\n    }\n    int endAncestor = end;\n    seenVertices.clear();\n    while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) {\n      if (seenVertices.contains(endAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(endAncestor);\n      rootToEnd.addFirst(endAncestor);\n      endAncestor = governors.get(endAncestor).get();\n    }\n    if (endAncestor == -1) {\n      rootToEnd.addFirst(-1);\n    }\n\n    // Get least common node\n    int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0;\n    for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) {\n      if (rootToStart.get(i).equals(rootToEnd.get(i))) {\n        leastCommonNodeIndex = i;\n      }\n    }\n\n    // Construct the path\n    if (leastCommonNodeIndex < 0) {\n      return Collections.EMPTY_LIST;\n    }\n    List<String> path = new ArrayList<>();\n    for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) {\n      path.add(selector.apply(sentence).get(rootToStart.get(i)));\n      path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\");\n    }\n    path.add(selector.apply(sentence).get(rootToStart.get(leastCommonNodeIndex)));\n    for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) {\n      path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\");\n      path.add(selector.apply(sentence).get(rootToEnd.get(i)));\n    }\n    return path;\n  }\n",
    "new_code_raw": "  public List<String> dependencyPathBetween(int start, int end, Optional<Function<Sentence, List<String>>> selector) {\n    // Get paths from a node to the root of the sentence\n    LinkedList<Integer> rootToStart = new LinkedList<>();\n    LinkedList<Integer> rootToEnd = new LinkedList<>();\n    int startAncestor = start;\n    List<Optional<Integer>> governors = sentence.governors();\n    Set<Integer> seenVertices = new HashSet<>();\n    while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) {\n      if (seenVertices.contains(startAncestor)) {\n        // Found loopiness -- revert to BFS\n        return loopyDependencyPathBetween(start, end, selector);\n      }\n      seenVertices.add(startAncestor);\n      rootToStart.addFirst(startAncestor);\n      startAncestor = governors.get(startAncestor).get();\n    }\n    if (startAncestor == -1) {\n      rootToStart.addFirst(-1);\n    }\n    int endAncestor = end;\n    seenVertices.clear();\n    while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) {\n      if (seenVertices.contains(endAncestor)) {\n        // Found loopiness -- revert to BFS\n        return loopyDependencyPathBetween(start, end, selector);\n      }\n      seenVertices.add(endAncestor);\n      rootToEnd.addFirst(endAncestor);\n      endAncestor = governors.get(endAncestor).get();\n    }\n    if (endAncestor == -1) {\n      rootToEnd.addFirst(-1);\n    }\n\n    // Get least common node\n    int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0;\n    for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) {\n      if (rootToStart.get(i).equals(rootToEnd.get(i))) {\n        leastCommonNodeIndex = i;\n      }\n    }\n\n    // Construct the path\n    if (leastCommonNodeIndex < 0) {\n      return Collections.emptyList();\n    }\n    List<String> path = new ArrayList<>();\n    Optional<List<String>> words = selector.map(x -> x.apply(sentence));\n    for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) {\n      final int index = i;\n      words.ifPresent(x -> path.add(x.get(rootToStart.get(index))));\n      path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\");\n    }\n    if (words.isPresent()) {\n      path.add(words.get().get(rootToStart.get(leastCommonNodeIndex)));\n    }\n    for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) {\n      final int index = i;\n      path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\");\n      words.ifPresent(x -> path.add(x.get(rootToEnd.get(index))));\n    }\n    return path;\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1556-Param-2",
    "old_comment_raw": "@param queryParams The query parameters",
    "old_code_raw": "  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    final String url = buildUrl(path, queryParams);\n    final Request.Builder reqBuilder = new Request.Builder().url(url);\n    processHeaderParams(headerParams, reqBuilder);\n\n    String contentType = (String) headerParams.get(\"Content-Type\");\n    // ensuring a default content type\n    if (contentType == null) {\n      contentType = \"application/json\";\n    }\n\n    RequestBody reqBody;\n    if (!HttpMethod.permitsRequestBody(method)) {\n      reqBody = null;\n    } else if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n      reqBody = buildRequestBodyFormEncoding(formParams);\n    } else if (\"multipart/form-data\".equals(contentType)) {\n      reqBody = buildRequestBodyMultipart(formParams);\n    } else if (body == null) {\n      if (\"DELETE\".equals(method)) {\n        // allow calling DELETE without sending a request body\n        reqBody = null;\n      } else {\n        // use an empty request body (for POST, PUT and PATCH)\n        reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n      }\n    } else {\n      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));\n    }\n\n    Request request = null;\n\n    if(progressRequestListener != null && reqBody != null) {\n      ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener);\n      request = reqBuilder.method(method, progressRequestBody).build();\n    } else {\n      request = reqBuilder.method(method, reqBody).build();\n    }\n\n    return httpClient.newCall(request);\n  }\n",
    "new_code_raw": "  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    final String url = buildUrl(path, queryParams);\n    final Request.Builder reqBuilder = new Request.Builder().url(url);\n    processHeaderParams(headerParams, reqBuilder);\n\n    String contentType = (String) headerParams.get(\"Content-Type\");\n    // ensuring a default content type\n    if (contentType == null) contentType = \"application/json\";\n\n    RequestBody reqBody;\n    if (!HttpMethod.permitsRequestBody(method)) {\n      reqBody = null;\n    } else if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n      reqBody = buildRequestBodyFormEncoding(formParams);\n    } else if (\"multipart/form-data\".equals(contentType)) {\n      reqBody = buildRequestBodyMultipart(formParams);\n    } else if (body == null) {\n      if (\"DELETE\".equals(method)) {\n        // allow calling DELETE without sending a request body\n        reqBody = null;\n      } else {\n        // use an empty request body (for POST, PUT and PATCH)\n        reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n      }\n    } else {\n      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));\n    }\n\n    Request request = reqBuilder.method(method, reqBody).build();\n    return httpClient.newCall(request);\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-1105-Param-0",
    "old_comment_raw": "@param field the field to check, may be null which returns false",
    "old_code_raw": "    public boolean isSupported(DateTimeField field) {\n        for (int i = 0, isize = getFieldSize(); i < isize; i++) {\n            if (getField(i) == field) {\n                return true;\n            }\n        }\n        return false;\n    }\n",
    "new_code_raw": "    public boolean isSupported(DateTimeFieldType type) {\n        for (int i = 0, isize = size(); i < isize; i++) {\n            if (getFieldType(i) == type) {\n                return true;\n            }\n        }\n        return false;\n    }\n"
  },
  {
    "id": "runelite_runelite-24-Param-1",
    "old_comment_raw": "@param graphics",
    "old_code_raw": "\tpublic static Point getCanvasImageLocation(Client client, Graphics2D graphics, Point localLocation, BufferedImage image, int zOffset)\n\t{\n\t\tint plane = client.getPlane();\n\n\t\tPoint p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset);\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tint xOffset = p.getX() - image.getWidth() / 2;\n\t\tint yOffset = p.getY() - image.getHeight() / 2;\n\n\t\treturn new Point(xOffset, yOffset);\n\t}\n",
    "new_code_raw": "\tpublic static Point getCanvasImageLocation(Client client, Graphics2D graphics, LocalPoint localLocation, BufferedImage image, int zOffset)\n\t{\n\t\tint plane = client.getPlane();\n\n\t\tPoint p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset);\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tint xOffset = p.getX() - image.getWidth() / 2;\n\t\tint yOffset = p.getY() - image.getHeight() / 2;\n\n\t\treturn new Point(xOffset, yOffset);\n\t}\n"
  },
  {
    "id": "JodaOrg_joda_time-443-Param-0",
    "old_comment_raw": "@param instant the time instant in millis to query",
    "old_code_raw": "    public String getAsText(long instant, Locale locale) {\n        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(get(instant));\n    }\n",
    "new_code_raw": "    protected String getAsText(int fieldValue, Locale locale) {\n        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(fieldValue);\n    }\n"
  },
  {
    "id": "SeleniumHQ_selenium-652-Param-0",
    "old_comment_raw": "@param cap",
    "old_code_raw": "\tpublic static RemoteProxy getNewBasicRemoteProxy(Map<String, Object> cap, String url) {\n\n\t\tRegistrationRequest req = new RegistrationRequest();\n\n\t\treq.addDesiredCapabilitiy(cap);\n\n\t\tMap<String, Object> config = new HashMap<String, Object>();\n\t\tconfig.put(\"url\", url);\n\t\treq.setConfiguration(config);\n\t\treturn new RemoteProxy(req);\n\n\t}\n",
    "new_code_raw": "\tpublic static RemoteProxy getNewBasicRemoteProxy(Map<String, Object> cap, String url,Registry registry) {\n\n\t\tRegistrationRequest req = new RegistrationRequest();\n\n\t\treq.addDesiredCapabilitiy(cap);\n\n\t\tMap<String, Object> config = new HashMap<String, Object>();\n\t\tconfig.put(\"url\", url);\n\t\treq.setConfiguration(config);\n\t\treturn new RemoteProxy(req,registry);\n\n\t}\n"
  },
  {
    "id": "querydsl_querydsl-1433-Param-1",
    "old_comment_raw": "@param clause clause",
    "old_code_raw": "    public SQLInsertClause insertOnDuplicateKeyUpdate(RelationalPath<?> entity, Expression<?> clause) {\n        SQLInsertClause insert = insert(entity);\n        insert.addFlag(Position.END, ExpressionUtils.template(String.class, \" on duplicate key update {0}\", clause));\n        return insert;\n    }\n",
    "new_code_raw": "    public SQLInsertClause insertOnDuplicateKeyUpdate(RelationalPath<?> entity, Expression<?>... clauses) {\n        SQLInsertClause insert = insert(entity);\n        StringBuilder flag = new StringBuilder(\" on duplicate key update \");\n        for (int i = 0; i < clauses.length; i++) {\n            flag.append(i > 0 ? \", \" : \"\").append(\"{\" + i + \"}\");\n        }\n        insert.addFlag(Position.END, ExpressionUtils.template(String.class, flag.toString(), clauses));\n        return insert;\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-52-Param-2",
    "old_comment_raw": "@param values the values of the partial instant which should be updated",
    "old_code_raw": "    public int[] add(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {\n        if (valueToAdd == 0) {\n            return values;\n        }\n        // there are more efficient algorithms than this (especially for time only fields)\n        // trouble is when dealing with days and months, so we use this technique of\n        // adding/removing one from the larger field at a time\n        DateTimeField nextField = null;\n        \n        while (valueToAdd > 0) {\n            int max = getMaximumValue(instant, values);\n            long proposed = values[fieldIndex] + valueToAdd;\n            if (proposed <= max) {\n                values[fieldIndex] = (int) proposed;\n                break;\n            }\n            if (nextField == null) {\n                if (fieldIndex == 0) {\n                    throw new IllegalArgumentException(\"Maximum value exceeded for add\");\n                }\n                nextField = instant.getField(fieldIndex - 1);\n                if (getRangeDurationField() != nextField.getDurationField()) {\n                    throw new IllegalArgumentException(\"Fields invalid for add\");\n                }\n            }\n            valueToAdd -= (max + 1) - values[fieldIndex];\n            values = nextField.add(instant, fieldIndex - 1, values, 1);\n            values[fieldIndex] = getMinimumValue(instant, values);\n        }\n        while (valueToAdd < 0) {\n            int min = getMinimumValue(instant, values);\n            long proposed = values[fieldIndex] + valueToAdd;\n            if (proposed >= min) {\n                values[fieldIndex] = (int) proposed;\n                break;\n            }\n            if (nextField == null) {\n                if (fieldIndex == 0) {\n                    throw new IllegalArgumentException(\"Maximum value exceeded for add\");\n                }\n                nextField = instant.getField(fieldIndex - 1);\n                if (getRangeDurationField() != nextField.getDurationField()) {\n                    throw new IllegalArgumentException(\"Fields invalid for add\");\n                }\n            }\n            valueToAdd -= (min - 1) - values[fieldIndex];\n            values = nextField.add(instant, fieldIndex - 1, values, -1);\n            values[fieldIndex] = getMaximumValue(instant, values);\n        }\n        \n        return set(instant, fieldIndex, values, values[fieldIndex]);  // adjusts smaller fields\n    }\n",
    "new_code_raw": "    public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n        if (valueToAdd == 0) {\n            return values;\n        }\n        // there are more efficient algorithms than this (especially for time only fields)\n        // trouble is when dealing with days and months, so we use this technique of\n        // adding/removing one from the larger field at a time\n        DateTimeField nextField = null;\n        \n        while (valueToAdd > 0) {\n            int max = getMaximumValue(instant, values);\n            long proposed = values[fieldIndex] + valueToAdd;\n            if (proposed <= max) {\n                values[fieldIndex] = (int) proposed;\n                break;\n            }\n            if (nextField == null) {\n                if (fieldIndex == 0) {\n                    throw new IllegalArgumentException(\"Maximum value exceeded for add\");\n                }\n                nextField = instant.getField(fieldIndex - 1);\n                if (getRangeDurationField() != nextField.getDurationField()) {\n                    throw new IllegalArgumentException(\"Fields invalid for add\");\n                }\n            }\n            valueToAdd -= (max + 1) - values[fieldIndex];\n            values = nextField.add(instant, fieldIndex - 1, values, 1);\n            values[fieldIndex] = getMinimumValue(instant, values);\n        }\n        while (valueToAdd < 0) {\n            int min = getMinimumValue(instant, values);\n            long proposed = values[fieldIndex] + valueToAdd;\n            if (proposed >= min) {\n                values[fieldIndex] = (int) proposed;\n                break;\n            }\n            if (nextField == null) {\n                if (fieldIndex == 0) {\n                    throw new IllegalArgumentException(\"Maximum value exceeded for add\");\n                }\n                nextField = instant.getField(fieldIndex - 1);\n                if (getRangeDurationField() != nextField.getDurationField()) {\n                    throw new IllegalArgumentException(\"Fields invalid for add\");\n                }\n            }\n            valueToAdd -= (min - 1) - values[fieldIndex];\n            values = nextField.add(instant, fieldIndex - 1, values, -1);\n            values[fieldIndex] = getMaximumValue(instant, values);\n        }\n        \n        return set(instant, fieldIndex, values, values[fieldIndex]);  // adjusts smaller fields\n    }\n"
  },
  {
    "id": "Netflix_eureka-324-Param-1",
    "old_comment_raw": "@param action the action that indicates the type of replication event - registrations, heartbeat etc",
    "old_code_raw": "    private MessageBatcher getBatcher(String serviceUrl, Action action) {\n        String batcherName = null;\n        try {\n            batcherName = new URL(serviceUrl).getHost();\n        } catch (MalformedURLException e1) {\n            batcherName = serviceUrl;\n        }\n        String absoluteBatcherName = batcherName + \"-\" + action.name();\n        ConfigurationManager.getConfigInstance().setProperty(\n                \"batcher.\" + absoluteBatcherName + \".queue.maxMessages\",\n                config.getMaxElementsInPeerReplicationPool());\n        ConfigurationManager.getConfigInstance().setProperty(\n                \"batcher.\" + absoluteBatcherName + \".keepAliveTime\",\n                config.getMaxIdleThreadAgeInMinutesForPeerReplication() * 60);\n        ConfigurationManager.getConfigInstance().setProperty(\n                \"batcher.\" + absoluteBatcherName + \".maxThreads\",\n                config.getMaxThreadsForPeerReplication());\n\n        return BatcherFactory.createBatcher(absoluteBatcherName,\n                new MessageProcessor<ReplicationTask>() {\n\n                    @Override\n                    public void process(List<ReplicationTask> tasks) {\n                        for (ReplicationTask task : tasks) {\n                            boolean done = true;\n                            do {\n                                done = true;\n                                try {\n                                    Object[] args = {\n                                            task.getAppName(),\n                                            task.getId(),\n                                            task.getAction(),\n                                            new Date(System.currentTimeMillis()),\n                                            new Date(task.getSubmitTime()) };\n                                    if (System.currentTimeMillis()\n                                            - config.getMaxTimeForReplication() > task\n                                            .getSubmitTime()) {\n                                        logger.warn(\n                                                \"Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}\",\n                                                args);\n\n                                        continue;\n                                    }\n                                    task.execute();\n                                } catch (Throwable e) {\n                                    logger.error(\n                                            name + task.getAppName() + \"/\"\n                                                    + task.getId() + \":\"\n                                                    + task.getAction(), e);\n                                    try {\n                                        Thread.sleep(RETRY_SLEEP_TIME_MS);\n                                    } catch (InterruptedException e1) {\n\n                                    }\n                                    if ((isNetworkConnectException(e))) {\n                                        DynamicCounter.increment(task\n                                                .getAction().name()\n                                                + \"_retries\");\n                                        done = false;\n                                    } else {\n                                        logger.info(\n                                                \"Not re-trying this exception because it does not seem to be a network exception\",\n                                                e);\n                                    }\n                                }\n                            } while (!done);\n                        }\n                    }\n                });\n    }\n",
    "new_code_raw": "    private MessageBatcher getBatcher(final String serviceUrl, String pBatcherName) {\n        String batcherName = null;\n        try {\n            batcherName = new URL(serviceUrl).getHost();\n        } catch (MalformedURLException e1) {\n            batcherName = serviceUrl;\n        }\n        String absoluteBatcherName = batcherName + \"-\" + pBatcherName;\n        ConfigurationManager.getConfigInstance().setProperty(\n                \"batcher.\" + absoluteBatcherName + \".queue.maxMessages\",\n                config.getMaxElementsInPeerReplicationPool());\n        ConfigurationManager.getConfigInstance().setProperty(\n                \"batcher.\" + absoluteBatcherName + \".batch.maxMessages\",\n                 250);\n        ConfigurationManager.getConfigInstance().setProperty(\n                \"batcher.\" + absoluteBatcherName + \".keepAliveTime\",\n                config.getMaxIdleThreadAgeInMinutesForPeerReplication() * 60);\n        ConfigurationManager.getConfigInstance().setProperty(\n                \"batcher.\" + absoluteBatcherName + \".maxThreads\",\n                config.getMaxThreadsForPeerReplication());\n\n        return BatcherFactory.createBatcher(absoluteBatcherName,\n                new MessageProcessor<ReplicationTask>() {\n\n            private String BATCH_URL_PATH = \"apps/batch/\";;\n\n            @Override\n            public void process(List<ReplicationTask> tasks) {\n                if (!tasks.get(0).isBatchingSupported()) {\n                    executeSingle(tasks);\n                } else if (!executeBatch(tasks)) {\n                    executeSingle(tasks);\n                }\n            }\n\n            private boolean executeBatch(List<ReplicationTask> tasks) {\n                boolean success = true;\n                boolean done = true;\n                PeerEurekaNode.ReplicationList list = new PeerEurekaNode.ReplicationList();\n                for (ReplicationTask task : tasks) {\n                    Object[] args = { task.getAppName(), task.getId(),\n                            task.getAction(),\n                            new Date(System.currentTimeMillis()),\n                            new Date(task.getSubmitTime()) };\n                    if (System.currentTimeMillis()\n                            - config.getMaxTimeForReplication() > task\n                            .getSubmitTime()) {\n                        logger.warn(\n                                \"Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}\",\n                                args);\n\n                        continue;\n                    }\n                    PeerEurekaNode.ReplicationInstance instance = new PeerEurekaNode.ReplicationInstance();\n                    instance.setAppName(task.getAppName());\n                    instance.setId(task.getId());\n                    InstanceInfo instanceInfo = task.getInstanceInfo();\n                    if (instanceInfo != null) {\n                        String overriddenStatus = (task\n                                .getOverriddenStatus() == null ? null\n                                        : task.getOverriddenStatus().name());\n                        instance.setOverriddenStatus(overriddenStatus);\n                        instance.setLastDirtyTimestamp(instanceInfo\n                                .getLastDirtyTimestamp());\n                        if (task.shouldReplicateInstanceInfo()) {\n                            instance.setInstanceInfo(instanceInfo);\n                        }\n                        String instanceStatus = instanceInfo\n                        .getStatus() == null ? null\n                                : instanceInfo.getStatus().name();\n                        instance.setStatus(instanceStatus);\n                    }\n                    list.addReplicationInstance(instance);\n                }\n                if (list.getList().size() == 0) {\n                    return true;\n                }\n                list.setAction(tasks.get(0).getAction());\n                DynamicCounter.increment(\"Batch_\"\n                        + list.getAction().name()\n\n                        + \"_tries\");\n\n                do {\n                    done = true;\n                    ClientResponse response = null;\n                    try {\n                        response = jerseyApacheClient\n                        .resource(serviceUrl)\n                        .path(BATCH_URL_PATH)\n                        .accept(MediaType.APPLICATION_JSON_TYPE)\n                        .type(MediaType.APPLICATION_JSON_TYPE)\n                        .post(ClientResponse.class, list);\n                        if (isSuccess(response)) {\n                            return false;\n                        }\n                        DynamicCounter.increment(\"Batch_\"\n                                + list.getAction().name()\n\n                                + \"_success\");\n\n                        PeerEurekaNode.ReplicationListResponse batchResponse = response\n                        .getEntity(PeerEurekaNode.ReplicationListResponse.class);\n                        int ctr = 0;\n                        for (PeerEurekaNode.ReplicationInstanceResponse singleResponse : batchResponse\n                                .getResponseList()) {\n                            int statusCode = singleResponse\n                            .getStatusCode();\n                            if ((!isSuccess(response))\n                                    || (singleResponse\n                                    .getResponseEntity() != null)) {\n                                if (singleResponse.getResponseEntity() != null) {\n                                    tasks.get(ctr)\n                                    .setPeerInstanceInfo(\n                                            singleResponse\n                                            .getResponseEntity());\n                                }\n                                tasks.get(ctr)\n                                .handleFailure(statusCode);\n                            }\n\n                            ++ctr;\n                        }\n                        done = true;\n\n                    } catch (Throwable e) {\n\n                        if ((isNetworkConnectException(e))) {\n                            DynamicCounter.increment(\"Batch_\"\n                                    + list.getAction().name()\n\n                                    + \"_retries\");\n                            done = false;\n                        } else {\n                            success = false;\n                            logger.info(\n                                    \"Not re-trying this exception because it does not seem to be a network exception\",\n                                    e);\n                        }\n                    } finally {\n                        if (response != null) {\n                            response.close();\n                        }\n                    }\n                } while (!done);\n                return success;\n            }\n\n            private boolean isSuccess(ClientResponse response) {\n                return response.getStatus() < 200\n                        || response.getStatus() >= 300;\n            }\n\n            private void executeSingle(List<ReplicationTask> tasks) {\n                for (ReplicationTask task : tasks) {\n                    boolean done = true;\n                    do {\n                        done = true;\n                        try {\n                            Object[] args = {\n                                    task.getAppName(),\n                                    task.getId(),\n                                    task.getAction(),\n                                    new Date(System.currentTimeMillis()),\n                                    new Date(task.getSubmitTime()) };\n                            if (System.currentTimeMillis()\n                                    - config.getMaxTimeForReplication() > task\n                                    .getSubmitTime()) {\n                                logger.warn(\n                                        \"Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}\",\n                                        args);\n\n                                continue;\n                            }\n                            DynamicCounter.increment(\"Single_\"\n                                    + task.getAction().name()\n\n                                    + \"_tries\");\n\n                            int statusCode = task.execute();\n                            if (statusCode < 200 && statusCode > 299) {\n                                task.handleFailure(statusCode);\n                            }\n                            DynamicCounter.increment(\"Single_\"\n                                    + task.getAction().name()\n\n                                    + \"_success\");\n\n                        } catch (Throwable e) {\n                            logger.error(\n                                    name + task.getAppName() + \"/\"\n                                    + task.getId() + \":\"\n                                    + task.getAction(), e);\n                            try {\n                                Thread.sleep(RETRY_SLEEP_TIME_MS);\n                            } catch (InterruptedException e1) {\n\n                            }\n                            if ((isNetworkConnectException(e))) {\n                                DynamicCounter.increment(task\n                                        .getAction().name()\n                                        + \"_retries\");\n                                done = false;\n                            } else {\n                                logger.info(\n                                        \"Not re-trying this exception because it does not seem to be a network exception\",\n                                        e);\n                            }\n                        }\n                    } while (!done);\n                }\n            }\n        });\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-1486-Param-0",
    "old_comment_raw": "@param search the string to be searched. The parameter will be interpreted as a regular expression.",
    "old_code_raw": "\tprivate boolean searchForToggleButton(String search, int matches) {\n\t\tsleeper.sleep();\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(search);\n\t\tMatcher matcher;\n\t\tArrayList<ToggleButton> toggleButtonList = viewFetcher.getCurrentViews(ToggleButton.class);\n\t\tif(matches == 0)\n\t\t\tmatches = 1;\n\t\tfor(ToggleButton toggleButton : toggleButtonList){\n\t\t\tmatcher = p.matcher(toggleButton.getText().toString());\n\t\t\tif(matcher.find()){\t\n\t\t\t\tcountMatches++;\n\t\t\t}\n\t\t\tif (countMatches == matches) {\n\t\t\t\tcountMatches=0;\n\t\t\t\treturn true;\n\t\t\t} \n\t\t}\n\n\t\tif (scroller.scroll(Scroller.Direction.DOWN))\n\t\t{\n\t\t\treturn searchForToggleButton(search, matches);\n\t\t} else {\n\t\t\tif(countMatches > 0)\n\t\t\t\tLog.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + search);\n\t\t\tcountMatches = 0;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t}\n",
    "new_code_raw": "\tprivate boolean searchForToggleButton(String regex, int matches) {\n\t\tsleeper.sleep();\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(regex);\n\t\tMatcher matcher;\n\t\tArrayList<ToggleButton> toggleButtonList = viewFetcher.getCurrentViews(ToggleButton.class);\n\t\tif(matches == 0)\n\t\t\tmatches = 1;\n\t\tfor(ToggleButton toggleButton : toggleButtonList){\n\t\t\tmatcher = p.matcher(toggleButton.getText().toString());\n\t\t\tif(matcher.find()){\t\n\t\t\t\tcountMatches++;\n\t\t\t}\n\t\t\tif (countMatches == matches) {\n\t\t\t\tcountMatches=0;\n\t\t\t\treturn true;\n\t\t\t} \n\t\t}\n\n\t\tif (scroller.scroll(Scroller.Direction.DOWN))\n\t\t{\n\t\t\treturn searchForToggleButton(regex, matches);\n\t\t} else {\n\t\t\tif(countMatches > 0)\n\t\t\t\tLog.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + regex);\n\t\t\tcountMatches = 0;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-347-Param-1",
    "old_comment_raw": "@param method The request method, one of \"GET\", \"POST\", \"PUT\", and \"DELETE\"",
    "old_code_raw": "  public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getStatusInfo() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getStatusInfo().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getStatusInfo().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n",
    "new_code_raw": "  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-437-Param-0",
    "old_comment_raw": "@param millis the time instant in millis to query.",
    "old_code_raw": "    public int get(long millis) {\n        // Get an initial estimate of the year, and the millis value\n        // that represents the start of that year.\n        int year = 1970 + (int) (millis / iRoughMillisPerYear);\n        long yearStartMillis = iChronology.getYearMillis(year);\n\n        if (millis > yearStartMillis) {\n            for (;;) {\n                // Actual year may be greater than what we estimated. Check if\n                // year should advance.\n                if (iChronology.isLeapYear(year)) {\n                    yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 366L;\n                } else {\n                    yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 365L;\n                }\n                if (millis < yearStartMillis) {\n                    // Year was correct, no need to advance.\n                    break;\n                }\n                year++;\n                if (millis == yearStartMillis) {\n                    // Millis is at start of year; year is now correct, so no\n                    // need to check anymore.\n                    break;\n                }\n                if ((millis ^ yearStartMillis) < 0) {\n                    // Sign mismatch, operation overflowed.\n                    return getOverflow(millis);\n                }\n            }\n        } else if (millis < yearStartMillis) {\n            for (;;) {\n                // Actual year less than what we estimated. Go to previous year\n                // and check.\n                year--;\n                if (iChronology.isLeapYear(year)) {\n                    yearStartMillis -= DateTimeConstants.MILLIS_PER_DAY * 366L;\n                } else {\n                    yearStartMillis -= DateTimeConstants.MILLIS_PER_DAY * 365L;\n                }\n                if (millis >= yearStartMillis) {\n                    // Year is now correct.\n                    break;\n                }\n                if ((millis ^ yearStartMillis) < 0) {\n                    // Sign mismatch, operation overflowed.\n                    return getOverflow(millis);\n                }\n            }\n        }\n\n        return year;\n    }\n",
    "new_code_raw": "    public int get(long instant) {\n        // Get an initial estimate of the year, and the millis value that\n        // represents the start of that year. Then verify estimate and fix if\n        // necessary.\n\n        int year;\n\n        long unitMillis = getDurationUnitMillis();\n        if (instant >= 0) {\n            year = 1970 + (int) (instant / unitMillis);\n        } else {\n            year = 1970 + (int) ((instant - unitMillis + 1) / unitMillis);\n        }\n\n        long yearStart = iChronology.getYearMillis(year);\n        if ((yearStart ^ instant) < 0) {\n            // Sign mismatch, operation overflowed.\n            return getOverflow(instant);\n        }\n\n        long diff = instant - yearStart;\n\n        if (diff < 0) {\n            // Subtract one year to fix estimate.\n            year--;\n        } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) {\n            // One year may need to be added to fix estimate.\n            long oneYear;\n            if (iChronology.isLeapYear(year)) {\n                oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L;\n            } else {\n                oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L;\n            }\n\n            yearStart += oneYear;\n            if ((yearStart ^ instant) < 0) {\n                // Sign mismatch, operation overflowed.\n                return getOverflow(instant);\n            }\n\n            if (yearStart <= instant) {\n                // Didn't go too far, so actually add one year.\n                year++;\n            }\n        }\n\n        return year;\n    }\n"
  },
  {
    "id": "debezium_debezium-723-Param-1",
    "old_comment_raw": "@param ts the timestamp for this row",
    "old_code_raw": "        public int delete(Object[] row, long ts) throws InterruptedException {\n            return delete(row, ts, 0, 1);\n        }\n",
    "new_code_raw": "        public int delete(Object[] row, Instant ts) throws InterruptedException {\n            return delete(row, ts, 0, 1);\n        }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1624-Param-0",
    "old_comment_raw": "@param p Swagger Property object",
    "old_code_raw": "    public String getTypeDeclaration(Property p) {\n        if (p instanceof ArrayProperty) {\n            ArrayProperty ap = (ArrayProperty) p;\n            Property inner = ap.getItems();\n            return getTypeDeclaration(inner) + \"[]\";\n        } else if (p instanceof MapProperty) {\n            MapProperty mp = (MapProperty) p;\n            Property inner = mp.getAdditionalProperties();\n            // TODO not sure if the following map/hash declaration is correct\n            return \"{String, \" + getTypeDeclaration(inner) + \"}\";\n        } else if (!languageSpecificPrimitives.contains(getSwaggerType(p))) {\n            return packageName + \".Model.\" + super.getTypeDeclaration(p);\n        }\n        return super.getTypeDeclaration(p);\n    }\n",
    "new_code_raw": "    public String getTypeDeclaration(Schema p) {\n        if (ModelUtils.isArraySchema(p)) {\n            ArraySchema ap = (ArraySchema) p;\n            Schema inner = ap.getItems();\n            return getTypeDeclaration(inner) + \"[]\";\n        } else if (ModelUtils.isMapSchema(p)) {\n            Schema inner = (Schema) p.getAdditionalProperties();\n            // TODO not sure if the following map/hash declaration is correct\n            return \"{String, \" + getTypeDeclaration(inner) + \"}\";\n        } else if (!languageSpecificPrimitives.contains(getSchemaType(p))) {\n            return packageName + \".Model.\" + super.getTypeDeclaration(p);\n        }\n        return super.getTypeDeclaration(p);\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-888-Param-0",
    "old_comment_raw": "@param semgrex the pattern string",
    "old_code_raw": "  public static SemgrexPattern compile(String semgrex) {\n    try {\n      SemgrexParser parser = new SemgrexParser(new StringReader(semgrex + \"\\n\"));\n      SemgrexPattern newPattern = parser.Root();\n      newPattern.patternString = semgrex;\n      return newPattern;\n    } catch (ParseException ex) {\n      throw new SemgrexParseException(\"Error parsing semgrex pattern \" + semgrex, ex);\n    } catch (TokenMgrError er) {\n      throw new SemgrexParseException(\"Error parsing semgrex pattern \" + semgrex, er);\n    }\n  }\n",
    "new_code_raw": "  public static SemgrexPattern compile(String semgrex, Env env) {\n    try {\n      SemgrexParser parser = new SemgrexParser(new StringReader(semgrex + \"\\n\"));\n      SemgrexPattern newPattern = parser.Root();\n      newPattern.env = env;\n      newPattern.patternString = semgrex;\n      return newPattern;\n    } catch (ParseException ex) {\n      throw new SemgrexParseException(\"Error parsing semgrex pattern \" + semgrex, ex);\n    } catch (TokenMgrError er) {\n      throw new SemgrexParseException(\"Error parsing semgrex pattern \" + semgrex, er);\n    }\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-430-Param-0",
    "old_comment_raw": "@param millis the time instant in millis to update.",
    "old_code_raw": "    public long set(long millis, int era) {\n        super.verifyValueBounds(era, DateTimeConstants.BCE, DateTimeConstants.CE);\n            \n        int oldEra = get(millis);\n        if (oldEra != era) {\n            int year = iChronology.year().get(millis);\n            return iChronology.year().set(millis, -year);\n        } else {\n            return millis;\n        }\n    }\n",
    "new_code_raw": "    public long set(long instant, int era) {\n        Utils.verifyValueBounds(this, era, DateTimeConstants.BCE, DateTimeConstants.CE);\n            \n        int oldEra = get(instant);\n        if (oldEra != era) {\n            int year = iChronology.year().get(instant);\n            return iChronology.year().set(instant, -year);\n        } else {\n            return instant;\n        }\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-1543-Param-0",
    "old_comment_raw": "@param annotators The annotators the user has requested.",
    "old_code_raw": "  public static String ensurePrerequisiteAnnotators(String[] annotators, Properties props) {\n    // Get an unordered set of annotators\n    Set<String> unorderedAnnotators = new LinkedHashSet<>();  // linked to preserve order\n    Collections.addAll(unorderedAnnotators, annotators);\n    for (String annotator : annotators) {\n      // Add the annotator\n      if (!getNamedAnnotators().containsKey(annotator.toLowerCase())) {\n        throw new IllegalArgumentException(\"Unknown annotator: \" + annotator);\n      }\n\n      // Add its transitive dependencies\n      unorderedAnnotators.add(annotator.toLowerCase());\n      if (!Annotator.DEFAULT_REQUIREMENTS.containsKey(annotator.toLowerCase())) {\n        throw new IllegalArgumentException(\"Cannot infer requirements for annotator: \" + annotator);\n      }\n      Queue<String> fringe = new LinkedList<>(Annotator.DEFAULT_REQUIREMENTS.get(annotator.toLowerCase()));\n      int ticks = 0;\n      while (!fringe.isEmpty()) {\n        ticks += 1;\n        if (ticks == 1000000) {\n          throw new IllegalStateException(\"[INTERNAL ERROR] Annotators have a circular dependency.\");\n        }\n        String prereq = fringe.poll();\n        unorderedAnnotators.add(prereq);\n        fringe.addAll(Annotator.DEFAULT_REQUIREMENTS.get(prereq.toLowerCase()));\n      }\n    }\n\n    // Order the annotators\n    List<String> orderedAnnotators = new ArrayList<>();\n    while (!unorderedAnnotators.isEmpty()) {\n      boolean somethingAdded = false;  // to make sure the dependencies are satisfiable\n      // Loop over candidate annotators to add\n      Iterator<String> iter = unorderedAnnotators.iterator();\n      while (iter.hasNext()) {\n        String candidate = iter.next();\n        // Are the requirements satisfied?\n        boolean canAdd = true;\n        for (String prereq : Annotator.DEFAULT_REQUIREMENTS.get(candidate.toLowerCase())) {\n          if (!orderedAnnotators.contains(prereq)) {\n            canAdd = false;\n            break;\n          }\n        }\n        // If so, add the annotator\n        if (canAdd) {\n          orderedAnnotators.add(candidate);\n          iter.remove();\n          somethingAdded = true;\n        }\n      }\n      // Make sure we're making progress every iteration, to prevent an infinite loop\n      if (!somethingAdded) {\n        throw new IllegalArgumentException(\"Unsatisfiable annotator list: \" + StringUtils.join(annotators, \",\"));\n      }\n    }\n\n    // Remove depparse + parse -- these are redundant\n    if (orderedAnnotators.contains(STANFORD_PARSE) && !ArrayUtils.contains(annotators, STANFORD_DEPENDENCIES)) {\n      orderedAnnotators.remove(STANFORD_DEPENDENCIES);\n    }\n\n    // Tweak the properties, if necessary\n    // (set the mention annotator to use dependency trees, if appropriate)\n    if (orderedAnnotators.contains(Annotator.STANFORD_MENTION) && !orderedAnnotators.contains(Annotator.STANFORD_PARSE) &&\n        !props.containsKey(\"coref.md.type\")) {\n      props.setProperty(\"coref.md.type\", \"dep\");\n    }\n    // (ensure regexner is after ner)\n    if (orderedAnnotators.contains(Annotator.STANFORD_NER) && orderedAnnotators.contains(STANFORD_REGEXNER)) {\n      orderedAnnotators.remove(STANFORD_REGEXNER);\n      int nerIndex = orderedAnnotators.indexOf(Annotator.STANFORD_NER);\n      orderedAnnotators.add(nerIndex + 1, STANFORD_REGEXNER);\n    }\n    // (ensure coref is before openie)\n    if (orderedAnnotators.contains(Annotator.STANFORD_COREF) && orderedAnnotators.contains(STANFORD_OPENIE)) {\n      int maxIndex = Math.max(\n          orderedAnnotators.indexOf(STANFORD_OPENIE),\n          orderedAnnotators.indexOf(STANFORD_COREF)\n          );\n      if (Objects.equals(orderedAnnotators.get(maxIndex), STANFORD_OPENIE)) {\n        orderedAnnotators.add(maxIndex, STANFORD_COREF);\n        orderedAnnotators.remove(STANFORD_COREF);\n      } else {\n        orderedAnnotators.add(maxIndex + 1, STANFORD_OPENIE);\n        orderedAnnotators.remove(STANFORD_OPENIE);\n      }\n    }\n\n    // Return\n    return StringUtils.join(orderedAnnotators, \",\");\n  }\n",
    "new_code_raw": "  public static String ensurePrerequisiteAnnotators(String[] annotators) {\n    // Get an unordered set of annotators\n    Set<String> unorderedAnnotators = new LinkedHashSet<>();  // linked to preserve order\n    Collections.addAll(unorderedAnnotators, annotators);\n    for (String annotator : annotators) {\n      // Add the annotator\n      if (!getNamedAnnotators().containsKey(annotator.toLowerCase())) {\n        throw new IllegalArgumentException(\"Unknown annotator: \" + annotator);\n      }\n\n      // Add its transitive dependencies\n      unorderedAnnotators.add(annotator.toLowerCase());\n      if (!Annotator.DEFAULT_REQUIREMENTS.containsKey(annotator.toLowerCase())) {\n        throw new IllegalArgumentException(\"Cannot infer requirements for annotator: \" + annotator);\n      }\n      Queue<String> fringe = new LinkedList<>(Annotator.DEFAULT_REQUIREMENTS.get(annotator.toLowerCase()));\n      int ticks = 0;\n      while (!fringe.isEmpty()) {\n        ticks += 1;\n        if (ticks == 1000000) {\n          throw new IllegalStateException(\"[INTERNAL ERROR] Annotators have a circular dependency.\");\n        }\n        String prereq = fringe.poll();\n        unorderedAnnotators.add(prereq);\n        fringe.addAll(Annotator.DEFAULT_REQUIREMENTS.get(prereq.toLowerCase()));\n      }\n    }\n\n    // Order the annotators\n    List<String> orderedAnnotators = new ArrayList<>();\n    while (!unorderedAnnotators.isEmpty()) {\n      boolean somethingAdded = false;  // to make sure the dependencies are satisfiable\n      // Loop over candidate annotators to add\n      Iterator<String> iter = unorderedAnnotators.iterator();\n      while (iter.hasNext()) {\n        String candidate = iter.next();\n        // Are the requirements satisfied?\n        boolean canAdd = true;\n        for (String prereq : Annotator.DEFAULT_REQUIREMENTS.get(candidate.toLowerCase())) {\n          if (!orderedAnnotators.contains(prereq)) {\n            canAdd = false;\n            break;\n          }\n        }\n        // If so, add the annotator\n        if (canAdd) {\n          orderedAnnotators.add(candidate);\n          iter.remove();\n          somethingAdded = true;\n        }\n      }\n      // Make sure we're making progress every iteration, to prevent an infinite loop\n      if (!somethingAdded) {\n        throw new IllegalArgumentException(\"Unsatisfiable annotator list: \" + StringUtils.join(annotators, \",\"));\n      }\n    }\n\n    // Return\n    return StringUtils.join(orderedAnnotators, \",\");\n  }\n"
  },
  {
    "id": "querydsl_querydsl-1419-Param-0",
    "old_comment_raw": "@param expr",
    "old_code_raw": "    public Query createQuery(Expr<?> expr1, Expr<?> expr2, Expr<?>... rest){\n        queryMixin.addToProjection(expr1, expr2);\n        queryMixin.addToProjection(rest);\n        String queryString = toString();\n        logQuery(queryString);\n        return createQuery(queryString, queryMixin.getMetadata().getModifiers());\n    }\n",
    "new_code_raw": "    public Query createQuery(Expr<?>[] args){\n        queryMixin.addToProjection(args);\n        String queryString = toString();\n        logQuery(queryString);\n        return createQuery(queryString, queryMixin.getMetadata().getModifiers());\n    }\n"
  },
  {
    "id": "MilosKozak_AndroidAPS-48-Param-0",
    "old_comment_raw": "@param absoluteRate",
    "old_code_raw": "    public PumpEnactResult setTempBasalAbsolute(Double absoluteRate, Integer durationInMinutes) {\n        Double rateAfterConstraints = applyBasalConstraints(absoluteRate);\n        PumpEnactResult result = activePump.setTempBasalAbsolute(rateAfterConstraints, durationInMinutes);\n        if (Config.logCongigBuilderActions)\n            log.debug(\"setTempBasalAbsolute rate: \" + rateAfterConstraints + \" durationInMinutes: \" + durationInMinutes + \" success: \" + result.success + \" enacted: \" + result.enacted);\n        return result;\n    }\n",
    "new_code_raw": "    public PumpEnactResult setTempBasalAbsolute(Double absoluteRate, Integer durationInMinutes, boolean force) {\n        Double rateAfterConstraints = applyBasalConstraints(absoluteRate);\n        PumpEnactResult result = activePump.setTempBasalAbsolute(rateAfterConstraints, durationInMinutes, force);\n        if (Config.logCongigBuilderActions)\n            log.debug(\"setTempBasalAbsolute rate: \" + rateAfterConstraints + \" durationInMinutes: \" + durationInMinutes + \" success: \" + result.success + \" enacted: \" + result.enacted);\n        return result;\n    }\n"
  },
  {
    "id": "hazelcast_hazelcast-613-Associations-Param0",
    "old_comment_raw": "@param pipeline",
    "old_code_raw": "    long getLoad(MigratablePipeline pipeline) {\n        return pipelineLoadCounter.get(pipeline);\n    }\n",
    "new_code_raw": "    long getLoad(MigratableHandler handler) {\n        return handlerLoadCounter.get(handler);\n    }\n\n"
  },
  {
    "id": "apache_drill-1526-Param-1",
    "old_comment_raw": "@param rowCount rows count in column chunk",
    "old_code_raw": "  private boolean hasSingleValue(ColumnMetadata columnChunkMetaData, long rowCount) {\n    return (columnChunkMetaData != null) && (columnChunkMetaData.hasSingleValue(rowCount));\n  }\n",
    "new_code_raw": "  private boolean hasSingleValue(ColumnStatistics columnStatistics, long rowCount) {\n    return columnStatistics != null && isSingleVal(columnStatistics, rowCount);\n  }\n"
  },
  {
    "id": "Rajawali_Rajawali-33-Associations-Param1",
    "old_comment_raw": "@param float y The point y coordinate.",
    "old_code_raw": "\tpublic float distanceTo(float x, float y, float z) {\n\t\tfinal float a = this.x - x;\n\t\tfinal float b = this.y - y;\n\t\tfinal float c = this.z - z;\n\t\treturn (float) Math.sqrt(a * a + b * b + c * c);\n\t}\n",
    "new_code_raw": "\tpublic double distanceTo(double x, double y, double z) {\n\t\tfinal double a = this.x - x;\n\t\tfinal double b = this.y - y;\n\t\tfinal double c = this.z - z;\n\t\treturn Math.sqrt(a * a + b * b + c * c);\n\t}\n\n"
  },
  {
    "id": "Atmosphere_atmosphere-544-Param-0",
    "old_comment_raw": "@param request  HttpServletRequest",
    "old_code_raw": "    public final static AtmosphereRequest cloneRequest(HttpServletRequest request, boolean loadInMemory, boolean copySession, boolean isDestroyable) {\n        Builder b;\n        HttpServletRequest r;\n\n        Cookie[] cs = request.getCookies();\n        Set<Cookie> hs = Collections.synchronizedSet(new HashSet());\n        if (cs != null) {\n            for (Cookie c : cs) {\n                hs.add(c);\n            }\n        }\n\n        boolean isWrapped = false;\n        if (AtmosphereRequest.class.isAssignableFrom(request.getClass())) {\n            b = AtmosphereRequest.class.cast(request).b;\n            isWrapped = true;\n        } else {\n            b = new Builder();\n            b.request(request);\n        }\n\n        HttpSession session = null;\n        if (copySession) {\n            session = request.getSession(true);\n            if (session != null) {\n                session = new FakeHttpSession(session);\n            }\n        }\n\n        b.servletPath(request.getServletPath())\n                .pathInfo(request.getPathInfo())\n                .contextPath(request.getContextPath())\n                .requestURI(request.getRequestURI())\n                .requestURL(request.getRequestURL().toString())\n                .method(request.getMethod())\n                .serverName(request.getServerName())\n                .serverPort(request.getServerPort())\n                .remoteAddr(request.getRemoteAddr())\n                .remoteHost(request.getRemoteHost())\n                .remotePort(request.getRemotePort())\n                .destroyable(isDestroyable)\n                .cookies(hs)\n                .session(session)\n                .principal(request.getUserPrincipal())\n                .authType(request.getAuthType())\n                .isSSecure(request.isSecure());\n\n        if (loadInMemory) {\n            String s = (String) attributeWithoutException(request, FrameworkConfig.THROW_EXCEPTION_ON_CLONED_REQUEST);\n            boolean throwException = s != null && Boolean.parseBoolean(s);\n            r = new NoOpsRequest(throwException);\n            if (isWrapped) {\n                load(b.request, b);\n            } else {\n                load(request, b);\n            }\n            b.request(r);\n        }\n\n        return isWrapped ? AtmosphereRequest.class.cast(request) : b.build();\n    }\n",
    "new_code_raw": "    public final static AtmosphereRequest cloneRequest(HttpServletRequest request, boolean loadInMemory, boolean copySession, boolean isDestroyable, boolean createSession) {\n        Builder b;\n        HttpServletRequest r;\n\n        Cookie[] cs = request.getCookies();\n        Set<Cookie> hs = Collections.synchronizedSet(new HashSet());\n        if (cs != null) {\n            for (Cookie c : cs) {\n                hs.add(c);\n            }\n        }\n\n        boolean isWrapped = false;\n        if (AtmosphereRequest.class.isAssignableFrom(request.getClass())) {\n            b = AtmosphereRequest.class.cast(request).b;\n            isWrapped = true;\n        } else {\n            b = new Builder();\n            b.request(request);\n        }\n\n        HttpSession session = null;\n        if (copySession) {\n            session = request.getSession(createSession);\n            if (session != null) {\n                session = new FakeHttpSession(session);\n            } else {\n                session = new FakeHttpSession(\"\", null, System.currentTimeMillis(), -1);\n            }\n        }\n\n        b.servletPath(request.getServletPath())\n                .pathInfo(request.getPathInfo())\n                .contextPath(request.getContextPath())\n                .requestURI(request.getRequestURI())\n                .requestURL(request.getRequestURL().toString())\n                .method(request.getMethod())\n                .serverName(request.getServerName())\n                .serverPort(request.getServerPort())\n                .remoteAddr(request.getRemoteAddr())\n                .remoteHost(request.getRemoteHost())\n                .remotePort(request.getRemotePort())\n                .destroyable(isDestroyable)\n                .cookies(hs)\n                .session(session)\n                .principal(request.getUserPrincipal())\n                .authType(request.getAuthType())\n                .isSSecure(request.isSecure());\n\n        if (loadInMemory) {\n            String s = (String) attributeWithoutException(request, FrameworkConfig.THROW_EXCEPTION_ON_CLONED_REQUEST);\n            boolean throwException = s != null && Boolean.parseBoolean(s);\n            r = new NoOpsRequest(throwException);\n            if (isWrapped) {\n                load(b.request, b);\n            } else {\n                load(request, b);\n            }\n            b.request(r);\n        }\n\n        return isWrapped ? AtmosphereRequest.class.cast(request) : b.build();\n    }\n"
  },
  {
    "id": "processing_processing-1227-Param-0",
    "old_comment_raw": "@param l a location",
    "old_code_raw": "  protected String locationToString(Location l) {\n    LineID line = locationToLineID(l);\n    int lineNumber;\n    if (line != null) {\n      lineNumber = line.lineIdx() + 1;\n    } else {\n      lineNumber = l.lineNumber();\n    }\n    return l.declaringType().name() + \".\" + l.method().name() + \":\" + lineNumber;\n  }\n",
    "new_code_raw": "  protected String locationToString(Location loc) {\n    LineID line = locationToLineID(loc);\n    int lineNumber = (line != null) ? (line.lineIdx() + 1) : loc.lineNumber();\n    return loc.declaringType().name() + \".\" + loc.method().name() + \":\" + lineNumber;\n  }\n"
  },
  {
    "id": "LawnchairLauncher_Lawnchair-52-Param-2",
    "old_comment_raw": "@param maxPreviewWidth width of the preview on either workspace or tray",
    "old_code_raw": "    private RectF drawBoxWithShadow(Canvas c, int width, int height) {\n        Resources res = mContext.getResources();\n\n        ShadowGenerator.Builder builder = new ShadowGenerator.Builder(Color.WHITE);\n        builder.shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);\n        builder.radius = res.getDimension(R.dimen.widget_preview_corner_radius);\n        builder.keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);\n\n        builder.bounds.set(builder.shadowBlur, builder.shadowBlur,\n                width - builder.shadowBlur,\n                height - builder.shadowBlur - builder.keyShadowDistance);\n        builder.drawShadow(c);\n        return builder.bounds;\n    }\n",
    "new_code_raw": "    private RectF drawBoxWithShadow(Canvas c, Paint p, int width, int height) {\n        Resources res = mContext.getResources();\n        float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);\n        float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);\n        float corner = res.getDimension(R.dimen.widget_preview_corner_radius);\n\n        RectF bounds = new RectF(shadowBlur, shadowBlur,\n                width - shadowBlur, height - shadowBlur - keyShadowDistance);\n        p.setColor(Color.WHITE);\n\n        // Key shadow\n        p.setShadowLayer(shadowBlur, 0, keyShadowDistance,\n                ShadowGenerator.KEY_SHADOW_ALPHA << 24);\n        c.drawRoundRect(bounds, corner, corner, p);\n\n        // Ambient shadow\n        p.setShadowLayer(shadowBlur, 0, 0,\n                ColorUtils.setAlphaComponent(Color.BLACK, ShadowGenerator.AMBIENT_SHADOW_ALPHA));\n        c.drawRoundRect(bounds, corner, corner, p);\n\n        p.clearShadowLayer();\n        return bounds;\n    }\n"
  },
  {
    "id": "eclipse_tcf-91-Associations-Param1",
    "old_comment_raw": "@param target The target node.",
    "old_code_raw": "\tprivate boolean isAncestorOf(Object node, Object target) {\r\n\t\tif (target == null) return false;\r\n\t\tObject parent = getParent(target);\r\n\t\tif (parent == node) return true;\r\n\t\treturn isAncestorOf(node, parent);\r\n   }\r\n",
    "new_code_raw": "\tprivate boolean isAncestorOf(Object object1, Object object2) {\r\n\t\tif (object2 == null) return false;\r\n\t\tObject parent = getParent(object2);\r\n\t\tif (parent == object1) return true;\r\n\t\treturn isAncestorOf(object1, parent);\r\n   }\r\n\n"
  },
  {
    "id": "processing_processing-379-Param-2",
    "old_comment_raw": "@param codeFolderImports",
    "old_code_raw": "  protected int writeImportList(PrintStream out, List<String> imports) {\n    return writeImportList(out, (String[]) imports.toArray(new String[0]));\n  }\n",
    "new_code_raw": "  protected int writeImportList(PrintWriter out, List<String> imports) {\n    return writeImportList(out, (String[]) imports.toArray(new String[0]));\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1704-Param-0",
    "old_comment_raw": "@param outerComposite Input composite as post body (optional)",
    "old_code_raw": "  public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws ApiException {\n    Object localVarPostBody = outerComposite;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/composite\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"*/*\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/composite\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"*/*\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-1151-Param-1",
    "old_comment_raw": "@param values The set of GrammaticalRelations to look for it among.",
    "old_code_raw": "  public static GrammaticalRelation valueOf(String s, Collection<GrammaticalRelation> values) {\n    for (GrammaticalRelation reln : values) {\n      if (reln.toString().equals(s)) return reln;\n    }\n\n    return null;\n  }\n",
    "new_code_raw": "  public static GrammaticalRelation valueOf(String s, Collection<GrammaticalRelation> values, Lock readValuesLock) {\n    readValuesLock.lock();\n    try {\n      for (GrammaticalRelation reln : values) {\n        if (reln.toString().equals(s)) return reln;\n      }\n    } finally {\n      readValuesLock.unlock();\n    }\n\n    return null;\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1645-Param-0",
    "old_comment_raw": "@param body order placed for purchasing the pet (required)",
    "old_code_raw": "  public ApiResponse<Order> placeOrderWithHttpInfo(Order body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling placeOrder\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/store/order\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/xml\", \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Order> localVarReturnType = new GenericType<Order>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public ApiResponse<Order> placeOrderWithHttpInfo(Order order) throws ApiException {\n    Object localVarPostBody = order;\n    \n    // verify the required parameter 'order' is set\n    if (order == null) {\n      throw new ApiException(400, \"Missing the required parameter 'order' when calling placeOrder\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/store/order\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/xml\", \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Order> localVarReturnType = new GenericType<Order>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "gabrielemariotti_cardslib-13-Param-0",
    "old_comment_raw": "@param viewCard",
    "old_code_raw": "    public boolean onExpandStart(CardView viewCard) {\n        Card card = viewCard.getCard();\n        if (card!=null){\n            String itemId = card.getId();\n            if (!mExpandedIds.contains(itemId)) {\n                return true;\n            }\n        }\n        return false;\n    }\n",
    "new_code_raw": "    public boolean onExpandStart(CommonCardView viewCard) {\n        Card card = viewCard.getCard();\n        if (card!=null){\n            String itemId = card.getId();\n            if (!mExpandedIds.contains(itemId)) {\n                return true;\n            }\n        }\n        return false;\n    }\n"
  },
  {
    "id": "dropwizard_dropwizard-38-Associations-Param1",
    "old_comment_raw": "@param urlPattern the URL pattern for requests that should be handled by  servlet",
    "old_code_raw": "    public ServletBuilder addServlet(Servlet servlet,\n                                     String urlPattern) {\n        final ServletHolder holder = new NonblockingServletHolder(checkNotNull(servlet));\n        final ServletBuilder builder = new ServletBuilder(holder, handler);\n        builder.addUrlPattern(checkNotNull(urlPattern));\n        return builder;\n    }\n",
    "new_code_raw": "    public ServletRegistration.Dynamic addServlet(String name, Servlet servlet) {\n        final ServletHolder holder = new NonblockingServletHolder(checkNotNull(servlet));\n        holder.setName(name);\n        handler.getServletHandler().addServlet(holder);\n        return holder.getRegistration();\n    }\n\n"
  },
  {
    "id": "graphql_java_graphql_java-298-Param-0",
    "old_comment_raw": "@param  the type of the result",
    "old_code_raw": "        public Builder(T data) {\n            this.data = data;\n        }\n",
    "new_code_raw": "        public Builder(DataFetcherResult<T> existing) {\n            data = existing.getData();\n            localContext = existing.getLocalContext();\n            errors.addAll(existing.getErrors());\n            mapRelativeErrors = existing.isMapRelativeErrors();\n        }\n"
  },
  {
    "id": "Omegaphora_dalvik-554-Associations-Param0",
    "old_comment_raw": "@param v the long to examine.",
    "old_code_raw": "    public static int bitCount(long v) {\n        // Combines techniques from several sources\n        v -=  (v >>> 1) & 0x5555555555555555L;\n        v = (v & 0x3333333333333333L) + ((v >>> 2) & 0x3333333333333333L);\n        int i =  ((int)(v >>> 32)) + (int) v;\n        i = (i & 0x0F0F0F0F) + ((i >>> 4) & 0x0F0F0F0F);\n        i += i >>> 8;\n        i += i >>> 16;\n        return i  & 0x0000007F;\n    }\n",
    "new_code_raw": "    public static int bitCount(long lng) {\n        lng = (lng & 0x5555555555555555L) + ((lng >> 1) & 0x5555555555555555L);\n        lng = (lng & 0x3333333333333333L) + ((lng >> 2) & 0x3333333333333333L);\n        // adjust for 64-bit integer\n        int i = (int) ((lng >>> 32) + lng);\n        i = (i & 0x0F0F0F0F) + ((i >> 4) & 0x0F0F0F0F);\n        i = (i & 0x00FF00FF) + ((i >> 8) & 0x00FF00FF);\n        i = (i & 0x0000FFFF) + ((i >> 16) & 0x0000FFFF);\n        return i;\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1727-Param-5",
    "old_comment_raw": "@param headerParams The header parameters",
    "old_code_raw": "    public Call buildCall(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n        Request request = buildRequest(path, method, queryParams, collectionQueryParams, body, headerParams, formParams, authNames, progressRequestListener);\n\n        return httpClient.newCall(request);\n    }\n",
    "new_code_raw": "    public Call buildCall(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {\n        Request request = buildRequest(path, method, queryParams, collectionQueryParams, body, headerParams, formParams, authNames, callback);\n\n        return httpClient.newCall(request);\n    }\n"
  },
  {
    "id": "codehaus_cake-8-Associations-Param0",
    "old_comment_raw": "@param attributes an object containing an AttributeMap",
    "old_code_raw": "    public float get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n",
    "new_code_raw": "    public float get(WithAttributes withAttributes) {\r\n        return withAttributes.getAttributes().get(this);\r\n    }\r\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-286-Param-7",
    "old_comment_raw": "@param contentType The request's Content-Type header",
    "old_code_raw": "  public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n",
    "new_code_raw": "  public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n"
  },
  {
    "id": "apache_calcite-937-Param-0",
    "old_comment_raw": "@param withClone Whether to create a \"foodmart2\" schema as in-memory clone",
    "old_code_raw": "  static OptiqConnection getConnection(boolean withClone)\n      throws ClassNotFoundException, SQLException {\n    Class.forName(\"net.hydromatic.optiq.jdbc.Driver\");\n    Connection connection = DriverManager.getConnection(\"jdbc:optiq:\");\n    OptiqConnection optiqConnection =\n        connection.unwrap(OptiqConnection.class);\n    final SchemaPlus rootSchema = optiqConnection.getRootSchema();\n    addSchema(rootSchema, SchemaSpec.JDBC_FOODMART);\n    if (withClone) {\n      addSchema(rootSchema, SchemaSpec.CLONE_FOODMART);\n    }\n    optiqConnection.setSchema(\"foodmart2\");\n    return optiqConnection;\n  }\n",
    "new_code_raw": "  static OptiqConnection getConnection(SchemaSpec schemaSpec)\n      throws ClassNotFoundException, SQLException {\n    Class.forName(\"net.hydromatic.optiq.jdbc.Driver\");\n    Connection connection = DriverManager.getConnection(\"jdbc:optiq:\");\n    OptiqConnection optiqConnection =\n        connection.unwrap(OptiqConnection.class);\n    final SchemaPlus rootSchema = optiqConnection.getRootSchema();\n    switch (schemaSpec) {\n    case JDBC_FOODMART:\n      addSchema(rootSchema, schemaSpec);\n      break;\n    case CLONE_FOODMART:\n    case JDBC_FOODMART_WITH_LATTICE:\n      addSchema(rootSchema, SchemaSpec.JDBC_FOODMART);\n      addSchema(rootSchema, schemaSpec);\n      break;\n    default:\n      throw new AssertionError(\"unknown schema \" + schemaSpec);\n    }\n    optiqConnection.setSchema(\"foodmart2\");\n    return optiqConnection;\n  }\n"
  },
  {
    "id": "RobotiumTech_robotium-262-Param-1",
    "old_comment_raw": "@param direction the direction to be scrolled",
    "old_code_raw": "\tpublic boolean scrollList(int listIndex, Direction direction) {\n\t\tint[] xy = new int[2];\n\t\tfinal ListView listView = viewFetcher.getCurrentViews(ListView.class).get(listIndex);\n\t\tlistView.getLocationOnScreen(xy);\n\t\n\t\twhile (xy[1] + 20 > activityUtils.getCurrentActivity(false)\n\t\t\t\t.getWindowManager().getDefaultDisplay().getHeight()) {\n\t\t\tscrollScrollView(direction);\n\t\t\tlistView.getLocationOnScreen(xy);\n\t\t}\n\t\tif (direction == Direction.DOWN) {\n\t\t\t\n\t\t\tif (listView.getLastVisiblePosition() >= listView.getCount() - 1) \n\t\t\t\treturn false;\n\t\t\t\n\t\t\tscrollListToLine(listView, listView.getLastVisiblePosition()+1);\n\t\t\t\n\t\t} else if (direction == Direction.UP) {\n\t\t\t\n\t\t\tif (listView.getFirstVisiblePosition() < 2) \n\t\t\t\treturn false;\n\t\t\t\n\t\t\tfinal int lines = (listView.getLastVisiblePosition()+1)-(listView.getFirstVisiblePosition());\n\t\t\tint lineToScrollTo = listView.getFirstVisiblePosition() - lines;\n\t\t\tif(lineToScrollTo < 0)\n\t\t\t\tlineToScrollTo=0;\n\t\t\t\n\t\t\tscrollListToLine(listView, lineToScrollTo);\n\t\t}\t\n\t\tsleeper.sleep();\n\t\treturn true;\n\t}\n",
    "new_code_raw": "\tpublic boolean scrollList(int listIndex, Direction direction, ArrayList<ListView> listViews) {\n\t\tint[] xy = new int[2];\n\t\tfinal ListView listView = getView(ListView.class, listViews, listIndex);\n\t\t\n\t\tlistView.getLocationOnScreen(xy);\n\t\n\t\twhile (xy[1] + 20 > activityUtils.getCurrentActivity(false)\n\t\t\t\t.getWindowManager().getDefaultDisplay().getHeight()) {\n\t\t\tscrollScrollView(direction, null);\n\t\t\tlistView.getLocationOnScreen(xy);\n\t\t}\n\t\tif (direction == Direction.DOWN) {\n\t\t\t\n\t\t\tif (listView.getLastVisiblePosition() >= listView.getCount() - 1) \n\t\t\t\treturn false;\n\t\t\t\n\t\t\tscrollListToLine(listView, listView.getLastVisiblePosition()+1);\n\t\t\t\n\t\t} else if (direction == Direction.UP) {\n\t\t\t\n\t\t\tif (listView.getFirstVisiblePosition() < 2) \n\t\t\t\treturn false;\n\t\t\t\n\t\t\tfinal int lines = (listView.getLastVisiblePosition()+1)-(listView.getFirstVisiblePosition());\n\t\t\tint lineToScrollTo = listView.getFirstVisiblePosition() - lines;\n\t\t\tif(lineToScrollTo < 0)\n\t\t\t\tlineToScrollTo=0;\n\t\t\t\n\t\t\tscrollListToLine(listView, lineToScrollTo);\n\t\t}\t\n\t\tsleeper.sleep();\n\t\treturn true;\n\t}\n"
  },
  {
    "id": "querydsl_querydsl-1443-Param-2",
    "old_comment_raw": "@param minimumSimilarity",
    "old_code_raw": "    public static BooleanExpression fuzzyLike(Path<String> path, String value, float minimumSimilarity) {\n        Term term = new Term(path.getMetadata().getName(), value);\n        return new QueryElement(new FuzzyQuery(term, minimumSimilarity));\n    }\n",
    "new_code_raw": "    public static BooleanExpression fuzzyLike(Path<String> path, String value, int maxEdits) {\n        Term term = new Term(path.getMetadata().getName(), value);\n        return new QueryElement(new FuzzyQuery(term, maxEdits));\n    }\n"
  },
  {
    "id": "Atmosphere_atmosphere-876-Param-1",
    "old_comment_raw": "@param defaultValue",
    "old_code_raw": "    public String getInitParameter(String key, String defaultValue) {\n        String s = getInitParameter(key);\n        if (s == null) {\n            return defaultValue;\n        }\n        return s;\n    }\n",
    "new_code_raw": "    public boolean getInitParameter(String key, boolean defaultValue) {\n        String s = getInitParameter(key);\n        if (s == null) {\n            return defaultValue;\n        }\n        return Boolean.valueOf(s);\n    }\n"
  },
  {
    "id": "processing_processing-251-Param-0",
    "old_comment_raw": "@param fd",
    "old_code_raw": "  private int getJavadocOffset(FieldDeclaration fd){\n    List<ASTNode> list= fd.modifiers();\n    SimpleName sn = (SimpleName) getNode();\n    \n    Type tp = fd.getType();\n    int lineNum = getLineNumber(sn);\n    log(\"SN \"+sn + \", \" + lineNum);\n    for (ASTNode astNode : list) {\n      if(getLineNumber(astNode) == lineNum)\n      {\n        log(\"first node in that line \" + astNode);\n        log(\"diff \" + (sn.getStartPosition() - astNode.getStartPosition()));\n        return (astNode.getStartPosition());\n      }\n    }\n    if(getLineNumber(fd.getType()) == lineNum)\n    {\n      log(\"first node in that line \" + tp);\n      log(\"diff \" + (sn.getStartPosition() - tp.getStartPosition()));\n      return (tp.getStartPosition());\n    }\n    \n    \n    return 0;   \n  }\n",
    "new_code_raw": "  private int getJavadocOffset(MethodDeclaration md) {\n    List<ASTNode> list = md.modifiers();\n    SimpleName sn = (SimpleName) getNode();\n    int lineNum = getLineNumber(sn);\n    log(\"SN \" + sn + \", \" + lineNum);\n    \n    for (ASTNode astNode : list) {\n      if (getLineNumber(astNode) == lineNum) {\n        log(\"first node in that line \" + astNode);\n        log(\"diff \" + (sn.getStartPosition() - astNode.getStartPosition()));\n        return (astNode.getStartPosition());\n      }\n    }\n    \n    if (!md.isConstructor()) {\n      Type tp = md.getReturnType2();\n      if (getLineNumber(tp) == lineNum) {\n        log(\"first node in that line \" + tp);\n        log(\"diff \" + (sn.getStartPosition() - tp.getStartPosition()));\n        return (tp.getStartPosition());\n      }\n    }\n    \n    return 0;\n  }\n"
  },
  {
    "id": "RobotiumTech_robotium-233-Param-3",
    "old_comment_raw": "@param scroll whether scrolling should be performed",
    "old_code_raw": "\tpublic boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll) {\n\t\tfinal long endTime = System.currentTimeMillis() + TIMEOUT;\n\n\t\twhile (System.currentTimeMillis() < endTime) {\n\t\t\tsleeper.sleep();\n\t\t\tfinal boolean foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, scroll);\n\t\t\tif (foundAnyMatchingView){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n",
    "new_code_raw": "\tpublic boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll, boolean visible) {\n\t\tfinal long endTime = System.currentTimeMillis() + TIMEOUT;\n\n\t\twhile (System.currentTimeMillis() < endTime) {\n\t\t\tsleeper.sleep();\n\t\t\tfinal boolean foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, scroll, visible);\n\t\t\tif (foundAnyMatchingView){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n"
  },
  {
    "id": "JodaOrg_joda_time-1086-Param-0",
    "old_comment_raw": "@param millis the time instant in millis to query",
    "old_code_raw": "    public int get(long millis) {\n        // 1970-01-01 is day of week 4, Thursday.\n\n        long daysSince19700101;\n        if (millis >= 0) {\n            daysSince19700101 = millis / DateTimeConstants.MILLIS_PER_DAY;\n        } else {\n            daysSince19700101 = (millis - (DateTimeConstants.MILLIS_PER_DAY - 1))\n                / DateTimeConstants.MILLIS_PER_DAY;\n            if (daysSince19700101 < -3) {\n                return 7 + (int) ((daysSince19700101 + 4) % 7);\n            }\n        }\n\n        return 1 + (int) ((daysSince19700101 + 3) % 7);\n    }\n",
    "new_code_raw": "    public int get(long instant) {\n        // 1970-01-01 is day of week 4, Thursday.\n\n        long daysSince19700101;\n        if (instant >= 0) {\n            daysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY;\n        } else {\n            daysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1))\n                / DateTimeConstants.MILLIS_PER_DAY;\n            if (daysSince19700101 < -3) {\n                return 7 + (int) ((daysSince19700101 + 4) % 7);\n            }\n        }\n\n        return 1 + (int) ((daysSince19700101 + 3) % 7);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-930-Param-1",
    "old_comment_raw": "@param name Updated name of the pet",
    "old_code_raw": "  public void updatePetWithForm (String petId, String name, String status) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = null;\n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'petId' when calling updatePetWithForm\",\n        new ApiException(400, \"Missing the required parameter 'petId' when calling updatePetWithForm\"));\n    }\n\n    // create path and map variables\n    String path = \"/pet/{petId}\".replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString()));\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n      \"application/x-www-form-urlencoded\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      if (name != null) {\n        localVarBuilder.addTextBody(\"name\", ApiInvoker.parameterToString(name), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      if (status != null) {\n        localVarBuilder.addTextBody(\"status\", ApiInvoker.parameterToString(status), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n      formParams.put(\"name\", ApiInvoker.parameterToString(name));\n      formParams.put(\"status\", ApiInvoker.parameterToString(status));\n    }\n\n    String[] authNames = new String[] { \"petstore_auth\" };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n       if (ex.getCause() instanceof VolleyError) {\n         VolleyError volleyError = (VolleyError)ex.getCause();\n         if (volleyError.networkResponse != null) {\n           throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n         }\n       }\n       throw ex;\n    } catch (TimeoutException ex) {\n       throw ex;\n    }\n  }\n",
    "new_code_raw": "  public void updatePetWithForm (Long petId, String name, String status) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = null;\n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'petId' when calling updatePetWithForm\",\n        new ApiException(400, \"Missing the required parameter 'petId' when calling updatePetWithForm\"));\n    }\n\n    // create path and map variables\n    String path = \"/pet/{petId}\".replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString()));\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n      \"application/x-www-form-urlencoded\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      if (name != null) {\n        localVarBuilder.addTextBody(\"name\", ApiInvoker.parameterToString(name), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      if (status != null) {\n        localVarBuilder.addTextBody(\"status\", ApiInvoker.parameterToString(status), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n      formParams.put(\"name\", ApiInvoker.parameterToString(name));\n      formParams.put(\"status\", ApiInvoker.parameterToString(status));\n    }\n\n    String[] authNames = new String[] { \"petstore_auth\" };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n"
  },
  {
    "id": "Atmosphere_atmosphere-835-Param-0",
    "old_comment_raw": "@param queryString",
    "old_code_raw": "    public AtmosphereRequest queryString(String queryString) {\n\n        if (queryString == null) return this;\n\n        // Don't override the builder\n        String qs = queryString;\n        if (qs.isEmpty()) {\n            qs = b.queryString;\n        }\n        if (!qs.isEmpty()) {\n            QueryStringDecoder decoder = new QueryStringDecoder(getRequestURI() + \"?\" + qs);\n            Map<String, List<String>> m = decoder.getParameters();\n            Map<String, String[]> newM = new HashMap<String, String[]>();\n            for (Map.Entry<String, List<String>> q : m.entrySet()) {\n                newM.put(q.getKey(), q.getValue().toArray(new String[q.getValue().size()]));\n            }\n            b.queryStrings(newM);\n            b.queryString = qs;\n        }\n        return this;\n    }\n",
    "new_code_raw": "    public AtmosphereRequest queryString(String qs) {\n\n        if (qs == null) return this;\n\n        if (!qs.isEmpty()) {\n            QueryStringDecoder decoder = new QueryStringDecoder(getRequestURI() + \"?\" + qs);\n            Map<String, List<String>> m = decoder.getParameters();\n            Map<String, String[]> newM = new HashMap<String, String[]>();\n            for (Map.Entry<String, List<String>> q : m.entrySet()) {\n                newM.put(q.getKey(), q.getValue().toArray(new String[q.getValue().size()]));\n            }\n            b.queryStrings(newM);\n        }\n        b.queryString = qs;\n        return this;\n    }\n"
  },
  {
    "id": "querydsl_querydsl-1434-Param-1",
    "old_comment_raw": "@param right",
    "old_code_raw": "    public static EBoolean endsWith(Expr<String> left, Expr<String> right, boolean caseSensitive) {\n        if (caseSensitive){\n            return endsWith(left, right);            \n        }else{\n            return operationFactory.createBoolean(Ops.ENDSWITH_IC, left, right);\n        }\n    }\n",
    "new_code_raw": "    public static EBoolean endsWith(Expr<String> left, Expr<String> right) {\n        return operationFactory.createBoolean(Ops.ENDSWITH, left, right);\n    }\n"
  },
  {
    "id": "Rajawali_Rajawali-62-Associations-Param2",
    "old_comment_raw": "@param double z The point z coordinate.",
    "old_code_raw": "\tpublic double distanceTo(double x, double y, double z) {\n\t\tfinal double a = this.x - x;\n\t\tfinal double b = this.y - y;\n\t\tfinal double c = this.z - z;\n\t\treturn Math.sqrt(a * a + b * b + c * c);\n\t}\n",
    "new_code_raw": "\tpublic float distanceTo(float x, float y, float z) {\n\t\tfinal float a = this.x - x;\n\t\tfinal float b = this.y - y;\n\t\tfinal float c = this.z - z;\n\t\treturn (float) Math.sqrt(a * a + b * b + c * c);\n\t}\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-1202-Param-3",
    "old_comment_raw": "@param position The position from which to start binding value(s).",
    "old_code_raw": "\tpublic int bind(PreparedStatement statement, QueryParameters qp, SessionImplementor session, int position) throws SQLException {\n\t\tType type = qp.getPositionalParameterTypes()[hqlPosition];\n\t\tObject value = qp.getPositionalParameterValues()[hqlPosition];\n\n\t\ttype.nullSafeSet( statement, value, position, session );\n\t\treturn type.getColumnSpan( session.getFactory() );\n\t}\n",
    "new_code_raw": "\tpublic int bind(PreparedStatement statement, QueryParameters qp, SharedSessionContractImplementor session, int position) throws SQLException {\n\t\tType type = qp.getPositionalParameterTypes()[hqlPosition];\n\t\tObject value = qp.getPositionalParameterValues()[hqlPosition];\n\n\t\ttype.nullSafeSet( statement, value, position, session );\n\t\treturn type.getColumnSpan( session.getFactory() );\n\t}\n"
  },
  {
    "id": "RobotiumTech_robotium-1193-Param-2",
    "old_comment_raw": "@param visible  true if only  Buttons visible on the screen should be searched",
    "old_code_raw": "\tpublic boolean searchButton(String text, int minimumNumberOfMatches, boolean visible) {\n\t\tboolean found = searcher.searchWithTimeoutFor(Button.class, text, minimumNumberOfMatches, true, visible);\n\t\treturn found;\n\t}\n",
    "new_code_raw": "\tpublic boolean searchButton(String text, int minimumNumberOfMatches, boolean onlyVisible) {\n\t\tboolean found = searcher.searchWithTimeoutFor(Button.class, text, minimumNumberOfMatches, true, onlyVisible);\n\t\treturn found;\n\t}\n"
  },
  {
    "id": "hibernate_hibernate_orm-1201-Param-2",
    "old_comment_raw": "@param hasTransformer Does this query have an associated  org.hibernate.transform.ResultTransformer",
    "old_code_raw": "\tpublic Object buildResultRow(Object[] data, ResultSet resultSet, boolean hasTransformer, SessionImplementor session)\n\t\t\tthrows SQLException, HibernateException {\n\t\tfinal Object[] resultRow = buildResultRow( data, resultSet, session );\n\t\tif ( hasTransformer ) {\n\t\t\treturn resultRow;\n\t\t}\n\t\telse {\n\t\t\treturn resultRow.length == 1\n\t\t\t\t\t? resultRow[0]\n\t\t\t\t\t: resultRow;\n\t\t}\n\t}\n",
    "new_code_raw": "\tpublic Object buildResultRow(Object[] data, ResultSet resultSet, boolean hasTransformer, SharedSessionContractImplementor session)\n\t\t\tthrows SQLException, HibernateException {\n\t\tfinal Object[] resultRow = buildResultRow( data, resultSet, session );\n\t\tif ( hasTransformer ) {\n\t\t\treturn resultRow;\n\t\t}\n\t\telse {\n\t\t\treturn resultRow.length == 1\n\t\t\t\t\t? resultRow[0]\n\t\t\t\t\t: resultRow;\n\t\t}\n\t}\n"
  },
  {
    "id": "rstudio_rstudio-130-Param-0",
    "old_comment_raw": "@param terminalClosing index of terminal being closed",
    "old_code_raw": "   private int terminalToShowWhenClosing(int terminalClosing)\n   {\n      if (terminalClosing > 0)\n         return terminalClosing - 1;\n      else if (terminalClosing + 1 < getTerminalCount())\n         return terminalClosing + 1;\n      else\n         return -1;\n   }\n",
    "new_code_raw": "   private String terminalToShowWhenClosing(String handle)\n   {\n      int terminalClosing = terminals_.indexOfTerminal(handle);\n      if (terminalClosing > 0)\n         return terminals_.terminalHandleAtIndex(terminalClosing - 1);\n      else if (terminalClosing + 1 < terminals_.terminalCount())\n         return terminals_.terminalHandleAtIndex(terminalClosing + 1);\n      else\n         return null;\n   }\n"
  },
  {
    "id": "debezium_debezium-718-Param-0",
    "old_comment_raw": "@param row the values of the row, in the same order as the columns in the  Table definition in the  MySqlSchema.",
    "old_code_raw": "        public int read(Object[] row, long ts, int rowNumber, int numberOfRows) throws InterruptedException {\n            return converter.read(source, row, rowNumber, numberOfRows, includedColumns, ts, consumer);\n        }\n",
    "new_code_raw": "        public int read(Object[] row, Instant ts, int rowNumber, int numberOfRows) throws InterruptedException {\n            return converter.read(source, row, rowNumber, numberOfRows, includedColumns, ts, consumer);\n        }\n"
  },
  {
    "id": "zaproxy_zaproxy-2306-Param-0",
    "old_comment_raw": "@param e",
    "old_code_raw": "        private ScanProgressActionIcon getScanProgressAction(MouseEvent e) {\n            TableColumnModel columnModel = table.getColumnModel();\n            int column = columnModel.getColumnIndexAtX(e.getX());\n            int row = e.getY() / table.getRowHeight();\n\n            if ((row < table.getRowCount()) && (row >= 0) && \n                (column < table.getColumnCount()) && (column >= 0)) {\n\n                Object value = table.getValueAt(row, column);\n                if (value instanceof ScanProgressActionIcon) {\n                    return (ScanProgressActionIcon)value;\n                }\n            }\n            \n            return null;\n        }        \n",
    "new_code_raw": "        private ScanProgressActionIcon getScanProgressAction(Point point) {\n            int column = table.columnAtPoint(point);\n            if (column == NOT_FOUND) {\n                return null;\n            }\n\n            int row = table.rowAtPoint(point);\n            if (row == NOT_FOUND) {\n                return null;\n            }\n\n            Object value = table.getValueAt(row, column);\n            if (value instanceof ScanProgressActionIcon) {\n                return (ScanProgressActionIcon)value;\n            }\n            \n            return null;\n        }        \n"
  },
  {
    "id": "graphql_java_graphql_java-377-Param-0",
    "old_comment_raw": "@param parameters the parameters to this method",
    "old_code_raw": "    private void collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet, List<String> visitedFragments, Map<String, MergedFields> fields) {\n\n        for (Selection selection : selectionSet.getSelections()) {\n            if (selection instanceof Field) {\n                collectField(parameters, fields, (Field) selection);\n            } else if (selection instanceof InlineFragment) {\n                collectInlineFragment(parameters, visitedFragments, fields, (InlineFragment) selection);\n            } else if (selection instanceof FragmentSpread) {\n                collectFragmentSpread(parameters, visitedFragments, fields, (FragmentSpread) selection);\n            }\n        }\n    }\n",
    "new_code_raw": "    public MergedSelectionSet collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet) {\n        Map<String, MergedFields> subFields = new LinkedHashMap<>();\n        List<String> visitedFragments = new ArrayList<>();\n        this.collectFields(parameters, selectionSet, visitedFragments, subFields);\n        return newMergedSelectionSet().subFields(subFields).build();\n    }\n"
  },
  {
    "id": "eclipse_rt.equinox.bundles-63-Associations-Param0",
    "old_comment_raw": "@param handler the type handler instance. It may have been obtained using  STextTypeHandlerFactory#getHandler(String) or by instantiating a type handler.",
    "old_code_raw": "\tstatic public ISTextExpert getStatefulExpert(STextTypeHandler handler, STextEnvironment environment) {\n\t\tif (environment == null)\n\t\t\tenvironment = STextEnvironment.DEFAULT;\n\t\treturn new STextImpl(handler, environment, true);\n\t}\n",
    "new_code_raw": "\tstatic public IStructuredTextExpert getStatefulExpert(StructuredTextTypeHandler handler, StructuredTextEnvironment environment) {\n\t\tif (environment == null)\n\t\t\tenvironment = StructuredTextEnvironment.DEFAULT;\n\t\treturn new StructuredTextImpl(handler, environment, true);\n\t}\n\n"
  },
  {
    "id": "debezium_debezium-1246-Param-2",
    "old_comment_raw": "@param resultConsumer the consumer of the query results",
    "old_code_raw": "    public JdbcConnection prepareQuery(String[] multiQuery, StatementPreparer preparer, BlockingMultiResultSetConsumer resultConsumer) throws SQLException, InterruptedException {\n        final Connection conn = connection();\n        final ResultSet[] resultSets = new ResultSet[multiQuery.length];\n        final PreparedStatement[] preparedStatements = new PreparedStatement[multiQuery.length];\n\n        try {\n            for (int i = 0; i < multiQuery.length; i++) {\n                final String query = multiQuery[i];\n                if (LOGGER.isTraceEnabled()) {\n                    LOGGER.trace(\"running '{}'\", query);\n                }\n                final PreparedStatement statement = createPreparedStatement(query);\n                preparedStatements[i] = statement;\n                preparer.accept(statement);\n                resultSets[i] = statement.executeQuery();\n            }\n            if (resultConsumer != null) {\n                resultConsumer.accept(resultSets);\n            }\n        }\n        finally {\n            for (ResultSet rs: resultSets) {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    }\n                    catch (Exception ei) {\n                    }\n                }\n            }\n        }\n        return this;\n    }\n",
    "new_code_raw": "    public JdbcConnection prepareQuery(String[] multiQuery, StatementPreparer[] preparers, BlockingMultiResultSetConsumer resultConsumer) throws SQLException, InterruptedException {\n        final ResultSet[] resultSets = new ResultSet[multiQuery.length];\n        final PreparedStatement[] preparedStatements = new PreparedStatement[multiQuery.length];\n\n        try {\n            for (int i = 0; i < multiQuery.length; i++) {\n                final String query = multiQuery[i];\n                if (LOGGER.isTraceEnabled()) {\n                    LOGGER.trace(\"running '{}'\", query);\n                }\n                final PreparedStatement statement = createPreparedStatement(query);\n                preparedStatements[i] = statement;\n                preparers[i].accept(statement);\n                resultSets[i] = statement.executeQuery();\n            }\n            if (resultConsumer != null) {\n                resultConsumer.accept(resultSets);\n            }\n        }\n        finally {\n            for (ResultSet rs: resultSets) {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    }\n                    catch (Exception ei) {\n                    }\n                }\n            }\n        }\n        return this;\n    }\n"
  },
  {
    "id": "debezium_debezium-1300-Param-1",
    "old_comment_raw": "@param adjuster the optional component that adjusts the local date value before obtaining the epoch day; may be null if no adjustment is necessary",
    "old_code_raw": "    public static long toNanoOfDay(Object value, TemporalAdjuster adjuster) {\n        LocalTime time = Conversions.toLocalTime(value);\n        if (adjuster !=null) {\n            time = time.with(adjuster);\n        }\n        return time.toNanoOfDay();\n    }\n",
    "new_code_raw": "    public static long toNanoOfDay(Object value, boolean acceptLargeValues) {\n        if (value instanceof Duration) {\n            Duration duration = (Duration) value;\n            if (!acceptLargeValues && (duration.isNegative() || duration.compareTo(ONE_DAY) > 0)) {\n                throw new IllegalArgumentException(\"Time values must be between 00:00:00 and 24:00:00 (inclusive): \" + duration);\n            }\n\n            return ((Duration) value).toNanos();\n        }\n\n        // TODO only needed for SQL Server/Oracle, where we don't produce Duration right away;\n        // this should go eventually, as the conversion to LocalTime is superfluous\n        LocalTime time = Conversions.toLocalTime(value);\n        return time.toNanoOfDay();\n    }\n"
  },
  {
    "id": "runelite_runelite-26-Param-0",
    "old_comment_raw": "@param client",
    "old_code_raw": "\tpublic static Point getCanvasSpriteLocation(Client client, Graphics2D graphics, Point localLocation, SpritePixels sprite, int zOffset)\n\t{\n\t\tint plane = client.getPlane();\n\n\t\tPoint p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset);\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tint xOffset = p.getX() - sprite.getWidth() / 2;\n\t\tint yOffset = p.getY() - sprite.getHeight() / 2;\n\n\t\treturn new Point(xOffset, yOffset);\n\t}\n",
    "new_code_raw": "\tpublic static Point getCanvasSpriteLocation(Client client, Graphics2D graphics, LocalPoint localLocation, SpritePixels sprite, int zOffset)\n\t{\n\t\tint plane = client.getPlane();\n\n\t\tPoint p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset);\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tint xOffset = p.getX() - sprite.getWidth() / 2;\n\t\tint yOffset = p.getY() - sprite.getHeight() / 2;\n\n\t\treturn new Point(xOffset, yOffset);\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1719-Param-0",
    "old_comment_raw": "@param client client model",
    "old_code_raw": "    public Mono<Client> call123testSpecialTags(Client client) throws RestClientException {\n        Object postBody = client;\n        \n        // verify the required parameter 'client' is set\n        if (client == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'client' when calling call123testSpecialTags\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"/another-fake/dummy\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "new_code_raw": "    public Mono<Client> call123testSpecialTags(Client body) throws RestClientException {\n        Object postBody = body;\n        \n        // verify the required parameter 'body' is set\n        if (body == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling call123testSpecialTags\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"/another-fake/dummy\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1556-Param-5",
    "old_comment_raw": "@param formParams The form parameters",
    "old_code_raw": "  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    final String url = buildUrl(path, queryParams);\n    final Request.Builder reqBuilder = new Request.Builder().url(url);\n    processHeaderParams(headerParams, reqBuilder);\n\n    String contentType = (String) headerParams.get(\"Content-Type\");\n    // ensuring a default content type\n    if (contentType == null) {\n      contentType = \"application/json\";\n    }\n\n    RequestBody reqBody;\n    if (!HttpMethod.permitsRequestBody(method)) {\n      reqBody = null;\n    } else if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n      reqBody = buildRequestBodyFormEncoding(formParams);\n    } else if (\"multipart/form-data\".equals(contentType)) {\n      reqBody = buildRequestBodyMultipart(formParams);\n    } else if (body == null) {\n      if (\"DELETE\".equals(method)) {\n        // allow calling DELETE without sending a request body\n        reqBody = null;\n      } else {\n        // use an empty request body (for POST, PUT and PATCH)\n        reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n      }\n    } else {\n      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));\n    }\n\n    Request request = null;\n\n    if(progressRequestListener != null && reqBody != null) {\n      ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener);\n      request = reqBuilder.method(method, progressRequestBody).build();\n    } else {\n      request = reqBuilder.method(method, reqBody).build();\n    }\n\n    return httpClient.newCall(request);\n  }\n",
    "new_code_raw": "  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    final String url = buildUrl(path, queryParams);\n    final Request.Builder reqBuilder = new Request.Builder().url(url);\n    processHeaderParams(headerParams, reqBuilder);\n\n    String contentType = (String) headerParams.get(\"Content-Type\");\n    // ensuring a default content type\n    if (contentType == null) contentType = \"application/json\";\n\n    RequestBody reqBody;\n    if (!HttpMethod.permitsRequestBody(method)) {\n      reqBody = null;\n    } else if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n      reqBody = buildRequestBodyFormEncoding(formParams);\n    } else if (\"multipart/form-data\".equals(contentType)) {\n      reqBody = buildRequestBodyMultipart(formParams);\n    } else if (body == null) {\n      if (\"DELETE\".equals(method)) {\n        // allow calling DELETE without sending a request body\n        reqBody = null;\n      } else {\n        // use an empty request body (for POST, PUT and PATCH)\n        reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n      }\n    } else {\n      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));\n    }\n\n    Request request = reqBuilder.method(method, reqBody).build();\n    return httpClient.newCall(request);\n  }\n"
  },
  {
    "id": "SeleniumHQ_selenium-834-Param-0",
    "old_comment_raw": "@param keysToSend The keys.",
    "old_code_raw": "  public Actions sendKeys(CharSequence... keysToSend) {\n    return this.sendKeys(null, keysToSend);\n  }\n",
    "new_code_raw": "  public Actions sendKeys(CharSequence... keys) {\n    if (isBuildingActions()) {\n      action.addAction(new SendKeysAction(jsonKeyboard, jsonMouse, null, keys));\n      return this;\n    }\n\n    for (CharSequence key : keys) {\n      key.codePoints().forEach(codePoint -> {\n        tick(defaultKeyboard.createKeyDown(codePoint));\n        tick(defaultKeyboard.createKeyUp(codePoint));\n      });\n    }\n\n    return this;\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-286-Param-8",
    "old_comment_raw": "@param authNames The authentications to apply",
    "old_code_raw": "  public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n",
    "new_code_raw": "  public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n"
  },
  {
    "id": "Atmosphere_atmosphere-863-Param-0",
    "old_comment_raw": "@param request the  AtmosphereRequest",
    "old_code_raw": "    public Action timedout(AtmosphereRequest request, AtmosphereResponse response)\n            throws IOException, ServletException {\n\n        AtmosphereResourceImpl r = null;\n\n        try {\n            SessionTimeoutSupport.restoreTimeout(request);\n\n            if (trackActiveRequest) {\n                long l = (Long) request.getAttribute(MAX_INACTIVE);\n                if (l == -1) {\n                    // The closedDetector closed the connection.\n                    return timedoutAction;\n                }\n                request.setAttribute(MAX_INACTIVE, (long) -1);\n            }\n\n            logger.debug(\"Timing out the connection for request {}\", request);\n\n            // Something went wrong.\n            if (request == null || response == null) {\n                logger.warn(\"Invalid Request/Response: {}/{}\", request, response);\n                return timedoutAction;\n            }\n\n            r = (AtmosphereResourceImpl) request.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n\n            if (r != null && r.isCancelled()) {\n                return cancelledAction;\n            }\n\n            if (r == null) {\n                logger.debug(\"AtmosphereResource was null, failed to timeout AtmosphereRequest {}\", request);\n            }\n\n            if (r != null && r.getAtmosphereResourceEvent().isSuspended()) {\n                r.getAtmosphereResourceEvent().setIsResumedOnTimeout(true);\n\n                Broadcaster b = r.getBroadcaster();\n                if (b instanceof DefaultBroadcaster) {\n                    ((DefaultBroadcaster) b).broadcastOnResume(r);\n                }\n\n                if (request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT) != null) {\n                    r.getAtmosphereResourceEvent().setIsResumedOnTimeout(\n                            (Boolean) request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT));\n                }\n\n                invokeAtmosphereHandler(r);\n            }\n        } catch (Throwable t) {\n            logger.error(\"failed to timeout resource {}\", r, t);\n        } finally {\n            config.framework().notify(Action.TYPE.TIMEOUT, request, response);\n            try {\n                if (r != null) {\n                    r.notifyListeners();\n                    r.setIsInScope(false);\n                    r.cancel();\n                }\n            } catch (Throwable t) {\n                logger.trace(\"timedout\", t);\n            } finally {\n                try {\n                    response.getOutputStream().close();\n                } catch (Throwable t) {\n                    try {\n                        response.getWriter().close();\n                    } catch (Throwable t2) {\n                    }\n                }\n\n                if (r != null) {\n                    r._destroy();\n                }\n            }\n        }\n\n        return timedoutAction;\n    }\n",
    "new_code_raw": "    public Action timedout(AtmosphereRequest req, AtmosphereResponse res)\n            throws IOException, ServletException {\n\n        logger.trace(\"Timing out {}\", req);\n        if (trackActiveRequest(req) && completeLifecycle(req.resource(), false)) {\n            config.framework().notify(Action.TYPE.TIMEOUT, req, res);\n        }\n        return timedoutAction;\n    }\n"
  },
  {
    "id": "apache_drill-203-Param-0",
    "old_comment_raw": "@param config DrillConfig containing BOOT options.",
    "old_code_raw": "  public static UserAuthenticator createAuthenticator(final DrillConfig config) throws DrillbitStartupException {\n    final String authImplConfigured = config.getString(USER_AUTHENTICATOR_IMPL);\n\n    if (Strings.isNullOrEmpty(authImplConfigured)) {\n      throw new DrillbitStartupException(String.format(\"Invalid value '%s' for BOOT option '%s'\", authImplConfigured,\n          USER_AUTHENTICATOR_IMPL));\n    }\n\n    final Collection<Class<? extends UserAuthenticator>> authImpls =\n        PathScanner.scanForImplementations(UserAuthenticator.class,\n            config.getStringList(ExecConstants.USER_AUTHENTICATOR_IMPL_PACKAGES));\n\n    for(Class<? extends UserAuthenticator> clazz : authImpls) {\n      final UserAuthenticatorTemplate template = clazz.getAnnotation(UserAuthenticatorTemplate.class);\n      if (template == null) {\n        logger.warn(\"{} doesn't have {} annotation. Skipping.\", clazz.getCanonicalName(), UserAuthenticatorTemplate.class);\n        continue;\n      }\n\n      if (Strings.isNullOrEmpty(template.type())) {\n        logger.warn(\"{} annotation doesn't have valid type field for UserAuthenticator implementation {}. Skipping..\",\n            UserAuthenticatorTemplate.class, clazz.getCanonicalName());\n        continue;\n      }\n\n      if (template.type().equalsIgnoreCase(authImplConfigured)) {\n        Constructor<?> validConstructor = null;\n        for (Constructor<?> c : clazz.getConstructors()) {\n          if (c.getParameterTypes().length == 0) {\n            validConstructor = c;\n            break;\n          }\n        }\n\n        if (validConstructor == null) {\n          logger.warn(\"Skipping UserAuthenticator implementation class '{}' since it doesn't \" +\n              \"implement a constructor [{}()]\", clazz.getCanonicalName(), clazz.getName());\n          continue;\n        }\n\n        // Instantiate authenticator and initialize it\n        try {\n          final UserAuthenticator authenticator = clazz.newInstance();\n          authenticator.setup(config);\n          return authenticator;\n        } catch(IllegalArgumentException | IllegalAccessException | InstantiationException e) {\n          throw new DrillbitStartupException(\n              String.format(\"Failed to create and initialize the UserAuthenticator class '%s'\",\n                  clazz.getCanonicalName()), e);\n        }\n      }\n    }\n\n    String errMsg = String.format(\"Failed to find the implementation of '%s' for type '%s'\",\n        UserAuthenticator.class.getCanonicalName(), authImplConfigured);\n    logger.error(errMsg);\n    throw new DrillbitStartupException(errMsg);\n  }\n",
    "new_code_raw": "  public static UserAuthenticator createAuthenticator(final DrillConfig config, ScanResult scan) throws DrillbitStartupException {\n    final String authImplConfigured = config.getString(USER_AUTHENTICATOR_IMPL);\n\n    if (Strings.isNullOrEmpty(authImplConfigured)) {\n      throw new DrillbitStartupException(String.format(\"Invalid value '%s' for BOOT option '%s'\", authImplConfigured,\n          USER_AUTHENTICATOR_IMPL));\n    }\n\n    final Collection<Class<? extends UserAuthenticator>> authImpls =\n        scan.getImplementations(UserAuthenticator.class);\n\n    for(Class<? extends UserAuthenticator> clazz : authImpls) {\n      final UserAuthenticatorTemplate template = clazz.getAnnotation(UserAuthenticatorTemplate.class);\n      if (template == null) {\n        logger.warn(\"{} doesn't have {} annotation. Skipping.\", clazz.getCanonicalName(), UserAuthenticatorTemplate.class);\n        continue;\n      }\n\n      if (Strings.isNullOrEmpty(template.type())) {\n        logger.warn(\"{} annotation doesn't have valid type field for UserAuthenticator implementation {}. Skipping..\",\n            UserAuthenticatorTemplate.class, clazz.getCanonicalName());\n        continue;\n      }\n\n      if (template.type().equalsIgnoreCase(authImplConfigured)) {\n        Constructor<?> validConstructor = null;\n        for (Constructor<?> c : clazz.getConstructors()) {\n          if (c.getParameterTypes().length == 0) {\n            validConstructor = c;\n            break;\n          }\n        }\n\n        if (validConstructor == null) {\n          logger.warn(\"Skipping UserAuthenticator implementation class '{}' since it doesn't \" +\n              \"implement a constructor [{}()]\", clazz.getCanonicalName(), clazz.getName());\n          continue;\n        }\n\n        // Instantiate authenticator and initialize it\n        try {\n          final UserAuthenticator authenticator = clazz.newInstance();\n          authenticator.setup(config);\n          return authenticator;\n        } catch(IllegalArgumentException | IllegalAccessException | InstantiationException e) {\n          throw new DrillbitStartupException(\n              String.format(\"Failed to create and initialize the UserAuthenticator class '%s'\",\n                  clazz.getCanonicalName()), e);\n        }\n      }\n    }\n\n    String errMsg = String.format(\"Failed to find the implementation of '%s' for type '%s'\",\n        UserAuthenticator.class.getCanonicalName(), authImplConfigured);\n    logger.error(errMsg);\n    throw new DrillbitStartupException(errMsg);\n  }\n"
  },
  {
    "id": "apache_ant-ivy-46-Associations-Param0",
    "old_comment_raw": "@param base the current base directory, may be null.",
    "old_code_raw": "    File getBaseDir(File base, File file) {\n        if (base == null) {\n            return file.getParentFile().getAbsoluteFile();\n        } else {\n            Iterator bases = getParents(base).iterator();\n            Iterator fileParents = getParents(file.getAbsoluteFile()).iterator();\n            File result = null;\n            while (bases.hasNext() && fileParents.hasNext()) {\n                File next = (File) bases.next();\n                if (next.equals(fileParents.next())) {\n                    result = next;\n                } else {\n                    break;\n                }\n            }\n            return result;\n        }\n    }\n",
    "new_code_raw": "    File getBaseDir(final File file1, final File file2) {\n        if (file1 == null || file2 == null) {\n            return null;\n        }\n        final Iterator bases = getParents(file1).iterator();\n        final Iterator fileParents = getParents(file2.getAbsoluteFile()).iterator();\n        File result = null;\n        while (bases.hasNext() && fileParents.hasNext()) {\n            File next = (File) bases.next();\n            if (next.equals(fileParents.next())) {\n                result = next;\n            } else {\n                break;\n            }\n        }\n        return result;\n    }\n\n"
  },
  {
    "id": "querydsl_querydsl-335-Param-0",
    "old_comment_raw": "@param val",
    "old_code_raw": "    public static ENumber<Integer> create(int i){\n        if (i >= 0 && i < 256){\n            return ints[i];\n        }else{\n            return new ENumberConst<Integer>(Integer.class, Integer.valueOf(i));\n        }\n    }\n",
    "new_code_raw": "    public static ENumber<Byte> create(byte i){\n        if (i >= 0 && i < 256){\n            return bytes[i];\n        }else{\n            return new ENumberConst<Byte>(Byte.class, Byte.valueOf(i));\n        }\n    }\n"
  },
  {
    "id": "apache_calcite-941-Param-0",
    "old_comment_raw": "@param filterRel the FilterRel",
    "old_code_raw": "  private RexProgram createProgram(FilterRelBase filterRel) {\n    RexProgramBuilder programBuilder =\n        new RexProgramBuilder(\n            filterRel.getRowType(),\n            filterRel.getCluster().getRexBuilder());\n    programBuilder.addIdentity();\n    programBuilder.addCondition(filterRel.getCondition());\n    return programBuilder.getProgram();\n  }\n",
    "new_code_raw": "  private RexProgram createProgram(Filter filterRel) {\n    RexProgramBuilder programBuilder =\n        new RexProgramBuilder(\n            filterRel.getRowType(),\n            filterRel.getCluster().getRexBuilder());\n    programBuilder.addIdentity();\n    programBuilder.addCondition(filterRel.getCondition());\n    return programBuilder.getProgram();\n  }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-506-Param-1",
    "old_comment_raw": "@param root The root of the Tree",
    "old_code_raw": "  public Collection<Tree> getRelatedNodes(Tree t, Tree root) {\n    Set<Tree> nodeList = new ArraySet<Tree>();\n    for (TregexPattern p : targetPatterns) {    // cdm: I deleted: && nodeList.isEmpty()\n      TregexMatcher m = p.matcher(root);\n      while (m.findAt(t)) {\n        nodeList.add(m.getNode(\"target\"));\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\"))\n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n",
    "new_code_raw": "  public Collection<Tree> getRelatedNodes(Tree t, Tree root, HeadFinder headFinder) {\n    Set<Tree> nodeList = new ArraySet<Tree>();\n    for (TregexPattern p : targetPatterns) {    // cdm: I deleted: && nodeList.isEmpty()\n      // Initialize the TregexMatcher with the HeadFinder so that we\n      // can use the same HeadFinder through the entire process of\n      // building the dependencies\n      TregexMatcher m = p.matcher(root, headFinder);\n      while (m.findAt(t)) {\n        nodeList.add(m.getNode(\"target\"));\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\"))\n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1716-Param-0",
    "old_comment_raw": "@param outerComposite Input composite as post body",
    "old_code_raw": "    public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws RestClientException {\n        Object postBody = outerComposite;\n        \n        String path = UriComponentsBuilder.fromPath(\"/fake/outer/composite\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"*/*\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<OuterComposite> returnType = new ParameterizedTypeReference<OuterComposite>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "new_code_raw": "    public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws RestClientException {\n        Object postBody = body;\n        \n        String path = UriComponentsBuilder.fromPath(\"/fake/outer/composite\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"*/*\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<OuterComposite> returnType = new ParameterizedTypeReference<OuterComposite>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1691-Param-0",
    "old_comment_raw": "@param petId ID of pet to update (required)",
    "old_code_raw": "  public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws ApiException {\n    Object localVarPostBody = null;\n    \n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n    }\n    \n    // verify the required parameter 'file' is set\n    if (file == null) {\n      throw new ApiException(400, \"Missing the required parameter 'file' when calling uploadFileWithRequiredFile\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake/{petId}/uploadImageWithRequiredFile\"\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString()));\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    if (additionalMetadata != null)\n      localVarFormParams.put(\"additionalMetadata\", additionalMetadata);\nif (file != null)\n      localVarFormParams.put(\"file\", file);\n\n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"multipart/form-data\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"petstore_auth\" };\n\n    GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException {\n    Object localVarPostBody = null;\n    \n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n    }\n    \n    // verify the required parameter 'requiredFile' is set\n    if (requiredFile == null) {\n      throw new ApiException(400, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake/{petId}/uploadImageWithRequiredFile\"\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString()));\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    if (additionalMetadata != null)\n      localVarFormParams.put(\"additionalMetadata\", additionalMetadata);\nif (requiredFile != null)\n      localVarFormParams.put(\"requiredFile\", requiredFile);\n\n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"multipart/form-data\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"petstore_auth\" };\n\n    GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "jiangzhonghui_android-platform-tools-base-34-Associations-Param0",
    "old_comment_raw": "@param names",
    "old_code_raw": "    private static String findValidPath(String... names) {\n        for (String name : names) {\n            String path;\n            if (name.indexOf('.') != -1) {\n                path = System.getProperty(name);\n            } else {\n                path = System.getenv(name);\n            }\n\n            if (path != null) {\n                File f = new File(path);\n                if (f.isDirectory()) {\n                    return path;\n                }\n            }\n        }\n\n        return null;\n    }\n",
    "new_code_raw": "    private static String findValidPath(EnvVar... vars) {\n        for (EnvVar var : vars) {\n            String path;\n            if (var.mIsSysProp) {\n                path = checkPath(System.getProperty(var.mName));\n                if (path != null) {\n                    return path;\n                }\n            }\n\n            if (var.mIsEnvVar) {\n                path = checkPath(System.getenv(var.mName));\n                if (path != null) {\n                    return path;\n                }\n            }\n        }\n\n        return null;\n    }\n\n"
  },
  {
    "id": "apache_activemq-393-Param-2",
    "old_comment_raw": "@param tmpStorage",
    "old_code_raw": "    public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize) {\n        return new FilePendingMessageCursor(name, tmpStorage);\n    }\n",
    "new_code_raw": "    public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize, Subscription sub) {\n        return new FilePendingMessageCursor(name, tmpStorage);\n    }\n"
  },
  {
    "id": "apache_activemq-1298-Param-0",
    "old_comment_raw": "@param info",
    "old_code_raw": "    private Connection createConnection(ActiveMQConnectionRequestInfo info) throws JMSException {\n        try {\n            if (info.isUseInboundSessionEnabled()) {\n                return new InboundConnectionProxy();\n            }\n            if (manager == null) {\n                throw new JMSException(\"No JCA ConnectionManager configured! Either enable UseInboundSessionEnabled or get your JCA container to configure one.\");\n            }\n            return (Connection)manager.allocateConnection(factory, info);\n        } catch (ResourceException e) {\n            // Throw the root cause if it was a JMSException..\n            if (e.getCause() instanceof JMSException) {\n                throw (JMSException)e.getCause();\n            }\n            LOG.debug(\"Connection could not be created:\", e);\n            throw new JMSException(e.getMessage());\n        }\n    }\n",
    "new_code_raw": "    private Connection createConnection(ActiveMQConnectionRequestInfo connectionRequestInfo) throws JMSException {\n        try {\n            if (connectionRequestInfo.isUseInboundSessionEnabled()) {\n                return new InboundConnectionProxy();\n            }\n            if (manager == null) {\n                throw new JMSException(\"No JCA ConnectionManager configured! Either enable UseInboundSessionEnabled or get your JCA container to configure one.\");\n            }\n            return (Connection)manager.allocateConnection(factory, connectionRequestInfo);\n        } catch (ResourceException e) {\n            // Throw the root cause if it was a JMSException..\n            if (e.getCause() instanceof JMSException) {\n                throw (JMSException)e.getCause();\n            }\n            LOG.debug(\"Connection could not be created:\", e);\n            throw new JMSException(e.getMessage());\n        }\n    }\n"
  },
  {
    "id": "Netflix_eureka-172-Param-1",
    "old_comment_raw": "@param acceptHeader the accept header of the request to indicate whether to serve JSON or XML data.",
    "old_code_raw": "    public Response getApplication(@PathParam(\"version\") String version,\n                                   @HeaderParam(\"Accept\") final String acceptHeader) {\n        if (!PeerAwareInstanceRegistryImpl.getInstance().shouldAllowAccess(false)) {\n            return Response.status(Status.FORBIDDEN).build();\n        }\n\n        EurekaMonitors.GET_APPLICATION.increment();\n\n        CurrentRequestVersion.set(Version.toEnum(version));\n        KeyType keyType = KeyType.JSON;\n        if (acceptHeader == null || !acceptHeader.contains(\"json\")) {\n            keyType = KeyType.XML;\n        }\n\n        Key cacheKey = new Key(Key.EntityType.Application, appName, keyType, CurrentRequestVersion.get());\n\n        String payLoad = ResponseCache.getInstance().get(cacheKey);\n\n        if (payLoad != null) {\n            logger.debug(\"Found: {}\", appName);\n            return Response.ok(payLoad).build();\n        } else {\n            logger.debug(\"Not Found: {}\", appName);\n            return Response.status(Status.NOT_FOUND).build();\n        }\n    }\n",
    "new_code_raw": "    public Response getApplication(@PathParam(\"version\") String version,\n                                   @HeaderParam(\"Accept\") final String acceptHeader,\n                                   @HeaderParam(EurekaAccept.HTTP_X_EUREKA_ACCEPT) String eurekaAccept) {\n        if (!registry.shouldAllowAccess(false)) {\n            return Response.status(Status.FORBIDDEN).build();\n        }\n\n        EurekaMonitors.GET_APPLICATION.increment();\n\n        CurrentRequestVersion.set(Version.toEnum(version));\n        KeyType keyType = KeyType.JSON;\n        if (acceptHeader == null || !acceptHeader.contains(\"json\")) {\n            keyType = KeyType.XML;\n        }\n\n        Key cacheKey = new Key(\n                Key.EntityType.Application,\n                appName,\n                keyType,\n                CurrentRequestVersion.get(),\n                EurekaAccept.fromString(eurekaAccept)\n        );\n\n        String payLoad = responseCache.get(cacheKey);\n\n        if (payLoad != null) {\n            logger.debug(\"Found: {}\", appName);\n            return Response.ok(payLoad).build();\n        } else {\n            logger.debug(\"Not Found: {}\", appName);\n            return Response.status(Status.NOT_FOUND).build();\n        }\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1667-Param-0",
    "old_comment_raw": "@param body Input composite as post body (optional)",
    "old_code_raw": "  public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/composite\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws ApiException {\n    Object localVarPostBody = outerComposite;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/composite\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"*/*\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "RobotiumTech_robotium-763-Param-1",
    "old_comment_raw": "@param recyclerViewIndex the index of the RecyclerView. E.g. Index 1 if two RecyclerViews are available",
    "old_code_raw": "\tpublic ArrayList<TextView> clickInRecyclerView(int itemIndex, int recyclerViewIndex, boolean longClick, int time) {\n\t\tView viewOnLine = null;\n\t\tfinal long endTime = SystemClock.uptimeMillis() + Timeout.getSmallTimeout();\n\n\t\tif(itemIndex < 0)\n\t\t\titemIndex = 0;\n\n\t\tArrayList<View> views = new ArrayList<View>();\n\t\tViewGroup recyclerView = viewFetcher.getRecyclerView(recyclerViewIndex, Timeout.getSmallTimeout());\n\t\t\n\t\tif(recyclerView == null){\n\t\t\tAssert.fail(\"RecyclerView is not found!\");\n\t\t}\n\t\telse{\n\t\t\tfailIfIndexHigherThenChildCount(recyclerView, itemIndex, endTime);\n\t\t\tviewOnLine = getViewOnRecyclerItemIndex((ViewGroup) recyclerView, recyclerViewIndex, itemIndex);\n\t\t}\n\t\t\n\t\tif(viewOnLine != null){\n\t\t\tviews = viewFetcher.getViews(viewOnLine, true);\n\t\t\tviews = RobotiumUtils.removeInvisibleViews(views);\n\t\t\tclickOnScreen(viewOnLine, longClick, time);\n\t\t}\n\t\treturn RobotiumUtils.filterViews(TextView.class, views);\n\t}\n",
    "new_code_raw": "\tpublic ArrayList<TextView> clickInRecyclerView(int itemIndex, int recyclerViewIndex, int id, boolean longClick, int time) {\n\t\tView viewOnLine = null;\n\t\tfinal long endTime = SystemClock.uptimeMillis() + Timeout.getSmallTimeout();\n\n\t\tif(itemIndex < 0)\n\t\t\titemIndex = 0;\n\n\t\tArrayList<View> views = new ArrayList<View>();\n\t\tViewGroup recyclerView = viewFetcher.getRecyclerView(recyclerViewIndex, Timeout.getSmallTimeout());\n\t\t\n\t\tif(recyclerView == null){\n\t\t\tAssert.fail(\"RecyclerView is not found!\");\n\t\t}\n\t\telse{\n\t\t\tfailIfIndexHigherThenChildCount(recyclerView, itemIndex, endTime);\n\t\t\tviewOnLine = getViewOnRecyclerItemIndex((ViewGroup) recyclerView, recyclerViewIndex, itemIndex);\n\t\t}\n\t\t\n\t\tif(viewOnLine != null){\n\t\t\tviews = viewFetcher.getViews(viewOnLine, true);\n\t\t\tviews = RobotiumUtils.removeInvisibleViews(views);\n\t\t\t\n\t\t\tif(id == 0){\n\t\t\t\tclickOnScreen(viewOnLine, longClick, time);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tclickOnScreen(getView(id, views));\n\t\t\t}\n\t\t}\n\t\treturn RobotiumUtils.filterViews(TextView.class, views);\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1715-Param-0",
    "old_comment_raw": "@param client client model",
    "old_code_raw": "    public Client call123testSpecialTags(Client client) throws RestClientException {\n        Object postBody = client;\n        \n        // verify the required parameter 'client' is set\n        if (client == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'client' when calling call123testSpecialTags\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"/another-fake/dummy\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "new_code_raw": "    public Client call123testSpecialTags(Client body) throws RestClientException {\n        Object postBody = body;\n        \n        // verify the required parameter 'body' is set\n        if (body == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling call123testSpecialTags\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"/another-fake/dummy\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-969-Param-0",
    "old_comment_raw": "@param includeExtras If true, the list of typed dependencies returned may include \"extras\", such as controlled subject links.",
    "old_code_raw": "  public List<TypedDependency> typedDependenciesCCprocessed(Extras includeExtras) {\n    List<TypedDependency> tdl = typedDependencies(includeExtras);\n    collapseDependencies(tdl, true, includeExtras);\n    return tdl;\n  }\n",
    "new_code_raw": "  public List<TypedDependency> typedDependenciesCCprocessed(boolean includeExtras) {\n    List<TypedDependency> tdl = typedDependencies(false);\n    // Adds stuff to the basic dependencies.\n    // We don't want to simply call typedDependencies with\n    // \"includeExtras\" because the collapseDependencies method may add\n    // the extras in a way that makes more logical sense.  For\n    // example, the English dependencies, when CC processed, have more\n    // nsubjs than they originally do.  If we wait until that occurs\n    // to add xsubj for xcomp dependencies, we get better coverage.\n    if (includeExtras) {\n      getTreeDeps(root(), tdl, new NoPunctTypedDependencyFilter(puncFilter));\n    }\n    collapseDependencies(tdl, true, includeExtras);\n    return tdl;\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1632-Param-1",
    "old_comment_raw": "@param body Updated user object",
    "old_code_raw": "  public void  updateUser (String username, User body) throws ApiException {\n    Object localVarPostBody = body;\n    // verify the required parameter 'username' is set\n    if (username == null) {\n       throw new ApiException(400, \"Missing the required parameter 'username' when calling updateUser\");\n    }\n    // verify the required parameter 'body' is set\n    if (body == null) {\n       throw new ApiException(400, \"Missing the required parameter 'body' when calling updateUser\");\n    }\n\n    // create path and map variables\n    String localVarPath = \"/user/{username}\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"username\" + \"\\\\}\", apiInvoker.escapeString(username.toString()));\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> localVarFormParams = new HashMap<String, String>();\n\n\n\n    String[] localVarContentTypes = {\n      \n    };\n    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application/json\";\n\n    if (localVarContentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      \n\n      localVarPostBody = localVarBuilder.build();\n    } else {\n      // normal form params\n          }\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"PUT\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);\n      if(localVarResponse != null){\n        return ;\n      }\n      else {\n        return ;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n",
    "new_code_raw": "  public void  updateUser (String username, User user) throws ApiException {\n    Object localVarPostBody = user;\n    // verify the required parameter 'username' is set\n    if (username == null) {\n       throw new ApiException(400, \"Missing the required parameter 'username' when calling updateUser\");\n    }\n    // verify the required parameter 'user' is set\n    if (user == null) {\n       throw new ApiException(400, \"Missing the required parameter 'user' when calling updateUser\");\n    }\n\n    // create path and map variables\n    String localVarPath = \"/user/{username}\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"username\" + \"\\\\}\", apiInvoker.escapeString(username.toString()));\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> localVarFormParams = new HashMap<String, String>();\n\n\n\n    String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application/json\";\n\n    if (localVarContentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      \n\n      localVarPostBody = localVarBuilder.build();\n    } else {\n      // normal form params\n          }\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"PUT\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);\n      if(localVarResponse != null){\n        return ;\n      }\n      else {\n        return ;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n"
  },
  {
    "id": "Teevity_ice-0-Param-0",
    "old_comment_raw": "@param accountId",
    "old_code_raw": "    public static Credentials getAssumedCredentials(String accountId, String role, String assumeRole) {\n        AssumeRoleRequest assumeRoleRequest = new AssumeRoleRequest()\n                .withRoleArn(\"arn:aws:iam::\" + accountId + \":role/\" + role)\n                .withRoleSessionName(assumeRole);\n        AssumeRoleResult roleResult = securityClient.assumeRole(assumeRoleRequest);\n        return roleResult.getCredentials();\n    }\n",
    "new_code_raw": "    public static Credentials getAssumedCredentials(String accountId, String role, String assumeRole, String externalId) {\n        AssumeRoleRequest assumeRoleRequest = new AssumeRoleRequest()\n                .withRoleArn(\"arn:aws:iam::\" + accountId + \":role/\" + role)\n                .withRoleSessionName(assumeRole);\n        if (!StringUtils.isEmpty(externalId))\n            assumeRoleRequest.setExternalId(externalId);\n        AssumeRoleResult roleResult = securityClient.assumeRole(assumeRoleRequest);\n        return roleResult.getCredentials();\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1627-Param-0",
    "old_comment_raw": "@param body Pet object that needs to be added to the store",
    "old_code_raw": "  public void  updatePet (Pet body) throws ApiException {\n    Object localVarPostBody = body;\n    // verify the required parameter 'body' is set\n    if (body == null) {\n       throw new ApiException(400, \"Missing the required parameter 'body' when calling updatePet\");\n    }\n\n    // create path and map variables\n    String localVarPath = \"/pet\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> localVarFormParams = new HashMap<String, String>();\n\n\n\n    String[] localVarContentTypes = {\n      \"application/json\",\"application/xml\"\n    };\n    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application/json\";\n\n    if (localVarContentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      \n\n      localVarPostBody = localVarBuilder.build();\n    } else {\n      // normal form params\n          }\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"PUT\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);\n      if(localVarResponse != null){\n        return ;\n      }\n      else {\n        return ;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n",
    "new_code_raw": "  public void  updatePet (Pet pet) throws ApiException {\n    Object localVarPostBody = pet;\n    // verify the required parameter 'pet' is set\n    if (pet == null) {\n       throw new ApiException(400, \"Missing the required parameter 'pet' when calling updatePet\");\n    }\n\n    // create path and map variables\n    String localVarPath = \"/pet\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> localVarFormParams = new HashMap<String, String>();\n\n\n\n    String[] localVarContentTypes = {\n      \n    };\n    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application/json\";\n\n    if (localVarContentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      \n\n      localVarPostBody = localVarBuilder.build();\n    } else {\n      // normal form params\n          }\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"PUT\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);\n      if(localVarResponse != null){\n        return ;\n      }\n      else {\n        return ;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n"
  },
  {
    "id": "apache_activemq-1153-Param-3",
    "old_comment_raw": "@param listener",
    "old_code_raw": "    public static Transport createLocalTransport(URI uri) throws Exception {\n        return createLocalTransport(uri, false);\n    }\n",
    "new_code_raw": "    public static Transport createLocalTransport(NetworkBridgeConfiguration configuration, URI uri) throws Exception {\n        // one end of the localbroker<->bridge transport needs to be async to allow concurrent forwards and acks\n        return createLocalTransport(uri, !configuration.isDispatchAsync());\n    }\n"
  },
  {
    "id": "mulesoft_handshake-connector-3-Associations-Param0",
    "old_comment_raw": "@param id of the Customer to get. The id is the one specified on creation, and not Handshake's uid @sample.xml ../../../doc/mule-module-handshake.xml.sample handshake:get-customer",
    "old_code_raw": "    @Processor\n    public Customer getCustomer(final String id) {\n        return getClientProvider().getClient(Customer.class).getById(id);\n    }\n",
    "new_code_raw": "    @Processor\n    public Customer getCustomer(final String resourceUri) {\n        return getClientProvider().getClient(Customer.class).getByResourceUri(resourceUri);\n    }\n\n"
  },
  {
    "id": "apache_activemq-394-Param-3",
    "old_comment_raw": "@param maxBatchSize",
    "old_code_raw": "    public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize) {\n        return new VMPendingMessageCursor();\n    }\n",
    "new_code_raw": "    public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize, Subscription sub) {\n        return new VMPendingMessageCursor();\n    }\n"
  },
  {
    "id": "apache_giraph-77-Associations-Param0",
    "old_comment_raw": "@param name the name of the metric",
    "old_code_raw": "  public Timer getTimer(String name) {\n    return getTimer(name, TimeUnit.MILLISECONDS, TimeUnit.SECONDS);\n  }\n",
    "new_code_raw": "  public Timer getTimer(TimerDesc timerDesc) {\n    return getTimer(timerDesc.getName(), timerDesc.getDurationUnit(),\n        timerDesc.getTimeUnit());\n  }\n\n"
  },
  {
    "id": "RobotiumTech_robotium-1496-Param-3",
    "old_comment_raw": "@param scroll true if scrolling should be performed",
    "old_code_raw": "\tpublic WebElement searchForWebElement(final By by, int match, int timeout, boolean scroll){\n\n\t\tif(match < 1){\n\t\t\tmatch = 1;\n\t\t}\n\n\t\tList<WebElement> viewsFromScreen = webUtils.getCurrentWebElements(by);\n\t\taddViewsToList (webElements, viewsFromScreen);\n\n\t\treturn getViewFromList(webElements, match);\n\t}\n",
    "new_code_raw": "\tpublic WebElement searchForWebElement(final By by, int minimumNumberOfMatches, int timeout, boolean scroll){\n\n\t\tif(minimumNumberOfMatches < 1){\n\t\t\tminimumNumberOfMatches = 1;\n\t\t}\n\n\t\tList<WebElement> viewsFromScreen = webUtils.getCurrentWebElements(by);\n\t\taddViewsToList (webElements, viewsFromScreen);\n\n\t\treturn getViewFromList(webElements, minimumNumberOfMatches);\n\t}\n"
  },
  {
    "id": "runelite_runelite-119-Param-2",
    "old_comment_raw": "@param y the ground coordinate on the y axis",
    "old_code_raw": "\tpublic static int getTileHeight(Client client, int x, int y, int plane)\n\t{\n\t\tint var3 = x >> 7;\n\t\tint var4 = y >> 7;\n\t\tif (var3 >= 0 && var4 >= 0 && var3 <= 103 && var4 <= 103)\n\t\t{\n\t\t\tbyte[][][] tileSettings = client.getTileSettings();\n\t\t\tint[][][] tileHeights = client.getTileHeights();\n\n\t\t\tint var5 = plane;\n\t\t\tif (plane < 3 && (tileSettings[1][var3][var4] & 2) == 2)\n\t\t\t{\n\t\t\t\tvar5 = plane + 1;\n\t\t\t}\n\n\t\t\tint var6 = x & 127;\n\t\t\tint var7 = y & 127;\n\t\t\tint var8 = var6 * tileHeights[var5][var3 + 1][var4] + (128 - var6) * tileHeights[var5][var3][var4] >> 7;\n\t\t\tint var9 = tileHeights[var5][var3][var4 + 1] * (128 - var6) + var6 * tileHeights[var5][var3 + 1][var4 + 1] >> 7;\n\t\t\treturn (128 - var7) * var8 + var7 * var9 >> 7;\n\t\t}\n\n\t\treturn 0;\n\t}\n",
    "new_code_raw": "\tpublic static int getTileHeight(Client client, int localX, int localY, int plane)\n\t{\n\t\tint sceneX = localX >> LOCAL_COORD_BITS;\n\t\tint sceneY = localY >> LOCAL_COORD_BITS;\n\t\tif (sceneX >= 0 && sceneY >= 0 && sceneX <= 103 && sceneY <= 103)\n\t\t{\n\t\t\tbyte[][][] tileSettings = client.getTileSettings();\n\t\t\tint[][][] tileHeights = client.getTileHeights();\n\n\t\t\tint var5 = plane;\n\t\t\tif (plane < 3 && (tileSettings[1][sceneX][sceneY] & 2) == 2)\n\t\t\t{\n\t\t\t\tvar5 = plane + 1;\n\t\t\t}\n\n\t\t\tint var6 = localX & 127;\n\t\t\tint var7 = localY & 127;\n\t\t\tint var8 = var6 * tileHeights[var5][sceneX + 1][sceneY] + (128 - var6) * tileHeights[var5][sceneX][sceneY] >> 7;\n\t\t\tint var9 = tileHeights[var5][sceneX][sceneY + 1] * (128 - var6) + var6 * tileHeights[var5][sceneX + 1][sceneY + 1] >> 7;\n\t\t\treturn (128 - var7) * var8 + var7 * var9 >> 7;\n\t\t}\n\n\t\treturn 0;\n\t}\n"
  },
  {
    "id": "debezium_debezium-910-Param-1",
    "old_comment_raw": "@param table the table definition; may not be null",
    "old_code_raw": "    public TableSchema create(String schemaPrefix, Table table) {\n        return create(schemaPrefix, table, null, null);\n    }\n",
    "new_code_raw": "    public TableSchema create(String schemaPrefix, String envelopeSchemaName, Table table) {\n        return create(schemaPrefix, envelopeSchemaName, table, null, null);\n    }\n"
  },
  {
    "id": "Netflix_eureka-378-Param-0",
    "old_comment_raw": "@param asgName - The name of the ASG",
    "old_code_raw": "    public boolean isASGEnabled(String asgName) {\n        try {\n            return asgCache.get(asgName);\n        } catch (ExecutionException e) {\n            logger.error(\"Error getting cache value for asg : \" + asgName, e);\n        }\n        return true;\n    }\n",
    "new_code_raw": "    public boolean isASGEnabled(InstanceInfo instanceInfo) {\n        CacheKey cacheKey = new CacheKey(getAccountId(instanceInfo, accountId), instanceInfo.getASGName());\n        asgCache.refresh(cacheKey);\n        Boolean result = asgCache.getIfPresent(cacheKey);\n        if (result != null) {\n            return result;\n        } else {\n            logger.warn(\"Cache value for asg {} does not exist yet\", cacheKey.asgName);\n            return true;\n        }\n    }\n"
  },
  {
    "id": "apache_drill-1115-Param-0",
    "old_comment_raw": "@param recordsReadInCurrentPass",
    "old_code_raw": "  public boolean determineSize(long recordsReadInCurrentPass, Integer lengthVarFieldsInCurrentRecord) throws IOException {\n\n    boolean doneReading = readPage();\n    if (doneReading) {\n      return true;\n    }\n\n    doneReading = processPageData((int) recordsReadInCurrentPass);\n    if (doneReading) {\n      return true;\n    }\n\n    // Never used in this code path. Hard to remove because the method is overidden by subclasses\n    lengthVarFieldsInCurrentRecord = -1;\n\n    doneReading = checkVectorCapacityReached();\n    if (doneReading) {\n      return true;\n    }\n\n    return false;\n  }\n",
    "new_code_raw": "  public boolean determineSize(long recordsReadInCurrentPass) throws IOException {\n\n    if (readPage()) {\n      return true;\n    }\n\n    if (processPageData((int) recordsReadInCurrentPass)) {\n      return true;\n    }\n\n    return checkVectorCapacityReached();\n  }\n"
  },
  {
    "id": "runelite_runelite-131-Param-0",
    "old_comment_raw": "@param image The image to be made more or less transparent.",
    "old_code_raw": "\tpublic static BufferedImage alphaOffset(final BufferedImage image, final float percentage)\n\t{\n\t\tfinal int numComponents = image.getColorModel().getNumComponents();\n\t\tfinal float[] scales = new float[numComponents];\n\t\tfinal float[] offsets = new float[numComponents];\n\n\t\tArrays.fill(scales, 1f);\n\t\tArrays.fill(offsets, 0f);\n\t\tscales[numComponents - 1] = percentage;\n\t\treturn offset(image, scales, offsets);\n\t}\n",
    "new_code_raw": "\tpublic static BufferedImage alphaOffset(final Image rawImg, final float percentage)\n\t{\n\t\tBufferedImage image = toARGB(rawImg);\n\t\tfinal int numComponents = image.getColorModel().getNumComponents();\n\t\tfinal float[] scales = new float[numComponents];\n\t\tfinal float[] offsets = new float[numComponents];\n\n\t\tArrays.fill(scales, 1f);\n\t\tArrays.fill(offsets, 0f);\n\t\tscales[numComponents - 1] = percentage;\n\t\treturn offset(image, scales, offsets);\n\t}\n"
  },
  {
    "id": "debezium_debezium-724-Param-1",
    "old_comment_raw": "@param ts the timestamp for this row",
    "old_code_raw": "        public int delete(Object[] row, long ts, int rowNumber, int numberOfRows) throws InterruptedException {\n            return converter.delete(source, row, rowNumber, numberOfRows, includedColumns, ts, consumer);\n        }\n",
    "new_code_raw": "        public int delete(Object[] row, Instant ts, int rowNumber, int numberOfRows) throws InterruptedException {\n            return converter.delete(source, row, rowNumber, numberOfRows, includedColumns, ts, consumer);\n        }\n"
  },
  {
    "id": "RobotiumTech_robotium-1192-Param-1",
    "old_comment_raw": "@param visible  true if only  Buttons visible on the screen should be searched",
    "old_code_raw": "\tpublic boolean searchButton(String text, boolean visible) {\n\t\tboolean found = searcher.searchWithTimeoutFor(Button.class, text, 0, true, visible);\n\t\treturn found;\n\t}\n",
    "new_code_raw": "\tpublic boolean searchButton(String text, boolean onlyVisible) {\n\t\tboolean found = searcher.searchWithTimeoutFor(Button.class, text, 0, true, onlyVisible);\n\t\treturn found;\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1077-Param-0",
    "old_comment_raw": "@param params Map of query params. A collection will be interpreted as passing in multiple instances of the same query param.",
    "old_code_raw": "    public Boolean fakeOuterBooleanSerialize(Boolean body, Map<String, Object> params) throws IOException {\n        HttpResponse response = fakeOuterBooleanSerializeForHttpResponse(body, params);\n        TypeReference typeRef = new TypeReference<Boolean>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n",
    "new_code_raw": "    public Boolean fakeOuterBooleanSerialize(Boolean booleanPostBody, Map<String, Object> params) throws IOException {\n        HttpResponse response = fakeOuterBooleanSerializeForHttpResponse(booleanPostBody, params);\n        TypeReference typeRef = new TypeReference<Boolean>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1728-Param-8",
    "old_comment_raw": "@param progressRequestListener Progress request listener",
    "old_code_raw": "    public Request buildRequest(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n        updateParamsForAuth(authNames, queryParams, headerParams);\n\n        final String url = buildUrl(path, queryParams, collectionQueryParams);\n        final Request.Builder reqBuilder = new Request.Builder().url(url);\n        processHeaderParams(headerParams, reqBuilder);\n\n        String contentType = (String) headerParams.get(\"Content-Type\");\n        // ensuring a default content type\n        if (contentType == null) {\n            contentType = \"application/json\";\n        }\n\n        RequestBody reqBody;\n        if (!HttpMethod.permitsRequestBody(method)) {\n            reqBody = null;\n        } else if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n            reqBody = buildRequestBodyFormEncoding(formParams);\n        } else if (\"multipart/form-data\".equals(contentType)) {\n            reqBody = buildRequestBodyMultipart(formParams);\n        } else if (body == null) {\n            if (\"DELETE\".equals(method)) {\n                // allow calling DELETE without sending a request body\n                reqBody = null;\n            } else {\n                // use an empty request body (for POST, PUT and PATCH)\n                reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n            }\n        } else {\n            reqBody = serialize(body, contentType);\n        }\n\n        Request request = null;\n\n        if(progressRequestListener != null && reqBody != null) {\n            ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener);\n            request = reqBuilder.method(method, progressRequestBody).build();\n        } else {\n            request = reqBuilder.method(method, reqBody).build();\n        }\n\n        return request;\n    }\n",
    "new_code_raw": "    public Request buildRequest(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {\n        updateParamsForAuth(authNames, queryParams, headerParams);\n\n        final String url = buildUrl(path, queryParams, collectionQueryParams);\n        final Request.Builder reqBuilder = new Request.Builder().url(url);\n        processHeaderParams(headerParams, reqBuilder);\n\n        String contentType = (String) headerParams.get(\"Content-Type\");\n        // ensuring a default content type\n        if (contentType == null) {\n            contentType = \"application/json\";\n        }\n\n        RequestBody reqBody;\n        if (!HttpMethod.permitsRequestBody(method)) {\n            reqBody = null;\n        } else if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n            reqBody = buildRequestBodyFormEncoding(formParams);\n        } else if (\"multipart/form-data\".equals(contentType)) {\n            reqBody = buildRequestBodyMultipart(formParams);\n        } else if (body == null) {\n            if (\"DELETE\".equals(method)) {\n                // allow calling DELETE without sending a request body\n                reqBody = null;\n            } else {\n                // use an empty request body (for POST, PUT and PATCH)\n                reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n            }\n        } else {\n            reqBody = serialize(body, contentType);\n        }\n\n        // Associate callback with request (if not null) so interceptor can\n        // access it when creating ProgressResponseBody\n        reqBuilder.tag(callback);\n\n        Request request = null;\n\n        if (callback != null && reqBody != null) {\n            ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, callback);\n            request = reqBuilder.method(method, progressRequestBody).build();\n        } else {\n            request = reqBuilder.method(method, reqBody).build();\n        }\n\n        return request;\n    }\n"
  },
  {
    "id": "debezium_debezium-392-Param-0",
    "old_comment_raw": "@param lsn the position in the server WAL for a particular event; may be null indicating that this information is not available",
    "old_code_raw": "    protected SourceInfo update(Long lsn, Long useconds, Long txId, TableId tableId) {\n        this.lsn = lsn;\n        this.useconds = useconds;\n        this.txId = txId;\n        if (tableId != null && tableId.schema() != null) {\n            this.schemaName = tableId.schema();\n        }\n        if (tableId != null && tableId.table() != null) {\n            this.tableName = tableId.table();\n        }\n        return this;\n    }\n",
    "new_code_raw": "    protected SourceInfo update(Long lsn, Instant commitTime, Long txId, TableId tableId) {\n        this.lsn = lsn;\n        this.useconds = Conversions.toEpochMicros(commitTime);\n        this.txId = txId;\n        if (tableId != null && tableId.schema() != null) {\n            this.schemaName = tableId.schema();\n        }\n        if (tableId != null && tableId.table() != null) {\n            this.tableName = tableId.table();\n        }\n        return this;\n    }\n"
  },
  {
    "id": "MilosKozak_AndroidAPS-124-Param-0",
    "old_comment_raw": "@param request",
    "old_code_raw": "    public PumpEnactResult applyAPSRequest(APSResult request) {\n        request.rate = applyBasalConstraints(request.rate);\n        PumpEnactResult result;\n\n        if (!isInitialized()) {\n            result = new PumpEnactResult();\n            result.comment = MainApp.sResources.getString(R.string.pumpNotInitialized);\n            result.enacted = false;\n            result.success = false;\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpNotInitialized));\n            return result;\n        }\n\n        if (isSuspended()) {\n            result = new PumpEnactResult();\n            result.comment = MainApp.sResources.getString(R.string.pumpsuspended);\n            result.enacted = false;\n            result.success = false;\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpsuspended));\n            return result;\n        }\n\n        if (Config.logCongigBuilderActions)\n            log.debug(\"applyAPSRequest: \" + request.toString());\n        if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - getBaseBasalRate()) < getPumpDescription().basalStep) {\n            if (isTempBasalInProgress()) {\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: cancelTempBasal()\");\n                result = cancelTempBasal(false);\n            } else {\n                result = new PumpEnactResult();\n                result.absolute = request.rate;\n                result.duration = 0;\n                result.enacted = false;\n                result.comment = \"Basal set correctly\";\n                result.success = true;\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: Basal set correctly\");\n            }\n        } else if (isTempBasalInProgress()\n                && getTempBasalRemainingMinutesFromHistory() > 5\n                && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < getPumpDescription().basalStep) {\n            result = new PumpEnactResult();\n            result.absolute = getTempBasalAbsoluteRateHistory();\n            result.duration = getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes();\n            result.enacted = false;\n            result.comment = \"Temp basal set correctly\";\n            result.success = true;\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: Temp basal set correctly\");\n        } else {\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: setTempBasalAbsolute()\");\n            result = setTempBasalAbsolute(request.rate, request.duration);\n        }\n        return result;\n    }\n",
    "new_code_raw": "    public boolean applyAPSRequest(APSResult request, Callback callback) {\n        PumpInterface pump = getActivePump();\n        request.rate = applyBasalConstraints(request.rate);\n        PumpEnactResult result;\n\n        if (!pump.isInitialized()) {\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpNotInitialized));\n            if (callback != null) {\n                callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpNotInitialized)).enacted(false).success(false)).run();\n            }\n            return false;\n        }\n\n        if (pump.isSuspended()) {\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpsuspended));\n            if (callback != null) {\n                callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpsuspended)).enacted(false).success(false)).run();\n            }\n            return false;\n        }\n\n        if (Config.logCongigBuilderActions)\n            log.debug(\"applyAPSRequest: \" + request.toString());\n        if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - pump.getBaseBasalRate()) < pump.getPumpDescription().basalStep) {\n            if (isTempBasalInProgress()) {\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: cancelTempBasal()\");\n                getCommandQueue().cancelTempBasal(false, callback);\n                return true;\n            } else {\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: Basal set correctly\");\n                if (callback != null) {\n                    callback.result(new PumpEnactResult().absolute(request.rate).duration(0).enacted(false).success(true).comment(\"Basal set correctly\")).run();\n                }\n                return false;\n            }\n        } else if (isTempBasalInProgress() && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < pump.getPumpDescription().basalStep) {\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: Temp basal set correctly\");\n            if (callback != null) {\n                callback.result(new PumpEnactResult().absolute(getTempBasalAbsoluteRateHistory()).duration(getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes()).enacted(false).success(true).comment(\"Temp basal set correctly\")).run();\n            }\n            return false;\n        } else {\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: setTempBasalAbsolute()\");\n            getCommandQueue().tempBasalAbsolute(request.rate, request.duration, false, callback);\n            return true;\n        }\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-1109-Param-0",
    "old_comment_raw": "@param instant the instant to compare to",
    "old_code_raw": "    public int compareTo(ReadablePartial instant) {\n        if (instant == null) {\n            throw new IllegalArgumentException(\"The instant must not be null\");\n        }\n        int thisValue = get();\n        int otherValue = instant.get(getField());\n        if (thisValue < otherValue) {\n            return -1;\n        } else if (thisValue > otherValue) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n",
    "new_code_raw": "    public int compareTo(ReadablePartial partial) {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"The instant must not be null\");\n        }\n        int thisValue = get();\n        int otherValue = partial.get(getFieldType());\n        if (thisValue < otherValue) {\n            return -1;\n        } else if (thisValue > otherValue) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n"
  },
  {
    "id": "debezium_debezium-728-Param-2",
    "old_comment_raw": "@param timestamp the timestamp for this message; may be null",
    "old_code_raw": "    public Struct delete(Object before, Struct source, Long timestamp) {\n        Struct struct = new Struct(schema);\n        struct.put(FieldName.OPERATION, Operation.DELETE.code());\n        if (before != null) {\n            struct.put(FieldName.BEFORE, before);\n        }\n        if (source != null) {\n            struct.put(FieldName.SOURCE, source);\n        }\n        if (timestamp != null) {\n            struct.put(FieldName.TIMESTAMP, timestamp);\n        }\n        return struct;\n    }\n",
    "new_code_raw": "    public Struct delete(Object before, Struct source, Instant timestamp) {\n        Struct struct = new Struct(schema);\n        struct.put(FieldName.OPERATION, Operation.DELETE.code());\n        if (before != null) {\n            struct.put(FieldName.BEFORE, before);\n        }\n        if (source != null) {\n            struct.put(FieldName.SOURCE, source);\n        }\n        if (timestamp != null) {\n            struct.put(FieldName.TIMESTAMP, timestamp.toEpochMilli());\n        }\n        return struct;\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-708-Param-7",
    "old_comment_raw": "@param _float None (optional)",
    "old_code_raw": "  public Call testEndpointParametersAsync(String number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password, final ApiCallback<Void> callback) throws ApiException {\n\n    ProgressResponseBody.ProgressListener progressListener = null;\n    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n    if (callback != null) {\n      progressListener = new ProgressResponseBody.ProgressListener() {\n        @Override\n        public void update(long bytesRead, long contentLength, boolean done) {\n          callback.onDownloadProgress(bytesRead, contentLength, done);\n        }\n      };\n\n      progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {\n        @Override\n        public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {\n          callback.onUploadProgress(bytesWritten, contentLength, done);\n        }\n      };\n    }\n\n    Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, progressListener, progressRequestListener);\n    apiClient.executeAsync(call, callback);\n    return call;\n  }\n",
    "new_code_raw": "  public Call testEndpointParametersAsync(BigDecimal number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password, final ApiCallback<Void> callback) throws ApiException {\n\n    ProgressResponseBody.ProgressListener progressListener = null;\n    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n    if (callback != null) {\n      progressListener = new ProgressResponseBody.ProgressListener() {\n        @Override\n        public void update(long bytesRead, long contentLength, boolean done) {\n          callback.onDownloadProgress(bytesRead, contentLength, done);\n        }\n      };\n\n      progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {\n        @Override\n        public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {\n          callback.onUploadProgress(bytesWritten, contentLength, done);\n        }\n      };\n    }\n\n    Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, progressListener, progressRequestListener);\n    apiClient.executeAsync(call, callback);\n    return call;\n  }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2405-Param-1",
    "old_comment_raw": "@param map The map from string to GrammaticalRelation",
    "old_code_raw": "  public static GrammaticalRelation valueOf(String s, Map<String, GrammaticalRelation> map) {\n    if (map.containsKey(s)) {\n      return map.get(s);\n    }\n    return null;\n  }\n",
    "new_code_raw": "  public static GrammaticalRelation valueOf(String s, Collection<GrammaticalRelation> values) {\n    for (GrammaticalRelation reln : values) {\n      if (reln.toString().equals(s)) return reln;\n    }\n\n    return null;\n  }\n"
  },
  {
    "id": "socketio_socket.io_client_java-11-Param-0",
    "old_comment_raw": "@param event an event name.",
    "old_code_raw": "    public Emitter emit(final String event, final Object... arguments) {\n        EventThread.exec(new Runnable() {\n            @Override\n            public void run() {\n                if (events.containsKey(event)) {\n                    Socket.super.emit(event, arguments);\n                    return;\n                }\n\n                List<Object> args = new ArrayList<Object>(arguments.length + 1);\n                args.add(event);\n                args.addAll(Arrays.asList(arguments));\n                JSONArray _args = new JSONArray(args);\n                int parserType = Parser.EVENT;\n                if (HasBinaryData.hasBinary(_args)) { parserType = Parser.BINARY_EVENT; }\n                Packet packet = new Packet(parserType, _args);\n\n                if (args.get(args.size() - 1) instanceof Ack) {\n                    logger.fine(String.format(\"emitting packet with ack id %d\", Socket.this.ids));\n                    Socket.this.acks.put(Socket.this.ids, (Ack)args.remove(args.size() - 1));\n                    packet.id = Socket.this.ids++;\n                }\n\n                Socket.this.packet(packet);\n            }\n        });\n        return this;\n    }\n",
    "new_code_raw": "    public Emitter emit(final String event, final Object... args) {\n        EventThread.exec(new Runnable() {\n            @Override\n            public void run() {\n                if (events.containsKey(event)) {\n                    Socket.super.emit(event, args);\n                    return;\n                }\n\n                List<Object> _args = new ArrayList<Object>(args.length + 1);\n                _args.add(event);\n                _args.addAll(Arrays.asList(args));\n                JSONArray jsonArgs = new JSONArray(_args);\n                int parserType = Parser.EVENT;\n                if (HasBinaryData.hasBinary(jsonArgs)) { parserType = Parser.BINARY_EVENT; }\n                Packet packet = new Packet(parserType, jsonArgs);\n\n                if (_args.get(_args.size() - 1) instanceof Ack) {\n                    logger.fine(String.format(\"emitting packet with ack id %d\", Socket.this.ids));\n                    Socket.this.acks.put(Socket.this.ids, (Ack)_args.remove(_args.size() - 1));\n                    packet.id = Socket.this.ids++;\n                }\n\n                Socket.this.packet(packet);\n            }\n        });\n        return this;\n    }\n"
  },
  {
    "id": "Letractively_prisms-17-Associations-Param1",
    "old_comment_raw": "@param toEdit The user to be edited",
    "old_code_raw": "\tpublic static boolean canEdit(User manager, User toEdit)\r\n\t{\r\n\t\tif(isAdmin(manager))\r\n\t\t\treturn true;\r\n\t\tif(isAdmin(toEdit))\r\n\t\t\treturn false;\r\n\r\n\t\treturn getManagementLevel(manager) > getManagementLevel(toEdit);\r\n\t}\r\n",
    "new_code_raw": "\tpublic static boolean canEdit(Permissions perms, Permissions user2Perms)\r\n\t{\r\n\t\tif(isAdmin(perms))\r\n\t\t\treturn true;\r\n\t\tif(isAdmin(user2Perms))\r\n\t\t\treturn false;\r\n\r\n\t\treturn getManagementLevel(perms) > getManagementLevel(user2Perms);\r\n\t}\r\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1595-Param-0",
    "old_comment_raw": "@param orderId ID of pet that needs to be fetched (required)",
    "old_code_raw": "  public Order getOrderById(Long orderId) throws ApiException {\n    Object localVarPostBody = null;\n    \n    // verify the required parameter 'orderId' is set\n    if (orderId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'orderId' when calling getOrderById\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/store/order/{orderId}\".replaceAll(\"\\\\{format\\\\}\",\"json\")\n      .replaceAll(\"\\\\{\" + \"orderId\" + \"\\\\}\", apiClient.escapeString(orderId.toString()));\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/xml\", \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Order> localVarReturnType = new GenericType<Order>() {};\n    return apiClient.invokeAPI(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public Order getOrderById(String orderId) throws ApiException {\n    Object localVarPostBody = null;\n    \n    // verify the required parameter 'orderId' is set\n    if (orderId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'orderId' when calling getOrderById\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/store/order/{orderId}\".replaceAll(\"\\\\{format\\\\}\",\"json\")\n      .replaceAll(\"\\\\{\" + \"orderId\" + \"\\\\}\", apiClient.escapeString(orderId.toString()));\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n    \n\n    \n\n    \n\n    final String[] localVarAccepts = {\n      \"application/json\", \"application/xml\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"test_api_key_query\", \"test_api_key_header\" };\n\n    \n    GenericType<Order> localVarReturnType = new GenericType<Order>() {};\n    return apiClient.invokeAPI(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n    \n  }\n"
  },
  {
    "id": "zaproxy_zaproxy-2130-Param-0",
    "old_comment_raw": "@param panelToolbar2 the toolbar",
    "old_code_raw": "\tprotected int addToolBarElements(JToolBar panelToolbar2, Location loc, int gridX) {\n\t\t// Override to add elements into the toolbar\n\t\treturn gridX;\n\t}\n",
    "new_code_raw": "\tprotected int addToolBarElements(JToolBar toolBar, Location location, int gridX) {\n\t\treturn gridX;\n\t}\n"
  },
  {
    "id": "hibernate_hibernate_orm-1947-Param-2",
    "old_comment_raw": "@param dialect Allow explicitly passing the Dialect to use.",
    "old_code_raw": "\tpublic List<String> generateCreationCommands(Metadata metadata, boolean createSchemas, Dialect dialect) {\n\t\tfinal ArrayList<String> commands = new ArrayList<String>();\n\t\tdoCreation(\n\t\t\t\tmetadata,\n\t\t\t\tcreateSchemas,\n\t\t\t\tdialect,\n\t\t\t\tnew Target() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean acceptsImportScriptActions() {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void prepare() {\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void accept(String action) {\n\t\t\t\t\t\tcommands.add( action );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void release() {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn commands;\n\t}\n",
    "new_code_raw": "\tpublic List<String> generateCreationCommands(Metadata metadata, boolean createNamespaces, Dialect dialect) {\n\t\tfinal ArrayList<String> commands = new ArrayList<String>();\n\t\tdoCreation(\n\t\t\t\tmetadata,\n\t\t\t\tcreateNamespaces,\n\t\t\t\tdialect,\n\t\t\t\tnew Target() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean acceptsImportScriptActions() {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void prepare() {\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void accept(String action) {\n\t\t\t\t\t\tcommands.add( action );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void release() {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn commands;\n\t}\n"
  },
  {
    "id": "apache_drill-965-Param-0",
    "old_comment_raw": "@param filterRel the FilterRel",
    "old_code_raw": "  private RexProgram createProgram(FilterRel filterRel) {\n    RexProgramBuilder programBuilder =\n        new RexProgramBuilder(\n            filterRel.getRowType(),\n            filterRel.getCluster().getRexBuilder());\n    programBuilder.addIdentity();\n    programBuilder.addCondition(filterRel.getCondition());\n    return programBuilder.getProgram();\n  }\n",
    "new_code_raw": "  private RexProgram createProgram(Filter filterRel) {\n    RexProgramBuilder programBuilder =\n        new RexProgramBuilder(\n            filterRel.getRowType(),\n            filterRel.getCluster().getRexBuilder());\n    programBuilder.addIdentity();\n    programBuilder.addCondition(filterRel.getCondition());\n    return programBuilder.getProgram();\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1196-Param-0",
    "old_comment_raw": "@param ps The prepared statement to which to bind the parameter values.",
    "old_code_raw": "\tprotected void coordinateSharedCacheCleanup(SessionImplementor session) {\n\t\tfinal BulkOperationCleanupAction action = new BulkOperationCleanupAction( session, getCustomQuery().getQuerySpaces() );\n\n\t\tif ( session.isEventSource() ) {\n\t\t\t( (EventSource) session ).getActionQueue().addAction( action );\n\t\t}\n\t\telse {\n\t\t\taction.getAfterTransactionCompletionProcess().doAfterTransactionCompletion( true, session );\n\t\t}\n\t}\n",
    "new_code_raw": "\tprotected void coordinateSharedCacheCleanup(SharedSessionContractImplementor session) {\n\t\tfinal BulkOperationCleanupAction action = new BulkOperationCleanupAction( session, getCustomQuery().getQuerySpaces() );\n\n\t\tif ( session.isEventSource() ) {\n\t\t\t( (EventSource) session ).getActionQueue().addAction( action );\n\t\t}\n\t\telse {\n\t\t\taction.getAfterTransactionCompletionProcess().doAfterTransactionCompletion( true, session );\n\t\t}\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1636-Param-0",
    "old_comment_raw": "@param body Created user object",
    "old_code_raw": "  public void createUser (User body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = body;\n    // verify the required parameter 'body' is set\n    if (body == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'body' when calling createUser\",\n        new ApiException(400, \"Missing the required parameter 'body' when calling createUser\"));\n    }\n\n    // create path and map variables\n    String path = \"/user\";\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n    }\n\n    String[] authNames = new String[] {  };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n",
    "new_code_raw": "  public void createUser (User user) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = user;\n    // verify the required parameter 'user' is set\n    if (user == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'user' when calling createUser\",\n        new ApiException(400, \"Missing the required parameter 'user' when calling createUser\"));\n    }\n\n    // create path and map variables\n    String path = \"/user\";\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n      \"application/json\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n    }\n\n    String[] authNames = new String[] {  };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-210-Param-1",
    "old_comment_raw": "@param tokens The tokens of the sentence, to form the backing labels of the tree.",
    "old_code_raw": "  public static SemanticGraph parseTree(String conll, List<CoreLabel> tokens) {\n    SemanticGraph tree = new SemanticGraph();\n    if (conll == null || conll.isEmpty()) {\n      return tree;\n    }\n    String[] treeLines = newline.split(conll);\n    IndexedWord[] vertices = new IndexedWord[tokens.size() + 2];\n    // Add edges\n    for (String line : treeLines) {\n      // Parse row\n      String[] fields = tab.split(line);\n      int dependentIndex = Integer.parseInt(fields[0]);\n      if (vertices[dependentIndex] == null) {\n        if (dependentIndex > tokens.size()) {\n          // Bizarre mismatch in sizes; the malt parser seems to do this often\n          return new SemanticGraph();\n        }\n        vertices[dependentIndex] = new IndexedWord(tokens.get(dependentIndex - 1));\n      }\n      IndexedWord dependent = vertices[dependentIndex];\n      int governorIndex = Integer.parseInt(fields[1]);\n      if (governorIndex > tokens.size()) {\n        // Bizarre mismatch in sizes; the malt parser seems to do this often\n        return new SemanticGraph();\n      }\n      if (vertices[governorIndex] == null && governorIndex > 0) {\n        vertices[governorIndex] = new IndexedWord(tokens.get(governorIndex - 1));\n      }\n      IndexedWord governor = vertices[governorIndex];\n      String relation = fields[2];\n\n      // Process row\n      if (governorIndex == 0) {\n        tree.addRoot(dependent);\n      } else {\n        tree.addVertex(dependent);\n        if (!tree.containsVertex(governor)) {\n          tree.addVertex(governor);\n        }\n        if (!\"ref\".equals(relation)) {\n          tree.addEdge(governor, dependent, GrammaticalRelation.valueOf(Language.English, relation), Double.NEGATIVE_INFINITY, false);\n        }\n      }\n    }\n    return tree;\n  }\n",
    "new_code_raw": "  public static SemanticGraph parseTree(JsonReader json, List<CoreLabel> tokens) {\n    SemanticGraph tree = new SemanticGraph();\n    JsonArray array = json.readArray();\n\n    if (array == null || array.isEmpty()) {\n      return tree;\n    }\n\n    IndexedWord[] vertices = new IndexedWord[tokens.size() + 2];\n    // Add edges\n    for(int i = 0; i < array.size(); i++) {\n      JsonObject entry = array.getJsonObject(i);\n      // Parse row\n      int dependentIndex = entry.getInt(\"dependent\");\n      if (vertices[dependentIndex] == null) {\n        if (dependentIndex > tokens.size()) {\n          // Bizarre mismatch in sizes; the malt parser seems to do this often\n          return new SemanticGraph();\n        }\n        vertices[dependentIndex] = new IndexedWord(tokens.get(dependentIndex - 1));\n      }\n      IndexedWord dependent = vertices[dependentIndex];\n      int governorIndex = entry.getInt(\"governor\");\n      if (governorIndex > tokens.size()) {\n        // Bizarre mismatch in sizes; the malt parser seems to do this often\n        return new SemanticGraph();\n      }\n      if (vertices[governorIndex] == null && governorIndex > 0) {\n        vertices[governorIndex] = new IndexedWord(tokens.get(governorIndex - 1));\n      }\n      IndexedWord governor = vertices[governorIndex];\n      String relation = entry.getString(\"dep\");\n\n      // Process row\n      if (governorIndex == 0) {\n        tree.addRoot(dependent);\n      } else {\n        tree.addVertex(dependent);\n        if (!tree.containsVertex(governor)) {\n          tree.addVertex(governor);\n        }\n        if (!\"ref\".equals(relation)) {\n          tree.addEdge(governor, dependent, GrammaticalRelation.valueOf(Language.English, relation), Double.NEGATIVE_INFINITY, false);\n        }\n      }\n    }\n    return tree;\n  }\n"
  },
  {
    "id": "querydsl_querydsl-1046-Param-1",
    "old_comment_raw": "@param template",
    "old_code_raw": "    public TemplateExpressionImpl(Class<? extends T> type, Template template, Expression<?>... args){\n        this(type, template, Arrays.<Expression<?>>asList(args));\n    }    \n",
    "new_code_raw": "    public TemplateExpressionImpl(Class<? extends T> type, Template template, Object... args){\n        this(type, template, Arrays.<Object>asList(args));\n    }    \n"
  },
  {
    "id": "apache_calcite-889-Param-0",
    "old_comment_raw": "@param now The current time in millis, as returned by  System#currentTimeMillis()",
    "old_code_raw": "  public CalciteSchema createSnapshot(long now) {\n    Preconditions.checkArgument(this.isRoot(), \"must be root schema\");\n    return snapshot(null, now);\n  }\n",
    "new_code_raw": "  public CalciteSchema createSnapshot(SchemaVersion version) {\n    Preconditions.checkArgument(this.isRoot(), \"must be root schema\");\n    return snapshot(null, version);\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1696-Param-0",
    "old_comment_raw": "@param petId ID of pet to update",
    "old_code_raw": "    public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws RestClientException {\n        Object postBody = new Object();\n        \n        // verify the required parameter 'petId' is set\n        if (petId == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n        }\n        \n        // verify the required parameter 'file' is set\n        if (file == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'file' when calling uploadFileWithRequiredFile\");\n        }\n        \n        // create path and map variables\n        final Map<String, Object> uriVariables = new HashMap<String, Object>();\n        uriVariables.put(\"petId\", petId);\n        String path = UriComponentsBuilder.fromPath(\"/fake/{petId}/uploadImageWithRequiredFile\").buildAndExpand(uriVariables).toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n        \n        if (additionalMetadata != null)\n            formParams.add(\"additionalMetadata\", additionalMetadata);\n        if (file != null)\n            formParams.add(\"file\", new FileSystemResource(file));\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"multipart/form-data\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"petstore_auth\" };\n\n        ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "new_code_raw": "    public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws RestClientException {\n        Object postBody = new Object();\n        \n        // verify the required parameter 'petId' is set\n        if (petId == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n        }\n        \n        // verify the required parameter 'requiredFile' is set\n        if (requiredFile == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\");\n        }\n        \n        // create path and map variables\n        final Map<String, Object> uriVariables = new HashMap<String, Object>();\n        uriVariables.put(\"petId\", petId);\n        String path = UriComponentsBuilder.fromPath(\"/fake/{petId}/uploadImageWithRequiredFile\").buildAndExpand(uriVariables).toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n        \n        if (additionalMetadata != null)\n            formParams.add(\"additionalMetadata\", additionalMetadata);\n        if (requiredFile != null)\n            formParams.add(\"requiredFile\", new FileSystemResource(requiredFile));\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"multipart/form-data\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"petstore_auth\" };\n\n        ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1727-Param-8",
    "old_comment_raw": "@param progressRequestListener Progress request listener",
    "old_code_raw": "    public Call buildCall(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n        Request request = buildRequest(path, method, queryParams, collectionQueryParams, body, headerParams, formParams, authNames, progressRequestListener);\n\n        return httpClient.newCall(request);\n    }\n",
    "new_code_raw": "    public Call buildCall(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {\n        Request request = buildRequest(path, method, queryParams, collectionQueryParams, body, headerParams, formParams, authNames, callback);\n\n        return httpClient.newCall(request);\n    }\n"
  },
  {
    "id": "graphql_java_graphql_java-240-Param-0",
    "old_comment_raw": "@param relativeError relative error",
    "old_code_raw": "    private List<SourceLocation> createAbsoluteLocations(GraphQLError relativeError, List<Field> fields) {\n        Optional<SourceLocation> baseLocation;\n        if (!fields.isEmpty()) {\n            baseLocation = Optional.ofNullable(fields.get(0).getSourceLocation());\n        } else {\n            baseLocation = Optional.empty();\n        }\n\n        // relative error empty path should yield an absolute error with the base path\n        if (relativeError.getLocations() != null && relativeError.getLocations().isEmpty()) {\n            return baseLocation.map(Collections::singletonList).orElse(null);\n        }\n\n        return Optional.ofNullable(\n                relativeError.getLocations())\n                .map(locations -> locations.stream()\n                        .map(l ->\n                                baseLocation\n                                        .map(base -> new SourceLocation(\n                                                base.getLine() + l.getLine(),\n                                                base.getColumn() + l.getColumn()))\n                                        .orElse(null))\n                        .collect(Collectors.toList()))\n                .map(Collections::unmodifiableList)\n                .orElse(null);\n    }\n",
    "new_code_raw": "    private List<SourceLocation> createAbsoluteLocations(GraphQLError relativeError, MergedFields fields) {\n        Optional<SourceLocation> baseLocation = Optional.ofNullable(fields.getSingleField().getSourceLocation());\n//        if (!fields.isEmpty()) {\n//            baseLocation = Optional.ofNullable(fields.get(0).getSourceLocation());\n//        } else {\n//            baseLocation = Optional.empty();\n//        }\n\n        // relative error empty path should yield an absolute error with the base path\n        if (relativeError.getLocations() != null && relativeError.getLocations().isEmpty()) {\n            return baseLocation.map(Collections::singletonList).orElse(null);\n        }\n\n        return Optional.ofNullable(\n                relativeError.getLocations())\n                .map(locations -> locations.stream()\n                        .map(l ->\n                                baseLocation\n                                        .map(base -> new SourceLocation(\n                                                base.getLine() + l.getLine(),\n                                                base.getColumn() + l.getColumn()))\n                                        .orElse(null))\n                        .collect(Collectors.toList()))\n                .map(Collections::unmodifiableList)\n                .orElse(null);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2568-Param-0",
    "old_comment_raw": "@param p Swagger property object",
    "old_code_raw": "    public String toExampleValue(Property p) {\n        if(p.getExample() != null) {\n            return p.getExample().toString();\n        }\n        if (p instanceof StringProperty) {\n            return \"null\";\n        } else if (p instanceof BooleanProperty) {\n            return \"null\";\n        } else if (p instanceof DateProperty) {\n            return \"null\";\n        } else if (p instanceof DateTimeProperty) {\n            return \"null\";\n        } else if (p instanceof DoubleProperty) {\n            DoubleProperty dp = (DoubleProperty) p;\n            if (dp.getExample() != null) {\n                return dp.getExample().toString();\n            }\n            return \"null\";\n        } else if (p instanceof FloatProperty) {\n            FloatProperty dp = (FloatProperty) p;\n            if (dp.getExample() != null) {\n                return dp.getExample().toString();\n            }\n            return \"null\";\n        } else if (p instanceof IntegerProperty) {\n            IntegerProperty dp = (IntegerProperty) p;\n            if (dp.getExample() != null) {\n                return dp.getExample().toString();\n            }\n            return \"null\";\n        } else if (p instanceof LongProperty) {\n            LongProperty dp = (LongProperty) p;\n            if (dp.getExample() != null) {\n                return dp.getExample().toString();\n            }\n            return \"null\";\n        } else {\n            return \"null\";\n        }\n    }\n",
    "new_code_raw": "    public String toExampleValue(Schema schema) {\n        if (schema.getExample() != null) {\n            return schema.getExample().toString();\n        }\n\n        if (ModelUtils.isBooleanSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isDateSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isDateTimeSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isNumberSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isIntegerSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isStringSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isObjectSchema(schema)) {\n            return \"null\";\n        } else {\n            return \"null\";\n        }\n    }\n"
  },
  {
    "id": "apache_drill-688-Param-0",
    "old_comment_raw": "@param key mapper key",
    "old_code_raw": "  public List<String> get(String key) {\n    Integer index = keyToIndexMapper.get(key);\n    if (index == null) {\n      return Collections.emptyList();\n    }\n    return partitionValues.get(index);\n  }\n",
    "new_code_raw": "  public List<String> get(Path key) {\n    Integer index = keyToIndexMapper.get(key);\n    if (index == null) {\n      return Collections.emptyList();\n    }\n    return partitionValues.get(index);\n  }\n"
  },
  {
    "id": "apache_ant-ivy-46-Associations-Param1",
    "old_comment_raw": "@param file the file for which the new base directory should be returned.",
    "old_code_raw": "    File getBaseDir(File base, File file) {\n        if (base == null) {\n            return file.getParentFile().getAbsoluteFile();\n        } else {\n            Iterator bases = getParents(base).iterator();\n            Iterator fileParents = getParents(file.getAbsoluteFile()).iterator();\n            File result = null;\n            while (bases.hasNext() && fileParents.hasNext()) {\n                File next = (File) bases.next();\n                if (next.equals(fileParents.next())) {\n                    result = next;\n                } else {\n                    break;\n                }\n            }\n            return result;\n        }\n    }\n",
    "new_code_raw": "    File getBaseDir(final File file1, final File file2) {\n        if (file1 == null || file2 == null) {\n            return null;\n        }\n        final Iterator bases = getParents(file1).iterator();\n        final Iterator fileParents = getParents(file2.getAbsoluteFile()).iterator();\n        File result = null;\n        while (bases.hasNext() && fileParents.hasNext()) {\n            File next = (File) bases.next();\n            if (next.equals(fileParents.next())) {\n                result = next;\n            } else {\n                break;\n            }\n        }\n        return result;\n    }\n\n"
  },
  {
    "id": "graphql_java_graphql_java-263-Param-1",
    "old_comment_raw": "@param parameters contains the parameters holding the fields to be executed and source object",
    "old_code_raw": "    protected FieldValueInfo completeField(ExecutionContext executionContext, ExecutionStrategyParameters parameters, Object fetchedValue) {\n        Field field = parameters.getField().getSingleField();\n        GraphQLObjectType parentType = (GraphQLObjectType) parameters.getExecutionStepInfo().getUnwrappedNonNullType();\n        GraphQLFieldDefinition fieldDef = getFieldDef(executionContext.getGraphQLSchema(), parentType, field);\n        ExecutionStepInfo executionStepInfo = createExecutionStepInfo(executionContext, parameters, fieldDef);\n\n        Instrumentation instrumentation = executionContext.getInstrumentation();\n        InstrumentationFieldCompleteParameters instrumentationParams = new InstrumentationFieldCompleteParameters(executionContext, parameters, fieldDef, executionStepInfo, fetchedValue);\n        InstrumentationContext<ExecutionResult> ctxCompleteField = instrumentation.beginFieldComplete(\n                instrumentationParams\n        );\n\n        GraphQLCodeRegistry codeRegistry = executionContext.getGraphQLSchema().getCodeRegistry();\n        Map<String, Object> argumentValues = valuesResolver.getArgumentValues(codeRegistry, fieldDef.getArguments(), field.getArguments(), executionContext.getVariables());\n\n        NonNullableFieldValidator nonNullableFieldValidator = new NonNullableFieldValidator(executionContext, executionStepInfo);\n\n        ExecutionStrategyParameters newParameters = parameters.transform(builder ->\n                builder.executionStepInfo(executionStepInfo)\n                        .arguments(argumentValues)\n                        .source(fetchedValue)\n                        .nonNullFieldValidator(nonNullableFieldValidator)\n        );\n\n        log.debug(\"'{}' completing field '{}'...\", executionContext.getExecutionId(), executionStepInfo.getPath());\n\n        FieldValueInfo fieldValueInfo = completeValue(executionContext, newParameters);\n\n        CompletableFuture<ExecutionResult> executionResultFuture = fieldValueInfo.getFieldValue();\n        ctxCompleteField.onDispatched(executionResultFuture);\n        executionResultFuture.whenComplete(ctxCompleteField::onCompleted);\n        return fieldValueInfo;\n    }\n",
    "new_code_raw": "    protected FieldValueInfo completeField(ExecutionContext executionContext, ExecutionStrategyParameters parameters, FetchedValue fetchedValue) {\n        Field field = parameters.getField().getSingleField();\n        GraphQLObjectType parentType = (GraphQLObjectType) parameters.getExecutionStepInfo().getUnwrappedNonNullType();\n        GraphQLFieldDefinition fieldDef = getFieldDef(executionContext.getGraphQLSchema(), parentType, field);\n        ExecutionStepInfo executionStepInfo = createExecutionStepInfo(executionContext, parameters, fieldDef);\n\n        Instrumentation instrumentation = executionContext.getInstrumentation();\n        InstrumentationFieldCompleteParameters instrumentationParams = new InstrumentationFieldCompleteParameters(executionContext, parameters, fieldDef, executionStepInfo, fetchedValue);\n        InstrumentationContext<ExecutionResult> ctxCompleteField = instrumentation.beginFieldComplete(\n                instrumentationParams\n        );\n\n        GraphQLCodeRegistry codeRegistry = executionContext.getGraphQLSchema().getCodeRegistry();\n        Map<String, Object> argumentValues = valuesResolver.getArgumentValues(codeRegistry, fieldDef.getArguments(), field.getArguments(), executionContext.getVariables());\n\n        NonNullableFieldValidator nonNullableFieldValidator = new NonNullableFieldValidator(executionContext, executionStepInfo);\n\n        ExecutionStrategyParameters newParameters = parameters.transform(builder ->\n                builder.executionStepInfo(executionStepInfo)\n                        .arguments(argumentValues)\n                        .source(fetchedValue.getFetchedValue())\n                        .localContext(fetchedValue.getLocalContext())\n                        .nonNullFieldValidator(nonNullableFieldValidator)\n        );\n\n        log.debug(\"'{}' completing field '{}'...\", executionContext.getExecutionId(), executionStepInfo.getPath());\n\n        FieldValueInfo fieldValueInfo = completeValue(executionContext, newParameters);\n\n        CompletableFuture<ExecutionResult> executionResultFuture = fieldValueInfo.getFieldValue();\n        ctxCompleteField.onDispatched(executionResultFuture);\n        executionResultFuture.whenComplete(ctxCompleteField::onCompleted);\n        return fieldValueInfo;\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-154-Param-1",
    "old_comment_raw": "@param l2",
    "old_code_raw": "  public static List<Integer> getSubListIndex(Object[] l1, Object[] l2){\n    if(l1.length > l2.length)\n      return null;\n    List<Integer> allIndices = new ArrayList<Integer>();\n    boolean matched = false;\n    int index = -1;\n    int lastUnmatchedIndex = 0;\n    for(int i = 0 ; i < l2.length;){\n      for(int j = 0; j < l1.length ;){\n        if(l1[j].equals(l2[i])){\n          index = i;\n          i++;\n          j++;\n          if(j == l1.length)\n          {\n            matched = true;\n            break;\n          }\n        }else{\n          j = 0;\n          i = lastUnmatchedIndex +1;\n          lastUnmatchedIndex = i;\n          index = -1;\n          if(lastUnmatchedIndex == l2.length)\n            break;\n        }\n        if(i >= l2.length){\n          index = -1;\n          break;\n        }\n      }\n      if(i == l2.length || matched){\n        if(index >= 0)\n          //index = index - l1.length + 1;\n          allIndices.add(index - l1.length + 1);\n        matched = false;\n        lastUnmatchedIndex = index;\n\n        //break;\n      }\n    }\n    //get starting point\n\n    return allIndices;\n  }\n",
    "new_code_raw": "  public static List<Integer> getSubListIndex(Object[] tofind, Object[] tokens){\n    if(tofind.length > tokens.length)\n      return null;\n    List<Integer> allIndices = new ArrayList<Integer>();\n    boolean matched = false;\n    int index = -1;\n    int lastUnmatchedIndex = 0;\n    for(int i = 0 ; i < tokens.length;){\n      for(int j = 0; j < tofind.length ;){\n        if(tofind[j].equals(tokens[i])){\n          index = i;\n          i++;\n          j++;\n          if(j == tofind.length)\n          {\n            matched = true;\n            break;\n          }\n        }else{\n          j = 0;\n          i = lastUnmatchedIndex +1;\n          lastUnmatchedIndex = i;\n          index = -1;\n          if(lastUnmatchedIndex == tokens.length)\n            break;\n        }\n        if(i >= tokens.length){\n          index = -1;\n          break;\n        }\n      }\n      if(i == tokens.length || matched){\n        if(index >= 0)\n          //index = index - l1.length + 1;\n          allIndices.add(index - tofind.length + 1);\n        matched = false;\n        lastUnmatchedIndex = index;\n\n        //break;\n      }\n    }\n    //get starting point\n\n    return allIndices;\n  }\n"
  },
  {
    "id": "debezium_debezium-734-Param-1",
    "old_comment_raw": "@param timestamp the timestamp in milliseconds at which the copy operation was started",
    "old_code_raw": "    protected long copyCollection(CollectionId collectionId, long timestamp) throws InterruptedException {\n        AtomicLong docCount = new AtomicLong();\n        primaryClient.executeBlocking(\"sync '\" + collectionId + \"'\", primary -> {\n            docCount.set(copyCollection(primary, collectionId, timestamp));\n        });\n        return docCount.get();\n    }\n",
    "new_code_raw": "    protected long copyCollection(CollectionId collectionId, Instant timestamp) throws InterruptedException {\n        AtomicLong docCount = new AtomicLong();\n        primaryClient.executeBlocking(\"sync '\" + collectionId + \"'\", primary -> {\n            docCount.set(copyCollection(primary, collectionId, timestamp));\n        });\n        return docCount.get();\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-1505-Param-0",
    "old_comment_raw": "@param search the string to be searched. The parameter will be interpreted as a regular expression.",
    "old_code_raw": "\tpublic boolean searchForText(String search, int matches, boolean scroll) {\n\t\tsleeper.sleep();\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(search);\n\t\tMatcher matcher;\n\t\tArrayList<TextView> textViewList = viewFetcher.getCurrentViews(TextView.class);\n\t\tif(matches == 0)\n\t\t\tmatches = 1;\n\t\tfor(TextView textView : textViewList){\n\t\t\tmatcher = p.matcher(textView.getText().toString());\n\t\t\tif(matcher.find()){\t\n\t\t\t\tcountMatches++;\n\t\t\t}\n\t\t\tif (countMatches == matches) {\n\t\t\t\tcountMatches=0;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (scroll && scroller.scroll(Scroller.Direction.DOWN)) {\n\t\t\treturn searchForText(search, matches, scroll);\n\t\t} else {\n\t\t\tif (countMatches > 0)\n\t\t\t\tLog.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + search);\n\t\t\tcountMatches=0;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t}\n",
    "new_code_raw": "\tpublic boolean searchForText(String regex, int matches, boolean scroll) {\n\t\tsleeper.sleep();\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(regex);\n\t\tMatcher matcher;\n\t\tArrayList<TextView> textViewList = viewFetcher.getCurrentViews(TextView.class);\n\t\tif(matches == 0)\n\t\t\tmatches = 1;\n\t\tfor(TextView textView : textViewList){\n\t\t\tmatcher = p.matcher(textView.getText().toString());\n\t\t\tif(matcher.find()){\t\n\t\t\t\tcountMatches++;\n\t\t\t}\n\t\t\tif (countMatches == matches) {\n\t\t\t\tcountMatches=0;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (scroll && scroller.scroll(Scroller.Direction.DOWN)) {\n\t\t\treturn searchForText(regex, matches, scroll);\n\t\t} else {\n\t\t\tif (countMatches > 0)\n\t\t\t\tLog.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + regex);\n\t\t\tcountMatches=0;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t}\n"
  },
  {
    "id": "LawnchairLauncher_Lawnchair-28-Param-0",
    "old_comment_raw": "@param context The application's context.",
    "old_code_raw": "    static Folder fromXml(Launcher launcher) {\n        return (Folder) launcher.getLayoutInflater().inflate(R.layout.user_folder, null);\n    }\n",
    "new_code_raw": "    static Folder fromXml(Context context) {\n        return (Folder) LayoutInflater.from(context).inflate(R.layout.user_folder, null);\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-1005-Param-0",
    "old_comment_raw": "@param search the string to be searched. The parameter will be interpreted as a regular expression.",
    "old_code_raw": "\tpublic boolean searchText(String search, int matches) {\n\t\tboolean found = searcher.searchText(search, matches, true);\n\t\treturn found;\n\n\t}\n",
    "new_code_raw": "\tpublic boolean searchText(String regex, int matches) {\n\t\tboolean found = searcher.searchText(regex, matches, true);\n\t\treturn found;\n\n\t}\n"
  },
  {
    "id": "querydsl_querydsl-904-Param-1",
    "old_comment_raw": "@param expr",
    "old_code_raw": "    public ScrollableResults scroll(ScrollMode mode, Expr<?> expr) {\n        Query query = createQuery(expr);\n        reset();\n        return query.scroll(mode);\n    }\n",
    "new_code_raw": "    public ScrollableResults scroll(ScrollMode mode, Expression<?> expr) {\n        Query query = createQuery(expr);\n        reset();\n        return query.scroll(mode);\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-263-Param-1",
    "old_comment_raw": "@param printOnlyLabelValue If true, print only the value() of each node's label",
    "old_code_raw": "  public StringBuilder toStringBuilder(StringBuilder sb, boolean printOnlyLabelValue) {\n    if (isLeaf()) {\n      if (label() != null) {\n        if(printOnlyLabelValue) {\n          sb.append(label().value());\n        } else {\n          sb.append(label());\n        }\n      }\n      return sb;\n    } else {\n      sb.append('(');\n      if (label() != null) {\n        if (printOnlyLabelValue) {\n          if (value() != null) {\n            sb.append(label().value());\n          }\n          // don't print a null, just nothing!\n        } else {\n          sb.append(valueAndSentimentString());\n        }\n      }\n      Tree[] kids = children();\n      if (kids != null) {\n        for (Tree kid : kids) {\n          sb.append(' ');\n          kid.toStringBuilder(sb, printOnlyLabelValue);\n        }\n      }\n      return sb.append(')');\n    }\n  }\n",
    "new_code_raw": "  public StringBuilder toStringBuilder(StringBuilder sb, Function<Label,String> labelFormatter) {\n    if (isLeaf()) {\n      if (label() != null) {\n        sb.append(labelFormatter.apply(label()));\n      }\n      return sb;\n    } else {\n      sb.append('(');\n      if (label() != null) {\n        sb.append(labelFormatter.apply(label()));\n      }\n      Tree[] kids = children();\n      if (kids != null) {\n        for (Tree kid : kids) {\n          sb.append(' ');\n          kid.toStringBuilder(sb, labelFormatter);\n        }\n      }\n      return sb.append(')');\n    }\n  }\n"
  },
  {
    "id": "apache_kylin-357-Param-0",
    "old_comment_raw": "@param tableDesc",
    "old_code_raw": "    public static String quoteIdentifierInSqlExpr(TableDesc tableDesc, String sqlExpr) {\n        String table = tableDesc.getName();\n        boolean tableMatched = false;\n        List<String> tabPatterns = getTableNameOrAliasPatterns(table);\n        if (isIdentifierNeedToQuote(sqlExpr, table, tabPatterns)) {\n            sqlExpr = quoteIdentifier(sqlExpr, table, tabPatterns);\n            tableMatched = true;\n        }\n\n        if (tableMatched) {\n            for (ColumnDesc columnDesc : tableDesc.getColumns()) {\n                String column = columnDesc.getName();\n                List<String> colPatterns = getColumnNameOrAliasPatterns(column);\n                if (isIdentifierNeedToQuote(sqlExpr, column, colPatterns)) {\n                    sqlExpr = quoteIdentifier(sqlExpr, column, colPatterns);\n                }\n            }\n        }\n\n        return sqlExpr;\n    }\n",
    "new_code_raw": "    public static String quoteIdentifierInSqlExpr(TableDesc tableDesc, String sqlExpr, SqlDialect sqlDialect) {\n        String table = tableDesc.getName();\n        boolean tableMatched = false;\n        List<String> tabPatterns = getTableNameOrAliasPatterns(table);\n        if (isIdentifierNeedToQuote(sqlExpr, table, tabPatterns)) {\n            sqlExpr = quoteIdentifier(sqlExpr, table, tabPatterns, sqlDialect);\n            tableMatched = true;\n        }\n\n        if (tableMatched) {\n            for (ColumnDesc columnDesc : tableDesc.getColumns()) {\n                String column = columnDesc.getName();\n                List<String> colPatterns = getColumnNameOrAliasPatterns(column);\n                if (isIdentifierNeedToQuote(sqlExpr, column, colPatterns)) {\n                    sqlExpr = quoteIdentifier(sqlExpr, column, colPatterns, sqlDialect);\n                }\n            }\n        }\n\n        return sqlExpr;\n    }\n"
  },
  {
    "id": "apache_deltaspike-17-Associations-Param0",
    "old_comment_raw": "@param repoClass The Repository class to lookup the method for",
    "old_code_raw": "    public RepositoryMetadata lookupComponent(Class<?> repoClass)\r\n    {\r\n        if (repositoriesMetadata.containsKey(repoClass))\r\n        {\r\n            return repositoriesMetadata.get(repoClass);\r\n        }\r\n        throw new RuntimeException(\"Unknown Repository class \" + repoClass.getName());\r\n    }\r\n",
    "new_code_raw": "    public RepositoryMetadata lookupComponent(Class<?> repositoryClass)\r\n    {\r\n        if (repositoriesMetadata.containsKey(repositoryClass))\r\n        {\r\n            return repositoriesMetadata.get(repositoryClass);\r\n        }\r\n        throw new RuntimeException(\"Unknown Repository class \" + repositoryClass.getName());\r\n    }\r\n\n"
  },
  {
    "id": "querydsl_querydsl-678-Param-0",
    "old_comment_raw": "@param template",
    "old_code_raw": "    public static StringExpression stringTemplate(Template template, Object... args) {\n        return new StringTemplate(template, ImmutableList.copyOf(args));\n    }\n",
    "new_code_raw": "    public static StringTemplate stringTemplate(String template, ImmutableList<?> args) {\n        return new StringTemplate(createTemplate(template), args);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1619-Param-2",
    "old_comment_raw": "@param allDefinitions a map of all Swagger models from the spec",
    "old_code_raw": "    public CodegenModel fromModel(String name, Model model, Map<String, Model> allDefinitions) {\n        if (typeAliases == null) {\n            // Only do this once during first call\n            typeAliases = getAllAliases(allDefinitions);\n        }\n        CodegenModel m = CodegenModelFactory.newInstance(CodegenModelType.MODEL);\n        if (reservedWords.contains(name)) {\n            m.name = escapeReservedWord(name);\n        } else {\n            m.name = name;\n        }\n        m.title = escapeText(model.getTitle());\n        m.description = escapeText(model.getDescription());\n        m.unescapedDescription = model.getDescription();\n        m.classname = toModelName(name);\n        m.classVarName = toVarName(name);\n        m.classFilename = toModelFilename(name);\n        m.modelJson = Json.pretty(model);\n        m.externalDocs = model.getExternalDocs();\n        m.vendorExtensions = model.getVendorExtensions();\n        m.isAlias = typeAliases.containsKey(name);\n\n        if (model instanceof ModelImpl) {\n            ModelImpl modelImpl = (ModelImpl) model;\n            m.discriminator = modelImpl.getDiscriminator();\n\n            if (modelImpl.getXml() != null) {\n                m.xmlPrefix = modelImpl.getXml().getPrefix();\n                m.xmlNamespace = modelImpl.getXml().getNamespace();\n                m.xmlName = modelImpl.getXml().getName();\n            }\n        }\n\n        if (model instanceof ArrayModel) {\n            ArrayModel am = (ArrayModel) model;\n            ArrayProperty arrayProperty = new ArrayProperty(am.getItems());\n            m.isArrayModel = true;\n            m.arrayModelType = fromProperty(name, arrayProperty).complexType;\n            addParentContainer(m, name, arrayProperty);\n        } else if (model instanceof RefModel) {\n            // TODO\n        } else if (model instanceof ComposedModel) {\n            final ComposedModel composed = (ComposedModel) model;\n            Map<String, Property> properties = new LinkedHashMap<String, Property>();\n            List<String> required = new ArrayList<String>();\n            Map<String, Property> allProperties;\n            List<String> allRequired;\n            if (supportsInheritance || supportsMixins) {\n                allProperties = new LinkedHashMap<String, Property>();\n                allRequired = new ArrayList<String>();\n                m.allVars = new ArrayList<CodegenProperty>();\n                int modelImplCnt = 0; // only one inline object allowed in a ComposedModel\n                for (Model innerModel: ((ComposedModel)model).getAllOf()) {\n                    if (innerModel instanceof ModelImpl) {\n                        ModelImpl modelImpl = (ModelImpl) innerModel;\n                        if (m.discriminator == null) {\n                            m.discriminator = modelImpl.getDiscriminator();\n                        }\n                        if (modelImpl.getXml() != null) {\n                            m.xmlPrefix = modelImpl.getXml().getPrefix();\n                            m.xmlNamespace = modelImpl.getXml().getNamespace();\n                            m.xmlName = modelImpl.getXml().getName();\n                        }\n                        if (modelImplCnt++ > 1) {\n                            LOGGER.warn(\"More than one inline schema specified in allOf:. Only the first one is recognized. All others are ignored.\");\n                            break; // only one ModelImpl with discriminator allowed in allOf\n                        }\n                    }\n                }\n            } else {\n                allProperties = null;\n                allRequired = null;\n            }\n            // parent model\n            RefModel parent = (RefModel) composed.getParent();\n\n            // interfaces (intermediate models)\n            if (composed.getInterfaces() != null) {\n                if (m.interfaces == null)\n                    m.interfaces = new ArrayList<String>();\n                for (RefModel _interface : composed.getInterfaces()) {\n                    Model interfaceModel = null;\n                    if (allDefinitions != null) {\n                        interfaceModel = allDefinitions.get(_interface.getSimpleRef());\n                    }\n                    // set first interface with discriminator found as parent\n                    if (parent == null\n                            && ((interfaceModel instanceof ModelImpl && ((ModelImpl) interfaceModel).getDiscriminator() != null)\n                            || (interfaceModel instanceof ComposedModel && isDiscriminatorInInterfaceTree((ComposedModel) interfaceModel, allDefinitions)))) {\n                        parent = _interface;\n                    } else {\n                        final String interfaceRef = toModelName(_interface.getSimpleRef());\n                        m.interfaces.add(interfaceRef);\n                        addImport(m, interfaceRef);\n                        if (allDefinitions != null) {\n                            if (!supportsMixins) {\n                                addProperties(properties, required, interfaceModel, allDefinitions);\n                            }\n                            if (supportsInheritance) {\n                                addProperties(allProperties, allRequired, interfaceModel, allDefinitions);\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (parent != null) {\n                final String parentRef = parent.getSimpleRef();\n                m.parentSchema = parentRef;\n                m.parent = toModelName(parent.getSimpleRef());\n                addImport(m, m.parent);\n                if (allDefinitions != null) {\n                    final Model parentModel = allDefinitions.get(m.parentSchema);\n                    if (supportsInheritance) {\n                        addProperties(allProperties, allRequired, parentModel, allDefinitions);\n                    } else {\n                        addProperties(properties, required, parentModel, allDefinitions);\n                    }\n                }\n            }\n\n            // child model (properties owned by the model itself)\n            Model child = composed.getChild();\n            if (child != null && child instanceof RefModel && allDefinitions != null) {\n                final String childRef = ((RefModel) child).getSimpleRef();\n                child = allDefinitions.get(childRef);\n            }\n            if (child != null && child instanceof ModelImpl) {\n                addProperties(properties, required, child, allDefinitions);\n                if (supportsInheritance) {\n                    addProperties(allProperties, allRequired, child, allDefinitions);\n                }\n            }\n            addVars(m, properties, required, allProperties, allRequired);\n        } else {\n            ModelImpl impl = (ModelImpl) model;\n            if (impl.getType() != null) {\n                Property p = PropertyBuilder.build(impl.getType(), impl.getFormat(), null);\n                m.dataType = getSwaggerType(p);\n            }\n            if(impl.getEnum() != null && impl.getEnum().size() > 0) {\n                m.isEnum = true;\n                // comment out below as allowableValues is not set in post processing model enum\n                m.allowableValues = new HashMap<String, Object>();\n                m.allowableValues.put(\"values\", impl.getEnum());\n            }\n            if (impl.getAdditionalProperties() != null) {\n                addAdditionPropertiesToCodeGenModel(m, impl);\n            }\n            addVars(m, impl.getProperties(), impl.getRequired());\n        }\n\n        if (m.vars != null) {\n            for(CodegenProperty prop : m.vars) {\n                postProcessModelProperty(m, prop);\n            }\n        }\n        return m;\n    }\n",
    "new_code_raw": "    public CodegenModel fromModel(String name, Schema schema, Map<String, Schema> allDefinitions) {\n        if (typeAliases == null) {\n            // Only do this once during first call\n            typeAliases = getAllAliases(allDefinitions);\n        }\n\n        CodegenModel m = CodegenModelFactory.newInstance(CodegenModelType.MODEL);\n\n        if (reservedWords.contains(name)) {\n            m.name = escapeReservedWord(name);\n        } else {\n            m.name = name;\n        }\n        m.title = escapeText(schema.getTitle());\n        m.description = escapeText(schema.getDescription());\n        m.unescapedDescription = schema.getDescription();\n        m.classname = toModelName(name);\n        m.classVarName = toVarName(name);\n        m.classFilename = toModelFilename(name);\n        m.modelJson = Json.pretty(schema);\n        m.externalDocumentation = schema.getExternalDocs();\n        if (schema.getExtensions() != null && !schema.getExtensions().isEmpty()) {\n            m.getVendorExtensions().putAll(schema.getExtensions());\n        }\n        m.isAlias = typeAliases.containsKey(name);\n        m.discriminator = schema.getDiscriminator();\n\n        if (schema.getXml() != null) {\n            m.xmlPrefix = schema.getXml().getPrefix();\n            m.xmlNamespace = schema.getXml().getNamespace();\n            m.xmlName = schema.getXml().getName();\n        }\n\n        if (ModelUtils.isArraySchema(schema)) {\n            m.isArrayModel = true;\n            m.arrayModelType = fromProperty(name, schema).complexType;\n            addParentContainer(m, name, schema);\n        } else if (schema instanceof ComposedSchema) {\n            final ComposedSchema composed = (ComposedSchema) schema;\n            Map<String, Schema> properties = new LinkedHashMap<String, Schema>();\n            List<String> required = new ArrayList<String>();\n            Map<String, Schema> allProperties;\n            List<String> allRequired;\n\n            if (supportsInheritance || supportsMixins) {\n                allProperties = new LinkedHashMap<String, Schema>();\n                allRequired = new ArrayList<String>();\n                m.allVars = new ArrayList<CodegenProperty>();\n                int modelImplCnt = 0; // only one inline object allowed in a ComposedModel\n                for (Schema innerModel : composed.getAllOf()) {\n                    if (m.discriminator == null) {\n                        m.discriminator = schema.getDiscriminator();\n                    }\n                    if (innerModel.getXml() != null) {\n                        m.xmlPrefix = innerModel.getXml().getPrefix();\n                        m.xmlNamespace = innerModel.getXml().getNamespace();\n                        m.xmlName = innerModel.getXml().getName();\n                    }\n                    if (modelImplCnt++ > 1) {\n                        LOGGER.warn(\"More than one inline schema specified in allOf:. Only the first one is recognized. All others are ignored.\");\n                        break; // only one ModelImpl with discriminator allowed in allOf\n                    }\n                }\n            } else {\n                allProperties = null;\n                allRequired = null;\n            }\n            // parent model\n            final String parentName = getParentName(composed, allDefinitions);\n            final Schema parent = StringUtils.isBlank(parentName) ? null : allDefinitions.get(parentName);\n\n            List<Schema> interfaces = getInterfaces(composed);\n\n            // interfaces (intermediate models)\n            if (interfaces != null) {\n                if (m.interfaces == null)\n                    m.interfaces = new ArrayList<String>();\n\n                for (Schema interfaceSchema : interfaces) {\n                    if (StringUtils.isBlank(interfaceSchema.get$ref())) {\n                        continue;\n                    }\n                    Schema refSchema = null;\n                    String ref = getSimpleRef(interfaceSchema.get$ref());\n                    if (allDefinitions != null) {\n                        refSchema = allDefinitions.get(ref);\n                    }\n                    final String modelName = toModelName(ref);\n                    m.interfaces.add(modelName);\n                    addImport(m, modelName);\n                    if (allDefinitions != null && refSchema != null) {\n                        if (!supportsMixins && !supportsInheritance) {\n                            addProperties(properties, required, refSchema, allDefinitions);\n                        }\n                        if (supportsInheritance) {\n                            addProperties(allProperties, allRequired, refSchema, allDefinitions);\n                        }\n                    }\n                }\n            }\n\n            if (parent != null) {\n                m.parentSchema = parentName;\n                m.parent = toModelName(parentName);\n                addImport(m, m.parent);\n                if (allDefinitions != null && !allDefinitions.isEmpty()) {\n                    if (supportsInheritance) {\n                        addProperties(allProperties, allRequired, parent, allDefinitions);\n                    } else {\n                        addProperties(properties, required, parent, allDefinitions);\n                    }\n                }\n            }\n\n            // child model (properties owned by the model itself)\n            Schema child = null;\n            if (composed.getAllOf() != null && !composed.getAllOf().isEmpty()) {\n                for (Schema component : composed.getAllOf()) {\n                    if (component.get$ref() == null) {\n                        child = component;\n                    }\n                }\n            }\n            if (child != null) {\n                addProperties(properties, required, child, allDefinitions);\n                if (supportsInheritance) {\n                    addProperties(allProperties, allRequired, child, allDefinitions);\n                }\n            }\n            addVars(m, properties, required, allProperties, allRequired);\n            // TODO\n            //} else if (schema instanceof RefModel) {\n        } else {\n            m.dataType = getSchemaType(schema);\n            if (schema.getEnum() != null && !schema.getEnum().isEmpty()) {\n                m.isEnum = true;\n                // comment out below as allowableValues is not set in post processing model enum\n                m.allowableValues = new HashMap<String, Object>();\n                m.allowableValues.put(\"values\", schema.getEnum());\n            }\n            if (ModelUtils.isMapSchema(schema)) {\n                addAdditionPropertiesToCodeGenModel(m, schema);\n            }\n            addVars(m, schema.getProperties(), schema.getRequired());\n        }\n\n        if (m.vars != null) {\n            for (CodegenProperty prop : m.vars) {\n                postProcessModelProperty(m, prop);\n            }\n        }\n        LOGGER.debug(\"debugging fromModel return: \" + m);\n\n        return m;\n    }\n"
  },
  {
    "id": "apache_activemq-393-Param-0",
    "old_comment_raw": "@param clientId",
    "old_code_raw": "    public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize) {\n        return new FilePendingMessageCursor(name, tmpStorage);\n    }\n",
    "new_code_raw": "    public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize, Subscription sub) {\n        return new FilePendingMessageCursor(name, tmpStorage);\n    }\n"
  },
  {
    "id": "debezium_debezium-1265-Param-0",
    "old_comment_raw": "@param years a number of years",
    "old_code_raw": "    public static double durationNanos(int years, int months, int days, int hours, int minutes, double seconds) {\n        return durationNanos(years, months, days, hours, minutes, seconds, 0);\n    }\n",
    "new_code_raw": "    public static long durationNanos(int years, int months, int days, int hours, int minutes, long seconds) {\n        return durationNanos(years, months, days, hours, minutes, seconds, 0);\n    }\n"
  },
  {
    "id": "apache_activemq-1284-Param-1",
    "old_comment_raw": "@param sync",
    "old_code_raw": "    public Location writeCommand(DataStructure command, boolean sync) throws IOException {\n        return asyncDataManager.write(wireFormat.marshal(command), sync);\n    }\n",
    "new_code_raw": "    public Location writeCommand(DataStructure command, boolean syncHint) throws IOException {\n        return asyncDataManager.write(wireFormat.marshal(command), (syncHint && syncOnWrite));\n    }\n"
  },
  {
    "id": "debezium_debezium-392-Param-3",
    "old_comment_raw": "@param tableId the table that should be included in the source info; may be null",
    "old_code_raw": "    protected SourceInfo update(Long lsn, Long useconds, Long txId, TableId tableId) {\n        this.lsn = lsn;\n        this.useconds = useconds;\n        this.txId = txId;\n        if (tableId != null && tableId.schema() != null) {\n            this.schemaName = tableId.schema();\n        }\n        if (tableId != null && tableId.table() != null) {\n            this.tableName = tableId.table();\n        }\n        return this;\n    }\n",
    "new_code_raw": "    protected SourceInfo update(Long lsn, Instant commitTime, Long txId, TableId tableId) {\n        this.lsn = lsn;\n        this.useconds = Conversions.toEpochMicros(commitTime);\n        this.txId = txId;\n        if (tableId != null && tableId.schema() != null) {\n            this.schemaName = tableId.schema();\n        }\n        if (tableId != null && tableId.table() != null) {\n            this.tableName = tableId.table();\n        }\n        return this;\n    }\n"
  },
  {
    "id": "facebook_fresco-79-Param-0",
    "old_comment_raw": "@param keys",
    "old_code_raw": "  public Task<Boolean> contains(final List<CacheKey> keys) {\n    if (keys.isEmpty()) {\n      return Task.forResult(false);\n    }\n    if (containsSync(keys)) {\n      return Task.forResult(true);\n    }\n    Task<Boolean> masterTask = containsAsync(keys.get(0));\n    if (keys.size() == 1) {\n      return masterTask;\n    }\n    for (final CacheKey key : keys.subList(1, keys.size())) {\n      masterTask = masterTask.continueWithTask(\n          new Continuation<Boolean, Task<Boolean>>() {\n            @Override\n            public Task<Boolean> then(Task<Boolean> previousTask) throws Exception {\n              if (previousTask.isCancelled() || previousTask.getResult()) {\n                return previousTask;\n              }\n              return containsAsync(key);\n            }\n          },\n          mReadExecutor);\n    }\n    return masterTask;\n  }\n",
    "new_code_raw": "  public Task<Boolean> contains(final CacheKey key) {\n    if (containsSync(key)) {\n      return Task.forResult(true);\n    }\n    return containsAsync(key);\n  }\n"
  },
  {
    "id": "graphql_java_graphql_java-56-Param-0",
    "old_comment_raw": "@param builderFunction a supplier for the builder impl",
    "old_code_raw": "        public Builder field(BuilderFunction<GraphQLFieldDefinition.Builder> builderFunction) {\n            assertNotNull(builderFunction, \"builderFunction can't be null\");\n            GraphQLFieldDefinition.Builder builder = GraphQLFieldDefinition.newFieldDefinition();\n            builder = builderFunction.apply(builder);\n            return field(builder);\n        }\n",
    "new_code_raw": "        public Builder field(UnaryOperator<GraphQLFieldDefinition.Builder> builderFunction) {\n            assertNotNull(builderFunction, \"builderFunction can't be null\");\n            GraphQLFieldDefinition.Builder builder = GraphQLFieldDefinition.newFieldDefinition();\n            builder = builderFunction.apply(builder);\n            return field(builder);\n        }\n"
  },
  {
    "id": "apache_drill-1032-Param-1",
    "old_comment_raw": "@param schemaConfig the source of session option value for partition column label",
    "old_code_raw": "  public static List<String> getPartitionColumnNames(FileSelection selection, SchemaConfig schemaConfig) {\n    int partitionsCount = getPartitionDepth(selection);\n\n    String partitionColumnLabel = schemaConfig.getOption(\n        ExecConstants.FILESYSTEM_PARTITION_COLUMN_LABEL).string_val;\n    List<String> partitions = new ArrayList<>();\n\n    // generates partition column names: dir0, dir1 etc.\n    for (int i = 0; i < partitionsCount; i++) {\n      partitions.add(partitionColumnLabel + i);\n    }\n    return partitions;\n  }\n",
    "new_code_raw": "  private static List<String> getPartitionColumnNames(FileSelection selection, String partitionColumnLabel) {\n    int partitionsCount = getPartitionDepth(selection);\n\n    List<String> partitions = new ArrayList<>();\n\n    // generates partition column names: dir0, dir1 etc.\n    for (int i = 0; i < partitionsCount; i++) {\n      partitions.add(partitionColumnLabel + i);\n    }\n    return partitions;\n  }\n"
  },
  {
    "id": "SeleniumHQ_selenium-210-Param-0",
    "old_comment_raw": "@param cap",
    "old_code_raw": "\tpublic static String getConsoleIconPath(DesiredCapabilities cap) {\n\t\tString name = consoleIconName(cap);\n\t\tInputStream in = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"images/\"+name+\".png\");\n\t\tif (in == null){\n\t\t\treturn null;\n\t\t}else {\n\t\t\treturn \"/grid/resources/images/\" + name + \".png\";\n\t\t}\n\t\t\n\t}\n",
    "new_code_raw": "\tpublic static String getConsoleIconPath(DesiredCapabilities cap,Registry registry) {\n\t\tString name = consoleIconName(cap,registry);\n\t\tInputStream in = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"images/\"+name+\".png\");\n\t\tif (in == null){\n\t\t\treturn null;\n\t\t}else {\n\t\t\treturn \"/grid/resources/images/\" + name + \".png\";\n\t\t}\n\t\t\n\t}\n"
  },
  {
    "id": "apache_drill-1509-Param-0",
    "old_comment_raw": "@param allocator The target allocator to create an association with.",
    "old_code_raw": "  public DrillBuf retain(BufferAllocator allocator) {\n\n    if (isEmpty) {\n      return this;\n    }\n\n    if (BaseAllocator.DEBUG) {\n      historicalLog.recordEvent(\"retain(%s)\", allocator.getName());\n    }\n    BufferLedger otherLedger = this.ledger.getLedgerForAllocator(allocator);\n    return otherLedger.newDrillBuf(offset, length, null, true);\n  }\n",
    "new_code_raw": "  public DrillBuf retain(BufferAllocator target) {\n\n    if (isEmpty) {\n      return this;\n    }\n\n    if (BaseAllocator.DEBUG) {\n      historicalLog.recordEvent(\"retain(%s)\", target.getName());\n    }\n    final BufferLedger otherLedger = this.ledger.getLedgerForAllocator(target);\n    return otherLedger.newDrillBuf(offset, length, null);\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-79-Param-0",
    "old_comment_raw": "@param duration duration to get modified",
    "old_code_raw": "    public void setInto(ReadWritableTimePeriod duration, Object object) {\n        duration.setTimePeriod((ReadableDuration) object);\n    }\n",
    "new_code_raw": "    public void setInto(ReadWritablePeriod duration, Object object) {\n        duration.setPeriod((ReadableDuration) object);\n    }\n"
  },
  {
    "id": "SeleniumHQ_selenium-840-Param-0",
    "old_comment_raw": "@param locator used to check parent element. For example table with locator By.xpath(\"//table\")",
    "old_code_raw": "      public List<WebElement> apply(WebDriver webDriver) {\n        List<WebElement> elements = null;\n        try {\n          elements = webDriver.findElement(locator).findElements(sub_locator);\n        } catch (Exception e) {/**/}\n        if (elements != null && elements.size() > 0) {\n          return elements;\n        }\n        return null;\n      }\n",
    "new_code_raw": "      public List<WebElement> apply(WebDriver driver) {\n        List<WebElement> allChildren = findElement(parent, driver).findElements(childLocator);\n\n        return allChildren.isEmpty() ? null : allChildren;\n      }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1947-Param-0",
    "old_comment_raw": "@param metadata The metadata for which to generate the creation commands.",
    "old_code_raw": "\tpublic List<String> generateCreationCommands(Metadata metadata, boolean createSchemas, Dialect dialect) {\n\t\tfinal ArrayList<String> commands = new ArrayList<String>();\n\t\tdoCreation(\n\t\t\t\tmetadata,\n\t\t\t\tcreateSchemas,\n\t\t\t\tdialect,\n\t\t\t\tnew Target() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean acceptsImportScriptActions() {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void prepare() {\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void accept(String action) {\n\t\t\t\t\t\tcommands.add( action );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void release() {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn commands;\n\t}\n",
    "new_code_raw": "\tpublic List<String> generateCreationCommands(Metadata metadata, boolean createNamespaces, Dialect dialect) {\n\t\tfinal ArrayList<String> commands = new ArrayList<String>();\n\t\tdoCreation(\n\t\t\t\tmetadata,\n\t\t\t\tcreateNamespaces,\n\t\t\t\tdialect,\n\t\t\t\tnew Target() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean acceptsImportScriptActions() {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void prepare() {\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void accept(String action) {\n\t\t\t\t\t\tcommands.add( action );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void release() {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn commands;\n\t}\n"
  },
  {
    "id": "apache_kylin-462-Param-0",
    "old_comment_raw": "@param name class name",
    "old_code_raw": "    protected boolean filter(String name, boolean isClassName) {\n        if (name == null)\n            return false;\n\n        // Looking up the package\n        String packageName = null;\n        int pos = name.lastIndexOf('.');\n        if (pos != -1)\n            packageName = name.substring(0, pos);\n        else\n            return false;\n\n        for (int i = 0; i < packageTriggers.length; i++) {\n            if (packageName.startsWith(packageTriggers[i]))\n                return true;\n        }\n\n        return super.filter(name, isClassName);\n    }\n",
    "new_code_raw": "    protected boolean filter(String name) {\n        if (name == null)\n            return false;\n\n        // Looking up the package\n        String packageName = null;\n        int pos = name.lastIndexOf('.');\n        if (pos != -1)\n            packageName = name.substring(0, pos);\n        else\n            return false;\n\n        for (int i = 0; i < packageTriggers.length; i++) {\n            if (packageName.startsWith(packageTriggers[i]))\n                return true;\n        }\n\n        return super.filter(name);\n    }\n"
  },
  {
    "id": "debezium_debezium-1300-Param-0",
    "old_comment_raw": "@param value the local or SQL date, time, or timestamp value; may not be null",
    "old_code_raw": "    public static long toNanoOfDay(Object value, TemporalAdjuster adjuster) {\n        LocalTime time = Conversions.toLocalTime(value);\n        if (adjuster !=null) {\n            time = time.with(adjuster);\n        }\n        return time.toNanoOfDay();\n    }\n",
    "new_code_raw": "    public static long toNanoOfDay(Object value, boolean acceptLargeValues) {\n        if (value instanceof Duration) {\n            Duration duration = (Duration) value;\n            if (!acceptLargeValues && (duration.isNegative() || duration.compareTo(ONE_DAY) > 0)) {\n                throw new IllegalArgumentException(\"Time values must be between 00:00:00 and 24:00:00 (inclusive): \" + duration);\n            }\n\n            return ((Duration) value).toNanos();\n        }\n\n        // TODO only needed for SQL Server/Oracle, where we don't produce Duration right away;\n        // this should go eventually, as the conversion to LocalTime is superfluous\n        LocalTime time = Conversions.toLocalTime(value);\n        return time.toNanoOfDay();\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-973-Param-0",
    "old_comment_raw": "@param dependencies The TypedDependencies to print",
    "old_code_raw": "  private static String toString(Collection<TypedDependency> dependencies, boolean extraSep, boolean includeTags) {\n    CoreLabel.OutputFormat labelFormat = (includeTags) ? CoreLabel.OutputFormat.VALUE_TAG_INDEX : CoreLabel.OutputFormat.VALUE_INDEX;\n    StringBuilder buf = new StringBuilder();\n    if (extraSep) {\n      List<TypedDependency> extraDeps =  new ArrayList<TypedDependency>();\n      for (TypedDependency td : dependencies) {\n        if (td.extra()) {\n          extraDeps.add(td);\n        } else {\n          buf.append(td.toString(labelFormat)).append('\\n');\n        }\n      }\n      // now we print the separator for extra dependencies, and print these if there are some\n      if (!extraDeps.isEmpty()) {\n        buf.append(\"======\\n\");\n        for (TypedDependency td : extraDeps) {\n          buf.append(td.toString(labelFormat)).append('\\n');\n        }\n      }\n    } else {\n      for (TypedDependency td : dependencies) {\n        buf.append(td.toString(labelFormat)).append('\\n');\n      }\n    }\n    return buf.toString();\n  }\n",
    "new_code_raw": "  private static String toString(Collection<TypedDependency> dependencies, boolean extraSep) {\n    StringBuilder buf = new StringBuilder();\n    if (extraSep) {\n      List<TypedDependency> extraDeps =  new ArrayList<TypedDependency>();\n      for (TypedDependency td : dependencies) {\n        if (td.extra()) {\n          extraDeps.add(td);\n        }\n        else {\n          buf.append(td.toString()).append('\\n');\n        }\n      }\n      // now we print the separator for extra dependencies, and print these if there are some\n      if (!extraDeps.isEmpty()) {\n        buf.append(\"======\\n\");\n        for (TypedDependency td : extraDeps) {\n          buf.append(td.toString()).append('\\n');\n        }\n      }\n    } else {\n      for (TypedDependency td : dependencies) {\n        buf.append(td.toString()).append('\\n');\n      }\n    }\n    return buf.toString();\n  }\n"
  },
  {
    "id": "RobotiumTech_robotium-1489-Param-3",
    "old_comment_raw": "@param visible  true if only texts visible on the screen should be searched",
    "old_code_raw": "\tpublic boolean searchText(String text, int minimumNumberOfMatches, boolean scroll, boolean visible) {\n\t\treturn searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, scroll, visible);\n\t}\n",
    "new_code_raw": "\tpublic boolean searchText(String text, int minimumNumberOfMatches, boolean scroll, boolean onlyVisible) {\n\t\treturn searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, scroll, onlyVisible);\n\t}\n"
  },
  {
    "id": "apache_activemq-604-Param-4",
    "old_comment_raw": "@param sub",
    "old_code_raw": "    public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name, int maxBatchSize, Subscription sub) {\n        StoreDurableSubscriberCursor cursor = new StoreDurableSubscriberCursor(broker,clientId, name, maxBatchSize, sub);\n        cursor.setImmediatePriorityDispatch(isImmediatePriorityDispatch());\n        return cursor;\n    }\n",
    "new_code_raw": "    public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name, int maxBatchSize, DurableTopicSubscription sub) {\n        StoreDurableSubscriberCursor cursor = new StoreDurableSubscriberCursor(broker,clientId, name, maxBatchSize, sub);\n        cursor.setImmediatePriorityDispatch(isImmediatePriorityDispatch());\n        return cursor;\n    }\n"
  },
  {
    "id": "yanzhenjie_NoHttp-152-Param-0",
    "old_comment_raw": "@param implRestParser the response parser, The result of parsing the network layer.",
    "old_code_raw": "    public static RequestQueue newRequestQueue(IRestParser implRestParser, int threadPoolSize) {\n        RequestQueue requestQueue = new RequestQueue(implRestParser, threadPoolSize);\n        requestQueue.start();\n        return requestQueue;\n    }\n",
    "new_code_raw": "    public static RequestQueue newRequestQueue(IRestParser iRestParser, int threadPoolSize) {\n        RequestQueue requestQueue = new RequestQueue(iRestParser, threadPoolSize);\n        requestQueue.start();\n        return requestQueue;\n    }\n"
  },
  {
    "id": "Atmosphere_atmosphere-48-Param-0",
    "old_comment_raw": "@param request  javax.servlet.http.HttpServletRequest",
    "old_code_raw": "    protected BroadcastAction filter(HttpServletRequest request, Object object) {\n        BroadcastAction transformed = new BroadcastAction(object);\n        for (PerRequestBroadcastFilter mf : perRequestFilters) {\n            transformed = mf.filter(request, transformed.message());\n            if (transformed == null || transformed.action() == BroadcastAction.ACTION.ABORT) {\n                return transformed;\n            }\n        }\n        return transformed;\n    }\n",
    "new_code_raw": "    protected BroadcastAction filter(HttpServletRequest request, HttpServletResponse response, Object object) {\n        BroadcastAction transformed = new BroadcastAction(object);\n        for (PerRequestBroadcastFilter mf : perRequestFilters) {\n            transformed = mf.filter(request, response, transformed.message());\n            if (transformed == null || transformed.action() == BroadcastAction.ACTION.ABORT) {\n                return transformed;\n            }\n        }\n        return transformed;\n    }\n"
  },
  {
    "id": "apache_activemq-394-Param-2",
    "old_comment_raw": "@param tmpStorage",
    "old_code_raw": "    public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize) {\n        return new VMPendingMessageCursor();\n    }\n",
    "new_code_raw": "    public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize, Subscription sub) {\n        return new VMPendingMessageCursor();\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1200-Param-3",
    "old_comment_raw": "@param returnProxies Should proxies be generated",
    "old_code_raw": "\tprivate static EntityKey getOptionalObjectKey(QueryParameters queryParameters, SessionImplementor session) {\n\t\tfinal Object optionalObject = queryParameters.getOptionalObject();\n\t\tfinal Serializable optionalId = queryParameters.getOptionalId();\n\t\tfinal String optionalEntityName = queryParameters.getOptionalEntityName();\n\n\t\tif ( optionalObject != null && optionalEntityName != null ) {\n\t\t\treturn session.generateEntityKey(\n\t\t\t\t\toptionalId, session.getEntityPersister(\n\t\t\t\t\t\t\toptionalEntityName,\n\t\t\t\t\t\t\toptionalObject\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\n\t}\n",
    "new_code_raw": "\tprivate static EntityKey getOptionalObjectKey(QueryParameters queryParameters, SharedSessionContractImplementor session) {\n\t\tfinal Object optionalObject = queryParameters.getOptionalObject();\n\t\tfinal Serializable optionalId = queryParameters.getOptionalId();\n\t\tfinal String optionalEntityName = queryParameters.getOptionalEntityName();\n\n\t\tif ( optionalObject != null && optionalEntityName != null ) {\n\t\t\treturn session.generateEntityKey(\n\t\t\t\t\toptionalId, session.getEntityPersister(\n\t\t\t\t\t\t\toptionalEntityName,\n\t\t\t\t\t\t\toptionalObject\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\n\t}\n"
  },
  {
    "id": "RSB4760_apq8016_developers_samples_android-0-Associations-Param0",
    "old_comment_raw": "@param sourceStr The String to append to.",
    "old_code_raw": "    private String appendIfNotNull(String sourceStr, String appendStr, String delimiter) {\n        if (appendStr != null) {\n            if (appendStr.length() == 0) {\n                delimiter = \"\";\n            }\n            sourceStr += delimiter + appendStr;\n        }\n        return sourceStr;\n    }\n",
    "new_code_raw": "    private StringBuilder appendIfNotNull(StringBuilder source, String addStr, String delimiter) {\n        if (addStr != null) {\n            if (addStr.length() == 0) {\n                delimiter = \"\";\n            }\n\n            return source.append(addStr).append(delimiter);\n        }\n        return source;\n    }\n\n"
  },
  {
    "id": "JodaOrg_joda_time-50-Param-1",
    "old_comment_raw": "@param locale the locale to use for selecting a text symbol, null for default",
    "old_code_raw": "    public String getAsText(PartialInstant partial, Locale locale) {\n        return getAsText(partial, partial.get(this), locale);\n    }\n",
    "new_code_raw": "    public String getAsText(ReadablePartial partial, Locale locale) {\n        return getAsText(partial, partial.get(this), locale);\n    }\n"
  },
  {
    "id": "apache_drill-1024-Param-0",
    "old_comment_raw": "@param rowGroups list of  RowGroupMetadata to be merged",
    "old_code_raw": "  public static FileMetadata getFileMetadata(List<RowGroupMetadata> rowGroups) {\n    if (rowGroups.isEmpty()) {\n      return null;\n    }\n    List<StatisticsHolder> fileStatistics = new ArrayList<>();\n    fileStatistics.add(new StatisticsHolder<>(TableStatisticsKind.ROW_COUNT.mergeStatistics(rowGroups), TableStatisticsKind.ROW_COUNT));\n\n    RowGroupMetadata rowGroupMetadata = rowGroups.iterator().next();\n    TupleMetadata schema = rowGroupMetadata.getSchema();\n\n    Set<SchemaPath> columns = rowGroupMetadata.getColumnsStatistics().keySet();\n\n    MetadataInfo metadataInfo = MetadataInfo.builder().type(MetadataType.FILE).build();\n\n    return FileMetadata.builder()\n        .tableInfo(rowGroupMetadata.getTableInfo())\n        .metadataInfo(metadataInfo)\n        .path(rowGroupMetadata.getPath())\n        .schema(schema)\n        .columnsStatistics(TableMetadataUtils.mergeColumnsStatistics(rowGroups, columns, PARQUET_COLUMN_STATISTICS))\n        .metadataStatistics(fileStatistics)\n        .build();\n  }\n",
    "new_code_raw": "  public static FileMetadata getFileMetadata(Collection<RowGroupMetadata> rowGroups) {\n    if (rowGroups.isEmpty()) {\n      return null;\n    }\n    List<StatisticsHolder> fileStatistics = new ArrayList<>();\n    fileStatistics.add(new StatisticsHolder<>(TableStatisticsKind.ROW_COUNT.mergeStatistics(rowGroups), TableStatisticsKind.ROW_COUNT));\n\n    RowGroupMetadata rowGroupMetadata = rowGroups.iterator().next();\n    TupleMetadata schema = rowGroupMetadata.getSchema();\n\n    Set<SchemaPath> columns = rowGroupMetadata.getColumnsStatistics().keySet();\n\n    MetadataInfo metadataInfo = MetadataInfo.builder().type(MetadataType.FILE).build();\n\n    return FileMetadata.builder()\n        .tableInfo(rowGroupMetadata.getTableInfo())\n        .metadataInfo(metadataInfo)\n        .path(rowGroupMetadata.getPath())\n        .schema(schema)\n        .columnsStatistics(TableMetadataUtils.mergeColumnsStatistics(rowGroups, columns, PARQUET_COLUMN_STATISTICS))\n        .metadataStatistics(fileStatistics)\n        .build();\n  }\n"
  },
  {
    "id": "runelite_runelite-122-Param-0",
    "old_comment_raw": "@param client the game client",
    "old_code_raw": "\tpublic static Area getClickbox(@Nonnull Client client, Model model, int orientation, int tileX, int tileY)\n\t{\n\t\tif (model == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tList<Triangle> triangles = model.getTriangles().stream()\n\t\t\t.map(triangle -> triangle.rotate(orientation))\n\t\t\t.collect(Collectors.toList());\n\n\t\tList<Vertex> vertices = model.getVertices().stream()\n\t\t\t\t.map(v -> v.rotate(orientation))\n\t\t\t\t.collect(Collectors.toList());\n\n\t\tArea clickBox = get2DGeometry(client, triangles, orientation, tileX, tileY);\n\t\tArea visibleAABB = getAABB(client, vertices, orientation, tileX, tileY);\n\n\t\tif (visibleAABB == null || clickBox == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tclickBox.intersect(visibleAABB);\n\t\treturn clickBox;\n\t}\n",
    "new_code_raw": "\tpublic static Area getClickbox(@Nonnull Client client, Model model, int orientation, int localX, int localY)\n\t{\n\t\tif (model == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tList<Triangle> triangles = model.getTriangles().stream()\n\t\t\t.map(triangle -> triangle.rotate(orientation))\n\t\t\t.collect(Collectors.toList());\n\n\t\tList<Vertex> vertices = model.getVertices().stream()\n\t\t\t\t.map(v -> v.rotate(orientation))\n\t\t\t\t.collect(Collectors.toList());\n\n\t\tArea clickBox = get2DGeometry(client, triangles, orientation, localX, localY);\n\t\tArea visibleAABB = getAABB(client, vertices, orientation, localX, localY);\n\n\t\tif (visibleAABB == null || clickBox == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tclickBox.intersect(visibleAABB);\n\t\treturn clickBox;\n\t}\n"
  },
  {
    "id": "debezium_debezium-721-Param-2",
    "old_comment_raw": "@param ts the timestamp for this row",
    "old_code_raw": "        public int update(Object[] before, Object[] after, long ts) throws InterruptedException {\n            return update(before, after, ts, 0, 1);\n        }\n",
    "new_code_raw": "        public int update(Object[] before, Object[] after, Instant ts) throws InterruptedException {\n            return update(before, after, ts, 0, 1);\n        }\n"
  },
  {
    "id": "runelite_runelite-130-Param-0",
    "old_comment_raw": "@param image The image to be made more or less transparent.",
    "old_code_raw": "\tpublic static BufferedImage alphaOffset(final BufferedImage image, final int offset)\n\t{\n\t\tfinal float offsetFloat = (float) offset;\n\t\tfinal int numComponents = image.getColorModel().getNumComponents();\n\t\tfinal float[] scales = new float[numComponents];\n\t\tfinal float[] offsets = new float[numComponents];\n\n\t\tArrays.fill(scales, 1f);\n\t\tArrays.fill(offsets, 0f);\n\t\toffsets[numComponents - 1] = offsetFloat;\n\t\treturn offset(image, scales, offsets);\n\t}\n",
    "new_code_raw": "\tpublic static BufferedImage alphaOffset(final Image rawImg, final int offset)\n\t{\n\t\tBufferedImage image = toARGB(rawImg);\n\t\tfinal float offsetFloat = (float) offset;\n\t\tfinal int numComponents = image.getColorModel().getNumComponents();\n\t\tfinal float[] scales = new float[numComponents];\n\t\tfinal float[] offsets = new float[numComponents];\n\n\t\tArrays.fill(scales, 1f);\n\t\tArrays.fill(offsets, 0f);\n\t\toffsets[numComponents - 1] = offsetFloat;\n\t\treturn offset(image, scales, offsets);\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-203-Param-7",
    "old_comment_raw": "@param contentType The request's Content-Type header",
    "old_code_raw": "  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n",
    "new_code_raw": "  public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n"
  },
  {
    "id": "eclipse_rt.equinox.bundles-60-Associations-Param1",
    "old_comment_raw": "@param environment the current environment, which may affect the behavior of the expert. This parameter may be specified as null, in which case the  STextEnvironment#DEFAULT environment should be assumed.",
    "old_code_raw": "\tstatic public ISTextExpert getExpert(String type, STextEnvironment environment) {\n\t\tISTextExpert expert;\n\t\tif (environment == null)\n\t\t\tenvironment = STextEnvironment.DEFAULT;\n\t\tsynchronized (sharedExperts) {\n\t\t\tMap experts = (Map) sharedExperts.get(type);\n\t\t\tif (experts == null) {\n\t\t\t\texperts = new HashMap(); // environment -> expert\n\t\t\t\tsharedExperts.put(type, experts);\n\t\t\t}\n\t\t\texpert = (ISTextExpert) experts.get(environment);\n\t\t\tif (expert == null) {\n\t\t\t\tSTextTypeHandler handler = STextTypeHandlerFactory.getHandler(type);\n\t\t\t\tif (handler == null)\n\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid type argument\"); //$NON-NLS-1$\n\t\t\t\texpert = new STextImpl(handler, environment, false);\n\t\t\t\texperts.put(type, expert);\n\t\t\t}\n\t\t}\n\t\treturn expert;\n\t}\n",
    "new_code_raw": "\tstatic public IStructuredTextExpert getExpert(String type, StructuredTextEnvironment environment) {\n\t\tIStructuredTextExpert expert;\n\t\tif (environment == null)\n\t\t\tenvironment = StructuredTextEnvironment.DEFAULT;\n\t\tsynchronized (sharedExperts) {\n\t\t\tMap experts = (Map) sharedExperts.get(type);\n\t\t\tif (experts == null) {\n\t\t\t\texperts = new HashMap(); // environment -> expert\n\t\t\t\tsharedExperts.put(type, experts);\n\t\t\t}\n\t\t\texpert = (IStructuredTextExpert) experts.get(environment);\n\t\t\tif (expert == null) {\n\t\t\t\tStructuredTextTypeHandler handler = StructuredTextTypeHandlerFactory.getHandler(type);\n\t\t\t\tif (handler == null)\n\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid type argument\"); //$NON-NLS-1$\n\t\t\t\texpert = new StructuredTextImpl(handler, environment, false);\n\t\t\t\texperts.put(type, expert);\n\t\t\t}\n\t\t}\n\t\treturn expert;\n\t}\n\n"
  },
  {
    "id": "debezium_debezium-731-Param-3",
    "old_comment_raw": "@param txOrder order of event in transaction; 0 for non-transactional event",
    "old_code_raw": "        public int recordEvent(Document oplogEvent, Document masterEvent, long timestamp, long txOrder) throws InterruptedException {\n            source.opLogEvent(replicaSetName, oplogEvent, masterEvent, txOrder);\n            final Struct sourceValue = source.struct();\n            final Map<String, ?> offset = source.lastOffset(replicaSetName);\n            Document patchObj = oplogEvent.get(\"o\", Document.class);\n            // Updates have an 'o2' field, since the updated object in 'o' might not have the ObjectID ...\n            Object o2 = oplogEvent.get(\"o2\");\n            String objId = o2 != null ? idObjToJson(o2) : idObjToJson(patchObj);\n            assert objId != null;\n            Operation operation = OPERATION_LITERALS.get(oplogEvent.getString(\"op\"));\n            return createRecords(sourceValue, offset, operation, objId, patchObj, timestamp);\n        }\n",
    "new_code_raw": "        public int recordEvent(Document oplogEvent, Document masterEvent, Instant timestamp, long txOrder) throws InterruptedException {\n            source.opLogEvent(replicaSetName, oplogEvent, masterEvent, txOrder);\n            final Struct sourceValue = source.struct();\n            final Map<String, ?> offset = source.lastOffset(replicaSetName);\n            Document patchObj = oplogEvent.get(\"o\", Document.class);\n            // Updates have an 'o2' field, since the updated object in 'o' might not have the ObjectID ...\n            Object o2 = oplogEvent.get(\"o2\");\n            String objId = o2 != null ? idObjToJson(o2) : idObjToJson(patchObj);\n            assert objId != null;\n            Operation operation = OPERATION_LITERALS.get(oplogEvent.getString(\"op\"));\n            return createRecords(sourceValue, offset, operation, objId, patchObj, timestamp);\n        }\n"
  },
  {
    "id": "runelite_runelite-105-Param-3",
    "old_comment_raw": "@param size expected size of file",
    "old_code_raw": "\tpublic static DataFileReadResult decompress(byte[] b)\n\t{\n\t\tInputStream stream = new InputStream(b);\n\t\t\n\t\tint compression = stream.readUnsignedByte();\n\t\tint compressedLength = stream.readInt();\n\t\tif (compressedLength < 0 || compressedLength > 1000000)\n\t\t\tthrow new RuntimeException(\"Invalid data\");\n\t\t\n\t\tbyte[] data;\n\t\tint revision;\n\t\tswitch (compression)\n\t\t{\n\t\t\tcase CompressionType.NONE:\n\t\t\t\tdata = new byte[compressedLength];\n\t\t\t\trevision = checkRevision(stream, compressedLength);\n\t\t\t\tstream.readBytes(data, 0, compressedLength);\n\t\t\t\tbreak;\n\t\t\tcase CompressionType.BZ2:\n\t\t\t{\n\t\t\t\tint length = stream.readInt();\n\t\t\t\trevision = checkRevision(stream, compressedLength);\n\t\t\t\tdata = BZip2.decompress(stream.getRemaining(), compressedLength);\n\t\t\t\tassert data.length == length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CompressionType.GZ:\n\t\t\t{\n\t\t\t\tint length = stream.readInt();\n\t\t\t\trevision = checkRevision(stream, compressedLength);\n\t\t\t\tdata = GZip.decompress(stream.getRemaining(), compressedLength);\n\t\t\t\tassert data.length == length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException(\"Unknown decompression type\");\n\t\t}\n\t\t\n\t\tDataFileReadResult res = new DataFileReadResult();\n\t\tres.data = data;\n\t\tres.revision = revision;\n\t\tint length = revision != -1 ? b.length - 2 : b.length;\n\t\tres.crc = CRC32HGenerator.getHash(b, length);\n\t\tres.whirlpool = Whirlpool.getHash(b, length);\n\t\tres.compression = compression;\n\t\treturn res;\n\t}\n",
    "new_code_raw": "\tpublic static DataFileReadResult decompress(byte[] b, int[] keys)\n\t{\n\t\tInputStream stream = new InputStream(b);\n\t\t\n\t\tint compression = stream.readUnsignedByte();\n\t\tint compressedLength = stream.readInt();\n\t\tif (compressedLength < 0 || compressedLength > 1000000)\n\t\t\tthrow new RuntimeException(\"Invalid data\");\n\n\t\tCrc32 crc32 = new Crc32();\n\t\tcrc32.update(b, 0, 5); // compression + length\n\t\t\n\t\tbyte[] data;\n\t\tint revision = -1;\n\t\tswitch (compression)\n\t\t{\n\t\t\tcase CompressionType.NONE:\n\t\t\t{\n\t\t\t\tbyte[] encryptedData = new byte[compressedLength];\n\t\t\t\tstream.readBytes(encryptedData, 0, compressedLength);\n\n\t\t\t\tcrc32.update(encryptedData, 0, compressedLength);\n\t\t\t\tbyte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys);\n\n\t\t\t\tif (stream.remaining() >= 2)\n\t\t\t\t{\n\t\t\t\t\trevision = stream.readUnsignedShort();\n\t\t\t\t\tassert revision != -1;\n\t\t\t\t}\n\n\t\t\t\tdata = decryptedData;\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CompressionType.BZ2:\n\t\t\t{\n\t\t\t\tbyte[] encryptedData = new byte[compressedLength + 4];\n\t\t\t\tstream.readBytes(encryptedData);\n\n\t\t\t\tcrc32.update(encryptedData, 0, encryptedData.length);\n\t\t\t\tbyte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys);\n\n\t\t\t\tif (stream.remaining() >= 2)\n\t\t\t\t{\n\t\t\t\t\trevision = stream.readUnsignedShort();\n\t\t\t\t\tassert revision != -1;\n\t\t\t\t}\n\n\t\t\t\tstream = new InputStream(decryptedData);\n\n\t\t\t\tint decompressedLength = stream.readInt();\n\t\t\t\tdata = BZip2.decompress(stream.getRemaining(), compressedLength);\n\n\t\t\t\tif (data == null)\n\t\t\t\t{\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tassert data.length == decompressedLength;\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CompressionType.GZ:\n\t\t\t{\n\t\t\t\tbyte[] encryptedData = new byte[compressedLength + 4];\n\t\t\t\tstream.readBytes(encryptedData);\n\n\t\t\t\tcrc32.update(encryptedData, 0, encryptedData.length);\n\t\t\t\tbyte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys);\n\n\t\t\t\tif (stream.remaining() >= 2)\n\t\t\t\t{\n\t\t\t\t\trevision = stream.readUnsignedShort();\n\t\t\t\t\tassert revision != -1;\n\t\t\t\t}\n\n\t\t\t\tstream = new InputStream(decryptedData);\n\n\t\t\t\tint decompressedLength = stream.readInt();\n\t\t\t\tdata = GZip.decompress(stream.getRemaining(), compressedLength);\n\n\t\t\t\tif (data == null)\n\t\t\t\t{\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tassert data.length == decompressedLength;\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException(\"Unknown decompression type\");\n\t\t}\n\t\t\n\t\tDataFileReadResult res = new DataFileReadResult();\n\t\tres.data = data;\n\t\tres.revision = revision;\n\t\tint length = revision != -1 ? b.length - 2 : b.length;;\n\t\tres.crc = crc32.getHash();\n\t\tres.whirlpool = Whirlpool.getHash(b, length);\n\t\tres.compression = compression;\n\t\treturn res;\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-441-Param-1",
    "old_comment_raw": "@param method The request method, one of \"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\", \"PATCH\" and \"DELETE\"",
    "old_code_raw": "  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    final String url = buildUrl(path, queryParams);\n    final Request.Builder reqBuilder = new Request.Builder().url(url);\n    processHeaderParams(headerParams, reqBuilder);\n\n    String contentType = (String) headerParams.get(\"Content-Type\");\n    // ensuring a default content type\n    if (contentType == null) contentType = \"application/json\";\n\n    RequestBody reqBody;\n    if (!HttpMethod.permitsRequestBody(method)) {\n      reqBody = null;\n    } else if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n      reqBody = buildRequestBodyFormEncoding(formParams);\n    } else if (\"multipart/form-data\".equals(contentType)) {\n      reqBody = buildRequestBodyMultipart(formParams);\n    } else if (body == null) {\n      if (\"DELETE\".equals(method)) {\n        // allow calling DELETE without sending a request body\n        reqBody = null;\n      } else {\n        // use an empty request body (for POST, PUT and PATCH)\n        reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n      }\n    } else {\n      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));\n    }\n\n    Request request = reqBuilder.method(method, reqBody).build();\n    return httpClient.newCall(request);\n  }\n",
    "new_code_raw": "  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    final String url = buildUrl(path, queryParams);\n    final Request.Builder reqBuilder = new Request.Builder().url(url);\n    processHeaderParams(headerParams, reqBuilder);\n\n    String contentType = (String) headerParams.get(\"Content-Type\");\n    // ensuring a default content type\n    if (contentType == null) contentType = \"application/json\";\n\n    RequestBody reqBody;\n    if (!HttpMethod.permitsRequestBody(method)) {\n      reqBody = null;\n    } else if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n      reqBody = buildRequestBodyFormEncoding(formParams);\n    } else if (\"multipart/form-data\".equals(contentType)) {\n      reqBody = buildRequestBodyMultipart(formParams);\n    } else if (body == null) {\n      if (\"DELETE\".equals(method)) {\n        // allow calling DELETE without sending a request body\n        reqBody = null;\n      } else {\n        // use an empty request body (for POST, PUT and PATCH)\n        reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n      }\n    } else {\n      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));\n    }\n\n    Request request = null;\n\n    if(progressRequestListener != null) {\n      ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener);\n      request = reqBuilder.method(method, progressRequestBody).build();\n    } else {\n      request = reqBuilder.method(method, reqBody).build();\n    }\n\n    return httpClient.newCall(request);\n  }\n"
  },
  {
    "id": "google_google-http-java-client-93-Associations-Param0",
    "old_comment_raw": "@param exec An executor to run the synchronous HttpRequest",
    "old_code_raw": "  public Future<HttpResponse> executeAsync(Executor exec) {\n    final SettableFuture<HttpResponse> future = SettableFuture.create();\n    exec.execute(new Runnable() {\n      public void run() {\n        try {\n          future.set(execute());\n        } catch (IOException ex) {\n          future.setException(ex);\n        }\n      }\n    });\n    return future;\n  }\n",
    "new_code_raw": "  public Future<HttpResponse> executeAsync(Executor executor) {\n    FutureTask<HttpResponse> future = new FutureTask<HttpResponse>(new Callable<HttpResponse>() {\n\n      public HttpResponse call() throws Exception {\n        return execute();\n      }\n    });\n    executor.execute(future);\n    return future;\n  }\n\n"
  },
  {
    "id": "debezium_debezium-300-Param-0",
    "old_comment_raw": "@param multiQuery the array of prepared queries",
    "old_code_raw": "    public JdbcConnection prepareQuery(String[] multiQuery, StatementPreparer preparer, MultiResultSetConsumer resultConsumer) throws SQLException {\n        final Connection conn = connection();\n        final ResultSet[] resultSets = new ResultSet[multiQuery.length];\n        final PreparedStatement[] preparedStatements = new PreparedStatement[multiQuery.length];\n\n        try {\n            for (int i = 0; i < multiQuery.length; i++) {\n                final String query = multiQuery[i];\n                if (LOGGER.isTraceEnabled()) {\n                    LOGGER.trace(\"running '{}'\", query);\n                }\n                final PreparedStatement statement = conn.prepareStatement(query);\n                preparedStatements[i] = statement;\n                preparer.accept(statement);\n                resultSets[i] = statement.executeQuery();\n            }\n            if (resultConsumer != null) {\n                resultConsumer.accept(resultSets);\n            }\n        }\n        finally {\n            for (ResultSet rs: resultSets) {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    }\n                    catch (Exception ei) {\n                    }\n                }\n            }\n            for (PreparedStatement ps: preparedStatements) {\n                if (ps != null) {\n                    try {\n                        ps.close();\n                    }\n                    catch (Exception ei) {\n                    }\n                }\n            }\n        }\n        return this;\n    }\n",
    "new_code_raw": "    public JdbcConnection prepareQuery(String[] multiQuery, StatementPreparer preparer, BlockingMultiResultSetConsumer resultConsumer) throws SQLException, InterruptedException {\n        final Connection conn = connection();\n        final ResultSet[] resultSets = new ResultSet[multiQuery.length];\n        final PreparedStatement[] preparedStatements = new PreparedStatement[multiQuery.length];\n\n        try {\n            for (int i = 0; i < multiQuery.length; i++) {\n                final String query = multiQuery[i];\n                if (LOGGER.isTraceEnabled()) {\n                    LOGGER.trace(\"running '{}'\", query);\n                }\n                final PreparedStatement statement = conn.prepareStatement(query);\n                preparedStatements[i] = statement;\n                preparer.accept(statement);\n                resultSets[i] = statement.executeQuery();\n            }\n            if (resultConsumer != null) {\n                resultConsumer.accept(resultSets);\n            }\n        }\n        finally {\n            for (ResultSet rs: resultSets) {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    }\n                    catch (Exception ei) {\n                    }\n                }\n            }\n            for (PreparedStatement ps: preparedStatements) {\n                if (ps != null) {\n                    try {\n                        ps.close();\n                    }\n                    catch (Exception ei) {\n                    }\n                }\n            }\n        }\n        return this;\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1620-Param-1",
    "old_comment_raw": "@param p Swagger property object",
    "old_code_raw": "    public CodegenProperty fromProperty(String name, Property p) {\n        if (p == null) {\n            LOGGER.error(\"unexpected missing property for name \" + name);\n            return null;\n        }\n\n        CodegenProperty property = CodegenModelFactory.newInstance(CodegenModelType.PROPERTY);\n        property.name = toVarName(name);\n        property.baseName = name;\n        property.nameInCamelCase = camelize(property.name, false);\n        property.description = escapeText(p.getDescription());\n        property.unescapedDescription = p.getDescription();\n        property.title = p.getTitle();\n        property.getter = toGetter(name);\n        property.setter = toSetter(name);\n        String example = toExampleValue(p);\n        if(!\"null\".equals(example)) {\n            property.example = example;\n        }\n        property.defaultValue = toDefaultValue(p);\n        property.defaultValueWithParam = toDefaultValueWithParam(name, p);\n        property.jsonSchema = Json.pretty(p);\n        if (p.getReadOnly() != null) {\n            property.isReadOnly = p.getReadOnly();\n        }\n        if (p.getXml() != null) {\n            if (p.getXml().getAttribute() != null) {\n                property.isXmlAttribute = p.getXml().getAttribute();\n            }\n            property.xmlPrefix = p.getXml().getPrefix();\n            property.xmlName = p.getXml().getName();\n            property.xmlNamespace = p.getXml().getNamespace();\n        }\n        property.vendorExtensions = p.getVendorExtensions();\n\n        String type = getSwaggerType(p);\n        if (p instanceof AbstractNumericProperty) {\n            AbstractNumericProperty np = (AbstractNumericProperty) p;\n            if (np.getMinimum() != null) {\n                if (p instanceof BaseIntegerProperty) { // int, long\n                    property.minimum = String.valueOf(np.getMinimum().longValue());\n                } else { // double, decimal\n                    property.minimum = String.valueOf(np.getMinimum());\n                }\n            }\n            if (np.getMaximum() != null) {\n                if (p instanceof BaseIntegerProperty) { // int, long\n                    property.maximum = String.valueOf(np.getMaximum().longValue());\n                } else { // double, decimal\n                    property.maximum = String.valueOf(np.getMaximum());\n                }\n            }\n\n            if (np.getExclusiveMinimum() != null) {\n                property.exclusiveMinimum = np.getExclusiveMinimum();\n            }\n            if (np.getExclusiveMaximum() != null) {\n                property.exclusiveMaximum = np.getExclusiveMaximum();\n            }\n\n            // check if any validation rule defined\n            // exclusive* are noop without corresponding min/max\n            if (property.minimum != null || property.maximum != null)\n                property.hasValidation = true;\n\n            // legacy support\n            Map<String, Object> allowableValues = new HashMap<String, Object>();\n            if (np.getMinimum() != null) {\n                allowableValues.put(\"min\", np.getMinimum());\n            }\n            if (np.getMaximum() != null) {\n                allowableValues.put(\"max\", np.getMaximum());\n            }\n            if(allowableValues.size() > 0) {\n                property.allowableValues = allowableValues;\n            }\n        }\n\n        if (p instanceof StringProperty) {\n            StringProperty sp = (StringProperty) p;\n            property.maxLength = sp.getMaxLength();\n            property.minLength = sp.getMinLength();\n            property.pattern = toRegularExpression(sp.getPattern());\n\n            // check if any validation rule defined\n            if (property.pattern != null || property.minLength != null || property.maxLength != null)\n                property.hasValidation = true;\n\n            property.isString = true;\n            if (sp.getEnum() != null) {\n                List<String> _enum = sp.getEnum();\n                property._enum = _enum;\n                property.isEnum = true;\n\n                // legacy support\n                Map<String, Object> allowableValues = new HashMap<String, Object>();\n                allowableValues.put(\"values\", _enum);\n                property.allowableValues = allowableValues;\n            }\n        }\n\n        // type is integer and without format\n        if (p instanceof BaseIntegerProperty && !(p instanceof IntegerProperty) && !(p instanceof LongProperty)) {\n            BaseIntegerProperty sp = (BaseIntegerProperty) p;\n            property.isInteger = true;\n            property.isNumeric = true;\n        }\n        if (p instanceof IntegerProperty) {\n            IntegerProperty sp = (IntegerProperty) p;\n            property.isInteger = true;\n            if (sp.getEnum() != null) {\n                List<Integer> _enum = sp.getEnum();\n                property._enum = new ArrayList<String>();\n                for(Integer i : _enum) {\n                    property._enum.add(i.toString());\n                }\n                property.isEnum = true;\n\n                // legacy support\n                Map<String, Object> allowableValues = new HashMap<String, Object>();\n                allowableValues.put(\"values\", _enum);\n                property.allowableValues = allowableValues;\n            }\n        }\n        if (p instanceof LongProperty) {\n            LongProperty sp = (LongProperty) p;\n            property.isLong = true;\n            property.isNumeric = true;\n            if (sp.getEnum() != null) {\n                List<Long> _enum = sp.getEnum();\n                property._enum = new ArrayList<String>();\n                for(Long i : _enum) {\n                    property._enum.add(i.toString());\n                }\n                property.isEnum = true;\n\n                // legacy support\n                Map<String, Object> allowableValues = new HashMap<String, Object>();\n                allowableValues.put(\"values\", _enum);\n                property.allowableValues = allowableValues;\n            }\n        }\n        if (p instanceof BooleanProperty) {\n            property.isBoolean = true;\n            property.getter = toBooleanGetter(name);\n        }\n        if (p instanceof BinaryProperty) {\n            property.isBinary = true;\n        }\n        if (p instanceof FileProperty) {\n            property.isFile = true;\n        }\n        if (p instanceof UUIDProperty) {\n            property.isString =true;\n            property.isUuid = true;\n\n        }\n        if (p instanceof ByteArrayProperty) {\n            property.isByteArray = true;\n        }\n        // type is number and without format\n        if (p instanceof DecimalProperty && !(p instanceof DoubleProperty) && !(p instanceof FloatProperty)) {\n            DecimalProperty sp = (DecimalProperty) p;\n            property.isNumber = true;\n        }\n        if (p instanceof DoubleProperty) {\n            DoubleProperty sp = (DoubleProperty) p;\n            property.isDouble = true;\n            property.isNumeric = true;\n            if (sp.getEnum() != null) {\n                List<Double> _enum = sp.getEnum();\n                property._enum = new ArrayList<String>();\n                for(Double i : _enum) {\n                    property._enum.add(i.toString());\n                }\n                property.isEnum = true;\n\n                // legacy support\n                Map<String, Object> allowableValues = new HashMap<String, Object>();\n                allowableValues.put(\"values\", _enum);\n                property.allowableValues = allowableValues;\n            }\n        }\n        if (p instanceof FloatProperty) {\n            FloatProperty sp = (FloatProperty) p;\n            property.isFloat = true;\n            property.isNumeric = true;\n            if (sp.getEnum() != null) {\n                List<Float> _enum = sp.getEnum();\n                property._enum = new ArrayList<String>();\n                for(Float i : _enum) {\n                    property._enum.add(i.toString());\n                }\n                property.isEnum = true;\n\n                // legacy support\n                Map<String, Object> allowableValues = new HashMap<String, Object>();\n                allowableValues.put(\"values\", _enum);\n                property.allowableValues = allowableValues;\n            }\n        }\n\n        if (p instanceof DateProperty) {\n            DateProperty sp = (DateProperty) p;\n            property.isDate = true;\n            if (sp.getEnum() != null) {\n                List<String> _enum = sp.getEnum();\n                property._enum = new ArrayList<String>();\n                for(String i : _enum) {\n                    property._enum.add(i);\n                }\n                property.isEnum = true;\n\n                // legacy support\n                Map<String, Object> allowableValues = new HashMap<String, Object>();\n                allowableValues.put(\"values\", _enum);\n                property.allowableValues = allowableValues;\n            }\n        }\n        if (p instanceof DateTimeProperty) {\n            DateTimeProperty sp = (DateTimeProperty) p;\n            property.isDateTime = true;\n            if (sp.getEnum() != null) {\n                List<String> _enum = sp.getEnum();\n                property._enum = new ArrayList<String>();\n                for(String i : _enum) {\n                    property._enum.add(i);\n                }\n                property.isEnum = true;\n\n                // legacy support\n                Map<String, Object> allowableValues = new HashMap<String, Object>();\n                allowableValues.put(\"values\", _enum);\n                property.allowableValues = allowableValues;\n            }\n        }\n        property.datatype = getTypeDeclaration(p);\n        property.dataFormat = p.getFormat();\n\n        // this can cause issues for clients which don't support enums\n        if (property.isEnum) {\n            property.datatypeWithEnum = toEnumName(property);\n            property.enumName = toEnumName(property);\n        } else {\n            property.datatypeWithEnum = property.datatype;\n        }\n\n        property.baseType = getSwaggerType(p);\n\n        if (p instanceof ArrayProperty) {\n            property.isContainer = true;\n            property.isListContainer = true;\n            property.containerType = \"array\";\n            property.baseType = getSwaggerType(p);\n            if (p.getXml() != null) {\n                property.isXmlWrapped = p.getXml().getWrapped() == null ? false : p.getXml().getWrapped();\n                property.xmlPrefix= p.getXml().getPrefix();\n                property.xmlNamespace = p.getXml().getNamespace();\n                property.xmlName = p.getXml().getName();\n            }\n            // handle inner property\n            ArrayProperty ap = (ArrayProperty) p;\n            property.maxItems = ap.getMaxItems();\n            property.minItems = ap.getMinItems();\n            String itemName = (String) p.getVendorExtensions().get(\"x-item-name\");\n            if (itemName == null) {\n                itemName = property.name;\n            }\n            CodegenProperty cp = fromProperty(itemName, ap.getItems());\n            updatePropertyForArray(property, cp);\n        } else if (p instanceof MapProperty) {\n            MapProperty ap = (MapProperty) p;\n\n            property.isContainer = true;\n            property.isMapContainer = true;\n            property.containerType = \"map\";\n            property.baseType = getSwaggerType(p);\n            property.minItems = ap.getMinProperties();\n            property.maxItems = ap.getMaxProperties();\n\n            // handle inner property\n            CodegenProperty cp = fromProperty(\"inner\", ap.getAdditionalProperties());\n            updatePropertyForMap(property, cp);\n        } else {\n            setNonArrayMapProperty(property, type);\n        }\n        return property;\n    }\n",
    "new_code_raw": "    public CodegenProperty fromProperty(String name, Schema p) {\n        if (p == null) {\n            LOGGER.error(\"Unexpected missing property for name \" + name);\n            return null;\n        }\n        LOGGER.debug(\"debugging fromProperty for \" + name + \" : \" + p);\n\n        CodegenProperty property = CodegenModelFactory.newInstance(CodegenModelType.PROPERTY);\n        property.name = toVarName(name);\n        property.baseName = name;\n        property.nameInCamelCase = camelize(property.name, false);\n        property.description = escapeText(p.getDescription());\n        property.unescapedDescription = p.getDescription();\n        property.title = p.getTitle();\n        property.getter = toGetter(name);\n        property.setter = toSetter(name);\n        String example = toExampleValue(p);\n        if (!\"null\".equals(example)) {\n            property.example = example;\n        }\n        property.defaultValue = toDefaultValue(p);\n        property.defaultValueWithParam = toDefaultValueWithParam(name, p);\n        property.jsonSchema = Json.pretty(p);\n        if (p.getReadOnly() != null) {\n            property.isReadOnly = p.getReadOnly();\n        }\n        if (p.getXml() != null) {\n            if (p.getXml().getAttribute() != null) {\n                property.isXmlAttribute = p.getXml().getAttribute();\n            }\n            property.xmlPrefix = p.getXml().getPrefix();\n            property.xmlName = p.getXml().getName();\n            property.xmlNamespace = p.getXml().getNamespace();\n        }\n        if (p.getExtensions() != null && !p.getExtensions().isEmpty()) {\n            property.getVendorExtensions().putAll(p.getExtensions());\n        }\n\n        String type = getSchemaType(p);\n        if (ModelUtils.isIntegerSchema(p)) { // integer type\n            property.isNumeric = Boolean.TRUE;\n            if (SchemaTypeUtil.INTEGER64_FORMAT.equals(p.getFormat())) { // int64/long format\n                property.isLong = Boolean.TRUE;\n            } else { // int32 format\n                property.isInteger = Boolean.TRUE;\n            }\n\n            if (p.getMinimum() != null) {\n                property.minimum = String.valueOf(p.getMinimum().longValue());\n            }\n            if (p.getMaximum() != null) {\n                property.maximum = String.valueOf(p.getMaximum().longValue());\n            }\n            if (p.getExclusiveMinimum() != null) {\n                property.exclusiveMinimum = p.getExclusiveMinimum();\n            }\n            if (p.getExclusiveMaximum() != null) {\n                property.exclusiveMaximum = p.getExclusiveMaximum();\n            }\n\n            // check if any validation rule defined\n            // exclusive* are noop without corresponding min/max\n            if (property.minimum != null || property.maximum != null)\n                property.hasValidation = true;\n\n            // legacy support\n            Map<String, Object> allowableValues = new HashMap<String, Object>();\n            if (p.getMinimum() != null) {\n                allowableValues.put(\"min\", p.getMinimum());\n            }\n            if (p.getMaximum() != null) {\n                allowableValues.put(\"max\", p.getMaximum());\n            }\n\n            if (p.getEnum() != null) {\n                List<Object> _enum = p.getEnum();\n                property._enum = new ArrayList<String>();\n                for (Object i : _enum) {\n                    property._enum.add(String.valueOf(i));\n                }\n                property.isEnum = true;\n                allowableValues.put(\"values\", _enum);\n            }\n\n            if (allowableValues.size() > 0) {\n                property.allowableValues = allowableValues;\n            }\n        } else if (ModelUtils.isBooleanSchema(p)) { // boolean type\n            property.isBoolean = true;\n            property.getter = toBooleanGetter(name);\n        } else if (ModelUtils.isDateSchema(p)) { // date format\n            property.isString = false; // for backward compatibility with 2.x\n            property.isDate = true;\n            if (p.getEnum() != null) {\n                List<String> _enum = p.getEnum();\n                property._enum = new ArrayList<String>();\n                for (String i : _enum) {\n                    property._enum.add(i);\n                }\n                property.isEnum = true;\n\n                // legacy support\n                Map<String, Object> allowableValues = new HashMap<String, Object>();\n                allowableValues.put(\"values\", _enum);\n                property.allowableValues = allowableValues;\n            }\n        } else if (ModelUtils.isDateTimeSchema(p)) { // date-time format\n            property.isString = false; // for backward compatibility with 2.x\n            property.isDateTime = true;\n            if (p.getEnum() != null) {\n                List<String> _enum = p.getEnum();\n                property._enum = new ArrayList<String>();\n                for (String i : _enum) {\n                    property._enum.add(i);\n                }\n                property.isEnum = true;\n\n                // legacy support\n                Map<String, Object> allowableValues = new HashMap<String, Object>();\n                allowableValues.put(\"values\", _enum);\n                property.allowableValues = allowableValues;\n            }\n        } else if (ModelUtils.isStringSchema(p)) {\n            if (ModelUtils.isByteArraySchema(p)) {\n                property.isByteArray = true;\n            } else if (ModelUtils.isBinarySchema(p)) {\n                property.isBinary = true;\n                property.isFile = true; // file = binary in OAS3\n            } else if (ModelUtils.isFileSchema(p)) {\n                property.isFile = true;\n            } else if (ModelUtils.isUUIDSchema(p)) {\n                // keep isString to true to make it backward compatible\n                property.isString = true;\n                property.isUuid = true;\n            } else {\n                property.isString = true;\n            }\n\n            property.maxLength = p.getMaxLength();\n            property.minLength = p.getMinLength();\n            property.pattern = toRegularExpression(p.getPattern());\n\n            // check if any validation rule defined\n            if (property.pattern != null || property.minLength != null || property.maxLength != null)\n                property.hasValidation = true;\n\n            if (p.getEnum() != null) {\n                List<String> _enum = p.getEnum();\n                property._enum = _enum;\n                property.isEnum = true;\n\n                // legacy support\n                Map<String, Object> allowableValues = new HashMap<String, Object>();\n                allowableValues.put(\"values\", _enum);\n                property.allowableValues = allowableValues;\n            }\n        } else if (ModelUtils.isNumberSchema(p)) {\n            property.isNumeric = Boolean.TRUE;\n            if (ModelUtils.isFloatSchema(p)) { // float\n                property.isFloat = Boolean.TRUE;\n            } else if (ModelUtils.isDoubleSchema(p)) { // double\n                property.isDouble = Boolean.TRUE;\n            } else { // type is number and without format\n                property.isNumber = Boolean.TRUE;\n            }\n\n            if (p.getMinimum() != null) {\n                property.minimum = String.valueOf(p.getMinimum());\n            }\n            if (p.getMaximum() != null) {\n                property.maximum = String.valueOf(p.getMaximum());\n            }\n            if (p.getExclusiveMinimum() != null) {\n                property.exclusiveMinimum = p.getExclusiveMinimum();\n            }\n            if (p.getExclusiveMaximum() != null) {\n                property.exclusiveMaximum = p.getExclusiveMaximum();\n            }\n\n            // check if any validation rule defined\n            // exclusive* are noop without corresponding min/max\n            if (property.minimum != null || property.maximum != null)\n                property.hasValidation = true;\n\n            if (p.getEnum() != null && !p.getEnum().isEmpty()) {\n                List<Object> _enum = p.getEnum();\n                property._enum = new ArrayList<String>();\n                for (Object i : _enum) {\n                    property._enum.add(String.valueOf(i));\n                }\n                property.isEnum = true;\n\n                // legacy support\n                Map<String, Object> allowableValues = new HashMap<String, Object>();\n                allowableValues.put(\"values\", _enum);\n                property.allowableValues = allowableValues;\n            }\n        }\n\n        property.datatype = getTypeDeclaration(p);\n        property.dataFormat = p.getFormat();\n        property.baseType = getSchemaType(p);\n\n        // this can cause issues for clients which don't support enums\n        if (property.isEnum) {\n            property.datatypeWithEnum = toEnumName(property);\n            property.enumName = toEnumName(property);\n        } else {\n            property.datatypeWithEnum = property.datatype;\n        }\n\n        if (ModelUtils.isArraySchema(p)) {\n            property.isContainer = true;\n            property.isListContainer = true;\n            property.containerType = \"array\";\n            property.baseType = getSchemaType(p);\n            if (p.getXml() != null) {\n                property.isXmlWrapped = p.getXml().getWrapped() == null ? false : p.getXml().getWrapped();\n                property.xmlPrefix = p.getXml().getPrefix();\n                property.xmlNamespace = p.getXml().getNamespace();\n                property.xmlName = p.getXml().getName();\n            }\n\n            // handle inner property\n            property.maxItems = p.getMaxItems();\n            property.minItems = p.getMinItems();\n            String itemName = null;\n            if (p.getExtensions() != null && p.getExtensions().get(\"x-item-name\") != null) {\n                itemName = p.getExtensions().get(\"x-item-name\").toString();\n            }\n            if (itemName == null) {\n                itemName = property.name;\n            }\n            CodegenProperty cp = fromProperty(itemName, ((ArraySchema) p).getItems());\n            updatePropertyForArray(property, cp);\n        } else if (ModelUtils.isMapSchema(p)) {\n            property.isContainer = true;\n            property.isMapContainer = true;\n            property.containerType = \"map\";\n            property.baseType = getSchemaType(p);\n            property.minItems = p.getMinProperties();\n            property.maxItems = p.getMaxProperties();\n\n            // handle inner property\n            CodegenProperty cp = fromProperty(\"inner\", (Schema) p.getAdditionalProperties());\n            updatePropertyForMap(property, cp);\n        } else { // model\n            // TODO revise the logic below\n            //if (StringUtils.isNotBlank(p.get$ref())) {\n            //    property.baseType = getSimpleRef(p.get$ref());\n            //}\n            // --END of revision\n\n            setNonArrayMapProperty(property, type);\n        }\n\n        LOGGER.debug(\"debugging from property return: \" + property);\n        return property;\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-42-Param-0",
    "old_comment_raw": "@param baseMillis source of missing fields",
    "old_code_raw": "    public long resolve(long baseMillis) {\n        long millis = baseMillis;\n        for (int i = 0; i < iFields.length; i++) {\n            millis = iFields[i].set(millis, iValues[i]);\n        }\n        return millis;\n    }\n",
    "new_code_raw": "    public long resolve(long baseMillis, DateTimeZone zone) {\n        Chronology chrono = iChronology.withZone(zone);\n        long millis = baseMillis;\n        millis = chrono.hourOfDay().set(millis, getValue(HOUR_OF_DAY));\n        millis = chrono.minuteOfHour().set(millis, getValue(MINUTE_OF_HOUR));\n        millis = chrono.secondOfMinute().set(millis, getValue(SECOND_OF_MINUTE));\n        millis = chrono.millisOfSecond().set(millis, getValue(MILLIS_OF_SECOND));\n        return millis;\n    }\n"
  },
  {
    "id": "krosenvold_struts2-0-Associations-Param1",
    "old_comment_raw": "@param key - Key to search for.",
    "old_code_raw": "    private static boolean containsItem(Collection itemCollection, String key) {\n        return itemCollection.contains(key.toLowerCase());\n    }\n",
    "new_code_raw": "    private static boolean containsItem(Collection<String> itemCollection, String item) {\n        return itemCollection.contains(item.toLowerCase());\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1679-Param-0",
    "old_comment_raw": "@param username name that need to be deleted (required)",
    "old_code_raw": "    public Single<Void> rxUpdateUser(String username, User body) {\n        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {\n            delegate.updateUser(username, body, fut);\n        }));\n    }\n",
    "new_code_raw": "    public Single<Void> rxUpdateUser(String username, User user) {\n        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {\n            delegate.updateUser(username, user, fut);\n        }));\n    }\n"
  },
  {
    "id": "hazelcast_hazelcast-381-Associations-Param0",
    "old_comment_raw": "@param flag the flag to check",
    "old_code_raw": "    public boolean isFlagSet(int flag) {\n        return (flags & flag) != 0;\n    }\n",
    "new_code_raw": "    public boolean isFlagSet(int flagsToCheck) {\n        return isFlagSet(flags, flagsToCheck);\n    }\n\n"
  },
  {
    "id": "debezium_debezium-182-Param-0",
    "old_comment_raw": "@param options the characters that appear in the same order as defined in the column; may not be null",
    "old_code_raw": "    protected Object convertSetToString(String options, Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return \"\";\n        }\n        if (data instanceof String) {\n            // JDBC should return strings ...\n            return data;\n        }\n        if (data instanceof Long) {\n            // The binlog will contain a long with the indexes of the options in the set value ...\n            long indexes = ((Long) data).longValue();\n            return convertSetValue(indexes, options);\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n",
    "new_code_raw": "    protected Object convertSetToString(List<String> options, Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return \"\";\n        }\n        if (data instanceof String) {\n            // JDBC should return strings ...\n            return data;\n        }\n        if (data instanceof Long) {\n            // The binlog will contain a long with the indexes of the options in the set value ...\n            long indexes = ((Long) data).longValue();\n            return convertSetValue(indexes, options);\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n"
  },
  {
    "id": "graphql_java_graphql_java-443-Param-0",
    "old_comment_raw": "@param requestString the query/mutation/subscription",
    "old_code_raw": "    public ExecutionResult execute(String requestString) {\n        return execute(requestString, null);\n    }\n",
    "new_code_raw": "    public ExecutionResult execute(ExecutionInput executionInput) {\n        String requestString = executionInput.getRequestString();\n        String operationName = executionInput.getOperationName();\n        Object context = executionInput.getContext();\n        Object root = executionInput.getRoot();\n        Map<String, Object> arguments = executionInput.getArguments() != null ? executionInput.getArguments() : Collections.emptyMap();\n\n        log.debug(\"Executing request. operation name: {}. Request: {} \", operationName, requestString);\n\n        InstrumentationContext<ExecutionResult> executionCtx = instrumentation.beginExecution(new InstrumentationExecutionParameters(requestString, operationName, context, arguments));\n\n\n        InstrumentationContext<Document> parseCtx = instrumentation.beginParse(new InstrumentationExecutionParameters(requestString, operationName, context, arguments));\n        Parser parser = new Parser();\n        Document document;\n        try {\n            document = parser.parseDocument(requestString);\n            parseCtx.onEnd(document);\n        } catch (ParseCancellationException e) {\n            RecognitionException recognitionException = (RecognitionException) e.getCause();\n            SourceLocation sourceLocation = null;\n            if (recognitionException != null) {\n                sourceLocation = new SourceLocation(recognitionException.getOffendingToken().getLine(), recognitionException.getOffendingToken().getCharPositionInLine());\n            }\n            InvalidSyntaxError invalidSyntaxError = new InvalidSyntaxError(sourceLocation);\n            return new ExecutionResultImpl(Collections.singletonList(invalidSyntaxError));\n        }\n\n        InstrumentationContext<List<ValidationError>> validationCtx = instrumentation.beginValidation(new InstrumentationValidationParameters(requestString, operationName, context, arguments, document));\n\n        Validator validator = new Validator();\n        List<ValidationError> validationErrors = validator.validateDocument(graphQLSchema, document);\n\n        validationCtx.onEnd(validationErrors);\n\n        if (validationErrors.size() > 0) {\n            return new ExecutionResultImpl(validationErrors);\n        }\n        ExecutionId executionId = idProvider.provide(requestString, operationName, context);\n\n        Execution execution = new Execution(queryStrategy, mutationStrategy, subscriptionStrategy, instrumentation);\n        ExecutionResult result = execution.execute(executionId, graphQLSchema, context, root, document, operationName, arguments);\n\n        executionCtx.onEnd(result);\n\n        return result;\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-55-Param-0",
    "old_comment_raw": "@param instant the partial instant",
    "old_code_raw": "    public int[] set(PartialInstant instant, int fieldIndex, int[] values, String text, Locale locale) {\n        int value = convertText(text, locale);\n        return set(instant, fieldIndex, values, value);\n    }\n",
    "new_code_raw": "    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, String text, Locale locale) {\n        int value = convertText(text, locale);\n        return set(instant, fieldIndex, values, value);\n    }\n"
  },
  {
    "id": "codehaus_cake-2-Associations-Param0",
    "old_comment_raw": "@param attributes an object containing an AttributeMap",
    "old_code_raw": "    public byte get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n",
    "new_code_raw": "    public byte get(WithAttributes withAttributes) {\r\n        return withAttributes.getAttributes().get(this);\r\n    }\r\n\n"
  },
  {
    "id": "Atmosphere_atmosphere-207-Param-0",
    "old_comment_raw": "@param clazz A class implementing  Broadcaster",
    "old_code_raw": "    public static BroadcasterFactory buildAndReplaceDefaultfactory(Class<? extends Broadcaster> clazz, AtmosphereServlet.AtmosphereConfig c)\n            throws InstantiationException, IllegalAccessException {\n\n        factory = new DefaultBroadcasterFactory(clazz, \"NEVER\", c);\n        return factory;\n    }\n",
    "new_code_raw": "    public static BroadcasterFactory buildAndReplaceDefaultfactory(Class<? extends Broadcaster> clazz, AtmosphereConfig c)\n            throws InstantiationException, IllegalAccessException {\n\n        factory = new DefaultBroadcasterFactory(clazz, \"NEVER\", c);\n        return factory;\n    }\n"
  },
  {
    "id": "zaproxy_zaproxy-2130-Param-1",
    "old_comment_raw": "@param loc the current location where elements can be added",
    "old_code_raw": "\tprotected int addToolBarElements(JToolBar panelToolbar2, Location loc, int gridX) {\n\t\t// Override to add elements into the toolbar\n\t\treturn gridX;\n\t}\n",
    "new_code_raw": "\tprotected int addToolBarElements(JToolBar toolBar, Location location, int gridX) {\n\t\treturn gridX;\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1105-Param-0",
    "old_comment_raw": "@param requestBody request body (required)",
    "old_code_raw": "    public ApiResponse<Void> testInlineAdditionalPropertiesWithHttpInfo(String requestBody) throws ApiException {\n        com.squareup.okhttp.Call call = testInlineAdditionalPropertiesValidateBeforeCall(requestBody, null, null);\n        return apiClient.execute(call);\n    }\n",
    "new_code_raw": "    public ApiResponse<Void> testInlineAdditionalPropertiesWithHttpInfo(Map<String, String> requestBody) throws ApiException {\n        com.squareup.okhttp.Call call = testInlineAdditionalPropertiesValidateBeforeCall(requestBody, null, null);\n        return apiClient.execute(call);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1658-Param-0",
    "old_comment_raw": "@param body order placed for purchasing the pet (required)",
    "old_code_raw": "  public Order placeOrder(Order body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling placeOrder\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/store/order\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/xml\", \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Order> localVarReturnType = new GenericType<Order>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public Order placeOrder(Order order) throws ApiException {\n    Object localVarPostBody = order;\n    \n    // verify the required parameter 'order' is set\n    if (order == null) {\n      throw new ApiException(400, \"Missing the required parameter 'order' when calling placeOrder\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/store/order\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/xml\", \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Order> localVarReturnType = new GenericType<Order>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "runelite_runelite-23-Param-0",
    "old_comment_raw": "@param client",
    "old_code_raw": "\tpublic static Point getCanvasTextLocation(Client client, Graphics2D graphics, Point localLocation, String text, int zOffset)\n\t{\n\t\tint plane = client.getPlane();\n\n\t\tPoint p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset);\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tFontMetrics fm = graphics.getFontMetrics();\n\t\tRectangle2D bounds = fm.getStringBounds(text, graphics);\n\t\tint xOffset = p.getX() - (int) (bounds.getWidth() / 2);\n\n\t\treturn new Point(xOffset, p.getY());\n\t}\n",
    "new_code_raw": "\tpublic static Point getCanvasTextLocation(Client client, Graphics2D graphics, LocalPoint localLocation, String text, int zOffset)\n\t{\n\t\tint plane = client.getPlane();\n\n\t\tPoint p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset);\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tFontMetrics fm = graphics.getFontMetrics();\n\t\tRectangle2D bounds = fm.getStringBounds(text, graphics);\n\t\tint xOffset = p.getX() - (int) (bounds.getWidth() / 2);\n\n\t\treturn new Point(xOffset, p.getY());\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1660-Param-0",
    "old_comment_raw": "@param body Input boolean as post body (optional)",
    "old_code_raw": "    public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException {\n        ApiResponse<Boolean> resp = fakeOuterBooleanSerializeWithHttpInfo(body);\n        return resp.getData();\n    }\n",
    "new_code_raw": "    public Boolean fakeOuterBooleanSerialize(Boolean booleanPostBody) throws ApiException {\n        ApiResponse<Boolean> resp = fakeOuterBooleanSerializeWithHttpInfo(booleanPostBody);\n        return resp.getData();\n    }\n"
  },
  {
    "id": "SeleniumHQ_selenium-510-Param-0",
    "old_comment_raw": "@param interval The timeout duration.",
    "old_code_raw": "  public FluentWait<T> pollingEvery(java.time.Duration interval) {\n    this.interval = interval;\n    return this;\n  }\n",
    "new_code_raw": "  public FluentWait<T> pollingEvery(Duration interval) {\n    this.interval = interval;\n    return this;\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1723-Param-0",
    "old_comment_raw": "@param order order placed for purchasing the pet",
    "old_code_raw": "    public Mono<Order> placeOrder(Order order) throws RestClientException {\n        Object postBody = order;\n        \n        // verify the required parameter 'order' is set\n        if (order == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'order' when calling placeOrder\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"/store/order\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application/xml\", \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Order> returnType = new ParameterizedTypeReference<Order>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "new_code_raw": "    public Mono<Order> placeOrder(Order body) throws RestClientException {\n        Object postBody = body;\n        \n        // verify the required parameter 'body' is set\n        if (body == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling placeOrder\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"/store/order\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application/xml\", \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Order> returnType = new ParameterizedTypeReference<Order>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1728-Param-4",
    "old_comment_raw": "@param body The request body object",
    "old_code_raw": "    public Request buildRequest(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n        updateParamsForAuth(authNames, queryParams, headerParams);\n\n        final String url = buildUrl(path, queryParams, collectionQueryParams);\n        final Request.Builder reqBuilder = new Request.Builder().url(url);\n        processHeaderParams(headerParams, reqBuilder);\n\n        String contentType = (String) headerParams.get(\"Content-Type\");\n        // ensuring a default content type\n        if (contentType == null) {\n            contentType = \"application/json\";\n        }\n\n        RequestBody reqBody;\n        if (!HttpMethod.permitsRequestBody(method)) {\n            reqBody = null;\n        } else if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n            reqBody = buildRequestBodyFormEncoding(formParams);\n        } else if (\"multipart/form-data\".equals(contentType)) {\n            reqBody = buildRequestBodyMultipart(formParams);\n        } else if (body == null) {\n            if (\"DELETE\".equals(method)) {\n                // allow calling DELETE without sending a request body\n                reqBody = null;\n            } else {\n                // use an empty request body (for POST, PUT and PATCH)\n                reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n            }\n        } else {\n            reqBody = serialize(body, contentType);\n        }\n\n        Request request = null;\n\n        if(progressRequestListener != null && reqBody != null) {\n            ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener);\n            request = reqBuilder.method(method, progressRequestBody).build();\n        } else {\n            request = reqBuilder.method(method, reqBody).build();\n        }\n\n        return request;\n    }\n",
    "new_code_raw": "    public Request buildRequest(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {\n        updateParamsForAuth(authNames, queryParams, headerParams);\n\n        final String url = buildUrl(path, queryParams, collectionQueryParams);\n        final Request.Builder reqBuilder = new Request.Builder().url(url);\n        processHeaderParams(headerParams, reqBuilder);\n\n        String contentType = (String) headerParams.get(\"Content-Type\");\n        // ensuring a default content type\n        if (contentType == null) {\n            contentType = \"application/json\";\n        }\n\n        RequestBody reqBody;\n        if (!HttpMethod.permitsRequestBody(method)) {\n            reqBody = null;\n        } else if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n            reqBody = buildRequestBodyFormEncoding(formParams);\n        } else if (\"multipart/form-data\".equals(contentType)) {\n            reqBody = buildRequestBodyMultipart(formParams);\n        } else if (body == null) {\n            if (\"DELETE\".equals(method)) {\n                // allow calling DELETE without sending a request body\n                reqBody = null;\n            } else {\n                // use an empty request body (for POST, PUT and PATCH)\n                reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n            }\n        } else {\n            reqBody = serialize(body, contentType);\n        }\n\n        // Associate callback with request (if not null) so interceptor can\n        // access it when creating ProgressResponseBody\n        reqBuilder.tag(callback);\n\n        Request request = null;\n\n        if (callback != null && reqBody != null) {\n            ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, callback);\n            request = reqBuilder.method(method, progressRequestBody).build();\n        } else {\n            request = reqBuilder.method(method, reqBody).build();\n        }\n\n        return request;\n    }\n"
  },
  {
    "id": "Atmosphere_atmosphere-818-Param-1",
    "old_comment_raw": "@param config An instance of  BroadcasterConfig",
    "old_code_raw": "    public static BroadcasterFactory buildAndReplaceDefaultfactory(Class<? extends Broadcaster> clazz, BroadcasterConfig config)\n            throws InstantiationException, IllegalAccessException {\n\n        factory = new DefaultBroadcasterFactory(clazz);\n        return factory;\n    }\n",
    "new_code_raw": "    public static BroadcasterFactory buildAndReplaceDefaultfactory(Class<? extends Broadcaster> clazz, AtmosphereServlet.AtmosphereConfig c)\n            throws InstantiationException, IllegalAccessException {\n\n        factory = new DefaultBroadcasterFactory(clazz);\n        config = c;\n        return factory;\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-153-Param-0",
    "old_comment_raw": "@param proto The serialized representation of the graph. This relies heavily on indexing into the original document.",
    "old_code_raw": "  private static SemanticGraph fromProto(CoreMapProtos.DependencyGraph proto, List<CoreLabel> sentence, String docid) {\n    SemanticGraph graph = new SemanticGraph();\n\n    // first construct the actual nodes; keep them indexed by their index\n    // This block is optimized as one of the places which take noticeable time\n    // in datum caching\n    int min = Integer.MAX_VALUE;\n    int max = Integer.MIN_VALUE;\n    for(CoreMapProtos.DependencyGraph.Node in: proto.getNodeList()){\n      min = in.getIndex() < min ? in.getIndex() : min;\n      max = in.getIndex() > max ? in.getIndex() : max;\n    }\n    IndexedWord[] nodes = new IndexedWord[max - min >= 0 ? max - min + 1 : 0];\n    for(CoreMapProtos.DependencyGraph.Node in: proto.getNodeList()){\n      CoreLabel token = sentence.get(in.getIndex() - 1); // index starts at 1!\n      IndexedWord word = new IndexedWord(docid, in.getSentenceIndex(), in.getIndex(), token);\n      word.set(ValueAnnotation.class, word.get(TextAnnotation.class));\n      if(in.hasCopyAnnotation()){ word.set(CopyAnnotation.class, in.getCopyAnnotation()); }\n      assert in.getIndex() == word.index();\n      nodes[in.getIndex() - min] = word;\n    }\n    for (IndexedWord node : nodes) {\n      if (node != null) { graph.addVertex(node); }\n    }\n\n    // add all edges to the actual graph\n    for(CoreMapProtos.DependencyGraph.Edge ie: proto.getEdgeList()){\n      IndexedWord source = nodes[ie.getSource() - min];\n      assert(source != null);\n      IndexedWord target = nodes[ie.getTarget() - min];\n      assert(target != null);\n      synchronized (globalLock) {\n        // this is not thread-safe: there are static fields in GrammaticalRelation\n        assert ie.hasDep();\n        GrammaticalRelation rel = GrammaticalRelation.valueOf(ie.getDep());\n        graph.addEdge(source, target, rel, 1.0, ie.hasIsExtra() && ie.getIsExtra());\n      }\n    }\n\n    if (proto.getRootCount() > 0) {\n      Collection<IndexedWord> roots = new ArrayList<IndexedWord>();\n      for(int rootI : proto.getRootList()){\n        roots.add(nodes[rootI]);\n      }\n      graph.setRoots(roots);\n    } else {\n      // Roots were not saved away\n      // compute root nodes if non-empty\n      if(!graph.isEmpty()){\n        graph.resetRoots();\n      }\n    }\n    return graph;\n  }\n",
    "new_code_raw": "  private static SemanticGraph fromProto(CoreNLPProtos.DependencyGraph proto, List<CoreLabel> sentence, String docid) {\n    SemanticGraph graph = new SemanticGraph();\n\n    // first construct the actual nodes; keep them indexed by their index\n    // This block is optimized as one of the places which take noticeable time\n    // in datum caching\n    int min = Integer.MAX_VALUE;\n    int max = Integer.MIN_VALUE;\n    for(CoreNLPProtos.DependencyGraph.Node in: proto.getNodeList()){\n      min = in.getIndex() < min ? in.getIndex() : min;\n      max = in.getIndex() > max ? in.getIndex() : max;\n    }\n    IndexedWord[] nodes = new IndexedWord[max - min >= 0 ? max - min + 1 : 0];\n    for(CoreNLPProtos.DependencyGraph.Node in: proto.getNodeList()){\n      CoreLabel token = sentence.get(in.getIndex() - 1); // index starts at 1!\n      IndexedWord word = new IndexedWord(docid, in.getSentenceIndex(), in.getIndex(), token);\n      word.set(ValueAnnotation.class, word.get(TextAnnotation.class));\n      if(in.hasCopyAnnotation()){ word.set(CopyAnnotation.class, in.getCopyAnnotation()); }\n      assert in.getIndex() == word.index();\n      nodes[in.getIndex() - min] = word;\n    }\n    for (IndexedWord node : nodes) {\n      if (node != null) { graph.addVertex(node); }\n    }\n\n    // add all edges to the actual graph\n    for(CoreNLPProtos.DependencyGraph.Edge ie: proto.getEdgeList()){\n      IndexedWord source = nodes[ie.getSource() - min];\n      assert(source != null);\n      IndexedWord target = nodes[ie.getTarget() - min];\n      assert(target != null);\n      synchronized (globalLock) {\n        // this is not thread-safe: there are static fields in GrammaticalRelation\n        assert ie.hasDep();\n        GrammaticalRelation rel = GrammaticalRelation.valueOf(ie.getDep());\n        graph.addEdge(source, target, rel, 1.0, ie.hasIsExtra() && ie.getIsExtra());\n      }\n    }\n\n    if (proto.getRootCount() > 0) {\n      Collection<IndexedWord> roots = new ArrayList<IndexedWord>();\n      for(int rootI : proto.getRootList()){\n        roots.add(nodes[rootI - min]);\n      }\n      graph.setRoots(roots);\n    } else {\n      // Roots were not saved away\n      // compute root nodes if non-empty\n      if(!graph.isEmpty()){\n        graph.resetRoots();\n      }\n    }\n    return graph;\n  }\n"
  },
  {
    "id": "apache_drill-1251-Param-1",
    "old_comment_raw": "@param length the length of the row group",
    "old_code_raw": "    static ColTypeInfo of(MessageType schema, Type type, String[] path, int depth) {\n      if (type.isPrimitive()) {\n        PrimitiveType primitiveType = (PrimitiveType) type;\n        int precision = 0;\n        int scale = 0;\n        if (primitiveType.getDecimalMetadata() != null) {\n          precision = primitiveType.getDecimalMetadata().getPrecision();\n          scale = primitiveType.getDecimalMetadata().getScale();\n        }\n\n        int repetitionLevel = schema.getMaxRepetitionLevel(path);\n        int definitionLevel = schema.getMaxDefinitionLevel(path);\n\n        return new ColTypeInfo(type.getOriginalType(), precision, scale, repetitionLevel, definitionLevel);\n      }\n      Type t = ((GroupType) type).getType(path[depth]);\n      return of(schema, t, path, depth + 1);\n    }\n",
    "new_code_raw": "    static ColTypeInfo of(MessageType schema, Type type, String[] path, int depth, List<OriginalType> parentTypes) {\n      if (type.isPrimitive()) {\n        PrimitiveType primitiveType = (PrimitiveType) type;\n        int precision = 0;\n        int scale = 0;\n        if (primitiveType.getDecimalMetadata() != null) {\n          precision = primitiveType.getDecimalMetadata().getPrecision();\n          scale = primitiveType.getDecimalMetadata().getScale();\n        }\n\n        int repetitionLevel = schema.getMaxRepetitionLevel(path);\n        int definitionLevel = schema.getMaxDefinitionLevel(path);\n\n        return new ColTypeInfo(type.getOriginalType(), parentTypes, precision, scale, repetitionLevel, definitionLevel);\n      }\n      Type t = ((GroupType) type).getType(path[depth]);\n      if (!t.isPrimitive()) {\n        OriginalType originalType = t.getOriginalType();\n        if (originalType == OriginalType.MAP && !ParquetReaderUtility.isLogicalMapType(t.asGroupType())) {\n          originalType = null;\n        }\n        parentTypes.add(originalType);\n      }\n      return of(schema, t, path, depth + 1, parentTypes);\n    }\n"
  },
  {
    "id": "Atmosphere_atmosphere-819-Param-0",
    "old_comment_raw": "@param req the  HttpServletRequest",
    "old_code_raw": "    public Action timedout(HttpServletRequest req, HttpServletResponse res)\n            throws IOException, ServletException {\n\n        AtmosphereResourceImpl re;\n        long l = (Long) req.getAttribute(MAX_INACTIVE);\n        if (l == -1) {\n            // The closedDetector closed the connection.\n            return timedoutAction;            \n        }\n        req.setAttribute(MAX_INACTIVE, (long)-1);\n\n        // Something went wrong.\n        if (req == null || res == null) {\n            logger.warning(\"Invalid Request/Response: \" + req + \"/\" + res);\n            return timedoutAction;\n        }\n\n        re = (AtmosphereResourceImpl) req.getAttribute(AtmosphereServlet.ATMOSPHERE_RESOURCE);\n\n        if (re != null) {\n            re.getAtmosphereResourceEvent().setIsResumedOnTimeout(true);\n\n            Broadcaster b = re.getBroadcaster();\n            if (b instanceof DefaultBroadcaster) {\n                ((DefaultBroadcaster)b).broadcastOnResume(re);\n            }\n\n            if (re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT) != null) {\n                re.getAtmosphereResourceEvent().setIsResumedOnTimeout(\n                        (Boolean) re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT));\n            }\n            invokeAtmosphereHandler(re);\n        }\n\n        return timedoutAction;\n    }\n",
    "new_code_raw": "    public Action timedout(HttpServletRequest request, HttpServletResponse response)\n            throws IOException, ServletException {\n\n        AtmosphereResourceImpl re;\n        long l = (Long) request.getAttribute(MAX_INACTIVE);\n        if (l == -1) {\n            // The closedDetector closed the connection.\n            return timedoutAction;            \n        }\n        request.setAttribute(MAX_INACTIVE, (long) -1);\n\n        // Something went wrong.\n        if (request == null || response == null) {\n            logger.warn(\"Invalid Request/Response: {}/{}\", request, response);\n            return timedoutAction;\n        }\n\n        re = (AtmosphereResourceImpl) request.getAttribute(AtmosphereServlet.ATMOSPHERE_RESOURCE);\n\n        if (re != null) {\n            re.getAtmosphereResourceEvent().setIsResumedOnTimeout(true);\n\n            Broadcaster b = re.getBroadcaster();\n            if (b instanceof DefaultBroadcaster) {\n                ((DefaultBroadcaster)b).broadcastOnResume(re);\n            }\n\n            if (re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT) != null) {\n                re.getAtmosphereResourceEvent().setIsResumedOnTimeout(\n                        (Boolean) re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT));\n            }\n            invokeAtmosphereHandler(re);\n        }\n\n        return timedoutAction;\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-1781-Param-0",
    "old_comment_raw": "@param props Properties object that contains the customizable properties attributes.",
    "old_code_raw": "  public QuoteAnnotator(Properties props, boolean verbose) {\n    USE_SINGLE = Boolean.parseBoolean(props.getProperty(\"singleQuotes\", \"false\"));\n    MAX_LENGTH = Integer.parseInt(props.getProperty(\"maxLength\", \"-1\"));\n    ASCII_QUOTES = Boolean.parseBoolean(props.getProperty(\"asciiQuotes\", \"false\"));\n    ALLOW_EMBEDDED_SAME = Boolean.parseBoolean(props.getProperty(\"allowEmbeddedSame\", \"false\"));\n    SMART_QUOTES = Boolean.parseBoolean(props.getProperty(\"smartQuotes\", \"false\"));\n    EXTRACT_UNCLOSED = Boolean.parseBoolean(props.getProperty(\"extractUnclosedQuotes\", \"false\"));\n    ATTRIBUTE_QUOTES = Boolean.parseBoolean(props.getProperty(\"attributeQuotes\", \"true\"));\n\n    VERBOSE = verbose;\n    Timing timer = null;\n    if (VERBOSE) {\n      timer = new Timing();\n      log.info(\"Preparing quote annotator...\");\n    }\n    if (ATTRIBUTE_QUOTES)\n      quoteAttributionAnnotator = new QuoteAttributionAnnotator(props);\n\n    if (VERBOSE) {\n      timer.stop(\"done.\");\n    }\n  }\n",
    "new_code_raw": "  public QuoteAnnotator(String name, Properties props, boolean verbose) {\n    USE_SINGLE = Boolean.parseBoolean(props.getProperty(name + \".\" + \"singleQuotes\", \"false\"));\n    MAX_LENGTH = Integer.parseInt(props.getProperty(name + \".\" + \"maxLength\", \"-1\"));\n    ASCII_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"asciiQuotes\", \"false\"));\n    ALLOW_EMBEDDED_SAME = Boolean.parseBoolean(props.getProperty(name + \".\" + \"allowEmbeddedSame\", \"false\"));\n    SMART_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"smartQuotes\", \"false\"));\n    EXTRACT_UNCLOSED = Boolean.parseBoolean(props.getProperty(name + \".\" + \"extractUnclosedQuotes\", \"false\"));\n    ATTRIBUTE_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"attributeQuotes\", \"true\"));\n\n    VERBOSE = verbose;\n    Timing timer = null;\n    if (VERBOSE) {\n      timer = new Timing();\n      log.info(\"Preparing quote annotator...\");\n    }\n    if (ATTRIBUTE_QUOTES)\n      quoteAttributionAnnotator = new QuoteAttributionAnnotator(props);\n\n    if (VERBOSE) {\n      timer.stop(\"done.\");\n    }\n  }\n"
  },
  {
    "id": "apache_kylin-379-Param-0",
    "old_comment_raw": "@param leftRel Left input to the join",
    "old_code_raw": "    private RexNode convertUsing(RelNode leftRel, RelNode rightRel, List<String> nameList) {\n        final List<RexNode> list = Lists.newArrayList();\n        for (String name : nameList) {\n            final RelDataType leftRowType = leftRel.getRowType();\n            RelDataTypeField leftField = catalogReader.field(leftRowType, name);\n            RexNode left = rexBuilder.makeInputRef(leftField.getType(), leftField.getIndex());\n            final RelDataType rightRowType = rightRel.getRowType();\n            RelDataTypeField rightField = catalogReader.field(rightRowType, name);\n            RexNode right = rexBuilder.makeInputRef(rightField.getType(), leftRowType.getFieldList().size() + rightField.getIndex());\n            RexNode equalsCall = rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, left, right);\n            list.add(equalsCall);\n        }\n        return RexUtil.composeConjunction(rexBuilder, list, false);\n    }\n",
    "new_code_raw": "    private RexNode convertUsing(SqlValidatorNamespace leftNamespace, SqlValidatorNamespace rightNamespace, List<String> nameList) {\n        final List<RexNode> list = Lists.newArrayList();\n        for (String name : nameList) {\n            List<RexNode> operands = new ArrayList<>();\n            int offset = 0;\n            for (SqlValidatorNamespace n : ImmutableList.of(leftNamespace, rightNamespace)) {\n                final RelDataType rowType = n.getRowType();\n                final RelDataTypeField field = catalogReader.field(rowType, name);\n                operands.add(rexBuilder.makeInputRef(field.getType(), offset + field.getIndex()));\n                offset += rowType.getFieldList().size();\n            }\n            list.add(rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, operands));\n        }\n        return RexUtil.composeConjunction(rexBuilder, list, false);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1534-Param-1",
    "old_comment_raw": "@param method The request method, one of \"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\", \"PATCH\" and \"DELETE\"",
    "old_code_raw": "  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    final String url = buildUrl(path, queryParams);\n    final Request.Builder reqBuilder = new Request.Builder().url(url);\n    processHeaderParams(headerParams, reqBuilder);\n\n    String contentType = (String) headerParams.get(\"Content-Type\");\n    // ensuring a default content type\n    if (contentType == null) contentType = \"application/json\";\n\n    RequestBody reqBody;\n    if (!HttpMethod.permitsRequestBody(method)) {\n      reqBody = null;\n    } else if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n      reqBody = buildRequestBodyFormEncoding(formParams);\n    } else if (\"multipart/form-data\".equals(contentType)) {\n      reqBody = buildRequestBodyMultipart(formParams);\n    } else if (body == null) {\n      if (\"DELETE\".equals(method)) {\n        // allow calling DELETE without sending a request body\n        reqBody = null;\n      } else {\n        // use an empty request body (for POST, PUT and PATCH)\n        reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n      }\n    } else {\n      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));\n    }\n\n    Request request = null;\n\n    if(progressRequestListener != null && reqBody != null) {\n      ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener);\n      request = reqBuilder.method(method, progressRequestBody).build();\n    } else {\n      request = reqBuilder.method(method, reqBody).build();\n    }\n\n    return httpClient.newCall(request);\n  }\n",
    "new_code_raw": "  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    final String url = buildUrl(path, queryParams);\n    final Request.Builder reqBuilder = new Request.Builder().url(url);\n    processHeaderParams(headerParams, reqBuilder);\n\n    String contentType = (String) headerParams.get(\"Content-Type\");\n    // ensuring a default content type\n    if (contentType == null) contentType = \"application/json\";\n\n    RequestBody reqBody;\n    if (!HttpMethod.permitsRequestBody(method)) {\n      reqBody = null;\n    } else if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n      reqBody = buildRequestBodyFormEncoding(formParams);\n    } else if (\"multipart/form-data\".equals(contentType)) {\n      reqBody = buildRequestBodyMultipart(formParams);\n    } else if (body == null) {\n      if (\"DELETE\".equals(method)) {\n        // allow calling DELETE without sending a request body\n        reqBody = null;\n      } else {\n        // use an empty request body (for POST, PUT and PATCH)\n        reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n      }\n    } else {\n      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));\n    }\n\n    Request request = reqBuilder.method(method, reqBody).build();\n    return httpClient.newCall(request);\n  }\n"
  },
  {
    "id": "Omegaphora_dalvik-539-Associations-Param0",
    "old_comment_raw": "@param lng the long to examine.",
    "old_code_raw": "    public static int numberOfLeadingZeros(long lng) {\n        lng |= lng >> 1;\n        lng |= lng >> 2;\n        lng |= lng >> 4;\n        lng |= lng >> 8;\n        lng |= lng >> 16;\n        lng |= lng >> 32;\n        return bitCount(~lng);\n    }\n",
    "new_code_raw": "    public static int numberOfLeadingZeros(long v) {\n        // After Hacker's Delight, Figure 5-6\n        if (v < 0) {\n            return 0;\n        }\n        if (v == 0) {\n            return 64;\n        }\n        // On a 64-bit VM, the two previous tests should probably be replaced by\n        // if (v <= 0) return ((int) (~v >> 57)) & 64;\n\n        int n = 1;\n        int i = (int) (v >>> 32);\n        if (i == 0) {\n            n +=  32;\n            i = (int) v;\n        }\n        if (i >> 16 == 0) {\n            n +=  16;\n            i <<= 16;\n        }\n        if (i >> 24 == 0) {\n            n +=  8;\n            i <<= 8;\n        }\n        if (i >> 28 == 0) {\n            n +=  4;\n            i <<= 4;\n        }\n        if (i >> 30 == 0) {\n            n +=  2;\n            i <<= 2;\n        }\n        return n - (i >>> 31);\n    }\n\n"
  },
  {
    "id": "runelite_runelite-142-Param-1",
    "old_comment_raw": "@param quantity",
    "old_code_raw": "\tpublic BufferedImage getImage(int itemId, int quantity)\n\t{\n\t\ttry\n\t\t{\n\t\t\treturn itemImages.get(itemId | (quantity << 16));\n\t\t}\n\t\tcatch (ExecutionException ex)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t}\n",
    "new_code_raw": "\tpublic BufferedImage getImage(int itemId, int quantity, boolean stackable)\n\t{\n\t\ttry\n\t\t{\n\t\t\treturn itemImages.get(new ImageKey(itemId, quantity, stackable));\n\t\t}\n\t\tcatch (ExecutionException ex)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t}\n"
  },
  {
    "id": "hibernate_hibernate_orm-334-Param-1",
    "old_comment_raw": "@param dialect The dialect in effect",
    "old_code_raw": "\tprotected String determineSegmentColumnName(Properties params, Dialect dialect) {\n\t\tfinal ObjectNameNormalizer normalizer = (ObjectNameNormalizer) params.get( IDENTIFIER_NORMALIZER );\n\t\tfinal String name = ConfigurationHelper.getString( SEGMENT_COLUMN_PARAM, params, DEF_SEGMENT_COLUMN );\n\t\treturn normalizer.toDatabaseIdentifierText( name );\n\t}\n",
    "new_code_raw": "\tprotected String determineSegmentColumnName(Properties params, JdbcEnvironment jdbcEnvironment) {\n\t\tfinal String name = ConfigurationHelper.getString( SEGMENT_COLUMN_PARAM, params, DEF_SEGMENT_COLUMN );\n\t\treturn jdbcEnvironment.getIdentifierHelper().toIdentifier( name ).render( jdbcEnvironment.getDialect() );\n\t}\n"
  },
  {
    "id": "alibaba_jstorm-12-Param-5",
    "old_comment_raw": "@param worker_id",
    "old_code_raw": "\tpublic static void redirectOutput(String port) throws Exception {\n\n\t\tif (System.getenv(\"REDIRECT\") == null\n\t\t\t\t|| !System.getenv(\"REDIRECT\").equals(\"true\")) {\n\t\t\treturn;\n\t\t}\n\n\t\tString OUT_TARGET_FILE = JStormUtils.getLogFileName();\n\t\tif (OUT_TARGET_FILE == null) {\n\t\t\tOUT_TARGET_FILE = \"/dev/null\";\n\t\t} else {\n\t\t\tOUT_TARGET_FILE += \".out\";\n\t\t}\n\n\t\tJStormUtils.redirectOutput(OUT_TARGET_FILE);\n\n\t}\n",
    "new_code_raw": "\tpublic void redirectOutput(){\n\n\t\tif (System.getenv(\"REDIRECT\") == null\n\t\t\t\t|| !System.getenv(\"REDIRECT\").equals(\"true\")) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tString DEFAULT_OUT_TARGET_FILE = JStormUtils.getLogFileName();\n\t\tif (DEFAULT_OUT_TARGET_FILE == null) {\n\t\t\tDEFAULT_OUT_TARGET_FILE = \"/dev/null\";\n\t\t} else {\n\t\t\tDEFAULT_OUT_TARGET_FILE += \".out\";\n\t\t}\n\t\t\n\t\tString outputFile = ConfigExtension.getWorkerRedirectOutputFile(workerData.getStormConf());\n\t\tif (outputFile == null) {\n\t\t\toutputFile = DEFAULT_OUT_TARGET_FILE;\n\t\t}else {\n\t\t\ttry {\n\t\t\t\tFile file = new File(outputFile);\n\t\t\t\tif (file.exists() == false) {\n\t\t\t\t\tPathUtils.touch(outputFile);\n\t\t\t\t}else {\n\t\t\t\t\tif (file.isDirectory() == true) {\n\t\t\t\t\t\tLOG.warn(\"Failed to write \" + outputFile);\n\t\t\t\t\t\toutputFile = DEFAULT_OUT_TARGET_FILE;\n\t\t\t\t\t}else if (file.canWrite() == false) {\n\t\t\t\t\t\tLOG.warn(\"Failed to write \" + outputFile);\n\t\t\t\t\t\toutputFile = DEFAULT_OUT_TARGET_FILE;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}catch(Exception e) {\n\t\t\t\tLOG.warn(\"Failed to touch \" + outputFile, e);\n\t\t\t\toutputFile = DEFAULT_OUT_TARGET_FILE;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tJStormUtils.redirectOutput(outputFile);\n\t\t}catch(Exception e) {\n\t\t\tLOG.warn(\"Failed to redirect to \" + outputFile, e);\n\t\t}\n\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1682-Param-0",
    "old_comment_raw": "@param booleanPostBody Input boolean as post body (optional)",
    "old_code_raw": "  public ApiResponse<Boolean> fakeOuterBooleanSerializeWithHttpInfo(Boolean booleanPostBody) throws ApiException {\n    Object localVarPostBody = booleanPostBody;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/boolean\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"*/*\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public ApiResponse<Boolean> fakeOuterBooleanSerializeWithHttpInfo(Boolean body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/boolean\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"*/*\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "SeleniumHQ_selenium-42-Param-3",
    "old_comment_raw": "@param outputFile - The file to which we'll output the HTML results",
    "old_code_raw": "    public String runHTMLSuite(String browser, String browserURL, String HTMLSuite, File outputFile, long timeoutInMs, boolean multiWindow) throws IOException {\n        server.handleHTMLRunnerResults(this);\n        BrowserLauncherFactory blf = new BrowserLauncherFactory(server);\n        String sessionId = Long.toString(System.currentTimeMillis() % 1000000);\n        BrowserLauncher launcher = blf.getBrowserLauncher(browser, sessionId, null);\n        launcher.launchHTMLSuite(HTMLSuite, browserURL, multiWindow);\n        long now = System.currentTimeMillis();\n        long end = now + timeoutInMs;\n        while (results == null && System.currentTimeMillis() < end) {\n            AsyncExecute.sleepTight(500);\n        }\n        launcher.close();\n        if (results == null) {\n            throw new SeleniumCommandTimedOutException();\n        }\n        if (outputFile != null) {\n            FileWriter fw = new FileWriter(outputFile);\n            results.write(fw);\n            fw.close();\n        }\n        \n        return results.getResult().toUpperCase();\n    }\n",
    "new_code_raw": "    public String runHTMLSuite(String browser, String browserURL, String HTMLSuite, File outputFile, int timeoutInSeconds, boolean multiWindow) throws IOException {\n        long timeoutInMs = 1000 * timeoutInSeconds;\n        server.handleHTMLRunnerResults(this);\n        BrowserLauncherFactory blf = new BrowserLauncherFactory(server);\n        String sessionId = Long.toString(System.currentTimeMillis() % 1000000);\n        BrowserLauncher launcher = blf.getBrowserLauncher(browser, sessionId, null);\n        launcher.launchHTMLSuite(HTMLSuite, browserURL, multiWindow);\n        long now = System.currentTimeMillis();\n        long end = now + timeoutInMs;\n        while (results == null && System.currentTimeMillis() < end) {\n            AsyncExecute.sleepTight(500);\n        }\n        launcher.close();\n        if (results == null) {\n            throw new SeleniumCommandTimedOutException();\n        }\n        if (outputFile != null) {\n            FileWriter fw = new FileWriter(outputFile);\n            results.write(fw);\n            fw.close();\n        }\n        \n        return results.getResult().toUpperCase();\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-448-Param-0",
    "old_comment_raw": "@param value the value to set the field in the copy to",
    "old_code_raw": "        public TimeOfDay setCopy(int value) {\n            int[] newValues = getField().set(iInstant, iFieldIndex, value);\n            return new TimeOfDay(iInstant, newValues);\n        }\n",
    "new_code_raw": "        public TimeOfDay setCopy(String text) {\n            return setCopy(text, null);\n        }\n"
  },
  {
    "id": "apache_activemq-1076-Param-0",
    "old_comment_raw": "@param broker",
    "old_code_raw": "    public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String name,int maxBatchSize) {\n        return new VMPendingMessageCursor();\n    }\n",
    "new_code_raw": "    public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String name,int maxBatchSize,Subscription subs) {\n        return new VMPendingMessageCursor(AbstractPendingMessageCursor.isPrioritizedMessageSubscriber(broker, subs));\n    }\n"
  },
  {
    "id": "apache_tuscany-das-2-Associations-Param0",
    "old_comment_raw": "@param ldapContext the dir context",
    "old_code_raw": "    public static LdapContext createPathContext(\n    \t\tLdapContext ldapContext, \n        String[] pathTokens) \n    throws NamingException\n    {\n        for (int i = 1; i < (pathTokens.length); i++)\n        {\n            String subContext = CN + \"=\" + pathTokens[i];\n            ldapContext = (LdapContext) createSubContext( \n            \t\tldapContext, \n            \t\tsubContext, null );\n        }\n        return ldapContext;\n    }\n",
    "new_code_raw": "    public static LdapContext createPathContext(\n        LdapContext authorityContext, \n        String[] pathTokens) \n    throws NamingException\n    {\n        for (int i = 1; i < (pathTokens.length); i++)\n        {\n            String subContext = CN + \"=\" + pathTokens[i];\n            authorityContext = (LdapContext) createSubContext( \n            \t\tauthorityContext, \n            \t\tsubContext, null );\n        }\n        return authorityContext;\n    }\n\n"
  },
  {
    "id": "Atmosphere_atmosphere-207-Param-1",
    "old_comment_raw": "@param c An instance of  AtmosphereServlet.AtmosphereConfig",
    "old_code_raw": "    public static BroadcasterFactory buildAndReplaceDefaultfactory(Class<? extends Broadcaster> clazz, AtmosphereServlet.AtmosphereConfig c)\n            throws InstantiationException, IllegalAccessException {\n\n        factory = new DefaultBroadcasterFactory(clazz, \"NEVER\", c);\n        return factory;\n    }\n",
    "new_code_raw": "    public static BroadcasterFactory buildAndReplaceDefaultfactory(Class<? extends Broadcaster> clazz, AtmosphereConfig c)\n            throws InstantiationException, IllegalAccessException {\n\n        factory = new DefaultBroadcasterFactory(clazz, \"NEVER\", c);\n        return factory;\n    }\n"
  },
  {
    "id": "yanzhenjie_NoHttp-199-Param-0",
    "old_comment_raw": "@param request  ImplServerRequest.",
    "old_code_raw": "    protected Connection getConnection(BasicServerRequest request) {\n        Logger.d(\"--------------Request start--------------\");\n\n        Headers responseHeaders = new HttpHeaders();\n        InputStream inputStream = null;\n        Exception exception = null;\n\n        HttpURLConnection urlConnection = null;\n        String url = request.url();\n        try {\n            if (!NetUtil.isNetworkAvailable())\n                throw new NetworkError(\"The network is not available, please check the network. The requested url is: \" + url);\n\n            // MalformedURLException, IOException, ProtocolException, UnknownHostException, SocketTimeoutException\n            urlConnection = createHttpURLConnection(request);\n            Logger.d(\"-------Response start-------\");\n            int responseCode = urlConnection.getResponseCode();\n            responseHeaders = parseResponseHeaders(new URI(request.url()), responseCode, urlConnection.getResponseMessage(), urlConnection.getHeaderFields());\n\n            // handle body\n            if (responseCode == 301 || responseCode == 302 || responseCode == 303 || responseCode == 307) {\n                Connection redirectConnectiont = handleRedirect(request, responseHeaders);\n                responseHeaders = redirectConnectiont.responseHeaders();\n                inputStream = redirectConnectiont.serverStream();\n                exception = redirectConnectiont.exception();\n            } else if (hasResponseBody(request.getRequestMethod(), responseCode)) {\n                inputStream = getServerStream(responseCode, responseHeaders.getContentEncoding(), urlConnection);\n            }\n            Logger.d(\"-------Response end-------\");\n        } catch (MalformedURLException e) {\n            exception = new URLError(\"The url is malformed: \" + url + \".\");\n        } catch (UnknownHostException e) {\n            exception = new UnKnownHostError(\"Hostname can not be resolved: \" + url + \".\");\n        } catch (SocketTimeoutException e) {\n            exception = new TimeoutError(\"Request time out: \" + url + \".\");\n        } catch (Exception e) {\n            exception = e;\n        } finally {\n            if (exception != null)\n                Logger.e(exception);\n        }\n        Logger.d(\"--------------Request finish--------------\");\n        return new Connection(urlConnection, responseHeaders, inputStream, exception);\n    }\n",
    "new_code_raw": "    protected Connection getConnection(IBasicRequest request) {\n        Logger.d(\"--------------Request start--------------\");\n\n        Headers responseHeaders = new HttpHeaders();\n        InputStream inputStream = null;\n        Exception exception = null;\n\n        HttpURLConnection urlConnection = null;\n        String url = request.url();\n        try {\n            if (!NetUtil.isNetworkAvailable())\n                throw new NetworkError(\"The network is not available, please check the network. The requested url is: \" + url);\n\n            // MalformedURLException, IOException, ProtocolException, UnknownHostException, SocketTimeoutException\n            urlConnection = createConnectionAndWriteData(request);\n            Logger.d(\"-------Response start-------\");\n            int responseCode = urlConnection.getResponseCode();\n            responseHeaders = parseResponseHeaders(new URI(request.url()), responseCode, urlConnection.getResponseMessage(), urlConnection.getHeaderFields());\n\n            // handle body\n            if (responseCode == 301 || responseCode == 302 || responseCode == 303 || responseCode == 307) {\n                Connection redirectConnection = handleRedirect(request, responseHeaders);\n                responseHeaders = redirectConnection.responseHeaders();\n                inputStream = redirectConnection.serverStream();\n                exception = redirectConnection.exception();\n            } else if (hasResponseBody(request.getRequestMethod(), responseCode)) {\n                inputStream = getServerStream(responseCode, responseHeaders.getContentEncoding(), urlConnection);\n            }\n            Logger.d(\"-------Response end-------\");\n        } catch (MalformedURLException e) {\n            exception = new URLError(\"The url is malformed: \" + url + \".\");\n        } catch (UnknownHostException e) {\n            exception = new UnKnownHostError(\"Hostname can not be resolved: \" + url + \".\");\n        } catch (SocketTimeoutException e) {\n            exception = new TimeoutError(\"Request time out: \" + url + \".\");\n        } catch (Exception e) {\n            exception = e;\n        } finally {\n            if (exception != null)\n                Logger.e(exception);\n        }\n        Logger.d(\"--------------Request finish--------------\");\n        return new Connection(urlConnection, responseHeaders, inputStream, exception);\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1186-Param-1",
    "old_comment_raw": "@param timestamp The timestamp against which to check.",
    "old_code_raw": "\tpublic boolean isUpToDate(Set<Serializable> spaces, Long timestamp, SessionImplementor session) throws CacheException {\n\t\tfinal boolean stats = factory != null && factory.getStatistics().isStatisticsEnabled();\n\n\t\tfor ( Serializable space : spaces ) {\n\t\t\tfinal Long lastUpdate = getLastUpdateTimestampForSpace( space, session );\n\t\t\tif ( lastUpdate == null ) {\n\t\t\t\tif ( stats ) {\n\t\t\t\t\tfactory.getStatisticsImplementor().updateTimestampsCacheMiss();\n\t\t\t\t}\n\t\t\t\t//the last update timestamp was lost from the cache\n\t\t\t\t//(or there were no updates since startup!)\n\t\t\t\t//updateTimestamps.put( space, new Long( updateTimestamps.nextTimestamp() ) );\n\t\t\t\t//result = false; // safer\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( DEBUG_ENABLED ) {\n\t\t\t\t\tLOG.debugf(\n\t\t\t\t\t\t\t\"[%s] last update timestamp: %s\",\n\t\t\t\t\t\t\tspace,\n\t\t\t\t\t\t\tlastUpdate + \", result set timestamp: \" + timestamp\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif ( stats ) {\n\t\t\t\t\tfactory.getStatisticsImplementor().updateTimestampsCacheHit();\n\t\t\t\t}\n\t\t\t\tif ( lastUpdate >= timestamp ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "new_code_raw": "\tpublic boolean isUpToDate(Set<Serializable> spaces, Long timestamp, SharedSessionContractImplementor session) throws CacheException {\n\t\tfinal boolean stats = factory != null && factory.getStatistics().isStatisticsEnabled();\n\n\t\tfor ( Serializable space : spaces ) {\n\t\t\tfinal Long lastUpdate = getLastUpdateTimestampForSpace( space, session );\n\t\t\tif ( lastUpdate == null ) {\n\t\t\t\tif ( stats ) {\n\t\t\t\t\tfactory.getStatistics().updateTimestampsCacheMiss();\n\t\t\t\t}\n\t\t\t\t//the last update timestamp was lost from the cache\n\t\t\t\t//(or there were no updates since startup!)\n\t\t\t\t//updateTimestamps.put( space, new Long( updateTimestamps.nextTimestamp() ) );\n\t\t\t\t//result = false; // safer\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( DEBUG_ENABLED ) {\n\t\t\t\t\tLOG.debugf(\n\t\t\t\t\t\t\t\"[%s] last update timestamp: %s\",\n\t\t\t\t\t\t\tspace,\n\t\t\t\t\t\t\tlastUpdate + \", result set timestamp: \" + timestamp\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif ( stats ) {\n\t\t\t\t\tfactory.getStatistics().updateTimestampsCacheHit();\n\t\t\t\t}\n\t\t\t\tif ( lastUpdate >= timestamp ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n"
  },
  {
    "id": "querydsl_querydsl-1441-Param-0",
    "old_comment_raw": "@param object",
    "old_code_raw": "    protected String convert(Path<?> path, Object value){\n        return value.toString();\n    }\n",
    "new_code_raw": "    protected String[] convert(Path<?> leftHandSide, Object rightHandSide) {\n        String str = rightHandSide.toString();\n        if (lowerCase){\n            str = str.toLowerCase();\n        }\n        if (splitTerms) {            \n            if (str.equals(\"\")) {\n                return new String[] { str };\n            } else {\n                return StringUtils.split(str);\n            }\n        } else {\n            return new String[] { str };\n        }\n    }\n"
  },
  {
    "id": "querydsl_querydsl-934-Param-0",
    "old_comment_raw": "@param right",
    "old_code_raw": "    public BooleanExpression after(D right) {\n        return gt(right);\n    }\n",
    "new_code_raw": "    public BooleanExpression after(T right) {\n        return gt(right);\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2374-Param-0",
    "old_comment_raw": "@param is The input stream to read from. This should contain a single protocol buffer and nothing else.",
    "old_code_raw": "  public Annotation readUndelimited(InputStream is) throws IOException {\n    return fromProto(CoreNLPProtos.Document.parseDelimitedFrom(is));\n  }\n",
    "new_code_raw": "  public Annotation readUndelimited(File in) throws IOException {\n    FileInputStream delimited = new FileInputStream(in);\n    FileInputStream undelimited = new FileInputStream(in);\n    CoreNLPProtos.Document doc;\n    try {\n      doc = CoreNLPProtos.Document.parseFrom(delimited);\n    } catch (Exception e) {\n      doc = CoreNLPProtos.Document.parseDelimitedFrom(undelimited);\n    } finally {\n      delimited.close();\n      undelimited.close();\n    }\n    return fromProto(doc);\n  }\n"
  },
  {
    "id": "RobotiumTech_robotium-1486-Param-1",
    "old_comment_raw": "@param matches the number of matches expected to be found. 0 matches means that one or more matches are expected to be found",
    "old_code_raw": "\tprivate boolean searchForToggleButton(String search, int matches) {\n\t\tsleeper.sleep();\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(search);\n\t\tMatcher matcher;\n\t\tArrayList<ToggleButton> toggleButtonList = viewFetcher.getCurrentViews(ToggleButton.class);\n\t\tif(matches == 0)\n\t\t\tmatches = 1;\n\t\tfor(ToggleButton toggleButton : toggleButtonList){\n\t\t\tmatcher = p.matcher(toggleButton.getText().toString());\n\t\t\tif(matcher.find()){\t\n\t\t\t\tcountMatches++;\n\t\t\t}\n\t\t\tif (countMatches == matches) {\n\t\t\t\tcountMatches=0;\n\t\t\t\treturn true;\n\t\t\t} \n\t\t}\n\n\t\tif (scroller.scroll(Scroller.Direction.DOWN))\n\t\t{\n\t\t\treturn searchForToggleButton(search, matches);\n\t\t} else {\n\t\t\tif(countMatches > 0)\n\t\t\t\tLog.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + search);\n\t\t\tcountMatches = 0;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t}\n",
    "new_code_raw": "\tprivate boolean searchForToggleButton(String regex, int matches) {\n\t\tsleeper.sleep();\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(regex);\n\t\tMatcher matcher;\n\t\tArrayList<ToggleButton> toggleButtonList = viewFetcher.getCurrentViews(ToggleButton.class);\n\t\tif(matches == 0)\n\t\t\tmatches = 1;\n\t\tfor(ToggleButton toggleButton : toggleButtonList){\n\t\t\tmatcher = p.matcher(toggleButton.getText().toString());\n\t\t\tif(matcher.find()){\t\n\t\t\t\tcountMatches++;\n\t\t\t}\n\t\t\tif (countMatches == matches) {\n\t\t\t\tcountMatches=0;\n\t\t\t\treturn true;\n\t\t\t} \n\t\t}\n\n\t\tif (scroller.scroll(Scroller.Direction.DOWN))\n\t\t{\n\t\t\treturn searchForToggleButton(regex, matches);\n\t\t} else {\n\t\t\tif(countMatches > 0)\n\t\t\t\tLog.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + regex);\n\t\t\tcountMatches = 0;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t}\n"
  },
  {
    "id": "zaproxy_zaproxy-2201-Param-0",
    "old_comment_raw": "@param handshakeMessage",
    "old_code_raw": "\tpublic boolean isConnected(HttpMessage handshakeMessage) {\n\t\tint historyId = handshakeMessage.getHistoryRef().getHistoryId();\n\t\tfor (Entry<Integer, WebSocketProxy> entry : wsProxies.entrySet()) {\n\t\t\tWebSocketProxy proxy = entry.getValue();\n\t\t\tif (historyId == proxy.getHandshakeReference().getHistoryId()) {\n\t\t\t\treturn proxy.isConnected();\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "new_code_raw": "\tpublic boolean isConnected(Integer channelId) {\n\t\tsynchronized (wsProxies) {\n\t\t\tif (wsProxies.containsKey(channelId)) {\n\t\t\t\treturn wsProxies.get(channelId).isConnected();\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n"
  },
  {
    "id": "querydsl_querydsl-904-Param-0",
    "old_comment_raw": "@param mode",
    "old_code_raw": "    public ScrollableResults scroll(ScrollMode mode, Expr<?> expr) {\n        Query query = createQuery(expr);\n        reset();\n        return query.scroll(mode);\n    }\n",
    "new_code_raw": "    public ScrollableResults scroll(ScrollMode mode, Expression<?> expr) {\n        Query query = createQuery(expr);\n        reset();\n        return query.scroll(mode);\n    }\n"
  },
  {
    "id": "Netflix_eureka-380-Param-0",
    "old_comment_raw": "@param action the action to be performed on eureka server. Try the fallback servers in case of problems communicating to the primary one.",
    "old_code_raw": "    private ClientResponse makeRemoteCall(Action action, int serviceUrlIndex)\n            throws Throwable {\n        String urlPath = null;\n        Stopwatch tracer = null;\n        String serviceUrl = eurekaServiceUrls.get().get(serviceUrlIndex);\n        ClientResponse response = null;\n        logger.debug(\"Discovery Client talking to the server {}\", serviceUrl);\n        try {\n            // If the application is unknown do not register/renew/cancel but\n            // refresh\n            if ((UNKNOWN.equals(instanceInfo.getAppName())\n                    && (!Action.Refresh.equals(action)) && (!Action.Refresh_Delta\n                    .equals(action)))) {\n                return null;\n            }\n            WebResource r = discoveryApacheClient.resource(serviceUrl);\n            String remoteRegionsToFetchStr;\n            switch (action) {\n            case Renew:\n                tracer = RENEW_TIMER.start();\n                urlPath = \"apps/\" + appPathIdentifier;\n                response = r\n                        .path(urlPath)\n                        .queryParam(\"status\",\n                                instanceInfo.getStatus().toString())\n                        .queryParam(\"lastDirtyTimestamp\",\n                                instanceInfo.getLastDirtyTimestamp().toString())\n                        .put(ClientResponse.class);\n                break;\n            case Refresh:\n                tracer = REFRESH_TIMER.start();\n                final String vipAddress = clientConfig.getRegistryRefreshSingleVipAddress();\n                urlPath = vipAddress == null ? \"apps/\" : \"vips/\" + vipAddress;\n                remoteRegionsToFetchStr = remoteRegionsToFetch.get();\n                if (!Strings.isNullOrEmpty(remoteRegionsToFetchStr)) {\n                    urlPath += \"?regions=\" + remoteRegionsToFetchStr;\n                }\n                response = getUrl(serviceUrl + urlPath);\n                break;\n            case Refresh_Delta:\n                tracer = REFRESH_DELTA_TIMER.start();\n                urlPath = \"apps/delta\";\n                remoteRegionsToFetchStr = remoteRegionsToFetch.get();\n                if (!Strings.isNullOrEmpty(remoteRegionsToFetchStr)) {\n                    urlPath += \"?regions=\" + remoteRegionsToFetchStr;\n                }\n                response = getUrl(serviceUrl + urlPath);\n                break;\n            case Register:\n                tracer = REGISTER_TIMER.start();\n                urlPath = \"apps/\" + instanceInfo.getAppName();\n                response = r.path(urlPath)\n                        .type(MediaType.APPLICATION_JSON_TYPE)\n                        .post(ClientResponse.class, instanceInfo);\n                break;\n            case Cancel:\n                tracer = CANCEL_TIMER.start();\n                urlPath = \"apps/\" + appPathIdentifier;\n                response = r.path(urlPath).delete(ClientResponse.class);\n                // Return without during de-registration if it is not registered\n                // already and if we get a 404\n                if ((!isRegisteredWithDiscovery)\n                        && (response.getStatus() == Status.NOT_FOUND\n                                .getStatusCode())) {\n                    return response;\n                }\n                break;\n            }\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Finished a call to service url {} and url path {} with status code {}.\",\n                            new String[] {serviceUrl, urlPath, String.valueOf(response.getStatus())});\n            }\n            if (isOk(action, response.getStatus())) {\n                return response;\n            } else {\n                logger.warn(\"Action: \" + action + \"  => returned status of \"\n                        + response.getStatus() + \" from \" + serviceUrl\n                        + urlPath);\n                throw new RuntimeException(\"Bad status: \"\n                        + response.getStatus());\n            }\n        } catch (Throwable t) {\n            closeResponse(response);\n            String msg = \"Can't get a response from \" + serviceUrl + urlPath;\n            if (eurekaServiceUrls.get().size() > (++serviceUrlIndex)) {\n                logger.warn(msg, t);\n                logger.warn(\"Trying backup: \"\n                        + eurekaServiceUrls.get().get(serviceUrlIndex));\n                SERVER_RETRY_COUNTER.increment();\n                return makeRemoteCall(action, serviceUrlIndex);\n            } else {\n                ALL_SERVER_FAILURE_COUNT.increment();\n                logger.error(\n                        msg\n                                + \"\\nCan't contact any eureka nodes - possibly a security group issue?\",\n                        t);\n                throw t;\n            }\n        } finally {\n            if (tracer != null) {\n                tracer.stop();\n            }\n        }\n    }\n",
    "new_code_raw": "    private ClientResponse makeRemoteCall(Action action, String serviceUrl) throws Throwable {\n        String urlPath = null;\n        Stopwatch tracer = null;\n        ClientResponse response = null;\n        logger.debug(\"Discovery Client talking to the server {}\", serviceUrl);\n        try {\n            // If the application is unknown do not register/renew/cancel but\n            // refresh\n            if ((UNKNOWN.equals(instanceInfo.getAppName())\n                    && (!Action.Refresh.equals(action)) && (!Action.Refresh_Delta\n                    .equals(action)))) {\n                return null;\n            }\n            WebResource r = discoveryApacheClient.resource(serviceUrl);\n            String remoteRegionsToFetchStr;\n            switch (action) {\n                case Renew:\n                    tracer = RENEW_TIMER.start();\n                    urlPath = \"apps/\" + appPathIdentifier;\n                    response = r\n                            .path(urlPath)\n                            .queryParam(\"status\",\n                                    instanceInfo.getStatus().toString())\n                            .queryParam(\"lastDirtyTimestamp\",\n                                    instanceInfo.getLastDirtyTimestamp().toString())\n                            .put(ClientResponse.class);\n                    break;\n                case Refresh:\n                    tracer = REFRESH_TIMER.start();\n                    final String vipAddress = clientConfig.getRegistryRefreshSingleVipAddress();\n                    urlPath = vipAddress == null ? \"apps/\" : \"vips/\" + vipAddress;\n                    remoteRegionsToFetchStr = remoteRegionsToFetch.get();\n                    if (!Strings.isNullOrEmpty(remoteRegionsToFetchStr)) {\n                        urlPath += \"?regions=\" + remoteRegionsToFetchStr;\n                    }\n                    response = getUrl(serviceUrl + urlPath);\n                    break;\n                case Refresh_Delta:\n                    tracer = REFRESH_DELTA_TIMER.start();\n                    urlPath = \"apps/delta\";\n                    remoteRegionsToFetchStr = remoteRegionsToFetch.get();\n                    if (!Strings.isNullOrEmpty(remoteRegionsToFetchStr)) {\n                        urlPath += \"?regions=\" + remoteRegionsToFetchStr;\n                    }\n                    response = getUrl(serviceUrl + urlPath);\n                    break;\n                case Register:\n                    tracer = REGISTER_TIMER.start();\n                    urlPath = \"apps/\" + instanceInfo.getAppName();\n                    response = r.path(urlPath)\n                            .type(MediaType.APPLICATION_JSON_TYPE)\n                            .post(ClientResponse.class, instanceInfo);\n                    break;\n                case Cancel:\n                    tracer = CANCEL_TIMER.start();\n                    urlPath = \"apps/\" + appPathIdentifier;\n                    response = r.path(urlPath).delete(ClientResponse.class);\n                    // Return without during de-registration if it is not registered\n                    // already and if we get a 404\n                    if ((!isRegisteredWithDiscovery)\n                            && (response.getStatus() == Status.NOT_FOUND\n                            .getStatusCode())) {\n                        return response;\n                    }\n                    break;\n            }\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Finished a call to service url {} and url path {} with status code {}.\",\n                        new String[] {serviceUrl, urlPath, String.valueOf(response.getStatus())});\n            }\n            if (isOk(action, response.getStatus())) {\n                return response;\n            } else {\n                logger.warn(\"Action: \" + action + \"  => returned status of \"\n                        + response.getStatus() + \" from \" + serviceUrl\n                        + urlPath);\n                throw new RuntimeException(\"Bad status: \"\n                        + response.getStatus());\n            }\n        } catch (Throwable t) {\n            closeResponse(response);\n            logger.warn(\"Can't get a response from \" + serviceUrl + urlPath, t);\n            throw t;\n        } finally {\n            if (tracer != null) {\n                tracer.stop();\n            }\n        }\n    }\n"
  },
  {
    "id": "apache_drill-765-Param-1",
    "old_comment_raw": "@param projType implied projection type for the column",
    "old_code_raw": "  private ColumnState buildPrimitive(ContainerState parent, ColumnTransform outputCol) {\n    ProjectionType projType = outputCol.projectionType();\n    ColumnMetadata columnSchema = outputCol.outputSchema();\n\n    // Enforce correspondence between implied type from the projection list\n    // and the actual type of the column.\n\n    switch (projType) {\n    case ARRAY:\n      if (! columnSchema.isArray()) {\n        incompatibleProjection(projType, columnSchema);\n      }\n      break;\n    case TUPLE:\n    case TUPLE_ARRAY:\n      incompatibleProjection(projType, columnSchema);\n      break;\n    default:\n      break;\n    }\n\n    ValueVector vector;\n    if (projType == ProjectionType.UNPROJECTED) {\n\n      // Column is not projected. No materialized backing for the column.\n\n      vector = null;\n    } else {\n\n      // Create the vector for the column.\n\n      vector = parent.vectorCache().addOrGet(columnSchema.schema());\n\n      // In permissive mode, the mode or precision of the vector may differ\n      // from that requested. Update the schema to match.\n\n      if (parent.vectorCache().isPermissive() && ! vector.getField().isEquivalent(columnSchema.schema())) {\n        columnSchema = ((PrimitiveColumnMetadata) columnSchema).mergeWith(vector.getField());\n      }\n    }\n\n    // Create the writer.\n\n    final AbstractObjectWriter colWriter = ColumnWriterFactory.buildColumnWriter(\n        columnSchema, outputCol, vector);\n\n    // Build the vector state which manages the vector.\n\n    VectorState vectorState;\n    if (vector == null) {\n      vectorState = new NullVectorState();\n    } else if (columnSchema.isArray()) {\n      vectorState = new RepeatedVectorState(colWriter.array(), (RepeatedValueVector) vector);\n    } else if (columnSchema.isNullable()) {\n      vectorState = new NullableVectorState(\n          colWriter, (NullableVector) vector);\n    } else {\n      vectorState = SimpleVectorState.vectorState(columnSchema,\n            colWriter.events(), vector);\n    }\n\n    // Create the column state which binds the vector and writer together.\n\n    return new PrimitiveColumnState(parent.loader(), colWriter,\n        vectorState);\n  }\n",
    "new_code_raw": "  private ColumnState buildPrimitive(ContainerState parent, ColumnReadProjection colProj) {\n    ColumnMetadata columnSchema = colProj.providedSchema();\n\n    ValueVector vector;\n    if (!colProj.isProjected()) {\n\n      // Column is not projected. No materialized backing for the column.\n\n      vector = null;\n    } else {\n\n      // Create the vector for the column.\n\n      vector = parent.vectorCache().addOrGet(columnSchema.schema());\n\n      // In permissive mode, the mode or precision of the vector may differ\n      // from that requested. Update the schema to match.\n\n      if (parent.vectorCache().isPermissive() && ! vector.getField().isEquivalent(columnSchema.schema())) {\n        columnSchema = ((PrimitiveColumnMetadata) columnSchema).mergeWith(vector.getField());\n      }\n    }\n\n    // Create the writer.\n\n    final AbstractObjectWriter colWriter = ColumnWriterFactory.buildColumnWriter(\n        columnSchema, colProj.conversionFactory(), vector);\n\n    // Build the vector state which manages the vector.\n\n    VectorState vectorState;\n    if (vector == null) {\n      vectorState = new NullVectorState();\n    } else if (columnSchema.isArray()) {\n      vectorState = new RepeatedVectorState(colWriter.array(), (RepeatedValueVector) vector);\n    } else if (columnSchema.isNullable()) {\n      vectorState = new NullableVectorState(\n          colWriter, (NullableVector) vector);\n    } else {\n      vectorState = SimpleVectorState.vectorState(columnSchema,\n            colWriter.events(), vector);\n    }\n\n    // Create the column state which binds the vector and writer together.\n\n    return new PrimitiveColumnState(parent.loader(), colWriter,\n        vectorState);\n  }\n"
  },
  {
    "id": "SeleniumHQ_selenium-835-Param-0",
    "old_comment_raw": "@param onElement Element to move to and click.",
    "old_code_raw": "  public Actions clickAndHold(WebElement onElement) {\n    action.addAction(new ClickAndHoldAction(mouse, (Locatable) onElement));\n    return this;\n  }\n",
    "new_code_raw": "  public Actions clickAndHold(WebElement target) {\n    if (isBuildingActions()) {\n      action.addAction(new ClickAndHoldAction(jsonMouse, (Locatable) target));\n      return this;\n    }\n    return moveToElement(target).clickAndHold();\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1192-Param-0",
    "old_comment_raw": "@param version The current version",
    "old_code_raw": "\tpublic static Object increment(Object version, VersionType versionType, SessionImplementor session) {\n\t\tfinal Object next = versionType.next( version, session );\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracef(\n\t\t\t\t\t\"Incrementing: %s to %s\",\n\t\t\t\t\tversionType.toLoggableString( version, session.getFactory() ),\n\t\t\t\t\tversionType.toLoggableString( next, session.getFactory() )\n\t\t\t);\n\t\t}\n\t\treturn next;\n\t}\n",
    "new_code_raw": "\tpublic static Object increment(Object version, VersionType versionType, SharedSessionContractImplementor session) {\n\t\tfinal Object next = versionType.next( version, session );\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracef(\n\t\t\t\t\t\"Incrementing: %s to %s\",\n\t\t\t\t\tversionType.toLoggableString( version, session.getFactory() ),\n\t\t\t\t\tversionType.toLoggableString( next, session.getFactory() )\n\t\t\t);\n\t\t}\n\t\treturn next;\n\t}\n"
  },
  {
    "id": "RobotiumTech_robotium-1183-Param-0",
    "old_comment_raw": "@param search the string to be searched. The parameter will be interpreted as a regular expression.",
    "old_code_raw": "\tpublic boolean searchButton(String search, int matches) {\n\t\tboolean found = searcher.searchButton(search, matches);\n\t\treturn found;\n\n\t}\n",
    "new_code_raw": "\tpublic boolean searchButton(String regex, int matches) {\n\t\tboolean found = searcher.searchButton(regex, matches);\n\t\treturn found;\n\n\t}\n"
  },
  {
    "id": "hibernate_hibernate_orm-1303-Param-1",
    "old_comment_raw": "@param session The session from which the request is originating.",
    "old_code_raw": "\tpublic Object getCollection(Serializable key, SharedSessionContractImplementor session, Object owner) {\n\n\t\tCollectionPersister persister = getPersister( session );\n\t\tfinal PersistenceContext persistenceContext = session.getPersistenceContext();\n\t\tfinal EntityMode entityMode = persister.getOwnerEntityPersister().getEntityMode();\n\n\t\t// check if collection is currently being loaded\n\t\tPersistentCollection collection = persistenceContext.getLoadContexts().locateLoadingCollection( persister, key );\n\n\t\tif ( collection == null ) {\n\n\t\t\t// check if it is already completely loaded, but unowned\n\t\t\tcollection = persistenceContext.useUnownedCollection( new CollectionKey(persister, key, entityMode) );\n\n\t\t\tif ( collection == null ) {\n\n\t\t\t\tcollection = persistenceContext.getCollection( new CollectionKey(persister, key, entityMode) );\n\n\t\t\t\tif ( collection == null ) {\n\t\t\t\t\t// create a new collection wrapper, to be initialized later\n\t\t\t\t\tcollection = instantiate( session, persister, key );\n\n\t\t\t\t\tcollection.setOwner( owner );\n\n\t\t\t\t\tpersistenceContext.addUninitializedCollection( persister, collection, key );\n\n\t\t\t\t\t// some collections are not lazy:\n\t\t\t\t\tif ( initializeImmediately() ) {\n\t\t\t\t\t\tsession.initializeCollection( collection, false );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( !persister.isLazy() ) {\n\t\t\t\t\t\tpersistenceContext.addNonLazyCollection( collection );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasHolder() ) {\n\t\t\t\t\t\tsession.getPersistenceContext().addCollectionHolder( collection );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracef( \"Created collection wrapper: %s\",\n\t\t\t\t\t\tMessageHelper.collectionInfoString( persister, collection,\n\t\t\t\t\t\t\t\tkey, session ) );\n\t\t\t}\n\n\t\t}\n\n\t\tcollection.setOwner(owner);\n\n\t\treturn collection.getValue();\n\t}\n",
    "new_code_raw": "\tpublic Object getCollection(Serializable key, SharedSessionContractImplementor session, Object owner, Boolean overridingEager) {\n\n\t\tCollectionPersister persister = getPersister( session );\n\t\tfinal PersistenceContext persistenceContext = session.getPersistenceContext();\n\t\tfinal EntityMode entityMode = persister.getOwnerEntityPersister().getEntityMode();\n\n\t\t// check if collection is currently being loaded\n\t\tPersistentCollection collection = persistenceContext.getLoadContexts().locateLoadingCollection( persister, key );\n\n\t\tif ( collection == null ) {\n\n\t\t\t// check if it is already completely loaded, but unowned\n\t\t\tcollection = persistenceContext.useUnownedCollection( new CollectionKey(persister, key, entityMode) );\n\n\t\t\tif ( collection == null ) {\n\n\t\t\t\tcollection = persistenceContext.getCollection( new CollectionKey(persister, key, entityMode) );\n\n\t\t\t\tif ( collection == null ) {\n\t\t\t\t\t// create a new collection wrapper, to be initialized later\n\t\t\t\t\tcollection = instantiate( session, persister, key );\n\n\t\t\t\t\tcollection.setOwner( owner );\n\n\t\t\t\t\tpersistenceContext.addUninitializedCollection( persister, collection, key );\n\n\t\t\t\t\t// some collections are not lazy:\n\t\t\t\t\tboolean eager = overridingEager != null ? overridingEager : !persister.isLazy();\n\t\t\t\t\tif ( initializeImmediately() ) {\n\t\t\t\t\t\tsession.initializeCollection( collection, false );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( eager ) {\n\t\t\t\t\t\tpersistenceContext.addNonLazyCollection( collection );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasHolder() ) {\n\t\t\t\t\t\tsession.getPersistenceContext().addCollectionHolder( collection );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracef( \"Created collection wrapper: %s\",\n\t\t\t\t\t\tMessageHelper.collectionInfoString( persister, collection,\n\t\t\t\t\t\t\t\tkey, session ) );\n\t\t\t}\n\n\t\t}\n\n\t\tcollection.setOwner(owner);\n\n\t\treturn collection.getValue();\n\t}\n"
  },
  {
    "id": "jackyglony_objectiveclipse-216-Associations-Param0",
    "old_comment_raw": "@param name the IASTName whose IType will be created",
    "old_code_raw": "\tpublic static IType createType(IASTName name) {\n\t\tif (!(name.getParent() instanceof IASTDeclarator)) return null;\n\t\t\n\t    IASTDeclSpecifier declSpec = null;\n\t\tIASTDeclarator declarator = (IASTDeclarator) name.getParent();\n\t\t\n\t\tIASTNode node = declarator.getParent();\n\t\twhile( node instanceof IASTDeclarator ){\n\t\t\tdeclarator = (IASTDeclarator) node;\n\t\t\tnode = node.getParent();\n\t\t}\n\t\t\n\t\tif( node instanceof IASTParameterDeclaration )\n\t\t\tdeclSpec = ((IASTParameterDeclaration) node).getDeclSpecifier();\n\t\telse if( node instanceof IASTSimpleDeclaration )\n\t\t\tdeclSpec = ((IASTSimpleDeclaration)node).getDeclSpecifier();\n\t\telse if( node instanceof IASTFunctionDefinition )\n\t\t\tdeclSpec = ((IASTFunctionDefinition)node).getDeclSpecifier();\n\t\telse if( node instanceof IASTTypeId )\n\t\t    declSpec = ((IASTTypeId)node).getDeclSpecifier();\n\t\n\t\tboolean isParameter = ( node instanceof IASTParameterDeclaration || node.getParent() instanceof ICASTKnRFunctionDeclarator ); \n\t\t\n\t\tIType type = null;\n\t\t\n\t\t//C99 6.7.5.3-12 The storage class specifier for a parameter declaration is ignored unless the declared parameter is one of the \n\t\t//members of the parameter type list for a function definition.\n\t\tif( isParameter && node.getParent().getParent() instanceof IASTFunctionDefinition ){\n\t\t    type = createBaseType( declSpec );\n\t\t} else {\n\t\t    type = createType( declSpec );\n\t\t}\n\t\t\n\t\ttype = createType( type, declarator );\n\t\t\n\t\t\n        if( isParameter ) {\n            //C99: 6.7.5.3-7 a declaration of a parameter as \"array of type\" shall be adjusted to \"qualified pointer to type\", where the\n    \t\t//type qualifiers (if any) are those specified within the [ and ] of the array type derivation\n            if( type instanceof IArrayType ){\n\t            CArrayType at = (CArrayType) type;\n\t            type = new CQualifiedPointerType( at.getType(), at.getModifier() );\n\t        } else if( type instanceof IFunctionType ) {\n\t            //-8 A declaration of a parameter as \"function returning type\" shall be adjusted to \"pointer to function returning type\"\n\t            type = new CPointerType( type );\n\t        }\n        }\n        \n\t\treturn type;\n\t}\n",
    "new_code_raw": "\tpublic static IType createType(IASTDeclarator declarator) {\n\t    IASTDeclSpecifier declSpec = null;\n\t\t\n\t\tIASTNode node = declarator.getParent();\n\t\twhile( node instanceof IASTDeclarator ){\n\t\t\tdeclarator = (IASTDeclarator) node;\n\t\t\tnode = node.getParent();\n\t\t}\n\t\t\n\t\tif( node instanceof IASTParameterDeclaration )\n\t\t\tdeclSpec = ((IASTParameterDeclaration) node).getDeclSpecifier();\n\t\telse if( node instanceof IASTSimpleDeclaration )\n\t\t\tdeclSpec = ((IASTSimpleDeclaration)node).getDeclSpecifier();\n\t\telse if( node instanceof IASTFunctionDefinition )\n\t\t\tdeclSpec = ((IASTFunctionDefinition)node).getDeclSpecifier();\n\t\telse if( node instanceof IASTTypeId )\n\t\t    declSpec = ((IASTTypeId)node).getDeclSpecifier();\n\t\n\t\tboolean isParameter = ( node instanceof IASTParameterDeclaration || node.getParent() instanceof ICASTKnRFunctionDeclarator ); \n\t\t\n\t\tIType type = null;\n\t\t\n\t\t//C99 6.7.5.3-12 The storage class specifier for a parameter declaration is ignored unless the declared parameter is one of the \n\t\t//members of the parameter type list for a function definition.\n\t\tif( isParameter && node.getParent().getParent() instanceof IASTFunctionDefinition ){\n\t\t    type = createBaseType( declSpec );\n\t\t} else {\n\t\t    type = createType( declSpec );\n\t\t}\n\t\t\n\t\ttype = createType( type, declarator );\n\t\t\n\t\t\n        if( isParameter ) {\n            //C99: 6.7.5.3-7 a declaration of a parameter as \"array of type\" shall be adjusted to \"qualified pointer to type\", where the\n    \t\t//type qualifiers (if any) are those specified within the [ and ] of the array type derivation\n            if( type instanceof IArrayType ){\n\t            CArrayType at = (CArrayType) type;\n\t            type = new CQualifiedPointerType( at.getType(), at.getModifier() );\n\t        } else if( type instanceof IFunctionType ) {\n\t            //-8 A declaration of a parameter as \"function returning type\" shall be adjusted to \"pointer to function returning type\"\n\t            type = new CPointerType( type );\n\t        }\n        }\n        \n\t\treturn type;\n\t}\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-203-Param-4",
    "old_comment_raw": "@param headerParams The header parameters",
    "old_code_raw": "  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n",
    "new_code_raw": "  public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1635-Param-0",
    "old_comment_raw": "@param body order placed for purchasing the pet",
    "old_code_raw": "  public Order placeOrder (Order body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = body;\n    // verify the required parameter 'body' is set\n    if (body == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'body' when calling placeOrder\",\n        new ApiException(400, \"Missing the required parameter 'body' when calling placeOrder\"));\n    }\n\n    // create path and map variables\n    String path = \"/store/order\";\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n    }\n\n    String[] authNames = new String[] {  };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return (Order) ApiInvoker.deserialize(localVarResponse, \"\", Order.class);\n      } else {\n         return null;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n",
    "new_code_raw": "  public Order placeOrder (Order order) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = order;\n    // verify the required parameter 'order' is set\n    if (order == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'order' when calling placeOrder\",\n        new ApiException(400, \"Missing the required parameter 'order' when calling placeOrder\"));\n    }\n\n    // create path and map variables\n    String path = \"/store/order\";\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n      \"application/json\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n    }\n\n    String[] authNames = new String[] {  };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return (Order) ApiInvoker.deserialize(localVarResponse, \"\", Order.class);\n      } else {\n         return null;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1211-Param-1",
    "old_comment_raw": "@param persister The underlying collection persister (metadata)",
    "old_code_raw": "\tpublic Object nullSafeGet(ResultSet rs, String name, SessionImplementor session, Object owner) throws SQLException {\n\t\treturn nullSafeGet( rs, new String[] { name }, session, owner );\n\t}\n",
    "new_code_raw": "\tpublic Object nullSafeGet(ResultSet rs, String name, SharedSessionContractImplementor session, Object owner) throws SQLException {\n\t\treturn nullSafeGet( rs, new String[] { name }, session, owner );\n\t}\n"
  },
  {
    "id": "Vexatos_Resonant-Induction-1-0-Associations-Param0",
    "old_comment_raw": "@param watts - The amount of watt this block recieved",
    "old_code_raw": "\t@Override\n\tpublic int onReceiveLiquid(int type,int amt, byte side)\n\t{\n\t\tif(type == this.type)\n\t\t{\n\t\tint rejectedLiquid = Math.max((this.getStoredLiquid(type) + amt) - this.capacity, 0);\n\t\t this.liquidStored += watt - rejectedElectricity;\n\t\treturn rejectedLiquid;\n\t\t}\n\t\treturn watt;\n\t}\n",
    "new_code_raw": "\t@Override\n\tpublic int onReceiveLiquid(int type,int vol, byte side)\n\t{\n\t\tif(type == this.type)\n\t\t{\n\t\tint rejectedVolume = Math.max((this.getStoredLiquid(type) + vol) - this.capacity, 0);\n\t\t this.liquidStored = vol - rejectedVolume;\n\t\treturn rejectedVolume;\n\t\t}\n\t\treturn vol;\n\t}\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-153-Param-2",
    "old_comment_raw": "@param docid A docid must be supplied, as it is not saved by the serialized representation.",
    "old_code_raw": "  private static SemanticGraph fromProto(CoreMapProtos.DependencyGraph proto, List<CoreLabel> sentence, String docid) {\n    SemanticGraph graph = new SemanticGraph();\n\n    // first construct the actual nodes; keep them indexed by their index\n    // This block is optimized as one of the places which take noticeable time\n    // in datum caching\n    int min = Integer.MAX_VALUE;\n    int max = Integer.MIN_VALUE;\n    for(CoreMapProtos.DependencyGraph.Node in: proto.getNodeList()){\n      min = in.getIndex() < min ? in.getIndex() : min;\n      max = in.getIndex() > max ? in.getIndex() : max;\n    }\n    IndexedWord[] nodes = new IndexedWord[max - min >= 0 ? max - min + 1 : 0];\n    for(CoreMapProtos.DependencyGraph.Node in: proto.getNodeList()){\n      CoreLabel token = sentence.get(in.getIndex() - 1); // index starts at 1!\n      IndexedWord word = new IndexedWord(docid, in.getSentenceIndex(), in.getIndex(), token);\n      word.set(ValueAnnotation.class, word.get(TextAnnotation.class));\n      if(in.hasCopyAnnotation()){ word.set(CopyAnnotation.class, in.getCopyAnnotation()); }\n      assert in.getIndex() == word.index();\n      nodes[in.getIndex() - min] = word;\n    }\n    for (IndexedWord node : nodes) {\n      if (node != null) { graph.addVertex(node); }\n    }\n\n    // add all edges to the actual graph\n    for(CoreMapProtos.DependencyGraph.Edge ie: proto.getEdgeList()){\n      IndexedWord source = nodes[ie.getSource() - min];\n      assert(source != null);\n      IndexedWord target = nodes[ie.getTarget() - min];\n      assert(target != null);\n      synchronized (globalLock) {\n        // this is not thread-safe: there are static fields in GrammaticalRelation\n        assert ie.hasDep();\n        GrammaticalRelation rel = GrammaticalRelation.valueOf(ie.getDep());\n        graph.addEdge(source, target, rel, 1.0, ie.hasIsExtra() && ie.getIsExtra());\n      }\n    }\n\n    if (proto.getRootCount() > 0) {\n      Collection<IndexedWord> roots = new ArrayList<IndexedWord>();\n      for(int rootI : proto.getRootList()){\n        roots.add(nodes[rootI]);\n      }\n      graph.setRoots(roots);\n    } else {\n      // Roots were not saved away\n      // compute root nodes if non-empty\n      if(!graph.isEmpty()){\n        graph.resetRoots();\n      }\n    }\n    return graph;\n  }\n",
    "new_code_raw": "  private static SemanticGraph fromProto(CoreNLPProtos.DependencyGraph proto, List<CoreLabel> sentence, String docid) {\n    SemanticGraph graph = new SemanticGraph();\n\n    // first construct the actual nodes; keep them indexed by their index\n    // This block is optimized as one of the places which take noticeable time\n    // in datum caching\n    int min = Integer.MAX_VALUE;\n    int max = Integer.MIN_VALUE;\n    for(CoreNLPProtos.DependencyGraph.Node in: proto.getNodeList()){\n      min = in.getIndex() < min ? in.getIndex() : min;\n      max = in.getIndex() > max ? in.getIndex() : max;\n    }\n    IndexedWord[] nodes = new IndexedWord[max - min >= 0 ? max - min + 1 : 0];\n    for(CoreNLPProtos.DependencyGraph.Node in: proto.getNodeList()){\n      CoreLabel token = sentence.get(in.getIndex() - 1); // index starts at 1!\n      IndexedWord word = new IndexedWord(docid, in.getSentenceIndex(), in.getIndex(), token);\n      word.set(ValueAnnotation.class, word.get(TextAnnotation.class));\n      if(in.hasCopyAnnotation()){ word.set(CopyAnnotation.class, in.getCopyAnnotation()); }\n      assert in.getIndex() == word.index();\n      nodes[in.getIndex() - min] = word;\n    }\n    for (IndexedWord node : nodes) {\n      if (node != null) { graph.addVertex(node); }\n    }\n\n    // add all edges to the actual graph\n    for(CoreNLPProtos.DependencyGraph.Edge ie: proto.getEdgeList()){\n      IndexedWord source = nodes[ie.getSource() - min];\n      assert(source != null);\n      IndexedWord target = nodes[ie.getTarget() - min];\n      assert(target != null);\n      synchronized (globalLock) {\n        // this is not thread-safe: there are static fields in GrammaticalRelation\n        assert ie.hasDep();\n        GrammaticalRelation rel = GrammaticalRelation.valueOf(ie.getDep());\n        graph.addEdge(source, target, rel, 1.0, ie.hasIsExtra() && ie.getIsExtra());\n      }\n    }\n\n    if (proto.getRootCount() > 0) {\n      Collection<IndexedWord> roots = new ArrayList<IndexedWord>();\n      for(int rootI : proto.getRootList()){\n        roots.add(nodes[rootI - min]);\n      }\n      graph.setRoots(roots);\n    } else {\n      // Roots were not saved away\n      // compute root nodes if non-empty\n      if(!graph.isEmpty()){\n        graph.resetRoots();\n      }\n    }\n    return graph;\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1570-Param-1",
    "old_comment_raw": "@param lazyAvailable Is property lazy loading currently available.",
    "old_code_raw": "\tpublic static StandardProperty buildStandardProperty(Property property, boolean lazyAvailable) {\n\t\t\n\t\tfinal Type type = property.getValue().getType();\n\t\t\n\t\t// we need to dirty check collections, since they can cause an owner\n\t\t// version number increment\n\t\t\n\t\t// we need to dirty check many-to-ones with not-found=\"ignore\" in order \n\t\t// to update the cache (not the database), since in this case a null\n\t\t// entity reference can lose information\n\t\t\n\t\tboolean alwaysDirtyCheck = type.isAssociationType() && \n\t\t\t\t( (AssociationType) type ).isAlwaysDirtyChecked(); \n\n\t\treturn new StandardProperty(\n\t\t\t\tproperty.getName(),\n\t\t\t\tproperty.getNodeName(),\n\t\t\t\ttype,\n\t\t\t\tlazyAvailable && property.isLazy(),\n\t\t\t\tproperty.isInsertable(),\n\t\t\t\tproperty.isUpdateable(),\n\t\t        property.getGeneration() == PropertyGeneration.INSERT || property.getGeneration() == PropertyGeneration.ALWAYS,\n\t\t\t\tproperty.getGeneration() == PropertyGeneration.ALWAYS,\n\t\t\t\tproperty.isOptional(),\n\t\t\t\talwaysDirtyCheck || property.isUpdateable(),\n\t\t\t\tproperty.isOptimisticLocked(),\n\t\t\t\tproperty.getCascadeStyle(),\n\t\t        property.getValue().getFetchMode()\n\t\t\t);\n\t}\n",
    "new_code_raw": "\tpublic static StandardProperty buildStandardProperty(AttributeBinding property, boolean lazyAvailable) {\n\n\t\tfinal Type type = property.getHibernateTypeDescriptor().getExplicitType();\n\n\t\t// we need to dirty check collections, since they can cause an owner\n\t\t// version number increment\n\n\t\t// we need to dirty check many-to-ones with not-found=\"ignore\" in order\n\t\t// to update the cache (not the database), since in this case a null\n\t\t// entity reference can lose information\n\n\t\tboolean alwaysDirtyCheck = type.isAssociationType() &&\n\t\t\t\t( (AssociationType) type ).isAlwaysDirtyChecked();\n\n\t\tif ( property.isSimpleValue() ) {\n\t\t\tSimpleAttributeBinding simpleProperty = ( SimpleAttributeBinding ) property;\n\t\t\treturn new StandardProperty(\n\t\t\t\t\tsimpleProperty.getAttribute().getName(),\n\t\t\t\t\tsimpleProperty.getNodeName(),\n\t\t\t\t\ttype,\n\t\t\t\t\tlazyAvailable && simpleProperty.isLazy(),\n\t\t\t\t\tsimpleProperty.isInsertable(),\n\t\t\t\t\tsimpleProperty.isUpdatable(),\n\t\t\t\t\tsimpleProperty.getGeneration() == PropertyGeneration.INSERT || simpleProperty.getGeneration() == PropertyGeneration.ALWAYS,\n\t\t\t\t\tsimpleProperty.getGeneration() == PropertyGeneration.ALWAYS,\n\t\t\t\t\tsimpleProperty.isNullable(),\n\t\t\t\t\talwaysDirtyCheck || simpleProperty.isUpdatable(),\n\t\t\t\t\tsimpleProperty.isOptimisticLockable(),\n\t\t\t\t\t// TODO: get cascadeStyle from simpleProperty when HHH-6355 is fixed; for now, assume NONE\n\t\t\t\t\t//simpleProperty.getCascadeStyle(),\n\t\t\t\t\tCascadeStyle.NONE,\n\t\t\t\t\t// TODO: get fetchMode() from simpleProperty when HHH-6357 is fixed; for now, assume FetchMode.DEFAULT\n\t\t\t\t\t//simpleProperty.getFetchMode()\n\t\t\t\t\tFetchMode.DEFAULT\n\t\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tPluralAttributeBinding pluralProperty = ( PluralAttributeBinding ) property;\n\n\t\t\treturn new StandardProperty(\n\t\t\t\t\tpluralProperty.getAttribute().getName(),\n\t\t\t\t\tpluralProperty.getNodeName(),\n\t\t\t\t\ttype,\n\t\t\t\t\tlazyAvailable && pluralProperty.isLazy(),\n\t\t\t\t\t// TODO: fix this when HHH-6356 is fixed; for now assume PluralAttributeBinding is updatable and insertable\n\t\t\t\t\t// pluralProperty.isInsertable(),\n\t\t\t\t\t//pluralProperty.isUpdatable(),\n\t\t\t\t\ttrue,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse,\n\t\t\t\t\tfalse,\n\t\t\t\t\tpluralProperty.isNullable(),\n\t\t\t\t\t// TODO: fix this when HHH-6356 is fixed; for now assume PluralAttributeBinding is updatable and insertable\n\t\t\t\t\t//alwaysDirtyCheck || pluralProperty.isUpdatable(),\n\t\t\t\t\ttrue,\n\t\t\t\t\tpluralProperty.isOptimisticLocked(),\n\t\t\t\t\t// TODO: get cascadeStyle from property when HHH-6355 is fixed; for now, assume NONE\n\t\t\t\t\t//pluralProperty.getCascadeStyle(),\n\t\t\t\t\tCascadeStyle.NONE,\n\t\t\t\t\t// TODO: get fetchMode() from simpleProperty when HHH-6357 is fixed; for now, assume FetchMode.DEFAULT\n\t\t\t\t\t//pluralProperty.getFetchMode()\n\t\t\t\t\tFetchMode.DEFAULT\n\t\t\t\t);\n\t\t}\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1707-Param-0",
    "old_comment_raw": "@param client client model (required)",
    "old_code_raw": "    public Client call123testSpecialTags(Client client) throws ApiException {\n        ApiResponse<Client> resp = call123testSpecialTagsWithHttpInfo(client);\n        return resp.getData();\n    }\n",
    "new_code_raw": "    public Client call123testSpecialTags(Client body) throws ApiException {\n        ApiResponse<Client> resp = call123testSpecialTagsWithHttpInfo(body);\n        return resp.getData();\n    }\n"
  },
  {
    "id": "querydsl_querydsl-1434-Param-0",
    "old_comment_raw": "@param left",
    "old_code_raw": "    public static EBoolean endsWith(Expr<String> left, Expr<String> right, boolean caseSensitive) {\n        if (caseSensitive){\n            return endsWith(left, right);            \n        }else{\n            return operationFactory.createBoolean(Ops.ENDSWITH_IC, left, right);\n        }\n    }\n",
    "new_code_raw": "    public static EBoolean endsWith(Expr<String> left, Expr<String> right) {\n        return operationFactory.createBoolean(Ops.ENDSWITH, left, right);\n    }\n"
  },
  {
    "id": "SeleniumHQ_selenium-84-Param-0",
    "old_comment_raw": "@param inputString the input browser string",
    "old_code_raw": "    private String validateBrowserString(String inputString) throws IllegalArgumentException {\n        String browserString = inputString;\n        if (SeleniumServer.getForcedBrowserMode() != null) {\n            browserString = SeleniumServer.getForcedBrowserMode();\n            log.info(\"overriding browser mode w/ forced browser mode setting: \" + browserString);\n        }\n        if (SeleniumServer.isProxyInjectionMode() && browserString.equals(\"*iexplore\")) {\n            log.warn(\"running in proxy injection mode, but you used a *iexplore browser string; this is \" +\n                    \"almost surely inappropriate, so I'm changing it to *piiexplore...\");\n            browserString = \"*piiexplore\";\n        } else if (SeleniumServer.isProxyInjectionMode() && browserString.equals(\"*firefox\")) {\n            log.warn(\"running in proxy injection mode, but you used a *firefox browser string; this is \" +\n                    \"almost surely inappropriate, so I'm changing it to *pifirefox...\");\n            browserString = \"*pifirefox\";\n        }\n\n        if (null == browserString) {\n            throw new IllegalArgumentException(\"browser string may not be null\");\n        }\n        return browserString;\n    }\n",
    "new_code_raw": "    private String validateBrowserString(String inputString, RemoteControlConfiguration configuration) throws IllegalArgumentException {\n        String browserString = inputString;\n        if (configuration.getForcedBrowserMode() != null) {\n            browserString = configuration.getForcedBrowserMode();\n            log.info(\"overriding browser mode w/ forced browser mode setting: \" + browserString);\n        }\n        if (SeleniumServer.isProxyInjectionMode() && browserString.equals(\"*iexplore\")) {\n            log.warn(\"running in proxy injection mode, but you used a *iexplore browser string; this is \" +\n                    \"almost surely inappropriate, so I'm changing it to *piiexplore...\");\n            browserString = \"*piiexplore\";\n        } else if (SeleniumServer.isProxyInjectionMode() && browserString.equals(\"*firefox\")) {\n            log.warn(\"running in proxy injection mode, but you used a *firefox browser string; this is \" +\n                    \"almost surely inappropriate, so I'm changing it to *pifirefox...\");\n            browserString = \"*pifirefox\";\n        }\n\n        if (null == browserString) {\n            throw new IllegalArgumentException(\"browser string may not be null\");\n        }\n        return browserString;\n    }\n"
  },
  {
    "id": "apache_drill-1527-Param-0",
    "old_comment_raw": "@param col",
    "old_code_raw": "  public Histogram getHistogram(String col) {\n    // Stats might not have materialized because of errors.\n    if (!materialized) {\n      return null;\n    }\n    final String upperCol = col.toUpperCase();\n    Histogram histogramCol = histogram.get(upperCol);\n    if (histogramCol == null) {\n      histogramCol = histogram.get(SchemaPath.getSimplePath(upperCol).toString());\n    }\n    return histogramCol;\n  }\n",
    "new_code_raw": "  public Histogram getHistogram(SchemaPath column) {\n    // Stats might not have materialized because of errors.\n    if (!materialized) {\n      return null;\n    }\n    return histogram.get(column);\n  }\n"
  },
  {
    "id": "Netflix_eureka-110-Param-0",
    "old_comment_raw": "@param apps the applications for which to compare this one.",
    "old_code_raw": "        public Pair(String item_1, String item_2) {\n            super();\n            this.item_1 = item_1;\n            this.item_2 = item_2;\n        }\n",
    "new_code_raw": "        public Pair(String item1, String item2) {\n            super();\n            this.item1 = item1;\n            this.item2 = item2;\n        }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2533-Param-0",
    "old_comment_raw": "@param p Swagger property object",
    "old_code_raw": "    public String toDefaultValue(Property p) {\n        if (p instanceof StringProperty) {\n            StringProperty dp = (StringProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\\\"\" + dp.getDefault() + \"\\\"\";\n            }\n        } else if (p instanceof BooleanProperty) {\n            BooleanProperty dp = (BooleanProperty) p;\n            if (dp.getDefault() != null) {\n                if (dp.getDefault().toString().equalsIgnoreCase(\"false\"))\n                    return \"@(NO)\";\n                else\n                    return \"@(YES)\";\n            }\n        } else if (p instanceof DateProperty) {\n            // TODO\n        } else if (p instanceof DateTimeProperty) {\n            // TODO\n        } else if (p instanceof DoubleProperty) {\n            DoubleProperty dp = (DoubleProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof FloatProperty) {\n            FloatProperty dp = (FloatProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof IntegerProperty) {\n            IntegerProperty dp = (IntegerProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof LongProperty) {\n            LongProperty dp = (LongProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        }\n\n        return null;\n    }\n",
    "new_code_raw": "    public String toDefaultValue(Schema p) {\n        if (ModelUtils.isDateSchema(p)) {\n            // TODO\n        } else if (ModelUtils.isDateTimeSchema(p)) {\n            // TODO\n        } else if (ModelUtils.isNumberSchema(p)) {\n            if (p.getDefault() != null) {\n                return \"@\" + p.getDefault().toString();\n            }\n        } else if (ModelUtils.isIntegerSchema(p)) {\n            if (p.getDefault() != null) {\n                return \"@\" + p.getDefault().toString();\n            }\n        } else if (ModelUtils.isStringSchema(p)) {\n            if (p.getDefault() != null) {\n                return \"@\\\"\" + (String) p.getDefault() + \"\\\"\";\n            }\n        } else if (ModelUtils.isBooleanSchema(p)) {\n            if (p.getDefault() != null) {\n                if (p.getDefault().toString().equalsIgnoreCase(\"false\"))\n                    return \"@(NO)\";\n                else\n                    return \"@(YES)\";\n            }\n        }\n\n        return null;\n    }\n"
  },
  {
    "id": "HoraApps_LeafPic-11-Param-0",
    "old_comment_raw": "@param preferenceId the id of the shared preference.",
    "old_code_raw": "  public static Uri getSharedPreferenceUri(final int preferenceId) {\n\tString uriString = getSharedPreferences().getString(MyApplication.getContext().getString(preferenceId),\n\tnull);\n\n\tif (uriString == null) {\n\t  return null;\n\t}\n\telse {\n\t  return Uri.parse(uriString);\n\t}\n  }\n",
    "new_code_raw": "  private static Uri getSharedPreferenceUri(Context context , int preferenceId) {\n\tString uriString = getSharedPreferences(context).getString(context.getString(preferenceId), null);\n\n\tif (uriString == null) return null;\n\treturn Uri.parse(uriString);\n  }\n"
  },
  {
    "id": "mukteshkrmishra_javasimon-58-Associations-Param0",
    "old_comment_raw": "@param pattern Simon name pattern (see  SimonPattern",
    "old_code_raw": "\tpublic static Collection<Simon> getSimons(SimonPattern pattern) {\n\t\treturn manager.getSimons(pattern);\n\t}\n",
    "new_code_raw": "\tpublic static Collection<Simon> getSimons(SimonFilter simonFilter) {\n\t\treturn manager.getSimons(simonFilter);\n\t}\n\n"
  },
  {
    "id": "debezium_debezium-265-Param-1",
    "old_comment_raw": "@param useconds the commit time (in microseconds since epoch) of the transaction that generated the event; may be null indicating that this information is not available",
    "old_code_raw": "    protected SourceInfo update(Long lsn, Long useconds, Integer txId) {\n        this.lsn = lsn;\n        this.useconds = useconds;\n        this.txId = txId;\n        return this;\n    }\n",
    "new_code_raw": "    protected SourceInfo update(Long lsn, Long useconds, Long txId) {\n        this.lsn = lsn;\n        this.useconds = useconds;\n        this.txId = txId;\n        return this;\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-436-Param-0",
    "old_comment_raw": "@param millis the time instant in millis to update.",
    "old_code_raw": "    public long set(long millis, int year) {\n        super.verifyValueBounds(Math.abs(year),\n                                iChronology.getMinYear(), iChronology.getMaxYear());\n        //\n        // Do nothing if no real change is requested.\n        //\n        int thisWeekyear = get( millis );\n        if ( thisWeekyear == year ) {\n            return millis;\n        }\n        //\n        // Calculate the DayOfWeek (to be preserved).\n        //\n        int thisDow = iChronology.dayOfWeek().get( millis );\n        //\n        // Calculate the maximum weeks in the target year.\n        //\n        int weeksInFromYear = iChronology.getWeeksInYear( thisWeekyear );\n        int weeksInToYear = iChronology.getWeeksInYear( year );\n        int maxOutWeeks = (weeksInToYear < weeksInFromYear) ?\n            weeksInToYear : weeksInFromYear;\n        //\n        // Get the current week of the year. This will be preserved in\n        // the output unless it is greater than the maximum possible\n        // for the target weekyear.  In that case it is adjusted\n        // to the maximum possible.\n        //\n        int setToWeek = iChronology.weekOfWeekyear().get( millis );\n        if ( setToWeek > maxOutWeeks ) {\n            setToWeek = maxOutWeeks;\n        }\n        //\n        // Get a wroking copy of the current date-time.\n        // This can be a convenience for debugging.\n        //\n        long workMillis = millis; // Get a copy\n        //\n        // Attempt to get close to the proper weekyear.\n        // Note - we cannot currently call ourself, so we just call\n        // set for the year.  This at least gets us close.\n        //\n        workMillis = iChronology.year().set( workMillis, year );\n        //\n        // Calculate the weekyear number for the get close to value\n        // (which might not be equal to the year just set).\n        //\n        int workWoyYear = iChronology.weekyear().get( workMillis );\n\n        // *TEMP Debugging\n        /*\n        MutableDateTime temp = new MutableDateTime(workMillis,\n            ISOChronology.getInstance());\n        System.out.println(\"Current mdt value 01: \"\n            + temp\n            + \" \" + workWoyYear\n        );\n        System.out.println(\"->Temp: \" + temp.toString()\n            + \" WOYYr=\" + temp.getWeekyear()\n            + \" WOYWk=\" + temp.getWeekOfWeekyear()\n            + \" DoW=\" + temp.getDayOfWeek()\n        );\n        */\n\n        //\n        // At most we are off by one year, which can be \"fixed\" by\n        // adding/subtracting a week.\n        //\n        if ( workWoyYear < year ) {\n            // System.out.println(\"Year: Adding \"+workWoyYear+\" \"+year);\n            workMillis += DateTimeConstants.MILLIS_PER_WEEK;\n        } else if ( workWoyYear > year ) {\n            // System.out.println(\"Year: Subing \"+workWoyYear+\" \"+year);\n            workMillis -= DateTimeConstants.MILLIS_PER_WEEK;\n        }\n        //\n        // Set the proper week in the current weekyear.\n        //\n\n        // BEGIN: possible set WeekOfWeekyear logic.\n        int currentWoyWeek = iChronology.weekOfWeekyear().get( workMillis );\n        // No range check required (we already know it is OK).\n        workMillis = workMillis + (setToWeek - currentWoyWeek)\n            * (long)DateTimeConstants.MILLIS_PER_WEEK;\n        // END: possible set WeekOfWeekyear logic.\n\n        //\n        // Reset DayOfWeek to previous value.\n        //\n        workMillis = iChronology.dayOfWeek().set( workMillis, thisDow );\n        //\n        // Return result.\n        //\n        return workMillis;\n    }\n",
    "new_code_raw": "    public long set(long instant, int year) {\n        Utils.verifyValueBounds(this, Math.abs(year),\n                                iChronology.getMinYear(), iChronology.getMaxYear());\n        //\n        // Do nothing if no real change is requested.\n        //\n        int thisWeekyear = get( instant );\n        if ( thisWeekyear == year ) {\n            return instant;\n        }\n        //\n        // Calculate the DayOfWeek (to be preserved).\n        //\n        int thisDow = iChronology.dayOfWeek().get( instant );\n        //\n        // Calculate the maximum weeks in the target year.\n        //\n        int weeksInFromYear = iChronology.getWeeksInYear( thisWeekyear );\n        int weeksInToYear = iChronology.getWeeksInYear( year );\n        int maxOutWeeks = (weeksInToYear < weeksInFromYear) ?\n            weeksInToYear : weeksInFromYear;\n        //\n        // Get the current week of the year. This will be preserved in\n        // the output unless it is greater than the maximum possible\n        // for the target weekyear.  In that case it is adjusted\n        // to the maximum possible.\n        //\n        int setToWeek = iChronology.weekOfWeekyear().get( instant );\n        if ( setToWeek > maxOutWeeks ) {\n            setToWeek = maxOutWeeks;\n        }\n        //\n        // Get a wroking copy of the current date-time.\n        // This can be a convenience for debugging.\n        //\n        long workInstant = instant; // Get a copy\n        //\n        // Attempt to get close to the proper weekyear.\n        // Note - we cannot currently call ourself, so we just call\n        // set for the year.  This at least gets us close.\n        //\n        workInstant = iChronology.year().set( workInstant, year );\n        //\n        // Calculate the weekyear number for the get close to value\n        // (which might not be equal to the year just set).\n        //\n        int workWoyYear = iChronology.weekyear().get( workInstant );\n\n        //\n        // At most we are off by one year, which can be \"fixed\" by\n        // adding/subtracting a week.\n        //\n        if ( workWoyYear < year ) {\n            workInstant += DateTimeConstants.MILLIS_PER_WEEK;\n        } else if ( workWoyYear > year ) {\n            workInstant -= DateTimeConstants.MILLIS_PER_WEEK;\n        }\n        //\n        // Set the proper week in the current weekyear.\n        //\n\n        // BEGIN: possible set WeekOfWeekyear logic.\n        int currentWoyWeek = iChronology.weekOfWeekyear().get( workInstant );\n        // No range check required (we already know it is OK).\n        workInstant = workInstant + (setToWeek - currentWoyWeek)\n            * (long)DateTimeConstants.MILLIS_PER_WEEK;\n        // END: possible set WeekOfWeekyear logic.\n\n        //\n        // Reset DayOfWeek to previous value.\n        //\n        workInstant = iChronology.dayOfWeek().set( workInstant, thisDow );\n        //\n        // Return result.\n        //\n        return workInstant;\n    }\n"
  },
  {
    "id": "apache_drill-1040-Param-1",
    "old_comment_raw": "@param colProj metadata description of the list which must contain exactly one subtype",
    "old_code_raw": "  private ColumnState buildSimpleList(ContainerState parent, ColumnReadProjection colProj) {\n    ColumnMetadata columnSchema = colProj.providedSchema();\n\n    // The variant must have the one and only type.\n\n    assert columnSchema.variantSchema().size() == 1;\n    assert columnSchema.variantSchema().isSimple();\n\n    // Create the manager for the one and only column within the list.\n\n    final ListState listState = new ListState(parent.loader(),\n        parent.vectorCache().childCache(columnSchema.name()));\n\n    // Create the child vector, writer and state.\n\n    final ColumnMetadata memberSchema = columnSchema.variantSchema().listSubtype();\n    final ColumnState memberState = buildColumn(listState, memberSchema);\n    listState.setSubColumn(memberState);\n\n    // Create the list vector. Contains a single type.\n\n    final ListVector listVector = new ListVector(columnSchema.schema().cloneEmpty(),\n        parent.loader().allocator(), null);\n    listVector.setChildVector(memberState.vector());\n\n    // Create the list writer: an array of the one type.\n\n    final ListWriterImpl listWriter = new ListWriterImpl(columnSchema,\n        listVector, memberState.writer());\n    final AbstractObjectWriter listObjWriter = new ArrayObjectWriter(listWriter);\n\n    // Create the list vector state that tracks the list vector lifecycle.\n\n    final ListVectorState vectorState = new ListVectorState(listWriter,\n        memberState.writer().events(), listVector);\n\n    // Assemble it all into a union column state.\n\n    return new UnionColumnState(parent.loader(),\n        listObjWriter, vectorState, listState);\n  }\n",
    "new_code_raw": "  private ColumnState buildSimpleList(ContainerState parent, ColumnMetadata columnSchema) {\n\n    // The variant must have the one and only type.\n    assert columnSchema.variantSchema().size() == 1;\n    assert columnSchema.variantSchema().isSimple();\n\n    // Create the manager for the one and only column within the list.\n    final ListState listState = new ListState(parent.loader(),\n        parent.vectorCache().childCache(columnSchema.name()));\n\n    // Create the child vector, writer and state.\n    final ColumnMetadata memberSchema = columnSchema.variantSchema().listSubtype();\n    final ColumnState memberState = buildColumn(listState, memberSchema);\n    listState.setSubColumn(memberState);\n\n    // Create the list vector. Contains a single type.\n    final ListVector listVector = new ListVector(columnSchema.schema().cloneEmpty(),\n        parent.loader().allocator(), null);\n    listVector.setChildVector(memberState.vector());\n\n    // Create the list writer: an array of the one type.\n    final ListWriterImpl listWriter = new ListWriterImpl(columnSchema,\n        listVector, memberState.writer());\n    final AbstractObjectWriter listObjWriter = new ArrayObjectWriter(listWriter);\n\n    // Create the list vector state that tracks the list vector lifecycle.\n    final ListVectorState vectorState = new ListVectorState(listWriter,\n        memberState.writer().events(), listVector);\n\n    // Assemble it all into a union column state.\n    return new UnionColumnState(parent.loader(),\n        listObjWriter, vectorState, listState);\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-1101-Param-1",
    "old_comment_raw": "@param totalMillisMaster true if total millis based duration",
    "old_code_raw": "    public DurationType getDurationType(Object object, boolean totalMillisMaster) {\n        if (totalMillisMaster) {\n            return DurationType.getPreciseAllType();\n        }\n        return DurationType.getAllType();\n    }\n",
    "new_code_raw": "    public DurationType getDurationType(Object object, boolean precise) {\n        if (precise) {\n            return DurationType.getPreciseAllType();\n        }\n        return DurationType.getAllType();\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1945-Param-1",
    "old_comment_raw": "@param entityName Entity name.",
    "old_code_raw": "\tprotected EntityInfo getEntityInfo(AuditConfiguration verCfg, String entityName) {\n\t\tEntityConfiguration entCfg = verCfg.getEntCfg().get( entityName );\n\t\tboolean isRelationAudited = true;\n\t\tif ( entCfg == null ) {\n\t\t\t// a relation marked as RelationTargetAuditMode.NOT_AUDITED\n\t\t\tentCfg = verCfg.getEntCfg().getNotVersionEntityConfiguration( entityName );\n\t\t\tisRelationAudited = false;\n\t\t}\n\t\tfinal Class entityClass = ReflectionTools.loadClass( entCfg.getEntityClassName(), verCfg.getClassLoaderService() );\n\t\treturn new EntityInfo( entityClass, entityName, isRelationAudited );\n\t}\n",
    "new_code_raw": "\tprotected EntityInfo getEntityInfo(EnversService enversService, String entityName) {\n\t\tEntityConfiguration entCfg = enversService.getEntitiesConfigurations().get( entityName );\n\t\tboolean isRelationAudited = true;\n\t\tif ( entCfg == null ) {\n\t\t\t// a relation marked as RelationTargetAuditMode.NOT_AUDITED\n\t\t\tentCfg = enversService.getEntitiesConfigurations().getNotVersionEntityConfiguration( entityName );\n\t\t\tisRelationAudited = false;\n\t\t}\n\t\tfinal Class entityClass = ReflectionTools.loadClass( entCfg.getEntityClassName(), enversService.getClassLoaderService() );\n\t\treturn new EntityInfo( entityClass, entityName, isRelationAudited );\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2607-Param-0",
    "old_comment_raw": "@param client client model (required)",
    "old_code_raw": "  public Client testClientModel(Client client) throws ApiException {\n    return testClientModelWithHttpInfo(client).getData();\n      }\n",
    "new_code_raw": "  public Client testClientModel(Client body) throws ApiException {\n    return testClientModelWithHttpInfo(body).getData();\n      }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-203-Param-3",
    "old_comment_raw": "@param body The request body object",
    "old_code_raw": "  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n",
    "new_code_raw": "  public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-435-Param-0",
    "old_comment_raw": "@param millis the time instant in millis to update.",
    "old_code_raw": "    public long addWrapped(long millis, int years) {\n        return add(millis, years);\n    }\n",
    "new_code_raw": "    public long addWrapped(long instant, int years) {\n        return add(instant, years);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-324-Param-8",
    "old_comment_raw": "@param authNames The authentications to apply",
    "old_code_raw": "  public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n",
    "new_code_raw": "  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n"
  },
  {
    "id": "dropwizard_dropwizard-34-Associations-Param0",
    "old_comment_raw": "@param name the servlet's name",
    "old_code_raw": "    public ServletRegistration.Dynamic addServlet(String name, Servlet servlet) {\n        final ServletHolder holder = new NonblockingServletHolder(checkNotNull(servlet));\n        holder.setName(name);\n        handler.getServletHandler().addServlet(holder);\n        return holder.getRegistration();\n    }\n",
    "new_code_raw": "    public ServletBuilder addServlet(Servlet servlet,\n                                     String urlPattern) {\n        final ServletHolder holder = new NonblockingServletHolder(checkNotNull(servlet));\n        final ServletBuilder builder = new ServletBuilder(holder, handler);\n        builder.addUrlPattern(checkNotNull(urlPattern));\n        return builder;\n    }\n\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-1766-Param-0",
    "old_comment_raw": "@param tofind array you want to find in tokens",
    "old_code_raw": "  public static List<Integer> getSubListIndex(Object[] tofind, Object[] tokens, Function<Pair, Boolean> matchingFunction){\n    if(tofind.length > tokens.length)\n      return null;\n    List<Integer> allIndices = new ArrayList<>();\n    boolean matched = false;\n    int index = -1;\n    int lastUnmatchedIndex = 0;\n    for(int i = 0 ; i < tokens.length;){\n      for(int j = 0; j < tofind.length ;){\n        if(matchingFunction.apply(new Pair(tofind[j], tokens[i]))){\n          index = i;\n          i++;\n          j++;\n          if(j == tofind.length)\n          {\n            matched = true;\n            break;\n          }\n        }else{\n          j = 0;\n          i = lastUnmatchedIndex +1;\n          lastUnmatchedIndex = i;\n          index = -1;\n          if(lastUnmatchedIndex == tokens.length)\n            break;\n        }\n        if(i >= tokens.length){\n          index = -1;\n          break;\n        }\n      }\n      if(i == tokens.length || matched){\n        if(index >= 0)\n          //index = index - l1.length + 1;\n          allIndices.add(index - tofind.length + 1);\n        matched = false;\n        lastUnmatchedIndex = index;\n\n        //break;\n      }\n    }\n    //get starting point\n\n    return allIndices;\n  }\n",
    "new_code_raw": "  public static List<Integer> getSubListIndex(Object[] tofind, Object[] tokens, Predicate<Pair> matchingFunction){\n    if(tofind.length > tokens.length)\n      return null;\n    List<Integer> allIndices = new ArrayList<>();\n    boolean matched = false;\n    int index = -1;\n    int lastUnmatchedIndex = 0;\n    for(int i = 0 ; i < tokens.length;){\n      for(int j = 0; j < tofind.length ;){\n        if(matchingFunction.test(new Pair(tofind[j], tokens[i]))){\n          index = i;\n          i++;\n          j++;\n          if(j == tofind.length)\n          {\n            matched = true;\n            break;\n          }\n        }else{\n          j = 0;\n          i = lastUnmatchedIndex +1;\n          lastUnmatchedIndex = i;\n          index = -1;\n          if(lastUnmatchedIndex == tokens.length)\n            break;\n        }\n        if(i >= tokens.length){\n          index = -1;\n          break;\n        }\n      }\n      if(i == tokens.length || matched){\n        if(index >= 0)\n          //index = index - l1.length + 1;\n          allIndices.add(index - tofind.length + 1);\n        matched = false;\n        lastUnmatchedIndex = index;\n\n        //break;\n      }\n    }\n    //get starting point\n\n    return allIndices;\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1706-Param-0",
    "old_comment_raw": "@param outerComposite Input composite as post body (optional)",
    "old_code_raw": "  public ApiResponse<OuterComposite> fakeOuterCompositeSerializeWithHttpInfo(OuterComposite outerComposite) throws ApiException {\n    Object localVarPostBody = outerComposite;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/composite\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"*/*\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public ApiResponse<OuterComposite> fakeOuterCompositeSerializeWithHttpInfo(OuterComposite body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/composite\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"*/*\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-707-Param-1",
    "old_comment_raw": "@param _double None (required)",
    "old_code_raw": "  public ApiResponse<Void> testEndpointParametersWithHttpInfo(String number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password) throws ApiException {\n    Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, null, null);\n    return apiClient.execute(call);\n  }\n",
    "new_code_raw": "  public ApiResponse<Void> testEndpointParametersWithHttpInfo(BigDecimal number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password) throws ApiException {\n    Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, null, null);\n    return apiClient.execute(call);\n  }\n"
  },
  {
    "id": "Atmosphere_atmosphere-864-Param-0",
    "old_comment_raw": "@param message an instance of  Message",
    "old_code_raw": "    public Message onMessage(Message message) throws IOException {\n\n        if (!users.contains(message.getAuthor())) {\n            users.add(message.getAuthor());\n            return new Message(message.getAuthor(), \" entered room \" + chatroomName);\n        }\n\n        logger.info(\"{} just send {}\", message.getAuthor(), message.getMessage());\n        return message;\n    }\n",
    "new_code_raw": "    public ChatProtocol onMessage(ChatProtocol message) throws IOException {\n\n        if (!users.containsKey(message.getAuthor())) {\n            users.put(message.getAuthor(), message.getUuid());\n            return new ChatProtocol(message.getAuthor(), \" entered room \" + chatroomName, users.keySet(), factory.lookupAll());\n        }\n\n        if (message.getMessage().contains(\"disconnecting\")) {\n            users.remove(message.getAuthor());\n            return new ChatProtocol(message.getAuthor(), \" disconnected from room \" + chatroomName, users.keySet(), factory.lookupAll());\n        }\n\n        message.setUsers(users.keySet());\n        logger.info(\"{} just send {}\", message.getAuthor(), message.getMessage());\n        return message;\n    }\n"
  },
  {
    "id": "LawnchairLauncher_Lawnchair-258-Param-4",
    "old_comment_raw": "@param preScaledWidthOut return the width of the returned bitmap",
    "old_code_raw": "    private RectF drawBoxWithShadow(Canvas c, Paint p, int width, int height) {\n        Resources res = mContext.getResources();\n        float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);\n        float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);\n        float corner = res.getDimension(R.dimen.widget_preview_corner_radius);\n\n        RectF bounds = new RectF(shadowBlur, shadowBlur,\n                width - shadowBlur, height - shadowBlur - keyShadowDistance);\n        p.setColor(Color.WHITE);\n\n        // Key shadow\n        p.setShadowLayer(shadowBlur, 0, keyShadowDistance,\n                ShadowGenerator.KEY_SHADOW_ALPHA << 24);\n        c.drawRoundRect(bounds, corner, corner, p);\n\n        // Ambient shadow\n        p.setShadowLayer(shadowBlur, 0, 0,\n                ColorUtils.setAlphaComponent(Color.BLACK, ShadowGenerator.AMBIENT_SHADOW_ALPHA));\n        c.drawRoundRect(bounds, corner, corner, p);\n\n        p.clearShadowLayer();\n        return bounds;\n    }\n",
    "new_code_raw": "    private RectF drawBoxWithShadow(Canvas c, int width, int height) {\n        Resources res = mContext.getResources();\n        float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);\n        float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);\n        float corner = res.getDimension(R.dimen.widget_preview_corner_radius);\n\n        RectF bounds = new RectF(shadowBlur, shadowBlur,\n                width - shadowBlur, height - shadowBlur - keyShadowDistance);\n        ShadowGenerator.drawShadow(c, bounds, Color.WHITE, shadowBlur, keyShadowDistance, corner);\n        return bounds;\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-1004-Param-0",
    "old_comment_raw": "@param search the string to be searched. The parameter will be interpreted as a regular expression.",
    "old_code_raw": "\tpublic boolean searchText(String search) {\n\t\tboolean found = searcher.searchText(search, 0, true);\n\t\treturn found;\n\t}\n",
    "new_code_raw": "\tpublic boolean searchText(String regex) {\n\t\tboolean found = searcher.searchText(regex, 0, true);\n\t\treturn found;\n\t}\n"
  },
  {
    "id": "RobotiumTech_robotium-1484-Param-1",
    "old_comment_raw": "@param scroll set to true if scrolling should be performed",
    "old_code_raw": "\tpublic boolean searchForEditText(String search, boolean scroll) {\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(search);\n\t\tMatcher matcher;\n\t\tArrayList<EditText> editTextList = viewFetcher.getCurrentViews(EditText.class);\n\t\tfor(EditText editText : editTextList){\n\t\t\tmatcher = p.matcher(editText.getText().toString());\n\t\t\tif (matcher.find()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (scroll && scroller.scroll(Scroller.Direction.DOWN))\n\t\t\treturn searchForEditText(search, scroll);\n\t\telse\n\t\t\treturn false;\n\t}\n",
    "new_code_raw": "\tpublic boolean searchForEditText(String regex, boolean scroll) {\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(regex);\n\t\tMatcher matcher;\n\t\tArrayList<EditText> editTextList = viewFetcher.getCurrentViews(EditText.class);\n\t\tfor(EditText editText : editTextList){\n\t\t\tmatcher = p.matcher(editText.getText().toString());\n\t\t\tif (matcher.find()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (scroll && scroller.scroll(Scroller.Direction.DOWN))\n\t\t\treturn searchForEditText(regex, scroll);\n\t\telse\n\t\t\treturn false;\n\t}\n"
  },
  {
    "id": "hibernate_hibernate_orm-1945-Param-0",
    "old_comment_raw": "@param verCfg Audit configuration.",
    "old_code_raw": "\tprotected EntityInfo getEntityInfo(AuditConfiguration verCfg, String entityName) {\n\t\tEntityConfiguration entCfg = verCfg.getEntCfg().get( entityName );\n\t\tboolean isRelationAudited = true;\n\t\tif ( entCfg == null ) {\n\t\t\t// a relation marked as RelationTargetAuditMode.NOT_AUDITED\n\t\t\tentCfg = verCfg.getEntCfg().getNotVersionEntityConfiguration( entityName );\n\t\t\tisRelationAudited = false;\n\t\t}\n\t\tfinal Class entityClass = ReflectionTools.loadClass( entCfg.getEntityClassName(), verCfg.getClassLoaderService() );\n\t\treturn new EntityInfo( entityClass, entityName, isRelationAudited );\n\t}\n",
    "new_code_raw": "\tprotected EntityInfo getEntityInfo(EnversService enversService, String entityName) {\n\t\tEntityConfiguration entCfg = enversService.getEntitiesConfigurations().get( entityName );\n\t\tboolean isRelationAudited = true;\n\t\tif ( entCfg == null ) {\n\t\t\t// a relation marked as RelationTargetAuditMode.NOT_AUDITED\n\t\t\tentCfg = enversService.getEntitiesConfigurations().getNotVersionEntityConfiguration( entityName );\n\t\t\tisRelationAudited = false;\n\t\t}\n\t\tfinal Class entityClass = ReflectionTools.loadClass( entCfg.getEntityClassName(), enversService.getClassLoaderService() );\n\t\treturn new EntityInfo( entityClass, entityName, isRelationAudited );\n\t}\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-1781-Param-1",
    "old_comment_raw": "@param verbose whether or not to output verbose information.",
    "old_code_raw": "  public QuoteAnnotator(Properties props, boolean verbose) {\n    USE_SINGLE = Boolean.parseBoolean(props.getProperty(\"singleQuotes\", \"false\"));\n    MAX_LENGTH = Integer.parseInt(props.getProperty(\"maxLength\", \"-1\"));\n    ASCII_QUOTES = Boolean.parseBoolean(props.getProperty(\"asciiQuotes\", \"false\"));\n    ALLOW_EMBEDDED_SAME = Boolean.parseBoolean(props.getProperty(\"allowEmbeddedSame\", \"false\"));\n    SMART_QUOTES = Boolean.parseBoolean(props.getProperty(\"smartQuotes\", \"false\"));\n    EXTRACT_UNCLOSED = Boolean.parseBoolean(props.getProperty(\"extractUnclosedQuotes\", \"false\"));\n    ATTRIBUTE_QUOTES = Boolean.parseBoolean(props.getProperty(\"attributeQuotes\", \"true\"));\n\n    VERBOSE = verbose;\n    Timing timer = null;\n    if (VERBOSE) {\n      timer = new Timing();\n      log.info(\"Preparing quote annotator...\");\n    }\n    if (ATTRIBUTE_QUOTES)\n      quoteAttributionAnnotator = new QuoteAttributionAnnotator(props);\n\n    if (VERBOSE) {\n      timer.stop(\"done.\");\n    }\n  }\n",
    "new_code_raw": "  public QuoteAnnotator(String name, Properties props, boolean verbose) {\n    USE_SINGLE = Boolean.parseBoolean(props.getProperty(name + \".\" + \"singleQuotes\", \"false\"));\n    MAX_LENGTH = Integer.parseInt(props.getProperty(name + \".\" + \"maxLength\", \"-1\"));\n    ASCII_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"asciiQuotes\", \"false\"));\n    ALLOW_EMBEDDED_SAME = Boolean.parseBoolean(props.getProperty(name + \".\" + \"allowEmbeddedSame\", \"false\"));\n    SMART_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"smartQuotes\", \"false\"));\n    EXTRACT_UNCLOSED = Boolean.parseBoolean(props.getProperty(name + \".\" + \"extractUnclosedQuotes\", \"false\"));\n    ATTRIBUTE_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"attributeQuotes\", \"true\"));\n\n    VERBOSE = verbose;\n    Timing timer = null;\n    if (VERBOSE) {\n      timer = new Timing();\n      log.info(\"Preparing quote annotator...\");\n    }\n    if (ATTRIBUTE_QUOTES)\n      quoteAttributionAnnotator = new QuoteAttributionAnnotator(props);\n\n    if (VERBOSE) {\n      timer.stop(\"done.\");\n    }\n  }\n"
  },
  {
    "id": "apache_jclouds-362-Associations-Param1",
    "old_comment_raw": "@param contextWrappableAs the contextWrappableAs to filter providers by",
    "old_code_raw": "   public static Iterable<ProviderMetadata> collocatedWith(ProviderMetadata providerMetadata,\n            TypeToken<? extends Wrapper> contextWrappableAs) {\n      return filter(all(), Predicates.and(ProviderPredicates.intersectingIso3166Code(providerMetadata),\n               ProviderPredicates.contextWrappableAs(contextWrappableAs)));\n   }\n",
    "new_code_raw": "   public static Iterable<ProviderMetadata<?, ?, ?, ?>> collocatedWith(ProviderMetadata<?, ?, ?, ?> providerMetadata,\n         ApiType type) {\n      return filter(all(),\n            Predicates.and(ProviderPredicates.intersectingIso3166Code(providerMetadata), ProviderPredicates.type(type)));\n   }\n\n"
  },
  {
    "id": "debezium_debezium-727-Param-0",
    "old_comment_raw": "@param before the state of the record before the update; may be null",
    "old_code_raw": "    public Struct update(Object before, Struct after, Struct source, Long timestamp) {\n        Struct struct = new Struct(schema);\n        struct.put(FieldName.OPERATION, Operation.UPDATE.code());\n        if (before != null) {\n            struct.put(FieldName.BEFORE, before);\n        }\n        struct.put(FieldName.AFTER, after);\n        if (source != null) {\n            struct.put(FieldName.SOURCE, source);\n        }\n        if (timestamp != null) {\n            struct.put(FieldName.TIMESTAMP, timestamp);\n        }\n        return struct;\n    }\n",
    "new_code_raw": "    public Struct update(Object before, Struct after, Struct source, Instant timestamp) {\n        Struct struct = new Struct(schema);\n        struct.put(FieldName.OPERATION, Operation.UPDATE.code());\n        if (before != null) {\n            struct.put(FieldName.BEFORE, before);\n        }\n        struct.put(FieldName.AFTER, after);\n        if (source != null) {\n            struct.put(FieldName.SOURCE, source);\n        }\n        if (timestamp != null) {\n            struct.put(FieldName.TIMESTAMP, timestamp.toEpochMilli());\n        }\n        return struct;\n    }\n"
  },
  {
    "id": "apache_calcite-885-Param-0",
    "old_comment_raw": "@param typeName Type to cast NULL to",
    "old_code_raw": "  public RexNode makeNullLiteral(SqlTypeName typeName) {\n    RelDataType type =\n        typeFactory.createTypeWithNullability(\n            typeFactory.createSqlType(typeName),\n            true);\n    return makeCast(type, constantNull());\n  }\n",
    "new_code_raw": "  public RexLiteral makeNullLiteral(RelDataType type) {\n    if (!type.isNullable()) {\n      type = typeFactory.createTypeWithNullability(type, true);\n    }\n    return (RexLiteral) makeCast(type, constantNull());\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-286-Param-0",
    "old_comment_raw": "@param path The sub-path of the HTTP URL",
    "old_code_raw": "  public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n",
    "new_code_raw": "  public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n"
  },
  {
    "id": "SeleniumHQ_selenium-177-Param-1",
    "old_comment_raw": "@param browserURL - the start URL for the browser",
    "old_code_raw": "    public String runHTMLSuite(String browser, String browserURL, String suiteURL, File outputFile, int timeoutInSeconds, boolean multiWindow) throws IOException {\n        return runHTMLSuite(browser, browserURL, suiteURL, outputFile,\n                timeoutInSeconds, multiWindow, \"info\");\n    }\n",
    "new_code_raw": "    public String runHTMLSuite(String browser, String browserURL, String suiteURL, File outputFile, long timeoutInSeconds, boolean multiWindow) throws IOException {\n        return runHTMLSuite(browser, browserURL, suiteURL, outputFile,\n                timeoutInSeconds, multiWindow, \"info\");\n    }\n"
  },
  {
    "id": "apache_calcite-278-Param-0",
    "old_comment_raw": "@param rel RelNode corresponding to the project",
    "old_code_raw": "  public static Double cardOfProjExpr(ProjectRelBase rel, RexNode expr) {\n    return expr.accept(new CardOfProjExpr(rel));\n  }\n",
    "new_code_raw": "  public static Double cardOfProjExpr(Project rel, RexNode expr) {\n    return expr.accept(new CardOfProjExpr(rel));\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2576-Param-0",
    "old_comment_raw": "@param body client model (required)",
    "old_code_raw": "  public Client testSpecialTags(Client body) throws ApiException {\n    return testSpecialTagsWithHttpInfo(body).getData();\n      }\n",
    "new_code_raw": "  public Client testSpecialTags(Client client) throws ApiException {\n    return testSpecialTagsWithHttpInfo(client).getData();\n      }\n"
  },
  {
    "id": "apache_calcite-942-Param-1",
    "old_comment_raw": "@param semiJoin the semijoin",
    "old_code_raw": "  private RexNode adjustCondition(ProjectRel project, SemiJoinRel semiJoin) {\n    // create two RexPrograms -- the bottom one representing a\n    // concatenation of the project and the RHS of the semijoin and the\n    // top one representing the semijoin condition\n\n    RexBuilder rexBuilder = project.getCluster().getRexBuilder();\n    RelDataTypeFactory typeFactory = rexBuilder.getTypeFactory();\n    RelNode rightChild = semiJoin.getRight();\n\n    // for the bottom RexProgram, the input is a concatenation of the\n    // child of the project and the RHS of the semijoin\n    RelDataType bottomInputRowType =\n        JoinRelBase.deriveJoinRowType(\n            project.getChild().getRowType(),\n            rightChild.getRowType(),\n            JoinRelType.INNER,\n            typeFactory,\n            null,\n            semiJoin.getSystemFieldList());\n    RexProgramBuilder bottomProgramBuilder =\n        new RexProgramBuilder(bottomInputRowType, rexBuilder);\n\n    // add the project expressions, then add input references for the RHS\n    // of the semijoin\n    for (Pair<RexNode, String> pair : project.getNamedProjects()) {\n      bottomProgramBuilder.addProject(pair.left, pair.right);\n    }\n    int nLeftFields = project.getChild().getRowType().getFieldCount();\n    List<RelDataTypeField> rightFields =\n        rightChild.getRowType().getFieldList();\n    int nRightFields = rightFields.size();\n    for (int i = 0; i < nRightFields; i++) {\n      final RelDataTypeField field = rightFields.get(i);\n      RexNode inputRef =\n          rexBuilder.makeInputRef(\n              field.getType(), i + nLeftFields);\n      bottomProgramBuilder.addProject(inputRef, field.getName());\n    }\n    RexProgram bottomProgram = bottomProgramBuilder.getProgram();\n\n    // input rowtype into the top program is the concatenation of the\n    // project and the RHS of the semijoin\n    RelDataType topInputRowType =\n        JoinRelBase.deriveJoinRowType(\n            project.getRowType(),\n            rightChild.getRowType(),\n            JoinRelType.INNER,\n            typeFactory,\n            null,\n            semiJoin.getSystemFieldList());\n    RexProgramBuilder topProgramBuilder =\n        new RexProgramBuilder(\n            topInputRowType,\n            rexBuilder);\n    topProgramBuilder.addIdentity();\n    topProgramBuilder.addCondition(semiJoin.getCondition());\n    RexProgram topProgram = topProgramBuilder.getProgram();\n\n    // merge the programs and expand out the local references to form\n    // the new semijoin condition; it now references a concatenation of\n    // the project's child and the RHS of the semijoin\n    RexProgram mergedProgram =\n        RexProgramBuilder.mergePrograms(\n            topProgram,\n            bottomProgram,\n            rexBuilder);\n\n    return mergedProgram.expandLocalRef(\n        mergedProgram.getCondition());\n  }\n",
    "new_code_raw": "  private RexNode adjustCondition(LogicalProject project, SemiJoin semiJoin) {\n    // create two RexPrograms -- the bottom one representing a\n    // concatenation of the project and the RHS of the semijoin and the\n    // top one representing the semijoin condition\n\n    RexBuilder rexBuilder = project.getCluster().getRexBuilder();\n    RelDataTypeFactory typeFactory = rexBuilder.getTypeFactory();\n    RelNode rightChild = semiJoin.getRight();\n\n    // for the bottom RexProgram, the input is a concatenation of the\n    // child of the project and the RHS of the semijoin\n    RelDataType bottomInputRowType =\n        Join.deriveJoinRowType(\n            project.getInput().getRowType(),\n            rightChild.getRowType(),\n            JoinRelType.INNER,\n            typeFactory,\n            null,\n            semiJoin.getSystemFieldList());\n    RexProgramBuilder bottomProgramBuilder =\n        new RexProgramBuilder(bottomInputRowType, rexBuilder);\n\n    // add the project expressions, then add input references for the RHS\n    // of the semijoin\n    for (Pair<RexNode, String> pair : project.getNamedProjects()) {\n      bottomProgramBuilder.addProject(pair.left, pair.right);\n    }\n    int nLeftFields = project.getInput().getRowType().getFieldCount();\n    List<RelDataTypeField> rightFields =\n        rightChild.getRowType().getFieldList();\n    int nRightFields = rightFields.size();\n    for (int i = 0; i < nRightFields; i++) {\n      final RelDataTypeField field = rightFields.get(i);\n      RexNode inputRef =\n          rexBuilder.makeInputRef(\n              field.getType(), i + nLeftFields);\n      bottomProgramBuilder.addProject(inputRef, field.getName());\n    }\n    RexProgram bottomProgram = bottomProgramBuilder.getProgram();\n\n    // input rowtype into the top program is the concatenation of the\n    // project and the RHS of the semijoin\n    RelDataType topInputRowType =\n        Join.deriveJoinRowType(\n            project.getRowType(),\n            rightChild.getRowType(),\n            JoinRelType.INNER,\n            typeFactory,\n            null,\n            semiJoin.getSystemFieldList());\n    RexProgramBuilder topProgramBuilder =\n        new RexProgramBuilder(\n            topInputRowType,\n            rexBuilder);\n    topProgramBuilder.addIdentity();\n    topProgramBuilder.addCondition(semiJoin.getCondition());\n    RexProgram topProgram = topProgramBuilder.getProgram();\n\n    // merge the programs and expand out the local references to form\n    // the new semijoin condition; it now references a concatenation of\n    // the project's child and the RHS of the semijoin\n    RexProgram mergedProgram =\n        RexProgramBuilder.mergePrograms(\n            topProgram,\n            bottomProgram,\n            rexBuilder);\n\n    return mergedProgram.expandLocalRef(\n        mergedProgram.getCondition());\n  }\n"
  },
  {
    "id": "lingochamp_FileDownloader-74-Param-1",
    "old_comment_raw": "@param path If  pathAsDirectory is  true,  path would be the absolute directory to place the file; If  pathAsDirectory is  false,  path would be the absolute file path.",
    "old_code_raw": "    public static int generateId(final String url, final String path, final boolean pathAsDirectory) {\n        return CustomComponentHolder.getImpl().getIdGeneratorInstance().generateId(url, path, pathAsDirectory);\n    }\n",
    "new_code_raw": "    public static int generateId(final String url, final String path) {\n        return CustomComponentHolder.getImpl().getIdGeneratorInstance()\n                .generateId(url, path, false);\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1187-Param-2",
    "old_comment_raw": "@param assumed The assumed return value, if avoiding database hit is desired",
    "old_code_raw": "\tpublic static boolean isNotTransient(String entityName, Object entity, Boolean assumed, SessionImplementor session) {\n\t\tif ( entity instanceof HibernateProxy ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( session.getPersistenceContext().isEntryFor( entity ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// todo : shouldnt assumed be revered here?\n\n\t\treturn !isTransient( entityName, entity, assumed, session );\n\t}\n",
    "new_code_raw": "\tpublic static boolean isNotTransient(String entityName, Object entity, Boolean assumed, SharedSessionContractImplementor session) {\n\t\tif ( entity instanceof HibernateProxy ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( session.getPersistenceContext().isEntryFor( entity ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// todo : shouldnt assumed be revered here?\n\n\t\treturn !isTransient( entityName, entity, assumed, session );\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1708-Param-0",
    "old_comment_raw": "@param user (User) (required)",
    "old_code_raw": "        public TestBodyWithQueryParamsOper body(User user) {\n            reqSpec.setBody(user);\n            return this;\n        }\n",
    "new_code_raw": "        public TestBodyWithQueryParamsOper body(User body) {\n            reqSpec.setBody(body);\n            return this;\n        }\n"
  },
  {
    "id": "hibernate_hibernate_orm-685-Param-0",
    "old_comment_raw": "@param bindingContext The binding context, giving access to needed services and information",
    "old_code_raw": "\tpublic static Set<ConfiguredClassHierarchy<EntityClass>> createEntityHierarchies(AnnotationsBindingContext bindingContext) {\n\t\tMap<ClassInfo, List<ClassInfo>> processedClassInfos = new HashMap<ClassInfo, List<ClassInfo>>();\n\n\t\tfor ( ClassInfo info : bindingContext.getIndex().getKnownClasses() ) {\n\t\t\tif ( !isEntityClass( info ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( processedClassInfos.containsKey( info ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tList<ClassInfo> configuredClassList = new ArrayList<ClassInfo>();\n\t\t\tClassInfo tmpClassInfo = info;\n\t\t\tClass<?> clazz = bindingContext.locateClassByName( tmpClassInfo.toString() );\n\t\t\twhile ( clazz != null && !clazz.equals( Object.class ) ) {\n\t\t\t\ttmpClassInfo = bindingContext.getIndex().getClassByName( DotName.createSimple( clazz.getName() ) );\n\t\t\t\tclazz = clazz.getSuperclass();\n\t\t\t\tif ( tmpClassInfo == null ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( existsHierarchyWithClassInfoAsLeaf( processedClassInfos, tmpClassInfo ) ) {\n\t\t\t\t\tList<ClassInfo> classInfoList = processedClassInfos.get( tmpClassInfo );\n\t\t\t\t\tfor ( ClassInfo tmpInfo : configuredClassList ) {\n\t\t\t\t\t\tclassInfoList.add( tmpInfo );\n\t\t\t\t\t\tprocessedClassInfos.put( tmpInfo, classInfoList );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconfiguredClassList.add( 0, tmpClassInfo );\n\t\t\t\t\tprocessedClassInfos.put( tmpClassInfo, configuredClassList );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSet<ConfiguredClassHierarchy<EntityClass>> hierarchies = new HashSet<ConfiguredClassHierarchy<EntityClass>>();\n\t\tList<List<ClassInfo>> processedList = new ArrayList<List<ClassInfo>>();\n\t\tfor ( List<ClassInfo> classInfoList : processedClassInfos.values() ) {\n\t\t\tif ( !processedList.contains( classInfoList ) ) {\n\t\t\t\thierarchies.add( ConfiguredClassHierarchy.createEntityClassHierarchy( classInfoList, bindingContext ) );\n\t\t\t\tprocessedList.add( classInfoList );\n\t\t\t}\n\t\t}\n\n\t\treturn hierarchies;\n\t}\n",
    "new_code_raw": "\tpublic static Set<ConfiguredClassHierarchy<EntityClass>> createEntityHierarchies(AnnotationBindingContext bindingContext) {\n\t\tMap<ClassInfo, List<ClassInfo>> processedClassInfos = new HashMap<ClassInfo, List<ClassInfo>>();\n\n\t\tfor ( ClassInfo info : bindingContext.getIndex().getKnownClasses() ) {\n\t\t\tif ( !isEntityClass( info ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( processedClassInfos.containsKey( info ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tList<ClassInfo> configuredClassList = new ArrayList<ClassInfo>();\n\t\t\tClassInfo tmpClassInfo = info;\n\t\t\tClass<?> clazz = bindingContext.locateClassByName( tmpClassInfo.toString() );\n\t\t\twhile ( clazz != null && !clazz.equals( Object.class ) ) {\n\t\t\t\ttmpClassInfo = bindingContext.getIndex().getClassByName( DotName.createSimple( clazz.getName() ) );\n\t\t\t\tclazz = clazz.getSuperclass();\n\t\t\t\tif ( tmpClassInfo == null ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( existsHierarchyWithClassInfoAsLeaf( processedClassInfos, tmpClassInfo ) ) {\n\t\t\t\t\tList<ClassInfo> classInfoList = processedClassInfos.get( tmpClassInfo );\n\t\t\t\t\tfor ( ClassInfo tmpInfo : configuredClassList ) {\n\t\t\t\t\t\tclassInfoList.add( tmpInfo );\n\t\t\t\t\t\tprocessedClassInfos.put( tmpInfo, classInfoList );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconfiguredClassList.add( 0, tmpClassInfo );\n\t\t\t\t\tprocessedClassInfos.put( tmpClassInfo, configuredClassList );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSet<ConfiguredClassHierarchy<EntityClass>> hierarchies = new HashSet<ConfiguredClassHierarchy<EntityClass>>();\n\t\tList<List<ClassInfo>> processedList = new ArrayList<List<ClassInfo>>();\n\t\tfor ( List<ClassInfo> classInfoList : processedClassInfos.values() ) {\n\t\t\tif ( !processedList.contains( classInfoList ) ) {\n\t\t\t\thierarchies.add( ConfiguredClassHierarchy.createEntityClassHierarchy( classInfoList, bindingContext ) );\n\t\t\t\tprocessedList.add( classInfoList );\n\t\t\t}\n\t\t}\n\n\t\treturn hierarchies;\n\t}\n"
  },
  {
    "id": "apache_qpid-jms-17-Associations-Param0",
    "old_comment_raw": "@param uri",
    "old_code_raw": "    public static String addPropertiesToURI(URI uri, Map<String, String> props) throws Exception {\n        return addPropertiesToURI(uri.toString(), props);\n    }\n",
    "new_code_raw": "    public static String addPropertiesToURI(URI uri, Map<String, String> properties) throws Exception {\n        return addPropertiesToURI(uri.toString(), properties);\n    }\n\n"
  },
  {
    "id": "apache_calcite-628-Param-0",
    "old_comment_raw": "@param list List",
    "old_code_raw": "  public Tester getTester(SqlConformance conformance) {\n    return new AdvisorTestImpl(conformance);\n  }\n",
    "new_code_raw": "  public SqlTester getTester() {\n    return new SqlTesterImpl(new AdvisorTesterFactory());\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1675-Param-0",
    "old_comment_raw": "@param body client model",
    "old_code_raw": "    public Client testClassname(Client body) throws RestClientException {\n        Object postBody = body;\n        \n        // verify the required parameter 'body' is set\n        if (body == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling testClassname\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"/fake_classname_test\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"api_key_query\" };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "new_code_raw": "    public Client testClassname(Client client) throws RestClientException {\n        Object postBody = client;\n        \n        // verify the required parameter 'client' is set\n        if (client == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'client' when calling testClassname\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"/fake_classname_test\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"api_key_query\" };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n"
  },
  {
    "id": "SeleniumHQ_selenium-42-Param-5",
    "old_comment_raw": "@param multiWindow TODO",
    "old_code_raw": "    public String runHTMLSuite(String browser, String browserURL, String HTMLSuite, File outputFile, long timeoutInMs, boolean multiWindow) throws IOException {\n        server.handleHTMLRunnerResults(this);\n        BrowserLauncherFactory blf = new BrowserLauncherFactory(server);\n        String sessionId = Long.toString(System.currentTimeMillis() % 1000000);\n        BrowserLauncher launcher = blf.getBrowserLauncher(browser, sessionId, null);\n        launcher.launchHTMLSuite(HTMLSuite, browserURL, multiWindow);\n        long now = System.currentTimeMillis();\n        long end = now + timeoutInMs;\n        while (results == null && System.currentTimeMillis() < end) {\n            AsyncExecute.sleepTight(500);\n        }\n        launcher.close();\n        if (results == null) {\n            throw new SeleniumCommandTimedOutException();\n        }\n        if (outputFile != null) {\n            FileWriter fw = new FileWriter(outputFile);\n            results.write(fw);\n            fw.close();\n        }\n        \n        return results.getResult().toUpperCase();\n    }\n",
    "new_code_raw": "    public String runHTMLSuite(String browser, String browserURL, String HTMLSuite, File outputFile, int timeoutInSeconds, boolean multiWindow) throws IOException {\n        long timeoutInMs = 1000 * timeoutInSeconds;\n        server.handleHTMLRunnerResults(this);\n        BrowserLauncherFactory blf = new BrowserLauncherFactory(server);\n        String sessionId = Long.toString(System.currentTimeMillis() % 1000000);\n        BrowserLauncher launcher = blf.getBrowserLauncher(browser, sessionId, null);\n        launcher.launchHTMLSuite(HTMLSuite, browserURL, multiWindow);\n        long now = System.currentTimeMillis();\n        long end = now + timeoutInMs;\n        while (results == null && System.currentTimeMillis() < end) {\n            AsyncExecute.sleepTight(500);\n        }\n        launcher.close();\n        if (results == null) {\n            throw new SeleniumCommandTimedOutException();\n        }\n        if (outputFile != null) {\n            FileWriter fw = new FileWriter(outputFile);\n            results.write(fw);\n            fw.close();\n        }\n        \n        return results.getResult().toUpperCase();\n    }\n"
  },
  {
    "id": "apache_ant-ivy-47-Associations-Param0",
    "old_comment_raw": "@param file1 One of the files, for which the common base directory is being sought, may be null.",
    "old_code_raw": "    File getBaseDir(final File file1, final File file2) {\n        if (file1 == null || file2 == null) {\n            return null;\n        }\n        final Iterator file1Parents = getParents(file1).iterator();\n        final Iterator file2Parents = getParents(file2.getAbsoluteFile()).iterator();\n        File result = null;\n        while (file1Parents.hasNext() && file2Parents.hasNext()) {\n            File next = (File) file1Parents.next();\n            if (next.equals(file2Parents.next())) {\n                result = next;\n            } else {\n                break;\n            }\n        }\n        return result;\n    }\n",
    "new_code_raw": "    File getBaseDir(File base, File file) {\n        if (base == null) {\n            return file.getParentFile().getAbsoluteFile();\n        } else {\n            Iterator bases = getParents(base).iterator();\n            Iterator fileParents = getParents(file.getAbsoluteFile()).iterator();\n            File result = null;\n            while (bases.hasNext() && fileParents.hasNext()) {\n                File next = (File) bases.next();\n                if (next.equals(fileParents.next())) {\n                    result = next;\n                } else {\n                    break;\n                }\n            }\n            return result;\n        }\n    }\n\n"
  },
  {
    "id": "debezium_debezium-512-Param-4",
    "old_comment_raw": "@param mappers the mapping functions for columns; may be null if none of the columns are to be mapped to different values",
    "old_code_raw": "    public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, Predicate<ColumnId> filter, ColumnMappers mappers) {\n        if (schemaPrefix == null) {\n            schemaPrefix = \"\";\n        }\n        // Build the schemas ...\n        final TableId tableId = table.id();\n        final String tableIdStr = tableSchemaName(tableId);\n        final String schemaNamePrefix = schemaPrefix + tableIdStr;\n        LOGGER.debug(\"Mapping table '{}' to schemas under '{}'\", tableId, schemaNamePrefix);\n        SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Value\"));\n        SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Key\"));\n        AtomicBoolean hasPrimaryKey = new AtomicBoolean(false);\n        table.columns().forEach(column -> {\n            if (table.isPrimaryKeyColumn(column.name())) {\n                // The column is part of the primary key, so ALWAYS add it to the PK schema ...\n                addField(keySchemaBuilder, column, null);\n                hasPrimaryKey.set(true);\n            }\n            if (filter == null || filter.test(new ColumnId(tableId, column.name()))) {\n                // Add the column to the value schema only if the column has not been filtered ...\n                ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column);\n                addField(valSchemaBuilder, column, mapper);\n            }\n        });\n        Schema valSchema = valSchemaBuilder.optional().build();\n        Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null;\n\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Mapped primary key for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(keySchema));\n            LOGGER.debug(\"Mapped columns for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(valSchema));\n        }\n\n        Envelope envelope = Envelope.defineSchema()\n                .withName(schemaNameAdjuster.adjust(envelopSchemaName))\n                .withRecord(valSchema)\n                .withSource(sourceInfoSchema)\n                .build();\n\n\n        // Create the generators ...\n        Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, table.primaryKeyColumns());\n        Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers);\n\n        // And the table schema ...\n        return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator);\n    }\n",
    "new_code_raw": "    public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers) {\n        if (schemaPrefix == null) {\n            schemaPrefix = \"\";\n        }\n\n        // Build the schemas ...\n        final TableId tableId = table.id();\n        final String tableIdStr = tableSchemaName(tableId);\n        final String schemaNamePrefix = schemaPrefix + tableIdStr;\n        LOGGER.debug(\"Mapping table '{}' to schemas under '{}'\", tableId, schemaNamePrefix);\n        SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Value\"));\n        SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Key\"));\n        AtomicBoolean hasPrimaryKey = new AtomicBoolean(false);\n        table.columns().forEach(column -> {\n            if (table.isPrimaryKeyColumn(column.name())) {\n                // The column is part of the primary key, so ALWAYS add it to the PK schema ...\n                addField(keySchemaBuilder, column, null);\n                hasPrimaryKey.set(true);\n            }\n            if (filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name())) {\n                // Add the column to the value schema only if the column has not been filtered ...\n                ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column);\n                addField(valSchemaBuilder, column, mapper);\n            }\n        });\n        Schema valSchema = valSchemaBuilder.optional().build();\n        Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null;\n\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Mapped primary key for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(keySchema));\n            LOGGER.debug(\"Mapped columns for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(valSchema));\n        }\n\n        Envelope envelope = Envelope.defineSchema()\n                .withName(schemaNameAdjuster.adjust(envelopSchemaName))\n                .withRecord(valSchema)\n                .withSource(sourceInfoSchema)\n                .build();\n\n\n        // Create the generators ...\n        Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, table.primaryKeyColumns());\n        Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers);\n\n        // And the table schema ...\n        return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator);\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-154-Param-0",
    "old_comment_raw": "@param l1 array you want to find in l2",
    "old_code_raw": "  public static List<Integer> getSubListIndex(Object[] l1, Object[] l2){\n    if(l1.length > l2.length)\n      return null;\n    List<Integer> allIndices = new ArrayList<Integer>();\n    boolean matched = false;\n    int index = -1;\n    int lastUnmatchedIndex = 0;\n    for(int i = 0 ; i < l2.length;){\n      for(int j = 0; j < l1.length ;){\n        if(l1[j].equals(l2[i])){\n          index = i;\n          i++;\n          j++;\n          if(j == l1.length)\n          {\n            matched = true;\n            break;\n          }\n        }else{\n          j = 0;\n          i = lastUnmatchedIndex +1;\n          lastUnmatchedIndex = i;\n          index = -1;\n          if(lastUnmatchedIndex == l2.length)\n            break;\n        }\n        if(i >= l2.length){\n          index = -1;\n          break;\n        }\n      }\n      if(i == l2.length || matched){\n        if(index >= 0)\n          //index = index - l1.length + 1;\n          allIndices.add(index - l1.length + 1);\n        matched = false;\n        lastUnmatchedIndex = index;\n\n        //break;\n      }\n    }\n    //get starting point\n\n    return allIndices;\n  }\n",
    "new_code_raw": "  public static List<Integer> getSubListIndex(Object[] tofind, Object[] tokens){\n    if(tofind.length > tokens.length)\n      return null;\n    List<Integer> allIndices = new ArrayList<Integer>();\n    boolean matched = false;\n    int index = -1;\n    int lastUnmatchedIndex = 0;\n    for(int i = 0 ; i < tokens.length;){\n      for(int j = 0; j < tofind.length ;){\n        if(tofind[j].equals(tokens[i])){\n          index = i;\n          i++;\n          j++;\n          if(j == tofind.length)\n          {\n            matched = true;\n            break;\n          }\n        }else{\n          j = 0;\n          i = lastUnmatchedIndex +1;\n          lastUnmatchedIndex = i;\n          index = -1;\n          if(lastUnmatchedIndex == tokens.length)\n            break;\n        }\n        if(i >= tokens.length){\n          index = -1;\n          break;\n        }\n      }\n      if(i == tokens.length || matched){\n        if(index >= 0)\n          //index = index - l1.length + 1;\n          allIndices.add(index - tofind.length + 1);\n        matched = false;\n        lastUnmatchedIndex = index;\n\n        //break;\n      }\n    }\n    //get starting point\n\n    return allIndices;\n  }\n"
  },
  {
    "id": "ctripcorp_apollo-1-Param-0",
    "old_comment_raw": "@param appId",
    "old_code_raw": "  public List<NamespaceVO> findNampspaces(String appId, Apollo.Env env, String clusterName) {\n\n    List<NamespaceDTO> namespaces = groupAPI.findGroupsByAppAndCluster(appId, env, clusterName);\n    if (namespaces == null || namespaces.size() == 0) {\n      return Collections.EMPTY_LIST;\n    }\n\n    List<NamespaceVO> namespaceVOs = new LinkedList<>();\n    for (NamespaceDTO namespace : namespaces) {\n\n      NamespaceVO namespaceVO = null;\n      try {\n        namespaceVO = parseNamespace(appId, env, clusterName, namespace);\n        namespaceVOs.add(namespaceVO);\n      } catch (Exception e) {\n        logger.error(\"parse namespace error. app id:{}, env:{}, clusterName:{}, namespace:{}\", appId, env, clusterName,\n                     namespace.getNamespaceName(), e);\n        return namespaceVOs;\n      }\n    }\n\n    return namespaceVOs;\n  }\n",
    "new_code_raw": "  public List<NamespaceVO> findNampspaces(String appId, Env env, String clusterName) {\n\n    List<NamespaceDTO> namespaces = groupAPI.findGroupsByAppAndCluster(appId, env, clusterName);\n    if (namespaces == null || namespaces.size() == 0) {\n      return Collections.EMPTY_LIST;\n    }\n\n    List<NamespaceVO> namespaceVOs = new LinkedList<>();\n    for (NamespaceDTO namespace : namespaces) {\n\n      NamespaceVO namespaceVO = null;\n      try {\n        namespaceVO = parseNamespace(appId, env, clusterName, namespace);\n        namespaceVOs.add(namespaceVO);\n      } catch (Exception e) {\n        logger.error(\"parse namespace error. app id:{}, env:{}, clusterName:{}, namespace:{}\", appId, env, clusterName,\n                     namespace.getNamespaceName(), e);\n        return namespaceVOs;\n      }\n    }\n\n    return namespaceVOs;\n  }\n"
  },
  {
    "id": "graphql_java_graphql_java-452-Param-0",
    "old_comment_raw": "@param parentType the container type",
    "old_code_raw": "    public DataFetcher getDataFetcher(GraphQLFieldsContainer parentType, GraphQLFieldDefinition fieldDefinition) {\n        return getDataFetcherImpl(parentType, fieldDefinition, dataFetcherMap, systemDataFetcherMap);\n    }\n",
    "new_code_raw": "    public DataFetcher getDataFetcher(FieldCoordinates coordinates, GraphQLFieldDefinition fieldDefinition) {\n        return getDataFetcherImpl(coordinates, fieldDefinition, dataFetcherMap, systemDataFetcherMap);\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-763-Param-0",
    "old_comment_raw": "@param itemIndex the item index that should be clicked",
    "old_code_raw": "\tpublic ArrayList<TextView> clickInRecyclerView(int itemIndex, int recyclerViewIndex, boolean longClick, int time) {\n\t\tView viewOnLine = null;\n\t\tfinal long endTime = SystemClock.uptimeMillis() + Timeout.getSmallTimeout();\n\n\t\tif(itemIndex < 0)\n\t\t\titemIndex = 0;\n\n\t\tArrayList<View> views = new ArrayList<View>();\n\t\tViewGroup recyclerView = viewFetcher.getRecyclerView(recyclerViewIndex, Timeout.getSmallTimeout());\n\t\t\n\t\tif(recyclerView == null){\n\t\t\tAssert.fail(\"RecyclerView is not found!\");\n\t\t}\n\t\telse{\n\t\t\tfailIfIndexHigherThenChildCount(recyclerView, itemIndex, endTime);\n\t\t\tviewOnLine = getViewOnRecyclerItemIndex((ViewGroup) recyclerView, recyclerViewIndex, itemIndex);\n\t\t}\n\t\t\n\t\tif(viewOnLine != null){\n\t\t\tviews = viewFetcher.getViews(viewOnLine, true);\n\t\t\tviews = RobotiumUtils.removeInvisibleViews(views);\n\t\t\tclickOnScreen(viewOnLine, longClick, time);\n\t\t}\n\t\treturn RobotiumUtils.filterViews(TextView.class, views);\n\t}\n",
    "new_code_raw": "\tpublic ArrayList<TextView> clickInRecyclerView(int itemIndex, int recyclerViewIndex, int id, boolean longClick, int time) {\n\t\tView viewOnLine = null;\n\t\tfinal long endTime = SystemClock.uptimeMillis() + Timeout.getSmallTimeout();\n\n\t\tif(itemIndex < 0)\n\t\t\titemIndex = 0;\n\n\t\tArrayList<View> views = new ArrayList<View>();\n\t\tViewGroup recyclerView = viewFetcher.getRecyclerView(recyclerViewIndex, Timeout.getSmallTimeout());\n\t\t\n\t\tif(recyclerView == null){\n\t\t\tAssert.fail(\"RecyclerView is not found!\");\n\t\t}\n\t\telse{\n\t\t\tfailIfIndexHigherThenChildCount(recyclerView, itemIndex, endTime);\n\t\t\tviewOnLine = getViewOnRecyclerItemIndex((ViewGroup) recyclerView, recyclerViewIndex, itemIndex);\n\t\t}\n\t\t\n\t\tif(viewOnLine != null){\n\t\t\tviews = viewFetcher.getViews(viewOnLine, true);\n\t\t\tviews = RobotiumUtils.removeInvisibleViews(views);\n\t\t\t\n\t\t\tif(id == 0){\n\t\t\t\tclickOnScreen(viewOnLine, longClick, time);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tclickOnScreen(getView(id, views));\n\t\t\t}\n\t\t}\n\t\treturn RobotiumUtils.filterViews(TextView.class, views);\n\t}\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2351-Param-0",
    "old_comment_raw": "@param t Target for finding dependents of t related by this GR",
    "old_code_raw": "  public Collection<Tree> getRelatedNodes(Tree t, Tree root, HeadFinder headFinder) {\n    Set<Tree> nodeList = new ArraySet<Tree>();\n    for (TregexPattern p : targetPatterns) {    // cdm: I deleted: && nodeList.isEmpty()\n      // Initialize the TregexMatcher with the HeadFinder so that we\n      // can use the same HeadFinder through the entire process of\n      // building the dependencies\n      TregexMatcher m = p.matcher(root, headFinder);\n      while (m.findAt(t)) {\n        nodeList.add(m.getNode(\"target\"));\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\"))\n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n",
    "new_code_raw": "  public Collection<Tree> getRelatedNodes(Tree t, Tree root) {\n    if (root.value() == null) {\n      root.setValue(\"ROOT\");  // todo: cdm: it doesn't seem like this line should be here\n    }\n    Set<Tree> nodeList = new LinkedHashSet<Tree>();\n    for (TregexPattern p : targetPatterns) {    // cdm: I deleted: && nodeList.isEmpty()\n      TregexMatcher m = p.matcher(root);\n      while (m.findAt(t)) {\n        nodeList.add(m.getNode(\"target\"));\n        //System.out.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p);\n      }\n    }\n    return nodeList;\n  }\n"
  },
  {
    "id": "querydsl_querydsl-905-Param-1",
    "old_comment_raw": "@param expr1",
    "old_code_raw": "    public ScrollableResults scroll(ScrollMode mode, Expr<?> expr1, Expr<?> expr2, Expr<?>... rest) {\n        Query query = createQuery(expr1, expr2, rest);\n        reset();\n        return query.scroll(mode);\n    }\n",
    "new_code_raw": "    public ScrollableResults scroll(ScrollMode mode, Expression<?> expr1, Expression<?> expr2, Expression<?>... rest) {\n        Query query = createQuery(expr1, expr2, rest);\n        reset();\n        return query.scroll(mode);\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-1007-Param-0",
    "old_comment_raw": "@param regex the text to search for. The parameter will be interpreted as a regular expression.",
    "old_code_raw": "\tpublic boolean searchText(String regex, int expectedMinimumNumberOfMatches) {\n\t\tboolean found = searcher.searchWithTimeoutFor(TextView.class, regex, expectedMinimumNumberOfMatches, true);\n\t\treturn found;\n\t}\n",
    "new_code_raw": "\tpublic boolean searchText(String text, int minimumNumberOfMatches) {\n\t\tboolean found = searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, true);\n\t\treturn found;\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-378-Param-0",
    "old_comment_raw": "@param body List of user object",
    "old_code_raw": "  public void createUsersWithListInput (List<User> body) throws ApiException {\n    Object postBody = body;\n    byte[] postBinaryBody = null;\n    \n    // create path and map variables\n    String path = \"/user/createWithList\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    Map<String, String> headerParams = new HashMap<String, String>();\n    Map<String, Object> formParams = new HashMap<String, Object>();\n\n    \n\n    \n\n    \n\n    final String[] accepts = {\n      \"application/json\", \"application/xml\"\n    };\n    final String accept = apiClient.selectHeaderAccept(accepts);\n\n    final String[] contentTypes = {\n      \n    };\n    final String contentType = apiClient.selectHeaderContentType(contentTypes);\n\n    String[] authNames = new String[] {  };\n\n    \n\n    \n    \n    apiClient.invokeAPI(path, \"POST\", queryParams, postBody, postBinaryBody, headerParams, formParams, accept, contentType, authNames, null);\n    \n    \n\n\n  }\n",
    "new_code_raw": "  public void createUsersWithListInput (java.util.List<User> body) throws ApiException {\n    Object postBody = body;\n    byte[] postBinaryBody = null;\n    \n    // create path and map variables\n    String path = \"/user/createWithList\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    java.util.List<Pair> queryParams = new java.util.ArrayList<Pair>();\n    java.util.Map<String, String> headerParams = new java.util.HashMap<String, String>();\n    java.util.Map<String, Object> formParams = new java.util.HashMap<String, Object>();\n\n    \n\n    \n\n    \n\n    final String[] accepts = {\n      \"application/json\", \"application/xml\"\n    };\n    final String accept = apiClient.selectHeaderAccept(accepts);\n\n    final String[] contentTypes = {\n      \n    };\n    final String contentType = apiClient.selectHeaderContentType(contentTypes);\n\n    String[] authNames = new String[] {  };\n\n    \n\n    \n    \n    apiClient.invokeAPI(path, \"POST\", queryParams, postBody, postBinaryBody, headerParams, formParams, accept, contentType, authNames, null);\n    \n    \n\n\n  }\n"
  },
  {
    "id": "apache_drill-720-Param-0",
    "old_comment_raw": "@param parent the parent (tuple, union or list) that holds this list",
    "old_code_raw": "  private static ColumnState buildUnionList(ContainerState parent, ColumnMetadata columnSchema) {\n\n    // The variant must start out empty.\n\n    assert columnSchema.variantSchema().size() == 0;\n\n    // Create the union writer, bound to an empty list shim.\n\n    final UnionWriterImpl unionWriter = new UnionWriterImpl(columnSchema);\n    unionWriter.bindShim(new EmptyListShim());\n    final VariantObjectWriter unionObjWriter = new VariantObjectWriter(unionWriter);\n\n    // Create the list vector. Starts with the default (dummy) data\n    // vector which corresponds to the empty union shim above.\n    // Don't get the list vector from the vector cache. List vectors may\n    // have content that varies from batch to batch. Only the leaf\n    // vectors can be cached.\n\n    final ListVector listVector = new ListVector(columnSchema.schema(),\n        parent.loader().allocator(), null);\n\n    // Create the list vector state that tracks the list vector lifecycle.\n\n    final ListVectorState vectorState = new ListVectorState(unionWriter, listVector);\n\n    // Create the list writer: an array of unions.\n\n    final AbstractObjectWriter listWriter = new ArrayObjectWriter(\n        new ListWriterImpl(columnSchema, listVector, unionObjWriter));\n\n    // Create the manager for the columns within the list (which may or\n    // may not be grouped into a union.)\n\n    final ListState listState = new ListState(parent.loader(),\n        parent.vectorCache().childCache(columnSchema.name()),\n        ImpliedTupleRequest.ALL_MEMBERS);\n\n    // Bind the union state to the union writer to handle column additions.\n\n    unionWriter.bindListener(listState);\n\n    // Assemble it all into a union column state.\n\n    return new UnionColumnState(parent.loader(),\n        listWriter, vectorState, listState);\n  }\n",
    "new_code_raw": "  private ColumnState buildUnionList(ContainerState parent, ColumnTransform outputCol) {\n    ColumnMetadata columnSchema = outputCol.outputSchema();\n\n    // The variant must start out empty.\n\n    assert columnSchema.variantSchema().size() == 0;\n\n    // Create the union writer, bound to an empty list shim.\n\n    final UnionWriterImpl unionWriter = new UnionWriterImpl(columnSchema);\n    unionWriter.bindShim(new EmptyListShim());\n    final VariantObjectWriter unionObjWriter = new VariantObjectWriter(unionWriter);\n\n    // Create the list vector. Starts with the default (dummy) data\n    // vector which corresponds to the empty union shim above.\n    // Don't get the list vector from the vector cache. List vectors may\n    // have content that varies from batch to batch. Only the leaf\n    // vectors can be cached.\n\n    final ListVector listVector = new ListVector(columnSchema.schema(),\n        parent.loader().allocator(), null);\n\n    // Create the list vector state that tracks the list vector lifecycle.\n\n    final ListVectorState vectorState = new ListVectorState(unionWriter, listVector);\n\n    // Create the list writer: an array of unions.\n\n    final AbstractObjectWriter listWriter = new ArrayObjectWriter(\n        new ListWriterImpl(columnSchema, listVector, unionObjWriter));\n\n    // Create the manager for the columns within the list (which may or\n    // may not be grouped into a union.)\n\n    final ListState listState = new ListState(parent.loader(),\n        parent.vectorCache().childCache(columnSchema.name()),\n        ImpliedTupleRequest.ALL_MEMBERS);\n\n    // Bind the union state to the union writer to handle column additions.\n\n    unionWriter.bindListener(listState);\n\n    // Assemble it all into a union column state.\n\n    return new UnionColumnState(parent.loader(),\n        listWriter, vectorState, listState);\n  }\n"
  },
  {
    "id": "RobotiumTech_robotium-1187-Param-1",
    "old_comment_raw": "@param matches the number of matches of text that must be shown.  0 means any number of matches",
    "old_code_raw": "\tpublic boolean waitForText(String text, int matches, long timeout, boolean scroll) {\n        final long endTime = System.currentTimeMillis() + timeout;\n\n\t\twhile (true) {\n\t\t\tfinal boolean timedOut = System.currentTimeMillis() > endTime;\n\t\t\tif (timedOut){\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tsleeper.sleep();\n\n\t\t\tfinal boolean foundAnyTextView = searcher.searchFor(TextView.class, text, matches, scroll);\n\t\t\tif (foundAnyTextView){\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfinal boolean foundAnyEditText = searcher.searchFor(EditText.class, text, 1, scroll);\n\t\t\tif (foundAnyEditText){\n\t\t\t\treturn true;\n\t\t\t}\n        }\n    }\n",
    "new_code_raw": "\tpublic boolean waitForText(String text, int expectedMinimumNumberOfMatches, long timeout, boolean scroll) {\n        final long endTime = System.currentTimeMillis() + timeout;\n\n\t\twhile (true) {\n\t\t\tfinal boolean timedOut = System.currentTimeMillis() > endTime;\n\t\t\tif (timedOut){\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tsleeper.sleep();\n\n\t\t\tfinal boolean foundAnyTextView = searcher.searchFor(TextView.class, text, expectedMinimumNumberOfMatches, scroll);\n\t\t\tif (foundAnyTextView){\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfinal boolean foundAnyEditText = searcher.searchFor(EditText.class, text, 1, scroll);\n\t\t\tif (foundAnyEditText){\n\t\t\t\treturn true;\n\t\t\t}\n        }\n    }\n"
  },
  {
    "id": "debezium_debezium-544-Param-4",
    "old_comment_raw": "@param mappers the mapping functions for columns; may be null if none of the columns are to be mapped to different values",
    "old_code_raw": "    public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers) {\n        if (schemaPrefix == null) {\n            schemaPrefix = \"\";\n        }\n\n        // Build the schemas ...\n        final TableId tableId = table.id();\n        final String tableIdStr = tableSchemaName(tableId);\n        final String schemaNamePrefix = schemaPrefix + tableIdStr;\n        LOGGER.debug(\"Mapping table '{}' to schemas under '{}'\", tableId, schemaNamePrefix);\n        SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Value\"));\n        SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Key\"));\n        AtomicBoolean hasPrimaryKey = new AtomicBoolean(false);\n        table.columns().forEach(column -> {\n            if (table.isPrimaryKeyColumn(column.name())) {\n                // The column is part of the primary key, so ALWAYS add it to the PK schema ...\n                addField(keySchemaBuilder, column, null);\n                hasPrimaryKey.set(true);\n            }\n            if (filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name())) {\n                // Add the column to the value schema only if the column has not been filtered ...\n                ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column);\n                addField(valSchemaBuilder, column, mapper);\n            }\n        });\n        Schema valSchema = valSchemaBuilder.optional().build();\n        Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null;\n\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Mapped primary key for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(keySchema));\n            LOGGER.debug(\"Mapped columns for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(valSchema));\n        }\n\n        Envelope envelope = Envelope.defineSchema()\n                .withName(schemaNameAdjuster.adjust(envelopSchemaName))\n                .withRecord(valSchema)\n                .withSource(sourceInfoSchema)\n                .build();\n\n\n        // Create the generators ...\n        Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, table.primaryKeyColumns());\n        Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers);\n\n        // And the table schema ...\n        return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator);\n    }\n",
    "new_code_raw": "    public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers, CustomKeyMapper keysMapper) {\n        if (schemaPrefix == null) {\n            schemaPrefix = \"\";\n        }\n\n        // Build the schemas ...\n        final TableId tableId = table.id();\n        final String tableIdStr = tableSchemaName(tableId);\n        final String schemaNamePrefix = schemaPrefix + tableIdStr;\n        LOGGER.debug(\"Mapping table '{}' to schemas under '{}'\", tableId, schemaNamePrefix);\n        SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Value\"));\n        SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Key\"));\n        AtomicBoolean hasPrimaryKey = new AtomicBoolean(false);\n        \n        Key tableKey = new Key.Builder(table).customKeyMapper(keysMapper).build();\n        tableKey.keyColumns().forEach(column -> {\n            addField(keySchemaBuilder, column, null);\n            hasPrimaryKey.set(true);\n        });\n        \n        table.columns()\n            .stream()\n            .filter(column -> filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name()))\n            .forEach(column -> {\n                ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column);\n                addField(valSchemaBuilder, column, mapper);\n            });\n        \n        Schema valSchema = valSchemaBuilder.optional().build();\n        Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null;\n\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Mapped primary key for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(keySchema));\n            LOGGER.debug(\"Mapped columns for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(valSchema));\n        }\n\n        Envelope envelope = Envelope.defineSchema()\n                .withName(schemaNameAdjuster.adjust(envelopSchemaName))\n                .withRecord(valSchema)\n                .withSource(sourceInfoSchema)\n                .build();\n\n\n        // Create the generators ...\n        Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, tableKey.keyColumns());\n        Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers);\n\n        // And the table schema ...\n        return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator);\n    }\n"
  },
  {
    "id": "processing_processing-1226-Param-0",
    "old_comment_raw": "@param fd",
    "old_code_raw": "  private int getJavadocOffset(FieldDeclaration fd){\n    List<ASTNode> list= fd.modifiers();\n    SimpleName sn = (SimpleName) getNode();\n    \n    Type tp = fd.getType();\n    int lineNum = getLineNumber(sn);\n    log(\"SN \"+sn + \", \" + lineNum);\n    for (ASTNode astNode : list) {\n      if(getLineNumber(astNode) == lineNum)\n      {\n        log(\"first node in that line \" + astNode);\n        log(\"diff \" + (sn.getStartPosition() - astNode.getStartPosition()));\n        return (astNode.getStartPosition());\n      }\n    }\n    if(getLineNumber(fd.getType()) == lineNum)\n    {\n      log(\"first node in that line \" + tp);\n      log(\"diff \" + (sn.getStartPosition() - tp.getStartPosition()));\n      return (tp.getStartPosition());\n    }\n    \n    \n    return 0;   \n  }\n",
    "new_code_raw": "  private int getJavadocOffset(TypeDeclaration td){\n    // TODO: This isn't perfect yet. Class \\n \\n \\n className still breaks it.. :'(\n    List<ASTNode> list= td.modifiers();\n    list = td.modifiers();\n    SimpleName sn = (SimpleName) getNode();\n    \n    int lineNum = getLineNumber(sn);\n    log(\"SN \"+sn + \", \" + lineNum);\n    for (ASTNode astNode : list) {\n      if(getLineNumber(astNode) == lineNum)\n      {\n        log(\"first node in that line \" + astNode);\n        log(\"diff \" + (sn.getStartPosition() - astNode.getStartPosition()));\n        return (astNode.getStartPosition());\n      }\n    }\n    \n    if(td.getJavadoc() != null){\n      log(\"diff \"\n          + (td.getJavadoc().getStartPosition() + td.getJavadoc().getLength() + 1));\n      return (td.getJavadoc().getStartPosition() + td.getJavadoc().getLength() + 1);\n    }\n    log(\"getJavadocOffset(TypeDeclaration td) \"+sn + \", found nothing. Meh.\");\n    return 0;\n  }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-406-Param-1",
    "old_comment_raw": "@param verbalSet The set of words",
    "old_code_raw": "  private boolean hasVerbalAuxiliary(Tree[] kids, HashSet<String> verbalSet) {\n    if (DEBUG) {\n      System.err.println(\"Checking for verbal auxiliary\");\n    }\n    for (Tree kid : kids) {\n      if (DEBUG) {\n        System.err.println(\"  checking in \" + kid);\n      }\n      if (kid.isPreTerminal()) {\n        Label kidLabel = kid.label();\n        String tag = null;\n        if (kidLabel instanceof HasTag) {\n          tag = ((HasTag) kidLabel).tag();\n        }\n        if (tag == null) {\n          tag = kid.value();\n        }\n        Label wordLabel = kid.firstChild().label();\n        String word = null;\n        if (wordLabel instanceof HasWord) {\n          word = ((HasWord) wordLabel).word();\n        }\n        if (word == null) {\n          word = wordLabel.value();\n        }\n\n        if (DEBUG) {\n          System.err.println(\"Checking \" + kid.value() + \" head is \" + word + '/' + tag);\n        }\n        String lcWord = word.toLowerCase();\n        if (verbalTags.contains(tag) && verbalSet.contains(lcWord)) {\n          if (DEBUG) {\n            System.err.println(\"hasVerbalAuxiliary returns true\");\n          }\n          return true;\n        }\n      }\n    }\n    if (DEBUG) {\n      System.err.println(\"hasVerbalAuxiliary returns false\");\n    }\n    return false;\n  }\n",
    "new_code_raw": "  private boolean hasVerbalAuxiliary(Tree[] kids, Set<String> verbalSet) {\n    if (DEBUG) {\n      System.err.println(\"Checking for verbal auxiliary\");\n    }\n    for (Tree kid : kids) {\n      if (DEBUG) {\n        System.err.println(\"  checking in \" + kid);\n      }\n      if (kid.isPreTerminal()) {\n        Label kidLabel = kid.label();\n        String tag = null;\n        if (kidLabel instanceof HasTag) {\n          tag = ((HasTag) kidLabel).tag();\n        }\n        if (tag == null) {\n          tag = kid.value();\n        }\n        Label wordLabel = kid.firstChild().label();\n        String word = null;\n        if (wordLabel instanceof HasWord) {\n          word = ((HasWord) wordLabel).word();\n        }\n        if (word == null) {\n          word = wordLabel.value();\n        }\n\n        if (DEBUG) {\n          System.err.println(\"Checking \" + kid.value() + \" head is \" + word + '/' + tag);\n        }\n        String lcWord = word.toLowerCase();\n        if (verbalTags.contains(tag) && verbalSet.contains(lcWord)) {\n          if (DEBUG) {\n            System.err.println(\"hasVerbalAuxiliary returns true\");\n          }\n          return true;\n        }\n      }\n    }\n    if (DEBUG) {\n      System.err.println(\"hasVerbalAuxiliary returns false\");\n    }\n    return false;\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1662-Param-0",
    "old_comment_raw": "@param body client model (required)",
    "old_code_raw": "    public Client testClientModel(Client body) throws ApiException {\n        ApiResponse<Client> resp = testClientModelWithHttpInfo(body);\n        return resp.getData();\n    }\n",
    "new_code_raw": "    public Client testClientModel(Client client) throws ApiException {\n        ApiResponse<Client> resp = testClientModelWithHttpInfo(client);\n        return resp.getData();\n    }\n"
  },
  {
    "id": "debezium_debezium-265-Param-0",
    "old_comment_raw": "@param lsn the position in the server WAL for a particular event; may be null indicating that this information is not available",
    "old_code_raw": "    protected SourceInfo update(Long lsn, Long useconds, Integer txId) {\n        this.lsn = lsn;\n        this.useconds = useconds;\n        this.txId = txId;\n        return this;\n    }\n",
    "new_code_raw": "    protected SourceInfo update(Long lsn, Long useconds, Long txId) {\n        this.lsn = lsn;\n        this.useconds = useconds;\n        this.txId = txId;\n        return this;\n    }\n"
  },
  {
    "id": "zaproxy_zaproxy-2134-Param-0",
    "old_comment_raw": "@param handshakeMessage",
    "old_code_raw": "\tpublic boolean isConnected(HttpMessage handshakeMessage) {\n\t\tint historyId = handshakeMessage.getHistoryRef().getHistoryId();\n\t\tsynchronized (wsProxies) {\n\t\t\tfor (Entry<Integer, WebSocketProxy> entry : wsProxies.entrySet()) {\n\t\t\t\tWebSocketProxy proxy = entry.getValue();\n\t\t\t\tif (historyId == proxy.getHandshakeReference().getHistoryId()) {\n\t\t\t\t\treturn proxy.isConnected();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "new_code_raw": "\tpublic boolean isConnected(HistoryReference handshakeRef) {\n\t\tint historyId = handshakeRef.getHistoryId();\n\t\tsynchronized (wsProxies) {\n\t\t\tfor (Entry<Integer, WebSocketProxy> entry : wsProxies.entrySet()) {\n\t\t\t\tWebSocketProxy proxy = entry.getValue();\n\t\t\t\tif (historyId == proxy.getHandshakeReference().getHistoryId()) {\n\t\t\t\t\treturn proxy.isConnected();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-404-Param-1",
    "old_comment_raw": "@param callback The callback to be executed when the API call finishes",
    "old_code_raw": "  public Call createUsersWithArrayInputAsync(List<User> body, ApiCallback<Void> callback) throws ApiException {\n    Call call = createUsersWithArrayInputCall(body);\n    apiClient.executeAsync(call, callback);\n    return call;\n  }\n",
    "new_code_raw": "  public Call createUsersWithArrayInputAsync(java.util.List<User> body, ApiCallback<Void> callback) throws ApiException {\n    Call call = createUsersWithArrayInputCall(body);\n    apiClient.executeAsync(call, callback);\n    return call;\n  }\n"
  },
  {
    "id": "debezium_debezium-1255-Param-0",
    "old_comment_raw": "@param value the local or SQL date, time, or timestamp value; may not be null",
    "old_code_raw": "    public static int toMilliOfDay(Object value, TemporalAdjuster adjuster) {\n        if (value instanceof Duration) {\n            // int conversion is ok for the range of TIME\n            return (int) ((Duration) value).toMillis();\n        }\n        LocalTime time = Conversions.toLocalTime(value);\n        if (adjuster != null) {\n            time = time.with(adjuster);\n        }\n        long micros = Math.floorDiv(time.toNanoOfDay(), Conversions.NANOSECONDS_PER_MILLISECOND);\n        assert Math.abs(micros) < Integer.MAX_VALUE;\n        return (int) micros;\n    }\n",
    "new_code_raw": "    public static int toMilliOfDay(Object value, boolean acceptLargeValues) {\n        if (value instanceof Duration) {\n            Duration duration = (Duration) value;\n            if (!acceptLargeValues && (duration.isNegative() || duration.compareTo(ONE_DAY) > 0)) {\n                throw new IllegalArgumentException(\"Time values must be between 00:00:00 and 24:00:00 (inclusive): \" + duration);\n            }\n\n            // int conversion is ok for the range of TIME\n            return (int) ((Duration) value).toMillis();\n        }\n\n        // TODO only needed for SQL Server/Oracle, where we don't produce Duration right away;\n        // this should go eventually, as the conversion to LocalTime is superfluous\n        LocalTime time = Conversions.toLocalTime(value);\n        long micros = Math.floorDiv(time.toNanoOfDay(), Conversions.NANOSECONDS_PER_MILLISECOND);\n        assert Math.abs(micros) < Integer.MAX_VALUE;\n        return (int) micros;\n    }\n"
  },
  {
    "id": "zaproxy_zaproxy-2015-Param-2",
    "old_comment_raw": "@param a",
    "old_code_raw": "    private String algC(int m, int n, String a, String b) {\n        int i;\n        int j;\n        StringBuilder sb;\n\n        // Step 1\n        if (n == 0) {\n            sb = new StringBuilder();\n            \n        } else if (m == 1) {\n            sb = new StringBuilder();\n            for (j = 0; j < n; j++) {\n                if (a.charAt(0) == b.charAt(j)) {\n                    sb.append(a.charAt(0));\n                    break;\n                }\n            }\n\n        // Step 2\n        } else {\n            i = (int)Math.floor(((double) m) / 2);\n\n            // Step 3\n            int[] l1 = algB(i, n, a.substring(0, i), b);\n            int[] l2 = algB(m - i, n, reverseString(a.substring(i)), reverseString(b));\n\n            // Step 4\n            int k = findK(l1, l2, n);\n\n            // Step 5\n            sb = new StringBuilder(algC(i, k, a.substring(0, i), b.substring(0, k)));\n            sb.append(algC(m - i, n - k, a.substring(i), b.substring(k)));\n        }\n\n        // Return the LCS\n        return sb.toString();\n    }\n",
    "new_code_raw": "    private static void algC(StringBuilder sb, int m, int n, String a, String b) {\n        int i;\n        int j;\n\n        // Step 1\n        if (n == 0) {\n            // Nothing to do\n        } else if (m == 1) {\n            for (j = 0; j < n; j++) {\n                if (a.charAt(0) == b.charAt(j)) {\n                    sb.append(a.charAt(0));\n                    break;\n                }\n            }\n\n        // Step 2\n        } else {\n            i = (int)Math.floor(((double) m) / 2);\n\n            // Step 3\n            int[] l1 = algB(i, n, a.substring(0, i), b);\n            int[] l2 = algB(m - i, n, reverseString(a.substring(i)), reverseString(b));\n\n            // Step 4\n            int k = findK(l1, l2, n);\n\n            // Step 5\n            algC(sb, i, k, a.substring(0, i), b.substring(0, k));\n            algC(sb, m - i, n - k, a.substring(i), b.substring(k));\n        }\n    }\n"
  },
  {
    "id": "querydsl_querydsl-838-Param-0",
    "old_comment_raw": "@param args",
    "old_code_raw": "    public BooleanBuilder andAnyOf(EBoolean... args) {\n        if (args.length > 0){\n            and(anyOf(args));\n        }\n        return this;\n    }\n",
    "new_code_raw": "    public BooleanBuilder andAnyOf(Predicate... args) {\n        if (args.length > 0){\n            and(ExpressionUtils.anyOf(args));\n        }\n        return this;\n    }\n"
  },
  {
    "id": "SeleniumHQ_selenium-864-Param-1",
    "old_comment_raw": "@param registry - Registry",
    "old_code_raw": "  public static String getConsoleIconPath(DesiredCapabilities cap, Registry registry) {\n    String name = consoleIconName(cap, registry);\n    String path = \"org/openqa/grid/images/\";\n    InputStream in =\n        Thread.currentThread().getContextClassLoader()\n            .getResourceAsStream(path + name + \".png\");\n    if (in == null) {\n      return null;\n    }\n    return \"/grid/resources/\" + path + name + \".png\";\n  }\n",
    "new_code_raw": "  public static String getConsoleIconPath(DesiredCapabilities cap, GridRegistry registry) {\n    String name = consoleIconName(cap, registry);\n    String path = \"org/openqa/grid/images/\";\n    InputStream in =\n        Thread.currentThread().getContextClassLoader()\n            .getResourceAsStream(path + name + \".png\");\n    if (in == null) {\n      return null;\n    }\n    return \"/grid/resources/\" + path + name + \".png\";\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-461-Param-0",
    "old_comment_raw": "@param lowerLimit inclusive lower limit for fields to be compared, null means no limit",
    "old_code_raw": "    public static DateTimeComparator getInstance(DateTimeField lowerLimit, DateTimeField upperLimit) {\n        if (lowerLimit == null && upperLimit == null) {\n            return INSTANCE;\n        }\n        if (lowerLimit != null && upperLimit != null) {\n            if (lowerLimit.getDurationField().getUnitMillis() > upperLimit.getDurationField().getUnitMillis()) {\n                throw new IllegalArgumentException(\"Lower limit greater than upper: \" +\n                    lowerLimit.getName() + \" > \" + upperLimit.getName());\n            }\n        }\n        return new DateTimeComparator(lowerLimit, upperLimit);\n    }\n",
    "new_code_raw": "    public static DateTimeComparator getInstance(DateTimeFieldType lowerLimit, DateTimeFieldType upperLimit) {\n        if (lowerLimit == null && upperLimit == null) {\n            return ALL_INSTANCE;\n        }\n        if (lowerLimit == DateTimeFieldType.dayOfYear() && upperLimit == null) {\n            return DATE_INSTANCE;\n        }\n        if (lowerLimit == null && upperLimit == DateTimeFieldType.dayOfYear()) {\n            return TIME_INSTANCE;\n        }\n        return new DateTimeComparator(lowerLimit, upperLimit);\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-1189-Param-1",
    "old_comment_raw": "@param matches the number of matches expected to be found.  0 matches means that one or more matches are expected to be found",
    "old_code_raw": "\tpublic boolean searchButton(String regex, int matches) {\n\t\tboolean found = searcher.searchWithTimeoutFor(Button.class, regex, matches, true);\n\t\treturn found;\n\t}\n",
    "new_code_raw": "\tpublic boolean searchButton(String regex, int expectedMinimumNumberOfMatches) {\n\t\tboolean found = searcher.searchWithTimeoutFor(Button.class, regex, expectedMinimumNumberOfMatches, true);\n\t\treturn found;\n\t}\n"
  },
  {
    "id": "SeleniumHQ_selenium-177-Param-3",
    "old_comment_raw": "@param outputFile - The file to which we'll output the HTML results",
    "old_code_raw": "    public String runHTMLSuite(String browser, String browserURL, String suiteURL, File outputFile, int timeoutInSeconds, boolean multiWindow) throws IOException {\n        return runHTMLSuite(browser, browserURL, suiteURL, outputFile,\n                timeoutInSeconds, multiWindow, \"info\");\n    }\n",
    "new_code_raw": "    public String runHTMLSuite(String browser, String browserURL, String suiteURL, File outputFile, long timeoutInSeconds, boolean multiWindow) throws IOException {\n        return runHTMLSuite(browser, browserURL, suiteURL, outputFile,\n                timeoutInSeconds, multiWindow, \"info\");\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2606-Param-0",
    "old_comment_raw": "@param client client model (required)",
    "old_code_raw": "  public Client call123testSpecialTags(Client client) throws ApiException {\n    return call123testSpecialTagsWithHttpInfo(client).getData();\n      }\n",
    "new_code_raw": "  public Client call123testSpecialTags(Client body) throws ApiException {\n    return call123testSpecialTagsWithHttpInfo(body).getData();\n      }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1204-Param-0",
    "old_comment_raw": "@param old The old state of the entity.",
    "old_code_raw": "\tpublic int[] findModified(Object[] old, Object[] current, Object entity, SessionImplementor session)\n\t\t\tthrows HibernateException {\n\t\tint[] props = TypeHelper.findModified(\n\t\t\t\tentityMetamodel.getProperties(),\n\t\t\t\tcurrent,\n\t\t\t\told,\n\t\t\t\tpropertyColumnUpdateable,\n\t\t\t\thasUninitializedLazyProperties( entity ),\n\t\t\t\tsession\n\t\t);\n\t\tif ( props == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tlogDirtyProperties( props );\n\t\t\treturn props;\n\t\t}\n\t}\n",
    "new_code_raw": "\tpublic int[] findModified(Object[] old, Object[] current, Object entity, SharedSessionContractImplementor session)\n\t\t\tthrows HibernateException {\n\t\tint[] props = TypeHelper.findModified(\n\t\t\t\tentityMetamodel.getProperties(),\n\t\t\t\tcurrent,\n\t\t\t\told,\n\t\t\t\tpropertyColumnUpdateable,\n\t\t\t\thasUninitializedLazyProperties( entity ),\n\t\t\t\tsession\n\t\t);\n\t\tif ( props == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tlogDirtyProperties( props );\n\t\t\treturn props;\n\t\t}\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1681-Param-0",
    "old_comment_raw": "@param booleanPostBody Input boolean as post body (optional)",
    "old_code_raw": "  public Boolean fakeOuterBooleanSerialize(Boolean booleanPostBody) throws ApiException {\n    Object localVarPostBody = booleanPostBody;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/boolean\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"*/*\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/boolean\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"*/*\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "JodaOrg_joda_time-430-Param-1",
    "old_comment_raw": "@param era the era to update the time to.",
    "old_code_raw": "    public long set(long millis, int era) {\n        super.verifyValueBounds(era, DateTimeConstants.BCE, DateTimeConstants.CE);\n            \n        int oldEra = get(millis);\n        if (oldEra != era) {\n            int year = iChronology.year().get(millis);\n            return iChronology.year().set(millis, -year);\n        } else {\n            return millis;\n        }\n    }\n",
    "new_code_raw": "    public long set(long instant, int era) {\n        Utils.verifyValueBounds(this, era, DateTimeConstants.BCE, DateTimeConstants.CE);\n            \n        int oldEra = get(instant);\n        if (oldEra != era) {\n            int year = iChronology.year().get(instant);\n            return iChronology.year().set(instant, -year);\n        } else {\n            return instant;\n        }\n    }\n"
  },
  {
    "id": "android_platform_packages_providers_contactsprovider-20-Associations-Param1",
    "old_comment_raw": "@param account the explicitly provided Account",
    "old_code_raw": "    private boolean resolveAccount(ContentValues values, Account account) {\n        // If either is specified then both must be specified.\n        final String accountName = values.getAsString(RawContacts.ACCOUNT_NAME);\n        final String accountType = values.getAsString(RawContacts.ACCOUNT_TYPE);\n        if (!TextUtils.isEmpty(accountName) || !TextUtils.isEmpty(accountType)) {\n            final Account valuesAccount = new Account(accountName, accountType);\n            if (account != null && !valuesAccount.equals(account)) {\n                return false;\n            }\n            account = valuesAccount;\n        }\n        if (account != null) {\n            values.put(RawContacts.ACCOUNT_NAME, account.name);\n            values.put(RawContacts.ACCOUNT_TYPE, account.type);\n        }\n        return true;\n    }\n",
    "new_code_raw": "    private boolean resolveAccount(Uri uri, ContentValues values) {\n        String accountName = getQueryParameter(uri, RawContacts.ACCOUNT_NAME);\n        String accountType = getQueryParameter(uri, RawContacts.ACCOUNT_TYPE);\n\n        if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(accountType)) {\n            accountName = null;\n            accountType = null;\n        }\n\n        String valueAccountName = values.getAsString(RawContacts.ACCOUNT_NAME);\n        String valueAccountType = values.getAsString(RawContacts.ACCOUNT_TYPE);\n\n        if (TextUtils.isEmpty(valueAccountName) && TextUtils.isEmpty(valueAccountType)) {\n            values.put(RawContacts.ACCOUNT_NAME, accountName);\n            values.put(RawContacts.ACCOUNT_TYPE, accountType);\n        } else {\n            if (accountName != null && !accountName.equals(valueAccountName)) {\n                return false;\n            }\n\n            if (accountType != null && !accountType.equals(valueAccountType)) {\n                return false;\n            }\n\n            accountName = valueAccountName;\n            accountType = valueAccountType;\n        }\n\n        if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(accountType)) {\n            mAccount = null;\n            return true;\n        }\n\n        if (mAccount == null\n                || !mAccount.name.equals(accountName)\n                || !mAccount.type.equals(accountType)) {\n            mAccount = new Account(accountName, accountType);\n        }\n\n        return true;\n    }\n\n"
  },
  {
    "id": "hibernate_hibernate_orm-1500-Param-2",
    "old_comment_raw": "@param suppressTimeout should any TimeoutException be suppressed?",
    "old_code_raw": "   protected Object suspendAndGet(Object key, Flag opt, boolean suppressTimeout) throws CacheException {\n       Transaction tx = suspend();\n       try {\n           if (suppressTimeout)\n               return CacheHelper.getAllowingTimeout(cache, key);\n           else\n               return CacheHelper.get(cache, key);\n       } finally {\n           resume(tx);\n       }\n   }\n",
    "new_code_raw": "   protected Object suspendAndGet(Object key, FlagAdapter opt, boolean suppressTimeout) throws CacheException {\n       Transaction tx = suspend();\n       try {\n           if (suppressTimeout)\n               return cacheAdapter.getAllowingTimeout(key);\n           else\n               return cacheAdapter.get(key);\n       } finally {\n           resume(tx);\n       }\n   }\n"
  },
  {
    "id": "RobotiumTech_robotium-1001-Param-0",
    "old_comment_raw": "@param paus the time to paus",
    "old_code_raw": "\tpublic Activity getCurrentActivity(int paus) {\n\t\tif(paus > 0){\n\t\t\tRobotiumUtils.sleep(paus);\n\t\t\tinst.waitForIdleSync();\n\t\t}\n\t\tBoolean found = false;\n\t\tif (activityMonitor != null) {\n\t\t\tif (activityMonitor.getLastActivity() != null)\n\t\t\t\tactivity = activityMonitor.getLastActivity();\n\t\t}\n\t\tfor(Activity storedActivity : activityList){\n\t\t\tif (storedActivity.getClass().getName().equals(\n\t\t\t\t\tactivity.getClass().getName()))\n\t\t\t\tfound = true;\n\t\t}\n\t\tif (found)\n\t\t\treturn activity;\n\t\telse {\n\t\t\tactivityList.add(activity);\n\t\t\treturn activity;\n\t\t}\n\t}\n",
    "new_code_raw": "\tpublic Activity getCurrentActivity(int pause) {\n\t\tif(pause > 0){\n\t\t\tRobotiumUtils.sleep(pause);\n\t\t\tinst.waitForIdleSync();\n\t\t}\n\t\tBoolean found = false;\n\t\tif (activityMonitor != null) {\n\t\t\tif (activityMonitor.getLastActivity() != null)\n\t\t\t\tactivity = activityMonitor.getLastActivity();\n\t\t}\n\t\tfor(Activity storedActivity : activityList){\n\t\t\tif (storedActivity.getClass().getName().equals(\n\t\t\t\t\tactivity.getClass().getName()))\n\t\t\t\tfound = true;\n\t\t}\n\t\tif (found)\n\t\t\treturn activity;\n\t\telse {\n\t\t\tactivityList.add(activity);\n\t\t\treturn activity;\n\t\t}\n\t}\n"
  },
  {
    "id": "elastic_elasticsearch_hadoop-13-Param-1",
    "old_comment_raw": "@param reader scroll reader",
    "old_code_raw": "    ScrollQuery scan(String query, ScrollReader reader) throws IOException {\n        String[] scrollInfo = client.scan(query);\n        String scrollId = scrollInfo[0];\n        long totalSize = Long.parseLong(scrollInfo[1]);\n        return new ScrollQuery(this, scrollId, totalSize, reader);\n    }\n",
    "new_code_raw": "    ScrollQuery scan(String query, BytesArray body, ScrollReader reader) throws IOException {\n        String[] scrollInfo = client.scan(query, body);\n        String scrollId = scrollInfo[0];\n        long totalSize = Long.parseLong(scrollInfo[1]);\n        return new ScrollQuery(this, scrollId, totalSize, reader);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1690-Param-1",
    "old_comment_raw": "@param file file to upload",
    "old_code_raw": "    public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, Map<String, Object> params) throws IOException {\n        HttpResponse response = uploadFileWithRequiredFileForHttpResponse(petId, file, params);\n        TypeReference typeRef = new TypeReference<ModelApiResponse>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n",
    "new_code_raw": "    public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, Map<String, Object> params) throws IOException {\n        HttpResponse response = uploadFileWithRequiredFileForHttpResponse(petId, requiredFile, params);\n        TypeReference typeRef = new TypeReference<ModelApiResponse>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n"
  },
  {
    "id": "runelite_runelite-17-Param-0",
    "old_comment_raw": "@param itemId",
    "old_code_raw": "\tprivate BufferedImage loadImage(int itemId, int quantity)\n\t{\n\t\tSpritePixels sprite = client.createItemSprite(itemId, quantity, 1, SpritePixels.DEFAULT_SHADOW_COLOR, 0, false);\n\t\treturn sprite.toBufferedImage();\n\t}\n",
    "new_code_raw": "\tprivate BufferedImage loadImage(int itemId, int quantity, boolean stackable)\n\t{\n\t\tSpritePixels sprite = client.createItemSprite(itemId, quantity, 1, SpritePixels.DEFAULT_SHADOW_COLOR, stackable ? 1 : 0, false);\n\t\treturn sprite.toBufferedImage();\n\t}\n"
  },
  {
    "id": "JodaOrg_joda_time-440-Param-0",
    "old_comment_raw": "@param millis the time instant in millis to update.",
    "old_code_raw": "    public long set(long millis, int year) {\n        super.verifyValueBounds(year, iChronology.getMinYear(), iChronology.getMaxYear());\n\n        int dayOfYear = iChronology.dayOfYear().get(millis);\n        int millisOfDay = iChronology.millisOfDay().get(millis);\n\n        if (dayOfYear > (31 + 28)) { // after Feb 28\n            if (isLeap(millis)) {\n                // Old date is Feb 29 or later.\n                if (!iChronology.isLeapYear(year)) {\n                    // Moving to a non-leap year, Feb 29 does not exist.\n                    dayOfYear--;\n                }\n            } else {\n                // Old date is Mar 01 or later.\n                if (iChronology.isLeapYear(year)) {\n                    // Moving to a leap year, account for Feb 29.\n                    dayOfYear++;\n                }\n            }\n        }\n\n        millis = iChronology.getYearMonthDayMillis(year, 1, dayOfYear);\n        millis += millisOfDay;\n\n        return millis;\n    }\n",
    "new_code_raw": "    public long set(long instant, int year) {\n        Utils.verifyValueBounds\n            (this, year, iChronology.getMinYear(), iChronology.getMaxYear());\n\n        int dayOfYear = iChronology.dayOfYear().get(instant);\n        int millisOfDay = iChronology.millisOfDay().get(instant);\n\n        if (dayOfYear > (31 + 28)) { // after Feb 28\n            if (isLeap(instant)) {\n                // Old date is Feb 29 or later.\n                if (!iChronology.isLeapYear(year)) {\n                    // Moving to a non-leap year, Feb 29 does not exist.\n                    dayOfYear--;\n                }\n            } else {\n                // Old date is Mar 01 or later.\n                if (iChronology.isLeapYear(year)) {\n                    // Moving to a leap year, account for Feb 29.\n                    dayOfYear++;\n                }\n            }\n        }\n\n        instant = iChronology.getYearMonthDayMillis(year, 1, dayOfYear);\n        instant += millisOfDay;\n\n        return instant;\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-104-Param-2",
    "old_comment_raw": "@param queryParams The query parameters",
    "old_code_raw": "  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String contentType) throws ApiException {\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder = client.resource(basePath + path + querystring).accept(\"application/json\");\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n",
    "new_code_raw": "  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType) throws ApiException {\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n"
  },
  {
    "id": "querydsl_querydsl-1441-Param-1",
    "old_comment_raw": "@param value",
    "old_code_raw": "    protected String convert(Path<?> path, Object value){\n        return value.toString();\n    }\n",
    "new_code_raw": "    protected String[] convert(Path<?> leftHandSide, Object rightHandSide) {\n        String str = rightHandSide.toString();\n        if (lowerCase){\n            str = str.toLowerCase();\n        }\n        if (splitTerms) {            \n            if (str.equals(\"\")) {\n                return new String[] { str };\n            } else {\n                return StringUtils.split(str);\n            }\n        } else {\n            return new String[] { str };\n        }\n    }\n"
  },
  {
    "id": "runelite_runelite-166-Param-0",
    "old_comment_raw": "@param itemId item id",
    "old_code_raw": "\tpublic ItemStats getItemStats(int itemId)\n\t{\n\t\tItemComposition itemComposition = getItemComposition(itemId);\n\n\t\tif (itemComposition == null || itemComposition.getName() == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\treturn itemStats.get(itemComposition.getName());\n\t}\n",
    "new_code_raw": "\tpublic ItemStats getItemStats(int itemId, boolean allowNote)\n\t{\n\t\tItemComposition itemComposition = getItemComposition(itemId);\n\n\t\tif (itemComposition == null || itemComposition.getName() == null || (!allowNote && itemComposition.getNote() != -1))\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\treturn itemStats.get(canonicalize(itemId));\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1651-Param-0",
    "old_comment_raw": "@param body client model",
    "old_code_raw": "    public Client testClassname(Client body, Map<String, Object> params) throws IOException {\n        HttpResponse response = testClassnameForHttpResponse(body, params);\n        TypeReference typeRef = new TypeReference<Client>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n",
    "new_code_raw": "    public Client testClassname(Client client, Map<String, Object> params) throws IOException {\n        HttpResponse response = testClassnameForHttpResponse(client, params);\n        TypeReference typeRef = new TypeReference<Client>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n"
  },
  {
    "id": "debezium_debezium-140-Param-0",
    "old_comment_raw": "@param record the state of the record as read; may not be null",
    "old_code_raw": "    public Struct read(Struct record, Struct source, Long timestamp) {\n        Struct struct = new Struct(schema);\n        struct.put(FieldName.OPERATION, Operation.READ.code());\n        struct.put(FieldName.AFTER, record);\n        if (source != null) struct.put(FieldName.SOURCE, source);\n        if (timestamp != null) struct.put(FieldName.TIMESTAMP, timestamp);\n        return struct;\n    }\n",
    "new_code_raw": "    public Struct read(Object record, Struct source, Long timestamp) {\n        Struct struct = new Struct(schema);\n        struct.put(FieldName.OPERATION, Operation.READ.code());\n        struct.put(FieldName.AFTER, record);\n        if (source != null) struct.put(FieldName.SOURCE, source);\n        if (timestamp != null) struct.put(FieldName.TIMESTAMP, timestamp);\n        return struct;\n    }\n"
  },
  {
    "id": "SeleniumHQ_selenium-848-Param-0",
    "old_comment_raw": "@param path path to file to locate from root of project",
    "old_code_raw": "  public static Path locate(String path) {\n    Path actualPath = Paths.get(path);\n    if (Files.exists(actualPath)) {\n      return actualPath.toAbsolutePath();\n    }\n\n    // Find the rakefile first\n    Path dir = Paths.get(\".\").toAbsolutePath();\n    Path pwd = dir;\n    while (dir != null && !dir.equals(dir.getParent())) {\n      Path versionFile = dir.resolve(\"java/version.bzl\");\n      if (Files.exists(versionFile)) {\n        break;\n      }\n      dir = dir.getParent();\n    }\n    Preconditions.checkNotNull(dir, \"Unable to find root of project in %s when looking for %s\", pwd, path);\n    dir = dir.normalize();\n\n    Path needle = dir.resolve(path);\n    if (Files.exists(needle)) {\n      return needle;\n    }\n\n    throw new WebDriverException(new FileNotFoundException(\n        \"Could not find \" + path + \" in the project\"));\n  }\n",
    "new_code_raw": "  public static Path locate(String... paths) {\n    Preconditions.checkArgument(paths.length > 0);\n    return Stream.of(paths)\n        .map(path -> Paths.get(path))\n        .filter(path -> Files.exists(path))\n        .findFirst()\n        .map(path -> path.toAbsolutePath())\n        .orElseGet(() -> {\n          Path root = findProjectRoot();\n          return Stream.of(paths)\n              .map(path -> {\n                Path needle = root.resolve(path);\n                return Files.exists(needle) ? needle : null;\n              })\n              .filter(Objects::nonNull)\n              .findFirst().orElseThrow(() -> new WebDriverException(new FileNotFoundException(\n                  String.format(\"Could not find any of %s in the project\",\n                                Stream.of(paths).collect(Collectors.joining(\",\"))))));\n        });\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-441-Param-5",
    "old_comment_raw": "@param formParams The form parameters",
    "old_code_raw": "  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    final String url = buildUrl(path, queryParams);\n    final Request.Builder reqBuilder = new Request.Builder().url(url);\n    processHeaderParams(headerParams, reqBuilder);\n\n    String contentType = (String) headerParams.get(\"Content-Type\");\n    // ensuring a default content type\n    if (contentType == null) contentType = \"application/json\";\n\n    RequestBody reqBody;\n    if (!HttpMethod.permitsRequestBody(method)) {\n      reqBody = null;\n    } else if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n      reqBody = buildRequestBodyFormEncoding(formParams);\n    } else if (\"multipart/form-data\".equals(contentType)) {\n      reqBody = buildRequestBodyMultipart(formParams);\n    } else if (body == null) {\n      if (\"DELETE\".equals(method)) {\n        // allow calling DELETE without sending a request body\n        reqBody = null;\n      } else {\n        // use an empty request body (for POST, PUT and PATCH)\n        reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n      }\n    } else {\n      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));\n    }\n\n    Request request = reqBuilder.method(method, reqBody).build();\n    return httpClient.newCall(request);\n  }\n",
    "new_code_raw": "  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    final String url = buildUrl(path, queryParams);\n    final Request.Builder reqBuilder = new Request.Builder().url(url);\n    processHeaderParams(headerParams, reqBuilder);\n\n    String contentType = (String) headerParams.get(\"Content-Type\");\n    // ensuring a default content type\n    if (contentType == null) contentType = \"application/json\";\n\n    RequestBody reqBody;\n    if (!HttpMethod.permitsRequestBody(method)) {\n      reqBody = null;\n    } else if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n      reqBody = buildRequestBodyFormEncoding(formParams);\n    } else if (\"multipart/form-data\".equals(contentType)) {\n      reqBody = buildRequestBodyMultipart(formParams);\n    } else if (body == null) {\n      if (\"DELETE\".equals(method)) {\n        // allow calling DELETE without sending a request body\n        reqBody = null;\n      } else {\n        // use an empty request body (for POST, PUT and PATCH)\n        reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n      }\n    } else {\n      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));\n    }\n\n    Request request = null;\n\n    if(progressRequestListener != null) {\n      ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener);\n      request = reqBuilder.method(method, progressRequestBody).build();\n    } else {\n      request = reqBuilder.method(method, reqBody).build();\n    }\n\n    return httpClient.newCall(request);\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2580-Param-0",
    "old_comment_raw": "@param body order placed for purchasing the pet (required)",
    "old_code_raw": "  public Order placeOrder(Order body) throws ApiException {\n    return placeOrderWithHttpInfo(body).getData();\n      }\n",
    "new_code_raw": "  public Order placeOrder(Order order) throws ApiException {\n    return placeOrderWithHttpInfo(order).getData();\n      }\n"
  },
  {
    "id": "apache_drill-829-Param-0",
    "old_comment_raw": "@param path the path of the directory",
    "old_code_raw": "  private ParquetTableMetadata_v4 getParquetTableMetadata(String path, FileSystem fs) throws IOException {\n    Path p = new Path(path);\n    FileStatus fileStatus = fs.getFileStatus(p);\n    Stopwatch watch = logger.isDebugEnabled() ? Stopwatch.createStarted() : null;\n    List<FileStatus> fileStatuses = new ArrayList<>();\n    if (fileStatus.isFile()) {\n      fileStatuses.add(fileStatus);\n    } else {\n      fileStatuses.addAll(DrillFileSystemUtil.listFiles(fs, p, true));\n    }\n    if (watch != null) {\n      logger.debug(\"Took {} ms to get file statuses\", watch.elapsed(TimeUnit.MILLISECONDS));\n      watch.reset();\n      watch.start();\n    }\n\n    Map<FileStatus, FileSystem> fileStatusMap = fileStatuses.stream()\n        .collect(\n            java.util.stream.Collectors.toMap(\n                Function.identity(),\n                s -> fs,\n                (oldFs, newFs) -> newFs,\n                LinkedHashMap::new));\n\n    ParquetTableMetadata_v4 metadata_v4 = getParquetTableMetadata(fileStatusMap);\n    if (watch != null) {\n      logger.debug(\"Took {} ms to read file metadata\", watch.elapsed(TimeUnit.MILLISECONDS));\n      watch.stop();\n    }\n    return metadata_v4;\n  }\n",
    "new_code_raw": "  private ParquetTableMetadata_v4 getParquetTableMetadata(Path path, FileSystem fs) throws IOException {\n    FileStatus fileStatus = fs.getFileStatus(path);\n    Stopwatch watch = logger.isDebugEnabled() ? Stopwatch.createStarted() : null;\n    List<FileStatus> fileStatuses = new ArrayList<>();\n    if (fileStatus.isFile()) {\n      fileStatuses.add(fileStatus);\n    } else {\n      // the thing we need!?\n      fileStatuses.addAll(DrillFileSystemUtil.listFiles(fs, path, true));\n    }\n    if (watch != null) {\n      logger.debug(\"Took {} ms to get file statuses\", watch.elapsed(TimeUnit.MILLISECONDS));\n      watch.reset();\n      watch.start();\n    }\n\n    Map<FileStatus, FileSystem> fileStatusMap = fileStatuses.stream()\n        .collect(\n            java.util.stream.Collectors.toMap(\n                Function.identity(),\n                s -> fs,\n                (oldFs, newFs) -> newFs,\n                LinkedHashMap::new));\n\n    ParquetTableMetadata_v4 metadata_v4 = getParquetTableMetadata(fileStatusMap);\n    if (watch != null) {\n      logger.debug(\"Took {} ms to read file metadata\", watch.elapsed(TimeUnit.MILLISECONDS));\n      watch.stop();\n    }\n    return metadata_v4;\n  }\n"
  },
  {
    "id": "runelite_runelite-143-Param-0",
    "old_comment_raw": "@param quantity The quantity to convert.",
    "old_code_raw": "\tpublic static String quantityToStackSize(int quantity)\n\t{\n\t\tif (quantity < 0)\n\t\t{\n\t\t\t// Integer.MIN_VALUE = -1 * Integer.MIN_VALUE so we need to correct for it.\n\t\t\treturn \"-\" + quantityToStackSize(quantity == Integer.MIN_VALUE ? Integer.MAX_VALUE : -quantity);\n\t\t}\n\t\telse if (quantity < 10_000)\n\t\t{\n\t\t\treturn NUMBER_FORMATTER.format(quantity);\n\t\t}\n\n\t\tString suffix = SUFFIXES[0];\n\t\tint divideBy = 1;\n\n\t\t// determine correct suffix by iterating backward through the list\n\t\t// of suffixes until the suffix results in a value >= 1\n\t\tfor (int i = (SUFFIXES.length - 1); i >= 0; i--)\n\t\t{\n\t\t\tdivideBy = (int) Math.pow(10, i * 3);\n\t\t\tif ((float) quantity / divideBy >= 1)\n\t\t\t{\n\t\t\t\tsuffix = SUFFIXES[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// get locale formatted string\n\t\tString formattedString = NUMBER_FORMATTER.format((float) quantity / divideBy);\n\n\t\t// strip down any digits past the 4 first\n\t\tformattedString = (formattedString.length() > 4 ? formattedString.substring(0, 4) : formattedString);\n\n\t\t// make sure the last character is not a \".\"\n\t\treturn (formattedString.endsWith(\".\") ? formattedString.substring(0, 3) : formattedString) + suffix;\n\t}\n",
    "new_code_raw": "\tpublic static String quantityToStackSize(long quantity)\n\t{\n\t\tif (quantity < 0)\n\t\t{\n\t\t\t// Long.MIN_VALUE = -1 * Long.MIN_VALUE so we need to correct for it.\n\t\t\treturn \"-\" + quantityToStackSize(quantity == Long.MIN_VALUE ? Long.MAX_VALUE : -quantity);\n\t\t}\n\t\telse if (quantity < 10_000)\n\t\t{\n\t\t\treturn NUMBER_FORMATTER.format(quantity);\n\t\t}\n\n\t\tString suffix = SUFFIXES[0];\n\t\tlong divideBy = 1;\n\n\t\t// determine correct suffix by iterating backward through the list\n\t\t// of suffixes until the suffix results in a value >= 1\n\t\tfor (int i = (SUFFIXES.length - 1); i >= 0; i--)\n\t\t{\n\t\t\tdivideBy = (long) Math.pow(10, i * 3);\n\t\t\tif ((double) quantity / divideBy >= 1)\n\t\t\t{\n\t\t\t\tsuffix = SUFFIXES[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// get locale formatted string\n\t\tString formattedString = NUMBER_FORMATTER.format((double) quantity / divideBy);\n\n\t\t// strip down any digits past the 4 first\n\t\tformattedString = (formattedString.length() > 4 ? formattedString.substring(0, 4) : formattedString);\n\n\t\t// make sure the last character is not a \".\"\n\t\treturn (formattedString.endsWith(\".\") ? formattedString.substring(0, 3) : formattedString) + suffix;\n\t}\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-1494-Param-0",
    "old_comment_raw": "@param props The properties to use in the  edu.stanford.nlp.pipeline.WordsToSentencesAnnotator.",
    "old_code_raw": "  protected List<Sentence> sentences(Properties props, Annotator tokenizer) {\n    if (sentences == null) {\n      Annotator ssplit = (props == EMPTY_PROPS || props == SINGLE_SENTENCE_DOCUMENT) ? defaultSSplit : AnnotatorFactories.sentenceSplit(props, backend).create();\n      // Annotate\n      Annotation ann = new Annotation(this.impl.getText());\n      tokenizer.annotate(ann);\n      ssplit.annotate(ann);\n      // Grok results\n      // (docid)\n      if (ann.containsKey(CoreAnnotations.DocIDAnnotation.class)) {\n        impl.setDocID(ann.get(CoreAnnotations.DocIDAnnotation.class));\n      }\n      // (sentences)\n      List<CoreMap> sentences = ann.get(CoreAnnotations.SentencesAnnotation.class);\n      this.sentences = new ArrayList<>(sentences.size());\n      for (CoreMap sentence : sentences) {\n        //Sentence sent = new Sentence(this, sentence);\n        Sentence sent = new Sentence(this, this.serializer.toProtoBuilder(sentence), sentence.get(CoreAnnotations.TextAnnotation.class), defaultProps);\n        this.sentences.add(sent);\n        this.impl.addSentence(sent.serialize());\n      }\n    }\n\n    return sentences;\n  }\n",
    "new_code_raw": "  public List<Sentence> sentences(Properties props) {\n    if (sentences == null) {\n      // Get annotators\n      Annotator tokenizer = (props == EMPTY_PROPS || props == SINGLE_SENTENCE_DOCUMENT) ? defaultTokenize : AnnotatorFactories.tokenize(props, backend).create();\n      Annotator ssplit = (props == EMPTY_PROPS || props == SINGLE_SENTENCE_DOCUMENT) ? defaultSSplit : AnnotatorFactories.sentenceSplit(props, backend).create();\n      // Annotate\n      Annotation ann = new Annotation(this.impl.getText());\n      tokenizer.annotate(ann);\n      ssplit.annotate(ann);\n      // Grok results\n      // (docid)\n      if (ann.containsKey(CoreAnnotations.DocIDAnnotation.class)) {\n        impl.setDocID(ann.get(CoreAnnotations.DocIDAnnotation.class));\n      }\n      // (sentences)\n      List<CoreMap> sentences = ann.get(CoreAnnotations.SentencesAnnotation.class);\n      this.sentences = new ArrayList<>(sentences.size());\n      for (CoreMap sentence : sentences) {\n        //Sentence sent = new Sentence(this, sentence);\n        Sentence sent = new Sentence(this, this.serializer.toProtoBuilder(sentence), sentence.get(CoreAnnotations.TextAnnotation.class), defaultProps);\n        this.sentences.add(sent);\n        this.impl.addSentence(sent.serialize());\n      }\n    }\n\n    return sentences;\n  }\n"
  },
  {
    "id": "Atmosphere_atmosphere-824-Param-1",
    "old_comment_raw": "@param response the  HttpServletResponse",
    "old_code_raw": "    public Action suspended(HttpServletRequest request, HttpServletResponse response)\n            throws IOException, ServletException {\n        return action(request, response);\n    }\n",
    "new_code_raw": "    public Action suspended(AtmosphereRequest request, AtmosphereResponse response)\n            throws IOException, ServletException {\n        return action(request, response);\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-797-Param-1",
    "old_comment_raw": "@param on The 'on' condition.",
    "old_code_raw": "\tprotected boolean addCondition(StringBuffer buffer, String on) {\n\t\tif ( StringHelper.isNotEmpty( on ) ) {\n\t\t\tif ( !on.startsWith( \" and\" ) ) buffer.append( \" and \" );\n\t\t\tbuffer.append( on );\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n",
    "new_code_raw": "\tprotected boolean addCondition(StringBuilder buffer, String on) {\n\t\tif ( StringHelper.isNotEmpty( on ) ) {\n\t\t\tif ( !on.startsWith( \" and\" ) ) buffer.append( \" and \" );\n\t\t\tbuffer.append( on );\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-231-Param-2",
    "old_comment_raw": "@param docid The id of the document we are de-serializing.",
    "old_code_raw": "  public static RelationTriple fromProto(CoreNLPProtos.RelationTriple proto, List<CoreLabel> sentence, String docid) {\n    if (Thread.interrupted()) {\n      throw new RuntimeInterruptedException();\n    }\n    // Get the spans for the extraction\n    List<CoreLabel> subject = proto.getSubjectTokensList().stream().map(sentence::get).collect(Collectors.toList());\n    List<CoreLabel> relation;\n    if (proto.getRelationTokensCount() == 0) {  // If we don't have a real span for the relation, make a dummy word\n      relation = Collections.singletonList(new CoreLabel(new Word(proto.getRelation())));\n    } else {\n      relation = proto.getRelationTokensList().stream().map(sentence::get).collect(Collectors.toList());\n    }\n    List<CoreLabel> object = proto.getObjectTokensList().stream().map(sentence::get).collect(Collectors.toList());\n\n    // Create the extraction\n    RelationTriple extraction;\n    double confidence = proto.getConfidence();\n    if (proto.hasTree()) {\n      SemanticGraph tree = fromProto(proto.getTree(), sentence, docid);\n      extraction =  new RelationTriple.WithTree(subject, relation, object, tree, confidence);\n    } else {\n      extraction = new RelationTriple(subject, relation, object, confidence);\n    }\n\n    // Tweak the extraction\n    if (proto.hasIstmod()) { extraction.istmod(proto.getIstmod()); }\n    if (proto.hasPrefixBe()) { extraction.isPrefixBe(proto.getPrefixBe()); }\n    if (proto.hasSuffixBe()) { extraction.isSuffixBe(proto.getSuffixBe()); }\n    if (proto.hasSuffixOf()) { extraction.isSuffixOf(proto.getSuffixOf()); }\n\n    // Return\n    return extraction;\n  }\n",
    "new_code_raw": "  public static RelationTriple fromProto(CoreNLPProtos.RelationTriple proto, Annotation doc, int sentenceIndex) {\n    if (Thread.interrupted()) {\n      throw new RuntimeInterruptedException();\n    }\n    // Get the spans for the extraction\n    List<CoreLabel> subject = proto.getSubjectTokensList().stream().map(loc ->\n        doc.get(SentencesAnnotation.class).get(loc.getSentenceIndex()).get(TokensAnnotation.class).get(loc.getTokenIndex())\n        ).collect(Collectors.toList());\n    List<CoreLabel> relation;\n    if (proto.getRelationTokensCount() == 0) {  // If we don't have a real span for the relation, make a dummy word\n      relation = Collections.singletonList(new CoreLabel(new Word(proto.getRelation())));\n    } else {\n      relation = proto.getRelationTokensList().stream().map(loc ->\n          doc.get(SentencesAnnotation.class).get(loc.getSentenceIndex()).get(TokensAnnotation.class).get(loc.getTokenIndex())\n      ).collect(Collectors.toList());\n    }\n    List<CoreLabel> object = proto.getObjectTokensList().stream().map(loc ->\n        doc.get(SentencesAnnotation.class).get(loc.getSentenceIndex()).get(TokensAnnotation.class).get(loc.getTokenIndex())\n    ).collect(Collectors.toList());\n\n    // Create the extraction\n    RelationTriple extraction;\n    double confidence = proto.getConfidence();\n    if (proto.hasTree()) {\n      SemanticGraph tree = fromProto(\n          proto.getTree(),\n          doc.get(SentencesAnnotation.class).get(sentenceIndex).get(TokensAnnotation.class),\n          doc.get(DocIDAnnotation.class),\n          Optional.of(doc));\n      extraction =  new RelationTriple.WithTree(subject, relation, object, tree, confidence);\n    } else {\n      extraction = new RelationTriple(subject, relation, object, confidence);\n    }\n\n    // Tweak the extraction\n    if (proto.hasIstmod()) { extraction.istmod(proto.getIstmod()); }\n    if (proto.hasPrefixBe()) { extraction.isPrefixBe(proto.getPrefixBe()); }\n    if (proto.hasSuffixBe()) { extraction.isSuffixBe(proto.getSuffixBe()); }\n    if (proto.hasSuffixOf()) { extraction.isSuffixOf(proto.getSuffixOf()); }\n\n    // Return\n    return extraction;\n  }\n"
  },
  {
    "id": "RobotiumTech_robotium-1510-Param-0",
    "old_comment_raw": "@param direction the direction to be scrolled",
    "old_code_raw": "\tprivate boolean scrollScrollView(int direction, ArrayList<ScrollView> scrollViews){\n\t\tfinal ScrollView scroll = viewFetcher.getView(ScrollView.class, scrollViews);\n\t\tint scrollAmount = 0;\n\t\t\n\t\tif(scroll != null){\n\t\t\tint height = scroll.getHeight();\n\t\t\theight--;\n\t\t\tint scrollTo = 0;\n\n\t\t\tif (direction == DOWN) {\n\t\t\t\tscrollTo = (height);\n\t\t\t}\n\n\t\t\telse if (direction == UP) {\n\t\t\t\tscrollTo = (-height);\n\t\t\t}\n\t\t\tscrollAmount = scroll.getScrollY();\n\t\t\tscrollScrollViewTo(scroll,0, scrollTo);\n\t\t\tif (scrollAmount == scroll.getScrollY()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "new_code_raw": "\tprivate boolean scrollScrollView(final ScrollView view, int direction){\n\t\t\n\t\t\n\t\tif(view == null){\n\t\t\tLog.e(TAG, \"ScrollView was null\");\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tint height = view.getHeight();\n\t\theight--;\n\t\tint scrollTo = -1;\n\n\t\tif (direction == DOWN) {\n\t\t\tscrollTo = height;\n\t\t}\n\n\t\telse if (direction == UP) {\n\t\t\tscrollTo = -height;\n\t\t}\n\t\t\n\t\tint originalY = view.getScrollY();\n\t\tfinal int scrollAmount = scrollTo;\n\t\tinst.runOnMainSync(new Runnable(){\n\t\t\tpublic void run(){\n\t\t\t\tview.scrollBy(0, scrollAmount);\n\t\t\t}\n\t\t});\n\t\t\n\t\tif (originalY == view.getScrollY()) {\n\t\t\treturn false;\n\t\t}\n\t\telse{\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t\n\t}\n"
  },
  {
    "id": "apache_drill-287-Param-1",
    "old_comment_raw": "@param path The path to the metadata file, located in the directory that contains the parquet files",
    "old_code_raw": "  public static ParquetTableMetadataBase readBlockMeta(FileSystem fs, String path, MetadataContext metaContext) throws IOException {\n    Metadata metadata = new Metadata(fs);\n    metadata.readBlockMeta(path, false, metaContext);\n    return metadata.parquetTableMetadata;\n  }\n",
    "new_code_raw": "  public static ParquetTableMetadataBase readBlockMeta(FileSystem fs, String path, MetadataContext metaContext, ParquetFormatConfig formatConfig) throws IOException {\n    Metadata metadata = new Metadata(fs, formatConfig);\n    metadata.readBlockMeta(path, false, metaContext);\n    return metadata.parquetTableMetadata;\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-432-Param-0",
    "old_comment_raw": "@param millis the time instant in millis to update.",
    "old_code_raw": "    public long addWrapped(long millis, int months) {\n        return set(millis, getWrappedValue(get(millis), months, MIN, MAX));\n    }\n",
    "new_code_raw": "    public long addWrapped(long instant, int months) {\n        return set(instant, Utils.getWrappedValue(get(instant), months, MIN, MAX));\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1842-Param-5",
    "old_comment_raw": "@param source The session which is the source of the current event.",
    "old_code_raw": "\tprivate static boolean shouldDelayIdentityInserts(boolean requiresImmediateIdAccess, EventSource source) {\n\t\treturn shouldDelayIdentityInserts( requiresImmediateIdAccess, isPartOfTransaction( source ), source.getHibernateFlushMode() );\n\t}\n",
    "new_code_raw": "\tprivate static boolean shouldDelayIdentityInserts(boolean requiresImmediateIdAccess, EventSource source, EntityPersister persister) {\n\t\treturn shouldDelayIdentityInserts( requiresImmediateIdAccess, isPartOfTransaction( source ), source.getHibernateFlushMode(), persister );\n\t}\n"
  },
  {
    "id": "processing_processing-1244-Param-0",
    "old_comment_raw": "@param parent The PGraphics object (or any object, really) associated",
    "old_code_raw": "  public Object getCache(Object parent) {\n    if (cacheMap == null) return null;\n    return cacheMap.get(parent);\n  }\n",
    "new_code_raw": "  public Object getCache(PGraphics renderer) {\n    if (cacheMap == null) return null;\n    return cacheMap.get(renderer);\n  }\n"
  },
  {
    "id": "apache_calcite-769-Param-3",
    "old_comment_raw": "@param groupSet Bit set of grouping fields",
    "old_code_raw": "  public boolean isValid(Litmus litmus) {\n    return super.isValid(litmus)\n        && litmus.check(Util.isDistinct(getRowType().getFieldNames()),\n            \"distinct field names: {}\", getRowType());\n  }\n",
    "new_code_raw": "  public boolean isValid(Litmus litmus, Context context) {\n    return super.isValid(litmus, context)\n        && litmus.check(Util.isDistinct(getRowType().getFieldNames()),\n            \"distinct field names: {}\", getRowType());\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1697-Param-1",
    "old_comment_raw": "@param file file to upload (required)",
    "old_code_raw": "    public Single<ModelApiResponse> rxUploadFileWithRequiredFile(Long petId, AsyncFile file, String additionalMetadata) {\n        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {\n            delegate.uploadFileWithRequiredFile(petId, file, additionalMetadata, fut);\n        }));\n    }\n",
    "new_code_raw": "    public Single<ModelApiResponse> rxUploadFileWithRequiredFile(Long petId, AsyncFile requiredFile, String additionalMetadata) {\n        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {\n            delegate.uploadFileWithRequiredFile(petId, requiredFile, additionalMetadata, fut);\n        }));\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-1190-Param-0",
    "old_comment_raw": "@param regex the text to search for. The parameter will be interpreted as a regular expression.",
    "old_code_raw": "\tpublic boolean searchToggleButton(String regex, int matches) {\n\t\tboolean found = searcher.searchWithTimeoutFor(ToggleButton.class, regex, matches, true);\n\t\treturn found;\n\t}\n",
    "new_code_raw": "\tpublic boolean searchToggleButton(String regex, int expectedMinimumNumberOfMatches) {\n\t\tboolean found = searcher.searchWithTimeoutFor(ToggleButton.class, regex, expectedMinimumNumberOfMatches, true);\n\t\treturn found;\n\t}\n"
  },
  {
    "id": "debezium_debezium-1246-Param-1",
    "old_comment_raw": "@param preparer the function that supplied arguments to the prepared statement; may not be null",
    "old_code_raw": "    public JdbcConnection prepareQuery(String[] multiQuery, StatementPreparer preparer, BlockingMultiResultSetConsumer resultConsumer) throws SQLException, InterruptedException {\n        final Connection conn = connection();\n        final ResultSet[] resultSets = new ResultSet[multiQuery.length];\n        final PreparedStatement[] preparedStatements = new PreparedStatement[multiQuery.length];\n\n        try {\n            for (int i = 0; i < multiQuery.length; i++) {\n                final String query = multiQuery[i];\n                if (LOGGER.isTraceEnabled()) {\n                    LOGGER.trace(\"running '{}'\", query);\n                }\n                final PreparedStatement statement = createPreparedStatement(query);\n                preparedStatements[i] = statement;\n                preparer.accept(statement);\n                resultSets[i] = statement.executeQuery();\n            }\n            if (resultConsumer != null) {\n                resultConsumer.accept(resultSets);\n            }\n        }\n        finally {\n            for (ResultSet rs: resultSets) {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    }\n                    catch (Exception ei) {\n                    }\n                }\n            }\n        }\n        return this;\n    }\n",
    "new_code_raw": "    public JdbcConnection prepareQuery(String[] multiQuery, StatementPreparer[] preparers, BlockingMultiResultSetConsumer resultConsumer) throws SQLException, InterruptedException {\n        final ResultSet[] resultSets = new ResultSet[multiQuery.length];\n        final PreparedStatement[] preparedStatements = new PreparedStatement[multiQuery.length];\n\n        try {\n            for (int i = 0; i < multiQuery.length; i++) {\n                final String query = multiQuery[i];\n                if (LOGGER.isTraceEnabled()) {\n                    LOGGER.trace(\"running '{}'\", query);\n                }\n                final PreparedStatement statement = createPreparedStatement(query);\n                preparedStatements[i] = statement;\n                preparers[i].accept(statement);\n                resultSets[i] = statement.executeQuery();\n            }\n            if (resultConsumer != null) {\n                resultConsumer.accept(resultSets);\n            }\n        }\n        finally {\n            for (ResultSet rs: resultSets) {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    }\n                    catch (Exception ei) {\n                    }\n                }\n            }\n        }\n        return this;\n    }\n"
  },
  {
    "id": "debezium_debezium-546-Param-2",
    "old_comment_raw": "@param table the table definition; may not be null",
    "old_code_raw": "    public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers, CustomKeyMapper keysMapper) {\n        if (schemaPrefix == null) {\n            schemaPrefix = \"\";\n        }\n\n        // Build the schemas ...\n        final TableId tableId = table.id();\n        final String tableIdStr = tableSchemaName(tableId);\n        final String schemaNamePrefix = schemaPrefix + tableIdStr;\n        LOGGER.debug(\"Mapping table '{}' to schemas under '{}'\", tableId, schemaNamePrefix);\n        SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Value\"));\n        SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Key\"));\n        AtomicBoolean hasPrimaryKey = new AtomicBoolean(false);\n        \n        Key tableKey = new Key.Builder(table).customKeyMapper(keysMapper).build();\n        tableKey.keyColumns().forEach(column -> {\n            addField(keySchemaBuilder, column, null);\n            hasPrimaryKey.set(true);\n        });\n        \n        table.columns()\n            .stream()\n            .filter(column -> filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name()))\n            .forEach(column -> {\n                ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column);\n                addField(valSchemaBuilder, column, mapper);\n            });\n        \n        Schema valSchema = valSchemaBuilder.optional().build();\n        Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null;\n\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Mapped primary key for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(keySchema));\n            LOGGER.debug(\"Mapped columns for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(valSchema));\n        }\n\n        Envelope envelope = Envelope.defineSchema()\n                .withName(schemaNameAdjuster.adjust(envelopSchemaName))\n                .withRecord(valSchema)\n                .withSource(sourceInfoSchema)\n                .build();\n\n\n        // Create the generators ...\n        Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, tableKey.keyColumns());\n        Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers);\n\n        // And the table schema ...\n        return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator);\n    }\n",
    "new_code_raw": "    public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers, KeyMapper keysMapper) {\n        if (schemaPrefix == null) {\n            schemaPrefix = \"\";\n        }\n\n        // Build the schemas ...\n        final TableId tableId = table.id();\n        final String tableIdStr = tableSchemaName(tableId);\n        final String schemaNamePrefix = schemaPrefix + tableIdStr;\n        LOGGER.debug(\"Mapping table '{}' to schemas under '{}'\", tableId, schemaNamePrefix);\n        SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Value\"));\n        SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Key\"));\n        AtomicBoolean hasPrimaryKey = new AtomicBoolean(false);\n\n        Key tableKey = new Key.Builder(table).customKeyMapper(keysMapper).build();\n        tableKey.keyColumns().forEach(column -> {\n            addField(keySchemaBuilder, column, null);\n            hasPrimaryKey.set(true);\n        });\n\n        table.columns()\n            .stream()\n            .filter(column -> filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name()))\n            .forEach(column -> {\n                ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column);\n                addField(valSchemaBuilder, column, mapper);\n            });\n\n        Schema valSchema = valSchemaBuilder.optional().build();\n        Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null;\n\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Mapped primary key for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(keySchema));\n            LOGGER.debug(\"Mapped columns for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(valSchema));\n        }\n\n        Envelope envelope = Envelope.defineSchema()\n                .withName(schemaNameAdjuster.adjust(envelopSchemaName))\n                .withRecord(valSchema)\n                .withSource(sourceInfoSchema)\n                .build();\n\n\n        // Create the generators ...\n        Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, tableKey.keyColumns());\n        Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers);\n\n        // And the table schema ...\n        return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1705-Param-0",
    "old_comment_raw": "@param client client model (required)",
    "old_code_raw": "  public ApiResponse<Client> call123testSpecialTagsWithHttpInfo(Client client) throws ApiException {\n    Object localVarPostBody = client;\n    \n    // verify the required parameter 'client' is set\n    if (client == null) {\n      throw new ApiException(400, \"Missing the required parameter 'client' when calling call123testSpecialTags\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/another-fake/dummy\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public ApiResponse<Client> call123testSpecialTagsWithHttpInfo(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling call123testSpecialTags\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/another-fake/dummy\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "apache_flume-88-Param-0",
    "old_comment_raw": "@param directory the directory to gather files from",
    "old_code_raw": "  private List<File> getCandidateFiles(File directory) {\n    Preconditions.checkNotNull(directory);\n    List<File> candidateFiles = new ArrayList<File>();\n    if (!directory.isDirectory()) {\n      return candidateFiles;\n    }\n\n    for (File file : directory.listFiles(filter)) {\n      if (file.isDirectory()) {\n        candidateFiles.addAll(getCandidateFiles(file));\n      } else {\n        candidateFiles.add(file);\n      }\n    }\n\n    return candidateFiles;\n  }\n",
    "new_code_raw": "  private List<File> getCandidateFiles(final Path directory) {\n    Preconditions.checkNotNull(directory);\n    final List<File> candidateFiles = new ArrayList<>();\n    try {\n      Files.walkFileTree(directory, new SimpleFileVisitor<Path>() {\n        @Override\n        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)\n            throws IOException {\n          if (directory.equals(dir)) { // The top directory should always be listed\n            return FileVisitResult.CONTINUE;\n          }\n          String directoryName = dir.getFileName().toString();\n          if (!recursiveDirectorySearch ||\n              directoryName.startsWith(\".\") ||\n              ignorePattern.matcher(directoryName).matches()) {\n            return FileVisitResult.SKIP_SUBTREE;\n          }\n          return FileVisitResult.CONTINUE;\n        }\n\n        @Override\n        public FileVisitResult visitFile(Path candidate, BasicFileAttributes attrs)\n            throws IOException {\n          String fileName = candidate.getFileName().toString();\n          if (!fileName.endsWith(completedSuffix) &&\n              !fileName.startsWith(\".\") &&\n              !ignorePattern.matcher(fileName).matches()) {\n            candidateFiles.add(candidate.toFile());\n          }\n\n          return FileVisitResult.CONTINUE;\n        }\n      });\n    } catch (IOException e) {\n      logger.error(\"I/O exception occurred while listing directories. \" +\n                   \"Files already matched will be returned. \" + directory, e);\n    }\n\n    return candidateFiles;\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1947-Param-1",
    "old_comment_raw": "@param createSchemas Should the schema(s) actually be created as well ( CREATE SCHEMA)?",
    "old_code_raw": "\tpublic List<String> generateCreationCommands(Metadata metadata, boolean createSchemas, Dialect dialect) {\n\t\tfinal ArrayList<String> commands = new ArrayList<String>();\n\t\tdoCreation(\n\t\t\t\tmetadata,\n\t\t\t\tcreateSchemas,\n\t\t\t\tdialect,\n\t\t\t\tnew Target() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean acceptsImportScriptActions() {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void prepare() {\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void accept(String action) {\n\t\t\t\t\t\tcommands.add( action );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void release() {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn commands;\n\t}\n",
    "new_code_raw": "\tpublic List<String> generateCreationCommands(Metadata metadata, boolean createNamespaces, Dialect dialect) {\n\t\tfinal ArrayList<String> commands = new ArrayList<String>();\n\t\tdoCreation(\n\t\t\t\tmetadata,\n\t\t\t\tcreateNamespaces,\n\t\t\t\tdialect,\n\t\t\t\tnew Target() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean acceptsImportScriptActions() {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void prepare() {\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void accept(String action) {\n\t\t\t\t\t\tcommands.add( action );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void release() {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn commands;\n\t}\n"
  },
  {
    "id": "hibernate_hibernate_orm-1144-Param-0",
    "old_comment_raw": "@param metadata The metadata for which to generate the creation commands.",
    "old_code_raw": "\tpublic List<String> generateCreationCommands(Metadata metadata, boolean createSchemas) {\n\t\tfinal ArrayList<String> commands = new ArrayList<String>();\n\t\tdoCreation(\n\t\t\t\tmetadata,\n\t\t\t\tcreateSchemas,\n\t\t\t\tnew Target() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean acceptsImportScriptActions() {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void prepare() {\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void accept(String action) {\n\t\t\t\t\t\tcommands.add( action );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void release() {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn commands;\n\t}\n",
    "new_code_raw": "\tpublic List<String> generateCreationCommands(Metadata metadata, boolean createNamespaces) {\n\t\tfinal ArrayList<String> commands = new ArrayList<String>();\n\t\tdoCreation(\n\t\t\t\tmetadata,\n\t\t\t\tcreateNamespaces,\n\t\t\t\tnew Target() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean acceptsImportScriptActions() {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void prepare() {\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void accept(String action) {\n\t\t\t\t\t\tcommands.add( action );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void release() {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn commands;\n\t}\n"
  },
  {
    "id": "RobotiumTech_robotium-1506-Param-0",
    "old_comment_raw": "@param search the string to be searched. The parameter will be interpreted as a regular expression.",
    "old_code_raw": "\tpublic boolean searchText(String search, int matches, boolean scroll) {\n\t\treturn searcher.searchText(search, matches, scroll);\n\t}\n",
    "new_code_raw": "\tpublic boolean searchText(String regex, int matches, boolean scroll) {\n\t\treturn searcher.searchText(regex, matches, scroll);\n\t}\n"
  },
  {
    "id": "iSoron_uhabits-59-Param-1",
    "old_comment_raw": "@param checks the checkmarks, ordered by decresing timestamp",
    "old_code_raw": "    protected ArrayList<Long> getTransitions(long beginning, int[] checks)\n    {\n        long day = DateUtils.millisecondsInOneDay;\n        long current = beginning;\n\n        ArrayList<Long> list = new ArrayList<>();\n        list.add(current);\n\n        for (int i = 1; i < checks.length; i++)\n        {\n            current += day;\n            int j = checks.length - i - 1;\n\n            if ((checks[j + 1] == 0 && checks[j] > 0)) list.add(current);\n            if ((checks[j + 1] > 0 && checks[j] == 0)) list.add(current - day);\n        }\n\n        if (list.size() % 2 == 1) list.add(current);\n\n        return list;\n    }\n",
    "new_code_raw": "    protected ArrayList<Timestamp> getTransitions(Timestamp beginning, int[] checks)\n    {\n        ArrayList<Timestamp> list = new ArrayList<>();\n        Timestamp current = beginning;\n        list.add(current);\n\n        for (int i = 1; i < checks.length; i++)\n        {\n            current = current.plus(1);\n            int j = checks.length - i - 1;\n\n            if ((checks[j + 1] == 0 && checks[j] > 0)) list.add(current);\n            if ((checks[j + 1] > 0 && checks[j] == 0)) list.add(current.minus(1));\n        }\n\n        if (list.size() % 2 == 1) list.add(current);\n\n        return list;\n    }\n"
  },
  {
    "id": "debezium_debezium-1264-Param-1",
    "old_comment_raw": "@param adjuster the optional component that adjusts the local date value before obtaining the epoch day; may be null if no adjustment is necessary",
    "old_code_raw": "    public static long toMicroOfDay(Object value, TemporalAdjuster adjuster) {\n        // conversion to nanos is fine as TIME values won't exceed long range\n        if (value instanceof Duration) {\n            return ((Duration) value).toNanos() / 1_000;\n        }\n\n        LocalTime time = Conversions.toLocalTime(value);\n        if (adjuster != null) {\n            time = time.with(adjuster);\n        }\n        return Math.floorDiv(time.toNanoOfDay(), Conversions.NANOSECONDS_PER_MICROSECOND);\n    }\n",
    "new_code_raw": "    public static long toMicroOfDay(Object value, boolean acceptLargeValues) {\n        if (value instanceof Duration) {\n            Duration duration = (Duration) value;\n            if (!acceptLargeValues && (duration.isNegative() || duration.compareTo(ONE_DAY) > 0)) {\n                throw new IllegalArgumentException(\"Time values must be between 00:00:00 and 24:00:00 (inclusive): \" + duration);\n            }\n\n            // conversion to nanos is fine as TIME values won't exceed long range\n            return ((Duration) value).toNanos() / 1_000;\n        }\n\n        // TODO only needed for SQL Server/Oracle, where we don't produce Duration right away;\n        // this should go eventually, as the conversion to LocalTime is superfluous\n        LocalTime time = Conversions.toLocalTime(value);\n        return Math.floorDiv(time.toNanoOfDay(), Conversions.NANOSECONDS_PER_MICROSECOND);\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-699-Param-1",
    "old_comment_raw": "@param lazyAvailable Is property lazy loading currently available.",
    "old_code_raw": "\tpublic static VersionProperty buildVersionProperty(SimpleSingularAttributeBinding property, boolean lazyAvailable) {\n\t\tString mappedUnsavedValue = ( (KeyValue) property.getValue() ).getNullValue();\n\n\t\tVersionValue unsavedValue = UnsavedValueFactory.getUnsavedVersionValue(\n\t\t\t\tmappedUnsavedValue,\n\t\t\t\tgetGetter( property ),\n\t\t\t\t(VersionType) property.getHibernateTypeDescriptor().getResolvedTypeMapping(),\n\t\t\t\tgetConstructor( property.getEntityBinding() )\n\t\t);\n\n\t\tboolean lazy = lazyAvailable && property.isLazy();\n\n\t\tfinal CascadeStyle cascadeStyle = property.isAssociation()\n\t\t\t\t? ( (AssociationAttributeBinding) property ).getCascadeStyle()\n\t\t\t\t: CascadeStyle.NONE;\n\n\t\treturn new VersionProperty(\n\t\t        property.getAttribute().getName(),\n\t\t        null,\n\t\t        property.getHibernateTypeDescriptor().getResolvedTypeMapping(),\n\t\t        lazy,\n\t\t\t\ttrue, // insertable\n\t\t\t\ttrue, // updatable\n\t\t        property.getGeneration() == PropertyGeneration.INSERT\n\t\t\t\t\t\t|| property.getGeneration() == PropertyGeneration.ALWAYS,\n\t\t\t\tproperty.getGeneration() == PropertyGeneration.ALWAYS,\n\t\t\t\tproperty.isNullable(),\n\t\t\t\t!lazy,\n\t\t\t\tproperty.isIncludedInOptimisticLocking(),\n\t\t\t\tcascadeStyle,\n\t\t        unsavedValue\n\t\t\t);\n\t}\n",
    "new_code_raw": "\tpublic static VersionProperty buildVersionProperty(SimpleAttributeBinding property, boolean lazyAvailable) {\n\t\tString mappedUnsavedValue = ( (KeyValue) property.getValue() ).getNullValue();\n\n\t\tVersionValue unsavedValue = UnsavedValueFactory.getUnsavedVersionValue(\n\t\t\t\tmappedUnsavedValue,\n\t\t\t\tgetGetter( property ),\n\t\t\t\t( VersionType ) property.getHibernateTypeDescriptor().getExplicitType(),\n\t\t\t\tgetConstructor( property.getEntityBinding() )\n\t\t);\n\n\t\tboolean lazy = lazyAvailable && property.isLazy();\n\n\t\treturn new VersionProperty(\n\t\t        property.getAttribute().getName(),\n\t\t        property.getNodeName(),\n\t\t        property.getHibernateTypeDescriptor().getExplicitType(),\n\t\t        lazy,\n\t\t\t\tproperty.isInsertable(),\n\t\t\t\tproperty.isUpdatable(),\n\t\t        property.getGeneration() == PropertyGeneration.INSERT || property.getGeneration() == PropertyGeneration.ALWAYS,\n\t\t\t\tproperty.getGeneration() == PropertyGeneration.ALWAYS,\n\t\t\t\tproperty.isNullable(),\n\t\t\t\tproperty.isUpdatable() && !lazy,\n\t\t\t\tproperty.isOptimisticLockable(),\n\t\t\t\t// TODO: get cascadeStyle from property when HHH-6355 is fixed; for now, assume NONE\n\t\t\t\t//property.getCascadeStyle(),\n\t\t\t\tCascadeStyle.NONE,\n\t\t        unsavedValue\n\t\t\t);\n\t}\n"
  },
  {
    "id": "Atmosphere_atmosphere-826-Param-1",
    "old_comment_raw": "@param response the  HttpServletResponse",
    "old_code_raw": "    public Action timedout(HttpServletRequest request, HttpServletResponse response)\n            throws IOException, ServletException {\n\n        AtmosphereResourceImpl r = null;\n        try {\n            if (trackActiveRequest) {\n                long l = (Long) request.getAttribute(MAX_INACTIVE);\n                if (l == -1) {\n                    // The closedDetector closed the connection.\n                    return timedoutAction;\n                }\n                request.setAttribute(MAX_INACTIVE, (long) -1);\n            }\n\n            logger.debug(\"Timing out the connection for request {}\", request);\n\n            // Something went wrong.\n            if (request == null || response == null) {\n                logger.warn(\"Invalid Request/Response: {}/{}\", request, response);\n                return timedoutAction;\n            }\n\n            r = (AtmosphereResourceImpl) request.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n\n            if (r != null && r.getAtmosphereResourceEvent().isSuspended()) {\n                r.getAtmosphereResourceEvent().setIsResumedOnTimeout(true);\n\n                Broadcaster b = r.getBroadcaster();\n                if (b instanceof DefaultBroadcaster) {\n                    ((DefaultBroadcaster) b).broadcastOnResume(r);\n                }\n\n                if (request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT) != null) {\n                    r.getAtmosphereResourceEvent().setIsResumedOnTimeout(\n                            (Boolean) request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT));\n                }\n\n                invokeAtmosphereHandler(r);\n            }\n        } catch (Throwable t) {\n            logger.error(\"failed to timeout resource {}\", r, t);\n        } finally {\n            try {\n                if (r != null) {\n                    r.notifyListeners();\n                    r.setIsInScope(false);\n                    r.cancel();\n                }\n            } catch (Throwable t) {\n                logger.trace(\"timedout\", t);\n            } finally {\n\n                try {\n                    response.getOutputStream().close();\n                } catch (Throwable t) {\n                    try {\n                        response.getWriter().close();\n                    } catch (Throwable t2) {\n                    }\n                }\n\n                if (r != null) {\n                    destroyResource(r);\n                }\n            }\n        }\n\n        return timedoutAction;\n    }\n",
    "new_code_raw": "    public Action timedout(AtmosphereRequest request, AtmosphereResponse response)\n            throws IOException, ServletException {\n\n        AtmosphereResourceImpl r = null;\n        try {\n            if (trackActiveRequest) {\n                long l = (Long) request.getAttribute(MAX_INACTIVE);\n                if (l == -1) {\n                    // The closedDetector closed the connection.\n                    return timedoutAction;\n                }\n                request.setAttribute(MAX_INACTIVE, (long) -1);\n            }\n\n            logger.debug(\"Timing out the connection for request {}\", request);\n\n            // Something went wrong.\n            if (request == null || response == null) {\n                logger.warn(\"Invalid Request/Response: {}/{}\", request, response);\n                return timedoutAction;\n            }\n\n            r = (AtmosphereResourceImpl) request.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n\n            if (r != null && r.getAtmosphereResourceEvent().isSuspended()) {\n                r.getAtmosphereResourceEvent().setIsResumedOnTimeout(true);\n\n                Broadcaster b = r.getBroadcaster();\n                if (b instanceof DefaultBroadcaster) {\n                    ((DefaultBroadcaster) b).broadcastOnResume(r);\n                }\n\n                if (request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT) != null) {\n                    r.getAtmosphereResourceEvent().setIsResumedOnTimeout(\n                            (Boolean) request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT));\n                }\n\n                invokeAtmosphereHandler(r);\n            }\n        } catch (Throwable t) {\n            logger.error(\"failed to timeout resource {}\", r, t);\n        } finally {\n            try {\n                if (r != null) {\n                    r.notifyListeners();\n                    r.setIsInScope(false);\n                    r.cancel();\n                }\n            } catch (Throwable t) {\n                logger.trace(\"timedout\", t);\n            } finally {\n\n                try {\n                    response.getOutputStream().close();\n                } catch (Throwable t) {\n                    try {\n                        response.getWriter().close();\n                    } catch (Throwable t2) {\n                    }\n                }\n\n                if (r != null) {\n                    destroyResource(r);\n                }\n            }\n        }\n\n        return timedoutAction;\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1188-Param-0",
    "old_comment_raw": "@param entityName The name of the entity",
    "old_code_raw": "\tpublic static boolean isTransient(String entityName, Object entity, Boolean assumed, SessionImplementor session) {\n\t\tif ( entity == LazyPropertyInitializer.UNFETCHED_PROPERTY ) {\n\t\t\t// an unfetched association can only point to\n\t\t\t// an entity that already exists in the db\n\t\t\treturn false;\n\t\t}\n\n\t\t// let the interceptor inspect the instance to decide\n\t\tBoolean isUnsaved = session.getInterceptor().isTransient( entity );\n\t\tif ( isUnsaved != null ) {\n\t\t\treturn isUnsaved;\n\t\t}\n\n\t\t// let the persister inspect the instance to decide\n\t\tfinal EntityPersister persister = session.getEntityPersister( entityName, entity );\n\t\tisUnsaved = persister.isTransient( entity, session );\n\t\tif ( isUnsaved != null ) {\n\t\t\treturn isUnsaved;\n\t\t}\n\n\t\t// we use the assumed value, if there is one, to avoid hitting\n\t\t// the database\n\t\tif ( assumed != null ) {\n\t\t\treturn assumed;\n\t\t}\n\n\t\t// hit the database, after checking the session cache for a snapshot\n\t\tfinal Object[] snapshot = session.getPersistenceContext().getDatabaseSnapshot(\n\t\t\t\tpersister.getIdentifier( entity, session ),\n\t\t\t\tpersister\n\t\t);\n\t\treturn snapshot == null;\n\n\t}\n",
    "new_code_raw": "\tpublic static boolean isTransient(String entityName, Object entity, Boolean assumed, SharedSessionContractImplementor session) {\n\t\tif ( entity == LazyPropertyInitializer.UNFETCHED_PROPERTY ) {\n\t\t\t// an unfetched association can only point to\n\t\t\t// an entity that already exists in the db\n\t\t\treturn false;\n\t\t}\n\n\t\t// let the interceptor inspect the instance to decide\n\t\tBoolean isUnsaved = session.getInterceptor().isTransient( entity );\n\t\tif ( isUnsaved != null ) {\n\t\t\treturn isUnsaved;\n\t\t}\n\n\t\t// let the persister inspect the instance to decide\n\t\tfinal EntityPersister persister = session.getEntityPersister( entityName, entity );\n\t\tisUnsaved = persister.isTransient( entity, session );\n\t\tif ( isUnsaved != null ) {\n\t\t\treturn isUnsaved;\n\t\t}\n\n\t\t// we use the assumed value, if there is one, to avoid hitting\n\t\t// the database\n\t\tif ( assumed != null ) {\n\t\t\treturn assumed;\n\t\t}\n\n\t\t// hit the database, afterQuery checking the session cache for a snapshot\n\t\tfinal Object[] snapshot = session.getPersistenceContext().getDatabaseSnapshot(\n\t\t\t\tpersister.getIdentifier( entity, session ),\n\t\t\t\tpersister\n\t\t);\n\t\treturn snapshot == null;\n\n\t}\n"
  },
  {
    "id": "RobotiumTech_robotium-1203-Param-0",
    "old_comment_raw": "@param clazz the class of the  Activity to wait for e.g.  \"MyActivity\"",
    "old_code_raw": "\tpublic boolean waitForActivity(Class<? extends Activity> clazz, int timeout){\n\t\tfinal long endTime = SystemClock.uptimeMillis() + timeout;\n\t\tActivity currentActivity = activityUtils.getCurrentActivity(false);\n\n\t\twhile(SystemClock.uptimeMillis() < endTime){\n\t\t\tif(currentActivity != null && currentActivity.getClass().equals(clazz))\n\t\t\t\treturn true;\n\n\t\t\tcurrentActivity = activityUtils.getCurrentActivity();\n\t\t}\n\t\treturn false;\n\t}\n",
    "new_code_raw": "\tpublic boolean waitForActivity(Class<? extends Activity> activityClass, int timeout){\n\t\tfinal long endTime = SystemClock.uptimeMillis() + timeout;\n\t\tActivity currentActivity = activityUtils.getCurrentActivity(false);\n\n\t\twhile(SystemClock.uptimeMillis() < endTime){\n\t\t\tif(currentActivity != null && currentActivity.getClass().equals(activityClass))\n\t\t\t\treturn true;\n\n\t\t\tcurrentActivity = activityUtils.getCurrentActivity();\n\t\t}\n\t\treturn false;\n\t}\n"
  },
  {
    "id": "RobotiumTech_robotium-403-Param-0",
    "old_comment_raw": "@param timeout the amount of time in milliseconds to wait",
    "old_code_raw": "\tpublic boolean waitForDialogToOpen(long timeout) {\n\t\tfinal long endTime = SystemClock.uptimeMillis() + timeout;\n\n\t\twhile (SystemClock.uptimeMillis() < endTime) {\n\n\t\t\tif(isDialogOpen()){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "new_code_raw": "\tpublic boolean waitForDialogToOpen(long timeout, boolean sleepFirst) {\n\t\tfinal long endTime = SystemClock.uptimeMillis() + timeout;\n\n\t\tif(sleepFirst)\n\t\t\tsleeper.sleep();\n\n\t\twhile (SystemClock.uptimeMillis() < endTime) {\n\n\t\t\tif(isDialogOpen()){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tsleeper.sleep(MINISLEEP);\n\t\t}\n\t\treturn false;\n\t}\n"
  },
  {
    "id": "apache_portals-pluto-17-Associations-Param0",
    "old_comment_raw": "@param containerName",
    "old_code_raw": "    public PortletContainer createContainer(String containerName,\r\n                                            PortletContainerServices services)\r\n        throws PortletContainerException {\r\n        return createContainer(containerName, services, new DefaultOptionalServices());\r\n   }\r\n",
    "new_code_raw": "    public PortletContainer createContainer(\r\n    \t\tString containerName,\r\n    \t\tRequiredContainerServices requiredServices)\r\n        throws PortletContainerException {\r\n        return createContainer(containerName,\r\n                               requiredServices,\r\n                               new DefaultOptionalContainerServices());\r\n   }\r\n\n"
  },
  {
    "id": "zaproxy_zaproxy-2139-Param-1",
    "old_comment_raw": "@param cookies the cookies present in the request header of the message",
    "old_code_raw": "\tprivate HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final Set<String> tokens) {\n\n\t\t// Pre-checks\n\t\tif (sessions.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tList<HttpSession> matchingSessions = new LinkedList<>(sessions);\n\t\tfor (String token : tokens) {\n\t\t\t// Get the corresponding cookie from the cookies list\n\t\t\tHttpCookie matchingCookie = null;\n\t\t\tfor (HttpCookie cookie : cookies) {\n\t\t\t\tif (cookie.getName().equals(token)) {\n\t\t\t\t\tmatchingCookie = cookie;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Filter the sessions that do not match the cookie value\n\t\t\tIterator<HttpSession> it = matchingSessions.iterator();\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tif (!it.next().matchesToken(token, matchingCookie)) {\n\t\t\t\t\tit.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Return the matching session\n\t\tif (matchingSessions.size() >= 1) {\n\t\t\tif (matchingSessions.size() > 1) {\n\t\t\t\tlog.warn(\"Multiple sessions matching the cookies from response for site: \" + getSite()\n\t\t\t\t\t\t+ \". Using first one.\");\n\t\t\t}\n\t\t\treturn matchingSessions.get(0);\n\t\t}\n\t\treturn null;\n\n\t}\n",
    "new_code_raw": "\tprivate HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final HttpSessionTokensSet siteTokens) {\n\n\t\t// Pre-checks\n\t\tif (sessions.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tList<HttpSession> matchingSessions = new LinkedList<>(sessions);\n\t\tfor (String token : siteTokens.getTokensSet()) {\n\t\t\t// Get the corresponding cookie from the cookies list\n\t\t\tHttpCookie matchingCookie = null;\n\t\t\tfor (HttpCookie cookie : cookies) {\n\t\t\t\tif (cookie.getName().equals(token)) {\n\t\t\t\t\tmatchingCookie = cookie;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Filter the sessions that do not match the cookie value\n\t\t\tIterator<HttpSession> it = matchingSessions.iterator();\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tif (!it.next().matchesToken(token, matchingCookie)) {\n\t\t\t\t\tit.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Return the matching session\n\t\tif (matchingSessions.size() >= 1) {\n\t\t\tif (matchingSessions.size() > 1) {\n\t\t\t\tlog.warn(\"Multiple sessions matching the cookies from response for site: \" + getSite()\n\t\t\t\t\t\t+ \". Using first one.\");\n\t\t\t}\n\t\t\treturn matchingSessions.get(0);\n\t\t}\n\t\treturn null;\n\n\t}\n"
  },
  {
    "id": "JodaOrg_joda_time-441-Param-0",
    "old_comment_raw": "@param millis the time instant in millis to update.",
    "old_code_raw": "    public long add(long millis, int years) {\n        return iChronology.year().add(millis, years);\n    }\n",
    "new_code_raw": "    public long add(long instant, int years) {\n        return getWrappedField().add(instant, years);\n    }\n"
  },
  {
    "id": "SeleniumHQ_selenium-255-Param-0",
    "old_comment_raw": "@param externalKey the external session key",
    "old_code_raw": "  public TestSession getSession(String externalKey) {\n    return activeTestSessions.findSessionByExternalKey(externalKey);\n  }\n",
    "new_code_raw": "  public TestSession getSession(ExternalSessionKey externalKey) {\n    return activeTestSessions.findSessionByExternalKey(externalKey);\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-72-Param-1",
    "old_comment_raw": "@param object the object to convert, must not be null",
    "old_code_raw": "    public void setInto(ReadWritableDuration duration, Object object) {\n        duration.setDuration((ReadableDuration) object);\n    }\n",
    "new_code_raw": "    public void setInto(ReadWritableTimePeriod duration, Object object) {\n        duration.setTimePeriod((ReadableDuration) object);\n    }\n"
  },
  {
    "id": "runelite_runelite-122-Param-2",
    "old_comment_raw": "@param orientation the orientation of the model (0-2048, where 0 is north)",
    "old_code_raw": "\tpublic static Area getClickbox(@Nonnull Client client, Model model, int orientation, int tileX, int tileY)\n\t{\n\t\tif (model == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tList<Triangle> triangles = model.getTriangles().stream()\n\t\t\t.map(triangle -> triangle.rotate(orientation))\n\t\t\t.collect(Collectors.toList());\n\n\t\tList<Vertex> vertices = model.getVertices().stream()\n\t\t\t\t.map(v -> v.rotate(orientation))\n\t\t\t\t.collect(Collectors.toList());\n\n\t\tArea clickBox = get2DGeometry(client, triangles, orientation, tileX, tileY);\n\t\tArea visibleAABB = getAABB(client, vertices, orientation, tileX, tileY);\n\n\t\tif (visibleAABB == null || clickBox == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tclickBox.intersect(visibleAABB);\n\t\treturn clickBox;\n\t}\n",
    "new_code_raw": "\tpublic static Area getClickbox(@Nonnull Client client, Model model, int orientation, int localX, int localY)\n\t{\n\t\tif (model == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tList<Triangle> triangles = model.getTriangles().stream()\n\t\t\t.map(triangle -> triangle.rotate(orientation))\n\t\t\t.collect(Collectors.toList());\n\n\t\tList<Vertex> vertices = model.getVertices().stream()\n\t\t\t\t.map(v -> v.rotate(orientation))\n\t\t\t\t.collect(Collectors.toList());\n\n\t\tArea clickBox = get2DGeometry(client, triangles, orientation, localX, localY);\n\t\tArea visibleAABB = getAABB(client, vertices, orientation, localX, localY);\n\n\t\tif (visibleAABB == null || clickBox == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tclickBox.intersect(visibleAABB);\n\t\treturn clickBox;\n\t}\n"
  },
  {
    "id": "JodaOrg_joda_time-1088-Param-0",
    "old_comment_raw": "@param millis the time instant in millis to query.",
    "old_code_raw": "    public int get(long millis) {\n        int year = iChronology.year().get(millis);\n        if (year <= 0) {\n            year = 1 - year;\n        }\n        return year;\n    }\n",
    "new_code_raw": "    public int get(long instant) {\n        int year = getWrappedField().get(instant);\n        if (year <= 0) {\n            year = 1 - year;\n        }\n        return year;\n    }\n"
  },
  {
    "id": "debezium_debezium-1181-Param-1",
    "old_comment_raw": "@param contentType the data content type of CloudEvents",
    "old_code_raw": "    public static CloudEventsMaker create(RecordParser parser, SerializerType contentType, String schemaUri) {\n        switch (parser.connectorType()) {\n            case \"mysql\":\n                return new MysqlCloudEventsMaker(parser, contentType, schemaUri);\n            case \"postgresql\":\n                return new PostgresCloudEventsMaker(parser, contentType, schemaUri);\n            case \"mongodb\":\n                return new MongodbCloudEventsMaker(parser, contentType, schemaUri);\n            case \"sqlserver\":\n                return new SqlserverCloudEventsMaker(parser, contentType, schemaUri);\n            default:\n                throw new DataException(\"No usable CloudEvents converters for connector type \\\"\" + parser.connectorType() + \"\\\"\");\n        }\n    }\n",
    "new_code_raw": "    public static CloudEventsMaker create(RecordParser parser, SerializerType contentType, String dataSchemaUriBase) {\n        switch (parser.connectorType()) {\n            case \"mysql\":\n                return new MysqlCloudEventsMaker(parser, contentType, dataSchemaUriBase);\n            case \"postgresql\":\n                return new PostgresCloudEventsMaker(parser, contentType, dataSchemaUriBase);\n            case \"mongodb\":\n                return new MongodbCloudEventsMaker(parser, contentType, dataSchemaUriBase);\n            case \"sqlserver\":\n                return new SqlserverCloudEventsMaker(parser, contentType, dataSchemaUriBase);\n            default:\n                throw new DataException(\"No usable CloudEvents converters for connector type \\\"\" + parser.connectorType() + \"\\\"\");\n        }\n    }\n"
  },
  {
    "id": "debezium_debezium-1255-Param-1",
    "old_comment_raw": "@param adjuster the optional component that adjusts the local date value before obtaining the epoch day; may be null if no adjustment is necessary",
    "old_code_raw": "    public static int toMilliOfDay(Object value, TemporalAdjuster adjuster) {\n        if (value instanceof Duration) {\n            // int conversion is ok for the range of TIME\n            return (int) ((Duration) value).toMillis();\n        }\n        LocalTime time = Conversions.toLocalTime(value);\n        if (adjuster != null) {\n            time = time.with(adjuster);\n        }\n        long micros = Math.floorDiv(time.toNanoOfDay(), Conversions.NANOSECONDS_PER_MILLISECOND);\n        assert Math.abs(micros) < Integer.MAX_VALUE;\n        return (int) micros;\n    }\n",
    "new_code_raw": "    public static int toMilliOfDay(Object value, boolean acceptLargeValues) {\n        if (value instanceof Duration) {\n            Duration duration = (Duration) value;\n            if (!acceptLargeValues && (duration.isNegative() || duration.compareTo(ONE_DAY) > 0)) {\n                throw new IllegalArgumentException(\"Time values must be between 00:00:00 and 24:00:00 (inclusive): \" + duration);\n            }\n\n            // int conversion is ok for the range of TIME\n            return (int) ((Duration) value).toMillis();\n        }\n\n        // TODO only needed for SQL Server/Oracle, where we don't produce Duration right away;\n        // this should go eventually, as the conversion to LocalTime is superfluous\n        LocalTime time = Conversions.toLocalTime(value);\n        long micros = Math.floorDiv(time.toNanoOfDay(), Conversions.NANOSECONDS_PER_MILLISECOND);\n        assert Math.abs(micros) < Integer.MAX_VALUE;\n        return (int) micros;\n    }\n"
  },
  {
    "id": "apache_calcite-279-Param-0",
    "old_comment_raw": "@param rel Calculation relational expression",
    "old_code_raw": "  protected boolean canImplement(CalcRel rel, String relTypeName) {\n    for (RelType relType : relTypes) {\n      if (relType.name.equals(relTypeName)) {\n        return relType.canImplement(rel.getProgram());\n      }\n    }\n    throw Util.newInternal(\"unknown reltype \" + relTypeName);\n  }\n",
    "new_code_raw": "  protected boolean canImplement(LogicalCalc rel, String relTypeName) {\n    for (RelType relType : relTypes) {\n      if (relType.name.equals(relTypeName)) {\n        return relType.canImplement(rel.getProgram());\n      }\n    }\n    throw Util.newInternal(\"unknown type \" + relTypeName);\n  }\n"
  },
  {
    "id": "zaproxy_zaproxy-2135-Param-0",
    "old_comment_raw": "@param hm",
    "old_code_raw": "\tprivate JSONObject httpMessageToJSON(HttpMessage hm) {\n\t\tJSONObject ja = new JSONObject();\n\t\tja.put(\"cookieParams\", XMLStringUtil.escapeControlChrs(hm.getCookieParamsAsString()));\n\t\tja.put(\"note\", hm.getNote());\n\t\tja.put(\"requestHeader\", XMLStringUtil.escapeControlChrs(hm.getRequestHeader().toString()));\n\t\tja.put(\"requestBody\", XMLStringUtil.escapeControlChrs(hm.getRequestBody().toString()));\n\t\tja.put(\"responseHeader\", XMLStringUtil.escapeControlChrs(hm.getResponseHeader().toString()));\n\t\t\n\t\tif (HttpHeader.GZIP.equals(hm.getResponseHeader().getHeader(HttpHeader.CONTENT_ENCODING))) {\n\t\t\t// Uncompress gziped content\n\t\t\ttry {\n\t\t\t\tByteArrayInputStream bais = new ByteArrayInputStream(hm.getResponseBody().getBytes());\n\t\t\t\tGZIPInputStream gis = new GZIPInputStream(bais);\n\t\t\t\tInputStreamReader isr = new InputStreamReader(gis);\n\t\t\t\tBufferedReader br = new BufferedReader(isr);\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tString line = null;\n\t\t\t\twhile ((line = br.readLine()) != null) {\n\t\t\t\t\tsb.append(line);\n\t\t\t\t}\n\t\t\t\tbr.close();\n\t\t\t\tisr.close();\n\t\t\t\tgis.close();\n\t\t\t\tbais.close();\n\t\t\t\tja.put(\"responseBody\", XMLStringUtil.escapeControlChrs(sb.toString()));\n\t\t\t} catch (IOException e) {\n\t\t\t\t//this.log.error(e.getMessage(), e);\n\t\t\t\tSystem.out.println(e);\n\t\t\t}\n\t\t} else {\n\t\t\tja.put(\"responseBody\", XMLStringUtil.escapeControlChrs(hm.getResponseBody().toString()));\n\t\t}\n\t\t\n\t\treturn ja;\n\t}\n",
    "new_code_raw": "\tprivate JSONObject httpMessageToJSON(HttpMessage msg) {\n\t\tJSONObject ja = new JSONObject();\n\t\tja.put(\"id\", msg.getHistoryRef().getHistoryId());\n\t\tja.put(\"cookieParams\", XMLStringUtil.escapeControlChrs(msg.getCookieParamsAsString()));\n\t\tja.put(\"note\", msg.getNote());\n\t\tja.put(\"requestHeader\", XMLStringUtil.escapeControlChrs(msg.getRequestHeader().toString()));\n\t\tja.put(\"requestBody\", XMLStringUtil.escapeControlChrs(msg.getRequestBody().toString()));\n\t\tja.put(\"responseHeader\", XMLStringUtil.escapeControlChrs(msg.getResponseHeader().toString()));\n\t\t\n\t\tif (HttpHeader.GZIP.equals(msg.getResponseHeader().getHeader(HttpHeader.CONTENT_ENCODING))) {\n\t\t\t// Uncompress gziped content\n\t\t\ttry {\n\t\t\t\tByteArrayInputStream bais = new ByteArrayInputStream(msg.getResponseBody().getBytes());\n\t\t\t\tGZIPInputStream gis = new GZIPInputStream(bais);\n\t\t\t\tInputStreamReader isr = new InputStreamReader(gis);\n\t\t\t\tBufferedReader br = new BufferedReader(isr);\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tString line = null;\n\t\t\t\twhile ((line = br.readLine()) != null) {\n\t\t\t\t\tsb.append(line);\n\t\t\t\t}\n\t\t\t\tbr.close();\n\t\t\t\tisr.close();\n\t\t\t\tgis.close();\n\t\t\t\tbais.close();\n\t\t\t\tja.put(\"responseBody\", XMLStringUtil.escapeControlChrs(sb.toString()));\n\t\t\t} catch (IOException e) {\n\t\t\t\t//this.log.error(e.getMessage(), e);\n\t\t\t\tSystem.out.println(e);\n\t\t\t}\n\t\t} else {\n\t\t\tja.put(\"responseBody\", XMLStringUtil.escapeControlChrs(msg.getResponseBody().toString()));\n\t\t}\n\t\t\n\t\treturn ja;\n\t}\n"
  },
  {
    "id": "hibernate_hibernate_orm-442-Param-2",
    "old_comment_raw": "@param limit Maximum number of rows to be returned by the query",
    "old_code_raw": "\tpublic String getLimitString(String querySqlString, int offset, int limit) {\n\t\tStringBuilder sb = new StringBuilder(querySqlString.trim().toLowerCase());\n\n\t\tint orderByIndex = sb.indexOf(\"order by\");\n\t\tCharSequence orderby = orderByIndex > 0 ? sb.subSequence(orderByIndex, sb.length())\n\t\t\t\t: \"ORDER BY CURRENT_TIMESTAMP\";\n\n\t\t// Delete the order by clause at the end of the query\n\t\tif (orderByIndex > 0) {\n\t\t\tsb.delete(orderByIndex, orderByIndex + orderby.length());\n\t\t}\n\n\t\t// HHH-5715 bug fix\n\t\treplaceDistinctWithGroupBy(sb);\n\n\t\tinsertRowNumberFunction(sb, orderby);\n\n\t\t// Wrap the query within a with statement:\n\t\tsb.insert(0, \"WITH query AS (\").append(\") SELECT * FROM query \");\n\t\tsb.append(\"WHERE __hibernate_row_nr__ BETWEEN \").append(offset + 1).append(\" AND \").append(limit);\n\n\t\treturn sb.toString();\n\t}\n",
    "new_code_raw": "\tpublic String getLimitString(String querySqlString, boolean hasOffset) {\n\t\tStringBuilder sb = new StringBuilder(querySqlString.trim().toLowerCase());\n\n\t\tint orderByIndex = sb.indexOf(\"order by\");\n\t\tCharSequence orderby = orderByIndex > 0 ? sb.subSequence(orderByIndex, sb.length())\n\t\t\t\t: \"ORDER BY CURRENT_TIMESTAMP\";\n\n\t\t// Delete the order by clause at the end of the query\n\t\tif (orderByIndex > 0) {\n\t\t\tsb.delete(orderByIndex, orderByIndex + orderby.length());\n\t\t}\n\n\t\t// HHH-5715 bug fix\n\t\treplaceDistinctWithGroupBy(sb);\n\n\t\tinsertRowNumberFunction(sb, orderby);\n\n\t\t// Wrap the query within a with statement:\n\t\tsb.insert(0, \"WITH query AS (\").append(\") SELECT * FROM query \");\n\t\t//sb.append(\"WHERE __hibernate_row_nr__ BETWEEN \").append(offset + 1).append(\" AND \").append(limit);\n\t\tsb.append(\"WHERE __hibernate_row_nr__ BETWEEN ? AND ?\");\n\n\t\treturn sb.toString();\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1672-Param-0",
    "old_comment_raw": "@param body Input boolean as post body",
    "old_code_raw": "    public Boolean fakeOuterBooleanSerialize(Boolean body) throws RestClientException {\n        Object postBody = body;\n        \n        String path = UriComponentsBuilder.fromPath(\"/fake/outer/boolean\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Boolean> returnType = new ParameterizedTypeReference<Boolean>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "new_code_raw": "    public Boolean fakeOuterBooleanSerialize(Boolean booleanPostBody) throws RestClientException {\n        Object postBody = booleanPostBody;\n        \n        String path = UriComponentsBuilder.fromPath(\"/fake/outer/boolean\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"*/*\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Boolean> returnType = new ParameterizedTypeReference<Boolean>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n"
  },
  {
    "id": "apache_activemq-604-Param-3",
    "old_comment_raw": "@param maxBatchSize",
    "old_code_raw": "    public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name, int maxBatchSize, Subscription sub) {\n        StoreDurableSubscriberCursor cursor = new StoreDurableSubscriberCursor(broker,clientId, name, maxBatchSize, sub);\n        cursor.setImmediatePriorityDispatch(isImmediatePriorityDispatch());\n        return cursor;\n    }\n",
    "new_code_raw": "    public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name, int maxBatchSize, DurableTopicSubscription sub) {\n        StoreDurableSubscriberCursor cursor = new StoreDurableSubscriberCursor(broker,clientId, name, maxBatchSize, sub);\n        cursor.setImmediatePriorityDispatch(isImmediatePriorityDispatch());\n        return cursor;\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1626-Param-0",
    "old_comment_raw": "@param body Pet object that needs to be added to the store",
    "old_code_raw": "  public void  addPet (Pet body) throws ApiException {\n    Object localVarPostBody = body;\n    // verify the required parameter 'body' is set\n    if (body == null) {\n       throw new ApiException(400, \"Missing the required parameter 'body' when calling addPet\");\n    }\n\n    // create path and map variables\n    String localVarPath = \"/pet\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> localVarFormParams = new HashMap<String, String>();\n\n\n\n    String[] localVarContentTypes = {\n      \"application/json\",\"application/xml\"\n    };\n    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application/json\";\n\n    if (localVarContentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      \n\n      localVarPostBody = localVarBuilder.build();\n    } else {\n      // normal form params\n          }\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);\n      if(localVarResponse != null){\n        return ;\n      }\n      else {\n        return ;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n",
    "new_code_raw": "  public void  addPet (Pet pet) throws ApiException {\n    Object localVarPostBody = pet;\n    // verify the required parameter 'pet' is set\n    if (pet == null) {\n       throw new ApiException(400, \"Missing the required parameter 'pet' when calling addPet\");\n    }\n\n    // create path and map variables\n    String localVarPath = \"/pet\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> localVarFormParams = new HashMap<String, String>();\n\n\n\n    String[] localVarContentTypes = {\n      \n    };\n    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application/json\";\n\n    if (localVarContentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      \n\n      localVarPostBody = localVarBuilder.build();\n    } else {\n      // normal form params\n          }\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);\n      if(localVarResponse != null){\n        return ;\n      }\n      else {\n        return ;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n"
  },
  {
    "id": "graphql_java_graphql_java-55-Param-0",
    "old_comment_raw": "@param builderFunction a supplier for the builder impl",
    "old_code_raw": "        public Builder field(BuilderFunction<GraphQLInputObjectField.Builder> builderFunction) {\n            assertNotNull(builderFunction, \"builderFunction should not be null\");\n            GraphQLInputObjectField.Builder builder = GraphQLInputObjectField.newInputObjectField();\n            builder = builderFunction.apply(builder);\n            return field(builder);\n        }\n",
    "new_code_raw": "        public Builder field(UnaryOperator<GraphQLInputObjectField.Builder> builderFunction) {\n            assertNotNull(builderFunction, \"builderFunction should not be null\");\n            GraphQLInputObjectField.Builder builder = GraphQLInputObjectField.newInputObjectField();\n            builder = builderFunction.apply(builder);\n            return field(builder);\n        }\n"
  },
  {
    "id": "JodaOrg_joda_time-425-Param-0",
    "old_comment_raw": "@param millisLocal the millisecond instant, relative to this time zone, to get the offset for",
    "old_code_raw": "    public int getOffsetFromLocal(long millisLocal) {\n        return getOffset(millisLocal - getOffset(millisLocal));\n    }\n",
    "new_code_raw": "    public int getOffsetFromLocal(long instantLocal) {\n        return getOffset(instantLocal - getOffset(instantLocal));\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-203-Param-0",
    "old_comment_raw": "@param path The sub-path of the HTTP URL",
    "old_code_raw": "  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n",
    "new_code_raw": "  public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-231-Param-1",
    "old_comment_raw": "@param sentence The sentence the triples were extracted from.",
    "old_code_raw": "  public static RelationTriple fromProto(CoreNLPProtos.RelationTriple proto, List<CoreLabel> sentence, String docid) {\n    if (Thread.interrupted()) {\n      throw new RuntimeInterruptedException();\n    }\n    // Get the spans for the extraction\n    List<CoreLabel> subject = proto.getSubjectTokensList().stream().map(sentence::get).collect(Collectors.toList());\n    List<CoreLabel> relation;\n    if (proto.getRelationTokensCount() == 0) {  // If we don't have a real span for the relation, make a dummy word\n      relation = Collections.singletonList(new CoreLabel(new Word(proto.getRelation())));\n    } else {\n      relation = proto.getRelationTokensList().stream().map(sentence::get).collect(Collectors.toList());\n    }\n    List<CoreLabel> object = proto.getObjectTokensList().stream().map(sentence::get).collect(Collectors.toList());\n\n    // Create the extraction\n    RelationTriple extraction;\n    double confidence = proto.getConfidence();\n    if (proto.hasTree()) {\n      SemanticGraph tree = fromProto(proto.getTree(), sentence, docid);\n      extraction =  new RelationTriple.WithTree(subject, relation, object, tree, confidence);\n    } else {\n      extraction = new RelationTriple(subject, relation, object, confidence);\n    }\n\n    // Tweak the extraction\n    if (proto.hasIstmod()) { extraction.istmod(proto.getIstmod()); }\n    if (proto.hasPrefixBe()) { extraction.isPrefixBe(proto.getPrefixBe()); }\n    if (proto.hasSuffixBe()) { extraction.isSuffixBe(proto.getSuffixBe()); }\n    if (proto.hasSuffixOf()) { extraction.isSuffixOf(proto.getSuffixOf()); }\n\n    // Return\n    return extraction;\n  }\n",
    "new_code_raw": "  public static RelationTriple fromProto(CoreNLPProtos.RelationTriple proto, Annotation doc, int sentenceIndex) {\n    if (Thread.interrupted()) {\n      throw new RuntimeInterruptedException();\n    }\n    // Get the spans for the extraction\n    List<CoreLabel> subject = proto.getSubjectTokensList().stream().map(loc ->\n        doc.get(SentencesAnnotation.class).get(loc.getSentenceIndex()).get(TokensAnnotation.class).get(loc.getTokenIndex())\n        ).collect(Collectors.toList());\n    List<CoreLabel> relation;\n    if (proto.getRelationTokensCount() == 0) {  // If we don't have a real span for the relation, make a dummy word\n      relation = Collections.singletonList(new CoreLabel(new Word(proto.getRelation())));\n    } else {\n      relation = proto.getRelationTokensList().stream().map(loc ->\n          doc.get(SentencesAnnotation.class).get(loc.getSentenceIndex()).get(TokensAnnotation.class).get(loc.getTokenIndex())\n      ).collect(Collectors.toList());\n    }\n    List<CoreLabel> object = proto.getObjectTokensList().stream().map(loc ->\n        doc.get(SentencesAnnotation.class).get(loc.getSentenceIndex()).get(TokensAnnotation.class).get(loc.getTokenIndex())\n    ).collect(Collectors.toList());\n\n    // Create the extraction\n    RelationTriple extraction;\n    double confidence = proto.getConfidence();\n    if (proto.hasTree()) {\n      SemanticGraph tree = fromProto(\n          proto.getTree(),\n          doc.get(SentencesAnnotation.class).get(sentenceIndex).get(TokensAnnotation.class),\n          doc.get(DocIDAnnotation.class),\n          Optional.of(doc));\n      extraction =  new RelationTriple.WithTree(subject, relation, object, tree, confidence);\n    } else {\n      extraction = new RelationTriple(subject, relation, object, confidence);\n    }\n\n    // Tweak the extraction\n    if (proto.hasIstmod()) { extraction.istmod(proto.getIstmod()); }\n    if (proto.hasPrefixBe()) { extraction.isPrefixBe(proto.getPrefixBe()); }\n    if (proto.hasSuffixBe()) { extraction.isSuffixBe(proto.getSuffixBe()); }\n    if (proto.hasSuffixOf()) { extraction.isSuffixOf(proto.getSuffixOf()); }\n\n    // Return\n    return extraction;\n  }\n"
  },
  {
    "id": "RobotiumTech_robotium-288-Param-1",
    "old_comment_raw": "@param index the index of the list. E.g. Index 1 if two lists are available",
    "old_code_raw": "\tpublic ArrayList<TextView> clickInList(int line, int index) {\t\n\t\tline--;\n\t\tif(line < 0)\n\t\t\tline = 0;\n\n\t\tboolean foundList = waiter.waitForView(ListView.class, index);\n\t\tif (!foundList) \n\t\t\tAssert.assertTrue(\"No ListView with index \" + index + \" is available!\", false);\n\n\t\tArrayList<View> views = new ArrayList<View>();\n\t\tfinal ListView listView = viewFetcher.getView(ListView.class, null, index);\n\t\tif(listView == null)\n\t\t\tAssert.assertTrue(\"ListView is null!\", false);\n\n\t\tView view = listView.getChildAt(line);\n\t\tif(view != null){\n\t\t\tviews = viewFetcher.getViews(view, true);\n\t\t\tviews = RobotiumUtils.removeInvisibleViews(views);\n\t\t\tclickOnScreen(view);\n\t\t}\n\t\treturn RobotiumUtils.filterViews(TextView.class, views);\n\t}\n",
    "new_code_raw": "\tpublic ArrayList<TextView> clickInList(int line, int index, boolean longClick, int time) {\t\n\t\tline--;\n\t\tif(line < 0)\n\t\t\tline = 0;\n\n\t\tboolean foundList = waiter.waitForView(ListView.class, index);\n\t\tif (!foundList) \n\t\t\tAssert.assertTrue(\"No ListView with index \" + index + \" is available!\", false);\n\n\t\tArrayList<View> views = new ArrayList<View>();\n\t\tfinal ListView listView = viewFetcher.getView(ListView.class, null, index);\n\t\tif(listView == null)\n\t\t\tAssert.assertTrue(\"ListView is null!\", false);\n\n\t\tView view = listView.getChildAt(line);\n\t\tif(view != null){\n\t\t\tviews = viewFetcher.getViews(view, true);\n\t\t\tviews = RobotiumUtils.removeInvisibleViews(views);\n\t\t\tclickOnScreen(view, longClick, time);\n\t\t}\n\t\treturn RobotiumUtils.filterViews(TextView.class, views);\n\t}\n"
  },
  {
    "id": "JodaOrg_joda_time-1150-Param-1",
    "old_comment_raw": "@param scalar the second value",
    "old_code_raw": "    public static long safeMultiply(long val1, int scalar) {\n        switch (scalar) {\n        case -1:\n            return -val1;\n        case 0:\n            return 0L;\n        case 1:\n            return val1;\n        }\n        long total = val1 * scalar;\n        if (total / scalar != val1) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" * \" + scalar);\n        }\n        return total;\n    }\n",
    "new_code_raw": "    public static long safeMultiply(long val1, int val2) {\n        switch (val2) {\n            case -1:\n                if (val1 == Long.MIN_VALUE) {\n                    throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n                }\n                return -val1;\n            case 0:\n                return 0L;\n            case 1:\n                return val1;\n        }\n        long total = val1 * val2;\n        if (total / val2 != val1) {\n          throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n"
  },
  {
    "id": "apache_drill-752-Param-0",
    "old_comment_raw": "@param col - column for which approximate count distinct is desired",
    "old_code_raw": "  public Double getNdv(String col) {\n    // Stats might not have materialized because of errors.\n    if (!materialized) {\n      return null;\n    }\n    final String upperCol = col.toUpperCase();\n    Long ndvCol = ndv.get(upperCol);\n    if (ndvCol == null) {\n      ndvCol = ndv.get(SchemaPath.getSimplePath(upperCol).toString());\n    }\n    // Ndv estimation techniques like HLL may over-estimate, hence cap it at rowCount\n    if (ndvCol != null) {\n      return Math.min(ndvCol, rowCount);\n    }\n    return null;\n  }\n",
    "new_code_raw": "  public Double getNdv(SchemaPath col) {\n    // Stats might not have materialized because of errors.\n    if (!materialized) {\n      return null;\n    }\n    Long ndvCol = ndv.get(col);\n    // Ndv estimation techniques like HLL may over-estimate, hence cap it at rowCount\n    if (ndvCol != null) {\n      return Math.min(ndvCol, rowCount);\n    }\n    return null;\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1617-Param-0",
    "old_comment_raw": "@param p Swagger property object",
    "old_code_raw": "    public String toInstantiationType(Property p) {\n        if (p instanceof MapProperty) {\n            MapProperty ap = (MapProperty) p;\n            Property additionalProperties2 = ap.getAdditionalProperties();\n            String type = additionalProperties2.getType();\n            if (null == type) {\n                LOGGER.error(\"No Type defined for Additional Property \" + additionalProperties2 + \"\\n\" //\n                        + \"\\tIn Property: \" + p);\n            }\n            String inner = getSwaggerType(additionalProperties2);\n            return instantiationTypes.get(\"map\") + \"<String, \" + inner + \">\";\n        } else if (p instanceof ArrayProperty) {\n            ArrayProperty ap = (ArrayProperty) p;\n            String inner = getSwaggerType(ap.getItems());\n            return instantiationTypes.get(\"array\") + \"<\" + inner + \">\";\n        } else {\n            return null;\n        }\n    }\n",
    "new_code_raw": "    public String toInstantiationType(Schema schema) {\n        if (ModelUtils.isMapSchema(schema)) {\n            Schema additionalProperties = (Schema) schema.getAdditionalProperties();\n            String type = additionalProperties.getType();\n            if (null == type) {\n                LOGGER.error(\"No Type defined for Additional Property \" + additionalProperties + \"\\n\" //\n                        + \"\\tIn Property: \" + schema);\n            }\n            String inner = getSchemaType(additionalProperties);\n            return instantiationTypes.get(\"map\") + \"<String, \" + inner + \">\";\n        } else if (ModelUtils.isArraySchema(schema)) {\n            ArraySchema arraySchema = (ArraySchema) schema;\n            String inner = getSchemaType(arraySchema.getItems());\n            return instantiationTypes.get(\"array\") + \"<\" + inner + \">\";\n        } else {\n            return null;\n        }\n    }\n"
  },
  {
    "id": "SeleniumHQ_selenium-286-Param-0",
    "old_comment_raw": "@param uri The requested URI, which should include a scheme, host and port.",
    "old_code_raw": "  protected URL isProxied(URI uri) throws MalformedURLException {\n    // Is this a proxy request?\n    if (isForbidden(uri))\n      return null;\n\n    // OK return URI as untransformed URL.\n    return new URL(uri.toString());\n  }\n",
    "new_code_raw": "  protected URL isProxied(HttpURI uri) throws MalformedURLException {\n    // Is this a proxy request?\n    if (isForbidden(uri))\n      return null;\n\n    // OK return URI as untransformed URL.\n    return new URL(uri.toString());\n  }\n"
  },
  {
    "id": "RobotiumTech_robotium-1479-Param-1",
    "old_comment_raw": "@param index the index of the list. E.g. Index 1 if two lists are available",
    "old_code_raw": "\tpublic ArrayList<TextView> clickInList(int line, int index) {\n\treturn soloClick.clickInList(line, index);\n\t}\n",
    "new_code_raw": "\tpublic ArrayList<TextView> clickInList(int line, int listIndex) {\n\treturn soloClick.clickInList(line, listIndex);\n\t}\n"
  },
  {
    "id": "LawnchairLauncher_Lawnchair-17-Param-0",
    "old_comment_raw": "@param componentName the component that should own the icon",
    "old_code_raw": "    private Bitmap getPreloadedIcon(ComponentName componentName, UserHandleCompat user) {\n        final String key = componentName.flattenToShortString();\n\n        // We don't keep icons for other profiles in persistent cache.\n        if (!user.equals(UserHandleCompat.myUserHandle())) {\n            return null;\n        }\n\n        if (DEBUG) Log.v(TAG, \"looking for pre-load icon for \" + key);\n        Bitmap icon = null;\n        FileInputStream resourceFile = null;\n        try {\n            resourceFile = mContext.openFileInput(getResourceFilename(componentName));\n            byte[] buffer = new byte[1024];\n            ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n            int bytesRead = 0;\n            while(bytesRead >= 0) {\n                bytes.write(buffer, 0, bytesRead);\n                bytesRead = resourceFile.read(buffer, 0, buffer.length);\n            }\n            if (DEBUG) Log.d(TAG, \"read \" + bytes.size());\n            icon = BitmapFactory.decodeByteArray(bytes.toByteArray(), 0, bytes.size());\n            if (icon == null) {\n                Log.w(TAG, \"failed to decode pre-load icon for \" + key);\n            }\n        } catch (FileNotFoundException e) {\n            if (DEBUG) Log.d(TAG, \"there is no restored icon for: \" + key, e);\n        } catch (IOException e) {\n            Log.w(TAG, \"failed to read pre-load icon for: \" + key, e);\n        } finally {\n            if(resourceFile != null) {\n                try {\n                    resourceFile.close();\n                } catch (IOException e) {\n                    Log.d(TAG, \"failed to manage pre-load icon file: \" + key, e);\n                }\n            }\n        }\n\n        return icon;\n    }\n",
    "new_code_raw": "    private Bitmap getPreloadedIcon(ComponentName componentName) {\n        final String key = componentName.flattenToShortString();\n\n        if (DEBUG) Log.v(TAG, \"looking for pre-load icon for \" + key);\n        Bitmap icon = null;\n        FileInputStream resourceFile = null;\n        try {\n            resourceFile = mContext.openFileInput(getResourceFilename(componentName));\n            byte[] buffer = new byte[1024];\n            ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n            int bytesRead = 0;\n            while(bytesRead >= 0) {\n                bytes.write(buffer, 0, bytesRead);\n                bytesRead = resourceFile.read(buffer, 0, buffer.length);\n            }\n            if (DEBUG) Log.d(TAG, \"read \" + bytes.size());\n            icon = BitmapFactory.decodeByteArray(bytes.toByteArray(), 0, bytes.size());\n            if (icon == null) {\n                Log.w(TAG, \"failed to decode pre-load icon for \" + key);\n            }\n        } catch (FileNotFoundException e) {\n            if (DEBUG) Log.d(TAG, \"there is no restored icon for: \" + key, e);\n        } catch (IOException e) {\n            Log.w(TAG, \"failed to read pre-load icon for: \" + key, e);\n        } finally {\n            if(resourceFile != null) {\n                try {\n                    resourceFile.close();\n                } catch (IOException e) {\n                    Log.d(TAG, \"failed to manage pre-load icon file: \" + key, e);\n                }\n            }\n        }\n\n        if (icon != null) {\n            // TODO: handle alpha mask in the view layer\n            Bitmap b = Bitmap.createBitmap(Math.max(icon.getWidth(), 1),\n                    Math.max(icon.getHeight(), 1),\n                    Bitmap.Config.ARGB_8888);\n            Canvas c = new Canvas(b);\n            Paint paint = new Paint();\n            paint.setAlpha(127);\n            c.drawBitmap(icon, 0, 0, paint);\n            c.setBitmap(null);\n            icon.recycle();\n            icon = b;\n        }\n\n        return icon;\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2370-Param-0",
    "old_comment_raw": "@param words The input sentence (a List of words)",
    "old_code_raw": "  public Tree apply(List<? extends HasWord> words) {\n    return parse(words);\n  }\n",
    "new_code_raw": "  public Tree apply(Object in) {\n    List<? extends HasWord> lst;\n    if (in instanceof String) {\n      TokenizerFactory<? extends HasWord> tf = op.tlpParams.treebankLanguagePack().getTokenizerFactory();\n      Tokenizer<? extends HasWord> tokenizer = tf.getTokenizer(new BufferedReader(new StringReader((String) in)));\n      lst = tokenizer.tokenize();\n    } else if (in instanceof List) {\n      lst = ErasureUtils.uncheckedCast(in);\n    } else {\n      throw new IllegalArgumentException(\"Can only parse Sentence/List/String\");\n    }\n\n    try {\n      LexicalizedParserQuery pq = new LexicalizedParserQuery(this);\n      if (pq.parse(lst)) {\n        Tree bestparse = pq.getBestParse();\n        // -10000 denotes unknown words\n        bestparse.setScore(pq.getPCFGScore() % -10000.0);\n        return bestparse;\n      }\n    } catch (Exception e) {\n      System.err.println(\"Following exception caught during parsing:\");\n      e.printStackTrace();\n      System.err.println(\"Recovering using fall through strategy: will construct an (X ...) tree.\");\n    }\n    // if can't parse or exception, fall through\n    // TODO: merge with ParserAnnotatorUtils\n    TreeFactory lstf = new LabeledScoredTreeFactory();\n    List<Tree> lst2 = new ArrayList<Tree>();\n    for (HasWord obj : lst) {\n      String s = obj.word();\n      Tree t = lstf.newLeaf(s);\n      Tree t2 = lstf.newTreeNode(\"X\", Collections.singletonList(t));\n      lst2.add(t2);\n    }\n    return lstf.newTreeNode(\"X\", lst2);\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-432-Param-1",
    "old_comment_raw": "@param months the months to add (can be negative).",
    "old_code_raw": "    public long addWrapped(long millis, int months) {\n        return set(millis, getWrappedValue(get(millis), months, MIN, MAX));\n    }\n",
    "new_code_raw": "    public long addWrapped(long instant, int months) {\n        return set(instant, Utils.getWrappedValue(get(instant), months, MIN, MAX));\n    }\n"
  },
  {
    "id": "trygvis_jop-152-Associations-Param0",
    "old_comment_raw": "@param signature the membername and descriptor of the method (classname is ignored).",
    "old_code_raw": "    public MethodInfo createMethod(Signature signature, String[] argNames) {\n        return createMethod(signature, argNames, null);\n    }\n",
    "new_code_raw": "    public MethodInfo createMethod(MemberID memberID, String[] argNames) {\n        return createMethod(memberID, argNames, null);\n    }\n\n"
  },
  {
    "id": "apache_calcite-580-Param-0",
    "old_comment_raw": "@param name Suggested name, may not be unique",
    "old_code_raw": "    public static String uniquify(String name, Collection<String> nameList)\n    {\n        if (name == null) {\n            name = \"EXPR$\";\n        }\n        if (nameList.contains(name)) {\n            String aliasBase = name;\n            for (int j = 0;; j++) {\n                name = aliasBase + j;\n                if (!nameList.contains(name)) {\n                    break;\n                }\n            }\n        }\n        nameList.add(name);\n        return name;\n    }\n",
    "new_code_raw": "    public static String uniquify(String name, Set<String> nameList)\n    {\n        if (name == null) {\n            name = \"EXPR$\";\n        }\n        if (nameList.add(name)) {\n            return name;\n        }\n        String aliasBase = name;\n        for (int j = 0;; j++) {\n            name = aliasBase + j;\n            if (nameList.add(name)) {\n                return name;\n            }\n        }\n    }\n"
  },
  {
    "id": "debezium_debezium-30-Param-0",
    "old_comment_raw": "@param fullyQualifiedTableNames the comma-separated list of fully-qualified table names to exclude; may be null or empty",
    "old_code_raw": "    public static Predicate<ColumnId> excludeColumns(String fullyQualifiedTableNames) {\n        return Predicates.excludes(fullyQualifiedTableNames, ColumnId::toString);\n    }\n",
    "new_code_raw": "    public static Predicate<ColumnId> excludeColumns(String columnNames) {\n        return Predicates.excludes(columnNames, ColumnId::toString);\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1220-Param-1",
    "old_comment_raw": "@param key The item key",
    "old_code_raw": "\tpublic boolean putFromLoad(SessionImplementor session, Object key, Object value, long txTimestamp, Object version, boolean minimalPutOverride)\n\t\t\tthrows CacheException {\n\t\tif ( !region.checkValid() ) {\n\t\t\tif ( TRACE_ENABLED ) {\n\t\t\t\tlog.tracef( \"Region %s not valid\", region.getName() );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// In theory, since putForExternalRead is already as minimal as it can\n\t\t// get, we shouldn't be need this check. However, without the check and\n\t\t// without https://issues.jboss.org/browse/ISPN-1986, it's impossible to\n\t\t// know whether the put actually occurred. Knowing this is crucial so\n\t\t// that Hibernate can expose accurate statistics.\n\t\tif ( minimalPutOverride && cache.containsKey( key ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tPutFromLoadValidator.Lock lock = putValidator.acquirePutFromLoadLock(session, key, txTimestamp);\n\t\tif ( lock == null) {\n\t\t\tif ( TRACE_ENABLED ) {\n\t\t\t\tlog.tracef( \"Put from load lock not acquired for key %s\", key );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\t\t\twriteCache.putForExternalRead( key, value );\n\t\t}\n\t\tfinally {\n\t\t\tputValidator.releasePutFromLoadLock( key, lock);\n\t\t}\n\n\t\treturn true;\n\t}\n",
    "new_code_raw": "\tpublic boolean putFromLoad(SharedSessionContractImplementor session, Object key, Object value, long txTimestamp, Object version, boolean minimalPutOverride)\n\t\t\tthrows CacheException {\n\t\tif ( !region.checkValid() ) {\n\t\t\tif ( TRACE_ENABLED ) {\n\t\t\t\tlog.tracef( \"Region %s not valid\", region.getName() );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// In theory, since putForExternalRead is already as minimal as it can\n\t\t// get, we shouldn't be need this check. However, without the check and\n\t\t// without https://issues.jboss.org/browse/ISPN-1986, it's impossible to\n\t\t// know whether the put actually occurred. Knowing this is crucial so\n\t\t// that Hibernate can expose accurate statistics.\n\t\tif ( minimalPutOverride && cache.containsKey( key ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tPutFromLoadValidator.Lock lock = putValidator.acquirePutFromLoadLock(session, key, txTimestamp);\n\t\tif ( lock == null) {\n\t\t\tif ( TRACE_ENABLED ) {\n\t\t\t\tlog.tracef( \"Put from load lock not acquired for key %s\", key );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\t\t\twriteCache.putForExternalRead( key, value );\n\t\t}\n\t\tfinally {\n\t\t\tputValidator.releasePutFromLoadLock( key, lock);\n\t\t}\n\n\t\treturn true;\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-286-Param-4",
    "old_comment_raw": "@param headerParams The header parameters",
    "old_code_raw": "  public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n",
    "new_code_raw": "  public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n"
  },
  {
    "id": "zaproxy_zaproxy-1141-Param-1",
    "old_comment_raw": "@param performRecursiveCheck True = get recursively the suffix from all the children.",
    "old_code_raw": "    private String getChildSuffix(SiteNode node, boolean performRecursiveCheck) {\n\n        String resultSuffix = \"\";\n        String suffix = null;\n        SiteNode child = null;\n        HistoryReference ref = null;\n        try {\n\n            for (int i = 0; i < staticSuffixList.length; i++) {\n                suffix = staticSuffixList[i];\n                for (int j = 0; j < node.getChildCount(); j++) {\n                    child = (SiteNode) node.getChildAt(j);\n                    ref = child.getHistoryReference();\n                    try {\n                        if (ref.getURI().getPath().endsWith(suffix)) {\n                            return suffix;\n                        }\n                    } catch (Exception e) {\n                    }\n                }\n            }\n\n            if (performRecursiveCheck) {\n                for (int j = 0; j < node.getChildCount(); j++) {\n                    resultSuffix = getChildSuffix((SiteNode) node.getChildAt(j), performRecursiveCheck);\n                    if (!resultSuffix.equals(\"\")) {\n                        return resultSuffix;\n                    }\n                }\n            }\n\n        } catch (Exception e) {\n        }\n\n        return resultSuffix;\n    }\n",
    "new_code_raw": "    private String getChildSuffix(StructuralNode node, boolean performRecursiveCheck) {\n\n        String resultSuffix = \"\";\n        String suffix = null;\n        StructuralNode child = null;\n        try {\n\n            for (int i = 0; i < staticSuffixList.length; i++) {\n                suffix = staticSuffixList[i];\n                Iterator<StructuralNode> iter = node.getChildIterator();\n                while (iter.hasNext()) {\n                    child = iter.next();\n                    try {\n                        if (child.getURI().getPath().endsWith(suffix)) {\n                            return suffix;\n                        }\n                    } catch (Exception e) {\n                    }\n                }\n            }\n\n            if (performRecursiveCheck) {\n                Iterator<StructuralNode> iter = node.getChildIterator();\n                while (iter.hasNext()) {\n                    child = iter.next();\n                    resultSuffix = getChildSuffix(child, performRecursiveCheck);\n                    if (!resultSuffix.equals(\"\")) {\n                        return resultSuffix;\n                    }\n                }\n            }\n\n        } catch (Exception e) {\n        }\n\n        return resultSuffix;\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2365-Param-0",
    "old_comment_raw": "@param t Target for finding dependents of t related by this GR",
    "old_code_raw": "  public Collection<TreeGraphNode> getRelatedNodes(TreeGraphNode t, TreeGraphNode root, HeadFinder headFinder) {\n    Set<TreeGraphNode> nodeList = new ArraySet<>();\n    for (TregexPattern p : targetPatterns) {    // cdm: I deleted: && nodeList.isEmpty()\n      // Initialize the TregexMatcher with the HeadFinder so that we\n      // can use the same HeadFinder through the entire process of\n      // building the dependencies\n      TregexMatcher m = p.matcher(root, headFinder);\n      while (m.findAt(t)) {\n        TreeGraphNode target = (TreeGraphNode) m.getNode(\"target\");\n        if (target == null) {\n          throw new AssertionError(\"Expression has no target: \" + p);\n        }\n        nodeList.add(target);\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \"-\" + t.headWordNode() + \", \" + m.getNode(\"target\") + \"-\" + ((TreeGraphNode) m.getNode(\"target\")).headWordNode() + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\"))\n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n",
    "new_code_raw": "  public Collection<Tree> getRelatedNodes(Tree t, Tree root) {\n    if (root.value() == null) {\n      root.setValue(\"ROOT\");  // todo: cdm: it doesn't seem like this line should be here\n    }\n    Set<Tree> nodeList = new LinkedHashSet<Tree>();\n    for (TregexPattern p : targetPatterns) {    // cdm: I deleted: && nodeList.isEmpty()\n      TregexMatcher m = p.matcher(root);\n      while (m.findAt(t)) {\n        nodeList.add(m.getNode(\"target\"));\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\")) \n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-53-Param-0",
    "old_comment_raw": "@param instant the partial instant",
    "old_code_raw": "    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {\n        int current = values[fieldIndex];\n        int wrapped = FieldUtils.getWrappedValue\n            (current, valueToAdd, getMinimumValue(instant), getMaximumValue(instant));\n        return set(instant, fieldIndex, values, wrapped);  // adjusts smaller fields\n    }\n",
    "new_code_raw": "    public int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n        int current = values[fieldIndex];\n        int wrapped = FieldUtils.getWrappedValue\n            (current, valueToAdd, getMinimumValue(instant), getMaximumValue(instant));\n        return set(instant, fieldIndex, values, wrapped);  // adjusts smaller fields\n    }\n"
  },
  {
    "id": "apache_deltaspike-15-Associations-Param0",
    "old_comment_raw": "@param ade The previously thrown exception representing a authorization check failure.",
    "old_code_raw": "    private boolean handleAccessDeniedException(AccessDeniedException ade) throws AccessDeniedException\n    {\n        ExceptionToCatchEvent exceptionToCatchEvent = new ExceptionToCatchEvent(ade);\n\n        exceptionToCatchEvent.setOptional(true);\n\n        beanManager.fireEvent(exceptionToCatchEvent);\n\n        if (!exceptionToCatchEvent.isHandled())\n        {\n            throw ade;\n        }\n\n        return false;\n    }\n",
    "new_code_raw": "    protected RuntimeException handleAccessDeniedException(AccessDeniedException originalException)\n    {\n        ExceptionToCatchEvent exceptionToCatchEvent = new ExceptionToCatchEvent(originalException);\n        this.beanManager.fireEvent(exceptionToCatchEvent);\n        //the next step won't happen per default since ExceptionHandlerBroadcaster will throw the exception,\n        //because BeforeAccessDeniedExceptionHandler calls #throwOriginal\n        //but allows to suppress it via deactivating BeforeAccessDeniedExceptionHandler\n        //(or a 2nd @BeforeHandles method which overrules the default behavior\n        //(if needed)\n        if (!exceptionToCatchEvent.isHandled())\n        {\n            throw originalException;\n        }\n\n        return null;\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1727-Param-2",
    "old_comment_raw": "@param queryParams The query parameters",
    "old_code_raw": "    public Call buildCall(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n        Request request = buildRequest(path, method, queryParams, collectionQueryParams, body, headerParams, formParams, authNames, progressRequestListener);\n\n        return httpClient.newCall(request);\n    }\n",
    "new_code_raw": "    public Call buildCall(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {\n        Request request = buildRequest(path, method, queryParams, collectionQueryParams, body, headerParams, formParams, authNames, callback);\n\n        return httpClient.newCall(request);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1674-Param-0",
    "old_comment_raw": "@param body client model",
    "old_code_raw": "    public Client testClientModel(Client body) throws RestClientException {\n        Object postBody = body;\n        \n        // verify the required parameter 'body' is set\n        if (body == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling testClientModel\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"/fake\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "new_code_raw": "    public Client testClientModel(Client client) throws RestClientException {\n        Object postBody = client;\n        \n        // verify the required parameter 'client' is set\n        if (client == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'client' when calling testClientModel\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"/fake\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-1188-Param-3",
    "old_comment_raw": "@param scroll whether scrolling should be performed",
    "old_code_raw": "\tpublic boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int matches, boolean scroll) {\n\t\tfinal long endTime = System.currentTimeMillis() + TIMEOUT;\n\n\t\twhile (System.currentTimeMillis() < endTime) {\n\t\t\tsleeper.sleep();\n\t\t\tfinal boolean foundAnyMatchingView = searchFor(viewClass, regex, matches, scroll);\n\t\t\tif (foundAnyMatchingView){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n",
    "new_code_raw": "\tpublic boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll) {\n\t\tfinal long endTime = System.currentTimeMillis() + TIMEOUT;\n\n\t\twhile (System.currentTimeMillis() < endTime) {\n\t\t\tsleeper.sleep();\n\t\t\tfinal boolean foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, scroll);\n\t\t\tif (foundAnyMatchingView){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2408-Param-1",
    "old_comment_raw": "@param docdate The document date",
    "old_code_raw": "  public static String normalizeDateString(String s, Date docdate) {\n    // TODO [pengqi]: still need to handle relative dates (\"\u00e5\u008e\u00bb\u00e5\u00b9\u00b4\") and temporal references (\"\u00e5\u00bd\u0093\u00e6\u0097\u00b6\")\n    // TODO [pengqi]: need to handle irregular years (\"81\u00e5\u00b9\u00b4\")\n    // TODO [pengqi]: need to handle basic localization (\"\u00e5\u009c\u00a8\u00e4\u00b8\u0083\u00e6\u009c\u0088\u00e4\u00ba\u008c\u00e6\u0097\u00a5\u00e5\u0088\u00b0[\u00e5\u0085\u00ab\u00e6\u0097\u00a5]\u00e9\u0097\u00b4\")\n    Pattern p = Pattern.compile(BASIC_YYYYMMDD_PATTERN);\n    Matcher m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 3) {\n      StringBuilder res = new StringBuilder();\n      String year = m.group(1);\n      for (int i = 0; i < year.length(); i++) {\n        String t = \"\" + year.charAt(i);\n        if (CHINESE_LITERAL_DECIMAL_PATTERN.matcher(t).matches()) {\n          if (wordsToValues.containsKey(t))\n            res.append((int)wordsToValues.getCount(t));\n          else\n            // something unexpected happened\n            return null;\n        } else\n          res.append(t);\n      }\n\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2)));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(3)));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(BASIC_MMDD_PATTERN);\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 2) {\n      StringBuilder res = new StringBuilder();\n      String year = new SimpleDateFormat(\"yyyy\").format(docdate);\n\n      res.append(year);\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1)));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2)));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(BASIC_DD_PATTERN);\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 1) {\n      StringBuilder res = new StringBuilder();\n      String year = new SimpleDateFormat(\"yyyy\").format(docdate);\n      String month = new SimpleDateFormat(\"MM\").format(docdate);\n\n      res.append(year);\n      res.append(\"-\");\n      res.append(month);\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1)));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(ENGLISH_MMDDYYYY_PATTERN);\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 3) {\n      StringBuilder res = new StringBuilder();\n\n      String year = new SimpleDateFormat(\"yyyy\").format(docdate);\n\n      if (m.group(3) == null)\n        res.append(year);\n      else\n        res.append(m.group(3));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1)));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2)));\n\n      return res.toString();\n    }\n\n    return s;\n  }\n",
    "new_code_raw": "  public static String normalizeDateString(String s, Date ctxdate) {\n    // TODO [pengqi]: need to handle basic localization (\"\u00e5\u009c\u00a8\u00e4\u00b8\u0083\u00e6\u009c\u0088\u00e4\u00ba\u008c\u00e6\u0097\u00a5\u00e5\u0088\u00b0[\u00e5\u0085\u00ab\u00e6\u0097\u00a5]\u00e9\u0097\u00b4\")\n    // TODO [pengqi]: need to handle literal numeral dates (usually used in events, e.g. \"\u00e4\u00b8\u0089\u00e4\u00b8\u0080\u00e4\u00ba\u0094\" for 03-15)\n    // TODO [pengqi]: might need to add a pattern for centuries (\"\u00e4\u00b8\u008a\u00e4\u00b8\u0096\u00e7\u00ba\u00aa90\u00e5\u00b9\u00b4\u00e4\u00bb\u00a3\")?\n    String ctxyear = new SimpleDateFormat(\"yyyy\").format(ctxdate);\n    String ctxmonth = new SimpleDateFormat(\"MM\").format(ctxdate);\n    String ctxday = new SimpleDateFormat(\"dd\").format(ctxdate);\n\n    Pattern p = Pattern.compile(\"^\" + BASIC_YYYYMMDD_PATTERN + \"$\");\n    Matcher m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 3) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(normalizeYear(m.group(1), ctxyear));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2), ctxmonth));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(3), ctxday));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + BASIC_MMDD_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 2) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(ctxyear);\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1), ctxmonth));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2), ctxday));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + BASIC_DD_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 1) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(ctxyear);\n      res.append(\"-\");\n      res.append(ctxmonth);\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1), ctxday));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + ENGLISH_MMDDYYYY_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 3) {\n      StringBuilder res = new StringBuilder();\n\n      if (m.group(3) == null)\n        res.append(ctxyear);\n      else\n        res.append(normalizeYear(m.group(3), ctxyear));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1), ctxmonth));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2), ctxday));\n\n      return res.toString();\n    }\n\n    return s;\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-686-Param-0",
    "old_comment_raw": "@param code The  java.sql.Types typecode",
    "old_code_raw": "\tpublic String getTypeName(int code, int length, int precision, int scale) throws HibernateException {\n\t\tString result = typeNames.get( code, length, precision, scale );\n\t\tif ( result == null ) {\n\t\t\tthrow new HibernateException(\n\t\t\t\t\t\"No type mapping for java.sql.Types code: \" +\n\t\t\t\t\tcode +\n\t\t\t\t\t\", length: \" +\n\t\t\t\t\tlength\n\t\t\t);\n\t\t}\n\t\treturn result;\n\t}\n",
    "new_code_raw": "\tpublic String getTypeName(int code, long length, int precision, int scale) throws HibernateException {\n\t\tString result = typeNames.get( code, length, precision, scale );\n\t\tif ( result == null ) {\n\t\t\tthrow new HibernateException(\n\t\t\t\t\t\"No type mapping for java.sql.Types code: \" +\n\t\t\t\t\tcode +\n\t\t\t\t\t\", length: \" +\n\t\t\t\t\tlength\n\t\t\t);\n\t\t}\n\t\treturn result;\n\t}\n"
  },
  {
    "id": "apache_drill-964-Param-0",
    "old_comment_raw": "@param buffer ByteBuf to read from",
    "old_code_raw": "    public static long readVLong(ByteBuf buffer, int start, int end) {\n      buffer.readerIndex(start);\n      byte firstByte = buffer.readByte();\n      int len = decodeVIntSize(firstByte);\n      int availableBytes = (end-start);\n      if (len == 1) {\n        return firstByte;\n      } else if (availableBytes < len) {\n        throw new NumberFormatException(\"Expected \" + len + \" bytes but the buffer '\"\n            + DrillStringUtils.toBinaryString(buffer, start, end) + \"' has  \"\n            + availableBytes + \" bytes.\");\n      }\n\n      long longValue = 0;\n      for (int idx = 0; idx < len-1; idx++) {\n        byte byteValue = buffer.readByte();\n        longValue = longValue << 8;\n        longValue = longValue | (byteValue & 0xFF);\n      }\n      return (isNegativeVInt(firstByte) ? (longValue ^ -1L) : longValue);\n    }\n",
    "new_code_raw": "    public static long readVLong(DrillBuf buffer, int start, int end) {\n      buffer.readerIndex(start);\n      byte firstByte = buffer.readByte();\n      int len = decodeVIntSize(firstByte);\n      int availableBytes = (end-start);\n      if (len == 1) {\n        return firstByte;\n      } else if (availableBytes < len) {\n        throw new NumberFormatException(\"Expected \" + len + \" bytes but the buffer '\"\n            + DrillStringUtils.toBinaryString(buffer, start, end) + \"' has  \"\n            + availableBytes + \" bytes.\");\n      }\n\n      long longValue = 0;\n      for (int idx = 0; idx < len-1; idx++) {\n        byte byteValue = buffer.readByte();\n        longValue = longValue << 8;\n        longValue = longValue | (byteValue & 0xFF);\n      }\n      return (isNegativeVInt(firstByte) ? (longValue ^ -1L) : longValue);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-708-Param-11",
    "old_comment_raw": "@param password None (optional)",
    "old_code_raw": "  public Call testEndpointParametersAsync(String number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password, final ApiCallback<Void> callback) throws ApiException {\n\n    ProgressResponseBody.ProgressListener progressListener = null;\n    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n    if (callback != null) {\n      progressListener = new ProgressResponseBody.ProgressListener() {\n        @Override\n        public void update(long bytesRead, long contentLength, boolean done) {\n          callback.onDownloadProgress(bytesRead, contentLength, done);\n        }\n      };\n\n      progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {\n        @Override\n        public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {\n          callback.onUploadProgress(bytesWritten, contentLength, done);\n        }\n      };\n    }\n\n    Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, progressListener, progressRequestListener);\n    apiClient.executeAsync(call, callback);\n    return call;\n  }\n",
    "new_code_raw": "  public Call testEndpointParametersAsync(BigDecimal number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password, final ApiCallback<Void> callback) throws ApiException {\n\n    ProgressResponseBody.ProgressListener progressListener = null;\n    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n    if (callback != null) {\n      progressListener = new ProgressResponseBody.ProgressListener() {\n        @Override\n        public void update(long bytesRead, long contentLength, boolean done) {\n          callback.onDownloadProgress(bytesRead, contentLength, done);\n        }\n      };\n\n      progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {\n        @Override\n        public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {\n          callback.onUploadProgress(bytesWritten, contentLength, done);\n        }\n      };\n    }\n\n    Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, progressListener, progressRequestListener);\n    apiClient.executeAsync(call, callback);\n    return call;\n  }\n"
  },
  {
    "id": "apache_empire-db-13-Associations-Param1",
    "old_comment_raw": "@param  the type for th list",
    "old_code_raw": "    public <T> List<T> querySimpleList(Class<T> c, String sqlCmd, Connection conn)\n    {   // Execute the  Statement\n        if (checkOpen()==false)\n            return null;\n        // Debug\n        ResultSet rs = null;\n        try\n        {\t// Check Open\n            if (checkOpen()==false)\n                return null;\n            // Debug\n            long start = System.currentTimeMillis();\n            if (log.isInfoEnabled())\n                log.info(\"executing: \" + sqlCmd);\n            // Get the next Value\n            rs = driver.executeQuery(sqlCmd, null, false, conn);\n            if (rs == null)\n            { // Error\n                error(driver);\n                return null;\n            }\n            // Check Result\n            List<T> result = new ArrayList<T>();\n            while (rs.next())\n            {\n                T item = ObjectUtils.convert(c, rs.getObject(1));\n                result.add(item);\n            }\n            // No Value\n            if (log.isInfoEnabled())\n                log.info(\"querySimpleList retured \"+String.valueOf(result.size())+\" items. Query completed in \" + String.valueOf(System.currentTimeMillis() - start) + \" ms\");\n            clearError();\n            return result;\n        } catch (ClassCastException e) \n        {   \n            log.error(\"querySingleValue cast exception: \", e);\n            error(Errors.Exception, e);\n            return null;\n        } catch (SQLException e) \n        {\n            log.error(\"querySimpleList exception: \", e);\n            error(DBErrors.QueryFailed, e);\n            return null;\n        } finally\n        { // Cleanup\n            closeResultSet(rs);\n        }\n    }\n",
    "new_code_raw": "    public <T> int querySimpleList(Class<T> c, String sqlCmd, Connection conn, Collection<T> result)\n    {   // Check status\n        if (checkOpen()==false)\n            return -1;\n        // Start query\n        ResultSet rs = null;\n        try\n        {   // Log performance\n            long start = System.currentTimeMillis();\n            if (log.isInfoEnabled())\n                log.info(\"executing: \" + sqlCmd);\n            // Get the next Value\n            rs = driver.executeQuery(sqlCmd, null, false, conn);\n            if (rs == null)\n            { // Error\n                error(driver);\n                return -1;\n            }\n            // Check Result\n            int count=0;\n            while (rs.next())\n            {\n                T item = ObjectUtils.convert(c, rs.getObject(1));\n                result.add(item);\n                count++;\n            }\n            // No Value\n            if (log.isInfoEnabled())\n                log.info(\"querySimpleList retured \"+String.valueOf(count)+\" items. Query completed in \" + String.valueOf(System.currentTimeMillis() - start) + \" ms\");\n            clearError();\n            return count;\n        } catch (ClassCastException e) \n        {   \n            log.error(\"querySingleValue cast exception: \", e);\n            error(Errors.Exception, e);\n            return -1;\n        } catch (SQLException e) \n        {\n            log.error(\"querySimpleList exception: \", e);\n            error(DBErrors.QueryFailed, e);\n            return -1;\n        } finally\n        { // Cleanup\n            closeResultSet(rs);\n        }\n    }\n\n"
  },
  {
    "id": "graphql_java_graphql_java-263-Param-2",
    "old_comment_raw": "@param fetchedValue the fetched raw value",
    "old_code_raw": "    protected FieldValueInfo completeField(ExecutionContext executionContext, ExecutionStrategyParameters parameters, Object fetchedValue) {\n        Field field = parameters.getField().getSingleField();\n        GraphQLObjectType parentType = (GraphQLObjectType) parameters.getExecutionStepInfo().getUnwrappedNonNullType();\n        GraphQLFieldDefinition fieldDef = getFieldDef(executionContext.getGraphQLSchema(), parentType, field);\n        ExecutionStepInfo executionStepInfo = createExecutionStepInfo(executionContext, parameters, fieldDef);\n\n        Instrumentation instrumentation = executionContext.getInstrumentation();\n        InstrumentationFieldCompleteParameters instrumentationParams = new InstrumentationFieldCompleteParameters(executionContext, parameters, fieldDef, executionStepInfo, fetchedValue);\n        InstrumentationContext<ExecutionResult> ctxCompleteField = instrumentation.beginFieldComplete(\n                instrumentationParams\n        );\n\n        GraphQLCodeRegistry codeRegistry = executionContext.getGraphQLSchema().getCodeRegistry();\n        Map<String, Object> argumentValues = valuesResolver.getArgumentValues(codeRegistry, fieldDef.getArguments(), field.getArguments(), executionContext.getVariables());\n\n        NonNullableFieldValidator nonNullableFieldValidator = new NonNullableFieldValidator(executionContext, executionStepInfo);\n\n        ExecutionStrategyParameters newParameters = parameters.transform(builder ->\n                builder.executionStepInfo(executionStepInfo)\n                        .arguments(argumentValues)\n                        .source(fetchedValue)\n                        .nonNullFieldValidator(nonNullableFieldValidator)\n        );\n\n        log.debug(\"'{}' completing field '{}'...\", executionContext.getExecutionId(), executionStepInfo.getPath());\n\n        FieldValueInfo fieldValueInfo = completeValue(executionContext, newParameters);\n\n        CompletableFuture<ExecutionResult> executionResultFuture = fieldValueInfo.getFieldValue();\n        ctxCompleteField.onDispatched(executionResultFuture);\n        executionResultFuture.whenComplete(ctxCompleteField::onCompleted);\n        return fieldValueInfo;\n    }\n",
    "new_code_raw": "    protected FieldValueInfo completeField(ExecutionContext executionContext, ExecutionStrategyParameters parameters, FetchedValue fetchedValue) {\n        Field field = parameters.getField().getSingleField();\n        GraphQLObjectType parentType = (GraphQLObjectType) parameters.getExecutionStepInfo().getUnwrappedNonNullType();\n        GraphQLFieldDefinition fieldDef = getFieldDef(executionContext.getGraphQLSchema(), parentType, field);\n        ExecutionStepInfo executionStepInfo = createExecutionStepInfo(executionContext, parameters, fieldDef);\n\n        Instrumentation instrumentation = executionContext.getInstrumentation();\n        InstrumentationFieldCompleteParameters instrumentationParams = new InstrumentationFieldCompleteParameters(executionContext, parameters, fieldDef, executionStepInfo, fetchedValue);\n        InstrumentationContext<ExecutionResult> ctxCompleteField = instrumentation.beginFieldComplete(\n                instrumentationParams\n        );\n\n        GraphQLCodeRegistry codeRegistry = executionContext.getGraphQLSchema().getCodeRegistry();\n        Map<String, Object> argumentValues = valuesResolver.getArgumentValues(codeRegistry, fieldDef.getArguments(), field.getArguments(), executionContext.getVariables());\n\n        NonNullableFieldValidator nonNullableFieldValidator = new NonNullableFieldValidator(executionContext, executionStepInfo);\n\n        ExecutionStrategyParameters newParameters = parameters.transform(builder ->\n                builder.executionStepInfo(executionStepInfo)\n                        .arguments(argumentValues)\n                        .source(fetchedValue.getFetchedValue())\n                        .localContext(fetchedValue.getLocalContext())\n                        .nonNullFieldValidator(nonNullableFieldValidator)\n        );\n\n        log.debug(\"'{}' completing field '{}'...\", executionContext.getExecutionId(), executionStepInfo.getPath());\n\n        FieldValueInfo fieldValueInfo = completeValue(executionContext, newParameters);\n\n        CompletableFuture<ExecutionResult> executionResultFuture = fieldValueInfo.getFieldValue();\n        ctxCompleteField.onDispatched(executionResultFuture);\n        executionResultFuture.whenComplete(ctxCompleteField::onCompleted);\n        return fieldValueInfo;\n    }\n"
  },
  {
    "id": "dropwizard_dropwizard-40-Associations-Param1",
    "old_comment_raw": "@param urlPattern the URL pattern for requests that should be handled by  filter",
    "old_code_raw": "    public FilterBuilder addFilter(Filter filter,\n                                   String urlPattern) {\n        final FilterHolder holder = new FilterHolder(checkNotNull(filter));\n        final FilterBuilder builder = new FilterBuilder(holder, handler);\n        builder.addUrlPattern(checkNotNull(urlPattern));\n        return builder;\n    }\n",
    "new_code_raw": "    public FilterRegistration.Dynamic addFilter(String name, Filter filter) {\n        final FilterHolder holder = new FilterHolder(checkNotNull(filter));\n        holder.setName(name);\n        handler.getServletHandler().addFilter(holder);\n        return holder.getRegistration();\n    }\n\n"
  },
  {
    "id": "yanzhenjie_NoHttp-24-Param-0",
    "old_comment_raw": "@param context ApplicationContext",
    "old_code_raw": "\tpublic static RequestQueue newRequestQueue(Context context, int threadPoolSize) {\n\t\tRequestQueue requestQueue = new RequestQueue(HttpRestConnection.getInstance(context), threadPoolSize);\n\t\trequestQueue.start();\n\t\treturn requestQueue;\n\t}\n",
    "new_code_raw": "\tpublic static RequestQueue newRequestQueue(int threadPoolSize) {\n\t\tRequestQueue requestQueue = new RequestQueue(HttpRestConnection.getInstance(getContext()), threadPoolSize);\n\t\trequestQueue.start();\n\t\treturn requestQueue;\n\t}\n"
  },
  {
    "id": "RobotiumTech_robotium-1190-Param-1",
    "old_comment_raw": "@param matches the number of matches expected to be found.  0 matches means that one or more matches are expected to be found",
    "old_code_raw": "\tpublic boolean searchToggleButton(String regex, int matches) {\n\t\tboolean found = searcher.searchWithTimeoutFor(ToggleButton.class, regex, matches, true);\n\t\treturn found;\n\t}\n",
    "new_code_raw": "\tpublic boolean searchToggleButton(String regex, int expectedMinimumNumberOfMatches) {\n\t\tboolean found = searcher.searchWithTimeoutFor(ToggleButton.class, regex, expectedMinimumNumberOfMatches, true);\n\t\treturn found;\n\t}\n"
  },
  {
    "id": "JodaOrg_joda_time-55-Param-3",
    "old_comment_raw": "@param text the text value to set",
    "old_code_raw": "    public int[] set(PartialInstant instant, int fieldIndex, int[] values, String text, Locale locale) {\n        int value = convertText(text, locale);\n        return set(instant, fieldIndex, values, value);\n    }\n",
    "new_code_raw": "    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, String text, Locale locale) {\n        int value = convertText(text, locale);\n        return set(instant, fieldIndex, values, value);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1683-Param-0",
    "old_comment_raw": "@param booleanPostBody Input boolean as post body (optional)",
    "old_code_raw": "  public Boolean fakeOuterBooleanSerialize(Boolean booleanPostBody) throws ApiException {\n    Object localVarPostBody = booleanPostBody;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/boolean\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"*/*\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/boolean\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"*/*\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "LawnchairLauncher_Lawnchair-26-Param-0",
    "old_comment_raw": "@param context The application's context.",
    "old_code_raw": "    static Folder fromXml(Context context) {\n        return (Folder) LayoutInflater.from(context).inflate(R.layout.user_folder, null);\n    }\n",
    "new_code_raw": "    static Folder fromXml(Launcher launcher) {\n        return (Folder) LayoutInflater.from(launcher).inflate(R.layout.user_folder,\n                launcher.getDragLayer(), false);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1649-Param-0",
    "old_comment_raw": "@param body Input composite as post body",
    "old_code_raw": "    public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws IOException {\n        HttpResponse response = fakeOuterCompositeSerializeForHttpResponse(body);\n        TypeReference typeRef = new TypeReference<OuterComposite>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n",
    "new_code_raw": "    public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws IOException {\n        HttpResponse response = fakeOuterCompositeSerializeForHttpResponse(outerComposite);\n        TypeReference typeRef = new TypeReference<OuterComposite>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-286-Param-1",
    "old_comment_raw": "@param method The request method, one of \"GET\", \"POST\", \"PUT\", and \"DELETE\"",
    "old_code_raw": "  public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n",
    "new_code_raw": "  public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n"
  },
  {
    "id": "processing_processing-1242-Param-0",
    "old_comment_raw": "@param parent The PGraphics object (or any object, really) associated",
    "old_code_raw": "  public Object getCache(Object parent) {\n    return g.getCache(parent);\n  }\n",
    "new_code_raw": "  public PMetadata getCache(PGraphics renderer) {\n    return g.getCache(renderer);\n  }\n"
  },
  {
    "id": "apache_flume-3-Param-0",
    "old_comment_raw": "@param t",
    "old_code_raw": "  static EventSource buildEventSource(CommonTree t) throws FlumeSpecException {\n    ASTNODE type = ASTNODE.valueOf(t.getText()); // convert to enum\n    switch (type) {\n    case SOURCE: {\n      // TODO thread context through sources\n      // Context ctx = new Context(context);\n      Context ctx = new Context();\n      Pair<String, List<String>> idArgs = handleArgs(t, ctx);\n      String sourceType = idArgs.getLeft();\n      List<String> args = idArgs.getRight();\n\n      EventSource src = srcFactory.getSource(sourceType, args\n          .toArray(new String[0]));\n      if (src == null) {\n        throw new FlumeIdException(\"Invalid source: \"\n            + FlumeSpecGen.genEventSource(t));\n      }\n      return src;\n    }\n    default:\n      throw new FlumeSpecException(\"bad parse tree! Expected source but got \"\n          + t.toStringTree());\n    }\n  }\n",
    "new_code_raw": "  static EventSource buildEventSource(Context context, CommonTree t)\n      throws FlumeSpecException {\n    ASTNODE type = ASTNODE.valueOf(t.getText()); // convert to enum\n    switch (type) {\n    case SOURCE: {\n      Context ctx = new Context(context);\n      Pair<String, List<String>> idArgs = handleArgs(t, ctx);\n      String sourceType = idArgs.getLeft();\n      List<String> args = idArgs.getRight();\n\n      EventSource src = srcFactory.getSource(ctx, sourceType, args\n          .toArray(new String[0]));\n      if (src == null) {\n        throw new FlumeIdException(\"Invalid source: \"\n            + FlumeSpecGen.genEventSource(t));\n      }\n      return src;\n    }\n    default:\n      throw new FlumeSpecException(\"bad parse tree! Expected source but got \"\n          + t.toStringTree());\n    }\n  }\n"
  },
  {
    "id": "eclipse_rt.equinox.bundles-60-Associations-Param0",
    "old_comment_raw": "@param type the identifier for the required type handler. This identifier may be one of those listed in  STextTypeHandlerFactory or it may be have been registered by a plug-in.",
    "old_code_raw": "\tstatic public ISTextExpert getExpert(String type, STextEnvironment environment) {\n\t\tISTextExpert expert;\n\t\tif (environment == null)\n\t\t\tenvironment = STextEnvironment.DEFAULT;\n\t\tsynchronized (sharedExperts) {\n\t\t\tMap experts = (Map) sharedExperts.get(type);\n\t\t\tif (experts == null) {\n\t\t\t\texperts = new HashMap(); // environment -> expert\n\t\t\t\tsharedExperts.put(type, experts);\n\t\t\t}\n\t\t\texpert = (ISTextExpert) experts.get(environment);\n\t\t\tif (expert == null) {\n\t\t\t\tSTextTypeHandler handler = STextTypeHandlerFactory.getHandler(type);\n\t\t\t\tif (handler == null)\n\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid type argument\"); //$NON-NLS-1$\n\t\t\t\texpert = new STextImpl(handler, environment, false);\n\t\t\t\texperts.put(type, expert);\n\t\t\t}\n\t\t}\n\t\treturn expert;\n\t}\n",
    "new_code_raw": "\tstatic public IStructuredTextExpert getExpert(String type, StructuredTextEnvironment environment) {\n\t\tIStructuredTextExpert expert;\n\t\tif (environment == null)\n\t\t\tenvironment = StructuredTextEnvironment.DEFAULT;\n\t\tsynchronized (sharedExperts) {\n\t\t\tMap experts = (Map) sharedExperts.get(type);\n\t\t\tif (experts == null) {\n\t\t\t\texperts = new HashMap(); // environment -> expert\n\t\t\t\tsharedExperts.put(type, experts);\n\t\t\t}\n\t\t\texpert = (IStructuredTextExpert) experts.get(environment);\n\t\t\tif (expert == null) {\n\t\t\t\tStructuredTextTypeHandler handler = StructuredTextTypeHandlerFactory.getHandler(type);\n\t\t\t\tif (handler == null)\n\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid type argument\"); //$NON-NLS-1$\n\t\t\t\texpert = new StructuredTextImpl(handler, environment, false);\n\t\t\t\texperts.put(type, expert);\n\t\t\t}\n\t\t}\n\t\treturn expert;\n\t}\n\n"
  },
  {
    "id": "apache_drill-828-Param-2",
    "old_comment_raw": "@param readerConfig parquet reader configuration",
    "old_code_raw": "  public static ParquetTableMetadata_v4 getParquetTableMetadata(FileSystem fs, String path, ParquetReaderConfig readerConfig) throws IOException {\n    Metadata metadata = new Metadata(readerConfig);\n    return metadata.getParquetTableMetadata(path, fs);\n  }\n",
    "new_code_raw": "  public static ParquetTableMetadata_v4 getParquetTableMetadata(FileSystem fs, Path path, ParquetReaderConfig readerConfig) throws IOException {\n    Metadata metadata = new Metadata(readerConfig);\n    return metadata.getParquetTableMetadata(path, fs);\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1621-Param-0",
    "old_comment_raw": "@param responses Swagger Operation's responses",
    "old_code_raw": "    protected Response findMethodResponse(Map<String, Response> responses) {\n\n        String code = null;\n        for (String responseCode : responses.keySet()) {\n            if (responseCode.startsWith(\"2\") || responseCode.equals(\"default\")) {\n                if (code == null || code.compareTo(responseCode) > 0) {\n                    code = responseCode;\n                }\n            }\n        }\n        if (code == null) {\n            return null;\n        }\n        return responses.get(code);\n    }\n",
    "new_code_raw": "    protected ApiResponse findMethodResponse(ApiResponses responses) {\n        String code = null;\n        for (String responseCode : responses.keySet()) {\n            if (responseCode.startsWith(\"2\") || responseCode.equals(\"default\")) {\n                if (code == null || code.compareTo(responseCode) > 0) {\n                    code = responseCode;\n                }\n            }\n        }\n        if (code == null) {\n            return null;\n        }\n        return responses.get(code);\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1691-Param-2",
    "old_comment_raw": "@param additionalMetadata Additional data to pass to server (optional, default to null)",
    "old_code_raw": "  public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws ApiException {\n    Object localVarPostBody = null;\n    \n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n    }\n    \n    // verify the required parameter 'file' is set\n    if (file == null) {\n      throw new ApiException(400, \"Missing the required parameter 'file' when calling uploadFileWithRequiredFile\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake/{petId}/uploadImageWithRequiredFile\"\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString()));\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    if (additionalMetadata != null)\n      localVarFormParams.put(\"additionalMetadata\", additionalMetadata);\nif (file != null)\n      localVarFormParams.put(\"file\", file);\n\n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"multipart/form-data\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"petstore_auth\" };\n\n    GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException {\n    Object localVarPostBody = null;\n    \n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n    }\n    \n    // verify the required parameter 'requiredFile' is set\n    if (requiredFile == null) {\n      throw new ApiException(400, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake/{petId}/uploadImageWithRequiredFile\"\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString()));\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    if (additionalMetadata != null)\n      localVarFormParams.put(\"additionalMetadata\", additionalMetadata);\nif (requiredFile != null)\n      localVarFormParams.put(\"requiredFile\", requiredFile);\n\n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"multipart/form-data\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"petstore_auth\" };\n\n    GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "RobotiumTech_robotium-1487-Param-1",
    "old_comment_raw": "@param matches the number of matches of text that must be shown.  0 means any number of matches",
    "old_code_raw": "\tpublic boolean waitForText(String text, int matches, long timeout)\n    {\n       return robotiumUtils.waitForText(text, matches, timeout);\n    }\n",
    "new_code_raw": "\tpublic boolean waitForText(String text, int expectedMinimumNumberOfMatches, long timeout) {\n       return robotiumUtils.waitForText(text, expectedMinimumNumberOfMatches, timeout);\n    }\n"
  },
  {
    "id": "apache_calcite-685-Param-0",
    "old_comment_raw": "@param fieldRefBitmap bitmap representing fields referenced",
    "old_code_raw": "  private BitSet factorBitmap(BitSet fieldRefBitmap) {\n    BitSet factorRefBitmap = new BitSet(nJoinFactors);\n    for (int field : BitSets.toIter(fieldRefBitmap)) {\n      int factor = findRef(field);\n      factorRefBitmap.set(factor);\n    }\n    return factorRefBitmap;\n  }\n",
    "new_code_raw": "  private ImmutableBitSet factorBitmap(ImmutableBitSet fieldRefBitmap) {\n    ImmutableBitSet.Builder factorRefBitmap = ImmutableBitSet.builder();\n    for (int field : fieldRefBitmap) {\n      int factor = findRef(field);\n      factorRefBitmap.set(factor);\n    }\n    return factorRefBitmap.build();\n  }\n"
  },
  {
    "id": "JodaOrg_joda_time-439-Param-0",
    "old_comment_raw": "@param millis the time instant in millis to update.",
    "old_code_raw": "    public long addWrapped(long millis, int years) {\n        if (years == 0) {\n            return millis;\n        }\n        // Return newly calculated millis value\n        int thisYear = iChronology.year().get(millis);\n        int wrappedYear = getWrappedValue\n            (thisYear, years, iChronology.getMinYear(), iChronology.getMaxYear());\n        return set(millis, wrappedYear);\n    }\n",
    "new_code_raw": "    public long addWrapped(long instant, int years) {\n        if (years == 0) {\n            return instant;\n        }\n        // Return newly calculated millis value\n        int thisYear = iChronology.year().get(instant);\n        int wrappedYear = Utils.getWrappedValue\n            (thisYear, years, iChronology.getMinYear(), iChronology.getMaxYear());\n        return set(instant, wrappedYear);\n    }\n"
  },
  {
    "id": "Atmosphere_atmosphere-374-Param-0",
    "old_comment_raw": "@param e  BroadcastFilter",
    "old_code_raw": "    protected boolean addFilter(BroadcastFilter e, boolean init) {\n        logDuplicateFilter(e);\n        if (filters.contains(e)) return false;\n\n        if (e instanceof BroadcastFilterLifecycle) {\n            ((BroadcastFilterLifecycle) e).init(config);\n        }\n\n        if (init && ClusterBroadcastFilter.class.isAssignableFrom(e.getClass())) {\n            Broadcaster b = config.getBroadcasterFactory().lookup(name, false);\n            if (b != null) {\n                synchronized (e) {\n                    ClusterBroadcastFilter.class.cast(e).setBroadcaster(b);\n                }\n            }\n        }\n\n        if (e instanceof PerRequestBroadcastFilter) {\n            perRequestFilters.add((PerRequestBroadcastFilter) e);\n        }\n\n        return filters.offer(e);\n    }\n",
    "new_code_raw": "    public boolean addFilter(BroadcastFilter e) {\n        logDuplicateFilter(e);\n        if (filters.contains(e)) return false;\n\n        if (e instanceof BroadcastFilterLifecycle) {\n            ((BroadcastFilterLifecycle) e).init();\n        }\n\n        if (e instanceof PerRequestBroadcastFilter) {\n            perRequestFilters.add((PerRequestBroadcastFilter) e);\n        }\n\n        return filters.offer(e);\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1939-Param-0",
    "old_comment_raw": "@param connection The configured connection.",
    "old_code_raw": "\tprivate Dialect determineDialect(Connection connection) {\n\t\tif ( connection == null ) {\n\t\t\tthrow new HibernateException( \"Connection cannot be null when 'hibernate.dialect' not set\" );\n\t\t}\n\n\t\ttry {\n\t\t\tfinal DatabaseMetaData databaseMetaData = connection.getMetaData();\n\t\t\tfinal Dialect dialect = dialectResolver.resolveDialect( databaseMetaData );\n\n\t\t\tif ( dialect == null ) {\n\t\t\t\tthrow new HibernateException(\n\t\t\t\t\t\t\"Unable to determine Dialect to use [name=\" + databaseMetaData.getDatabaseProductName() +\n\t\t\t\t\t\t\t\t\", majorVersion=\" + databaseMetaData.getDatabaseMajorVersion() +\n\t\t\t\t\t\t\t\t\"]; user must register resolver or explicitly set 'hibernate.dialect'\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn dialect;\n\t\t}\n\t\tcatch ( SQLException sqlException ) {\n\t\t\tthrow new HibernateException(\n\t\t\t\t\t\"Unable to access java.sql.DatabaseMetaData to determine appropriate Dialect to use\",\n\t\t\t\t\tsqlException\n\t\t\t);\n\t\t}\n\t}\n",
    "new_code_raw": "\tprivate Dialect determineDialect(DialectResolutionInfoSource resolutionInfoSource) {\n\t\tif ( resolutionInfoSource == null ) {\n\t\t\tthrow new HibernateException( \"Access to DialectResolutionInfo cannot be null when 'hibernate.dialect' not set\" );\n\t\t}\n\n\t\tfinal DialectResolutionInfo info = resolutionInfoSource.getDialectResolutionInfo();\n\t\tfinal Dialect dialect = dialectResolver.resolveDialect( info );\n\n\t\tif ( dialect == null ) {\n\t\t\tthrow new HibernateException(\n\t\t\t\t\t\"Unable to determine Dialect to use [name=\" + info.getDatabaseName() +\n\t\t\t\t\t\t\t\", majorVersion=\" + info.getDatabaseMajorVersion() +\n\t\t\t\t\t\t\t\"]; user must register resolver or explicitly set 'hibernate.dialect'\"\n\t\t\t);\n\t\t}\n\n\t\treturn dialect;\n\t}\n"
  },
  {
    "id": "apache_activemq-56-Param-0",
    "old_comment_raw": "@param command",
    "old_code_raw": "    public Response syncSendPacket(Command command) throws JMSException {\n        if (isClosed()) {\n            throw new ConnectionClosedException();\n        } else {\n\n            if (command.isMessage() && flowControlSleepTime > 0) {\n                try {\n                    Thread.sleep(flowControlSleepTime);\n                } catch (InterruptedException e) {\n                }\n            }\n\n            try {\n                Response response = this.transport.request(command);\n                if (response.isException()) {\n                    ExceptionResponse er = (ExceptionResponse) response;\n                    if (er.getException() instanceof JMSException)\n                        throw (JMSException) er.getException();\n                    else\n                        throw JMSExceptionSupport.create(er.getException());\n                }\n                return response;\n            } catch (IOException e) {\n                throw JMSExceptionSupport.create(e);\n            }\n        }\n    }\n",
    "new_code_raw": "    public Response syncSendPacket(Command command, int timeout) throws JMSException {\n        if (isClosed()) {\n            throw new ConnectionClosedException();\n        } else {\n\n            if (command.isMessage() && flowControlSleepTime > 0) {\n                try {\n                    Thread.sleep(flowControlSleepTime);\n                } catch (InterruptedException e) {\n                }\n            }\n\n            try {\n                Response response = this.transport.request(command,timeout);\n                if (response.isException()) {\n                    ExceptionResponse er = (ExceptionResponse) response;\n                    if (er.getException() instanceof JMSException)\n                        throw (JMSException) er.getException();\n                    else\n                        throw JMSExceptionSupport.create(er.getException());\n                }\n                return response;\n            } catch (IOException e) {\n                throw JMSExceptionSupport.create(e);\n            }\n        }\n    }\n"
  },
  {
    "id": "apache_portals-pluto-17-Associations-Param1",
    "old_comment_raw": "@param services",
    "old_code_raw": "    public PortletContainer createContainer(String containerName,\r\n                                            PortletContainerServices services)\r\n        throws PortletContainerException {\r\n        return createContainer(containerName, services, new DefaultOptionalServices());\r\n   }\r\n",
    "new_code_raw": "    public PortletContainer createContainer(\r\n    \t\tString containerName,\r\n    \t\tRequiredContainerServices requiredServices)\r\n        throws PortletContainerException {\r\n        return createContainer(containerName,\r\n                               requiredServices,\r\n                               new DefaultOptionalContainerServices());\r\n   }\r\n\n"
  },
  {
    "id": "apache_calcite-280-Param-0",
    "old_comment_raw": "@param join join to be swapped",
    "old_code_raw": "  public static RelNode swap(JoinRelBase join, boolean swapOuterJoins) {\n    final JoinRelType joinType = join.getJoinType();\n    if (!swapOuterJoins && joinType != JoinRelType.INNER) {\n      return null;\n    }\n    final RexBuilder rexBuilder = join.getCluster().getRexBuilder();\n    final RelDataType leftRowType = join.getLeft().getRowType();\n    final RelDataType rightRowType = join.getRight().getRowType();\n    final VariableReplacer variableReplacer =\n        new VariableReplacer(rexBuilder, leftRowType, rightRowType);\n    final RexNode oldCondition = join.getCondition();\n    RexNode condition = variableReplacer.go(oldCondition);\n\n    // NOTE jvs 14-Mar-2006: We preserve attribute semiJoinDone after the\n    // swap.  This way, we will generate one semijoin for the original\n    // join, and one for the swapped join, and no more.  This\n    // doesn't prevent us from seeing any new combinations assuming\n    // that the planner tries the desired order (semijoins after swaps).\n    JoinRelBase newJoin =\n        join.copy(join.getTraitSet(), condition, join.getRight(),\n            join.getLeft(), joinType.swap(), join.isSemiJoinDone());\n    final List<RexNode> exps =\n        RelOptUtil.createSwappedJoinExprs(newJoin, join, true);\n    return RelOptUtil.createProject(\n        newJoin,\n        exps,\n        join.getRowType().getFieldNames(),\n        true);\n  }\n",
    "new_code_raw": "  public static RelNode swap(Join join, boolean swapOuterJoins) {\n    final JoinRelType joinType = join.getJoinType();\n    if (!swapOuterJoins && joinType != JoinRelType.INNER) {\n      return null;\n    }\n    final RexBuilder rexBuilder = join.getCluster().getRexBuilder();\n    final RelDataType leftRowType = join.getLeft().getRowType();\n    final RelDataType rightRowType = join.getRight().getRowType();\n    final VariableReplacer variableReplacer =\n        new VariableReplacer(rexBuilder, leftRowType, rightRowType);\n    final RexNode oldCondition = join.getCondition();\n    RexNode condition = variableReplacer.go(oldCondition);\n\n    // NOTE jvs 14-Mar-2006: We preserve attribute semiJoinDone after the\n    // swap.  This way, we will generate one semijoin for the original\n    // join, and one for the swapped join, and no more.  This\n    // doesn't prevent us from seeing any new combinations assuming\n    // that the planner tries the desired order (semijoins after swaps).\n    Join newJoin =\n        join.copy(join.getTraitSet(), condition, join.getRight(),\n            join.getLeft(), joinType.swap(), join.isSemiJoinDone());\n    final List<RexNode> exps =\n        RelOptUtil.createSwappedJoinExprs(newJoin, join, true);\n    return RelOptUtil.createProject(\n        newJoin,\n        exps,\n        join.getRowType().getFieldNames(),\n        true);\n  }\n"
  },
  {
    "id": "RobotiumTech_robotium-1180-Param-0",
    "old_comment_raw": "@param pause the time to pause in milliseconds",
    "old_code_raw": "\tpublic Activity getCurrentActivity(int pause) {\n\t\tif(pause > 0){\n\t\t\tRobotiumUtils.sleep(pause);\n\t\t\tinst.waitForIdleSync();\n\t\t}\n\t\tBoolean found = false;\n\t\tif (activityMonitor != null) {\n\t\t\tif (activityMonitor.getLastActivity() != null)\n\t\t\t\tactivity = activityMonitor.getLastActivity();\n\t\t}\n\t\tfor(Activity storedActivity : activityList){\n\t\t\tif (storedActivity.getClass().getName().equals(\n\t\t\t\t\tactivity.getClass().getName()))\n\t\t\t\tfound = true;\n\t\t}\n\t\tif (found)\n\t\t\treturn activity;\n\t\telse {\n\t\t\tactivityList.add(activity);\n\t\t\treturn activity;\n\t\t}\n\t}\n",
    "new_code_raw": "\tpublic Activity getCurrentActivity(boolean shouldSleepFirst) {\n\t\tif(shouldSleepFirst){\n\t\t\tRobotiumUtils.sleep();\n\t\t\tinst.waitForIdleSync();\n\t\t}\n\t\tBoolean found = false;\n\t\tif (activityMonitor != null) {\n\t\t\tif (activityMonitor.getLastActivity() != null)\n\t\t\t\tactivity = activityMonitor.getLastActivity();\n\t\t}\n\t\tfor(Activity storedActivity : activityList){\n\t\t\tif (storedActivity.getClass().getName().equals(\n\t\t\t\t\tactivity.getClass().getName()))\n\t\t\t\tfound = true;\n\t\t}\n\t\tif (found)\n\t\t\treturn activity;\n\t\telse {\n\t\t\tactivityList.add(activity);\n\t\t\treturn activity;\n\t\t}\n\t}\n"
  },
  {
    "id": "hibernate_hibernate_orm-1592-Param-0",
    "old_comment_raw": "@param map The map of entries",
    "old_code_raw": "\tpublic static Iterator keyIterator(Map map) {\n\t\treturn ( (IdentityMap) map ).keyIterator();\n\t}\n",
    "new_code_raw": "\tpublic Iterator keyIterator() {\n\t\treturn new KeyIterator( map.keySet().iterator() );\n\t}\n"
  },
  {
    "id": "Atmosphere_atmosphere-823-Param-0",
    "old_comment_raw": "@param req the  HttpServletRequest",
    "old_code_raw": "    Action action(HttpServletRequest req, HttpServletResponse res)\n            throws IOException, ServletException {\n\n        boolean webSocketEnabled = false;\n        if (req.getHeaders(\"Connection\") != null && req.getHeaders(\"Connection\").hasMoreElements()) {\n            String[] e = req.getHeaders(\"Connection\").nextElement().toString().split(\",\");\n            for (String upgrade : e) {\n                if (upgrade.equalsIgnoreCase(\"Upgrade\")) {\n                    webSocketEnabled = true;\n                    break;\n                }\n            }\n        }\n\n        if (webSocketEnabled && !supportWebSocket()) {\n            res.setStatus(501);\n            res.addHeader(X_ATMOSPHERE_ERROR, \"Websocket protocol not supported\");\n            res.flushBuffer();\n            return new Action();\n        }\n\n        if (config.handlers().isEmpty()) {\n            logger.error(\"No AtmosphereHandler found. Make sure you define it inside META-INF/atmosphere.xml\");\n            throw new AtmosphereMappingException(\"No AtmosphereHandler found. Make sure you define it inside META-INF/atmosphere.xml\");\n        }\n\n        if (supportSession()) {\n            // Create the session needed to support the Resume\n            // operation from disparate requests.\n            HttpSession session = req.getSession(true);\n            // Do not allow times out.\n            if (session.getMaxInactiveInterval() == DEFAULT_SESSION_TIMEOUT) {\n                session.setMaxInactiveInterval(-1);\n            }\n        }\n\n        req.setAttribute(FrameworkConfig.SUPPORT_SESSION, supportSession());\n\n        AtmosphereHandlerWrapper handlerWrapper = map(req);\n        // Check Broadcaster state. If destroyed, replace it.\n        Broadcaster b = handlerWrapper.broadcaster;\n        if (b.isDestroyed()) {\n            synchronized (handlerWrapper) {\n                config.getBroadcasterFactory().remove(b, b.getID());\n                handlerWrapper.broadcaster = config.getBroadcasterFactory().get(b.getID());\n            }\n        }\n        AtmosphereResourceImpl resource = new AtmosphereResourceImpl(config, handlerWrapper.broadcaster, req, res, this, handlerWrapper.atmosphereHandler);\n\n        req.setAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE, resource);\n        req.setAttribute(FrameworkConfig.ATMOSPHERE_HANDLER, handlerWrapper.atmosphereHandler);\n\n        try {\n            handlerWrapper.atmosphereHandler.onRequest(resource);\n        } catch (IOException t) {\n            resource.onThrowable(t);\n            throw t;\n        }\n\n        if (trackActiveRequest && resource.getAtmosphereResourceEvent().isSuspended() && req.getAttribute(FrameworkConfig.CANCEL_SUSPEND_OPERATION) == null) {\n            req.setAttribute(MAX_INACTIVE, System.currentTimeMillis());\n            aliveRequests.put(req, resource);\n        }\n        return resource.action();\n    }\n",
    "new_code_raw": "    Action action(AtmosphereRequest req, AtmosphereResponse res)\n            throws IOException, ServletException {\n\n        boolean webSocketEnabled = false;\n        if (req.getHeaders(\"Connection\") != null && req.getHeaders(\"Connection\").hasMoreElements()) {\n            String[] e = req.getHeaders(\"Connection\").nextElement().toString().split(\",\");\n            for (String upgrade : e) {\n                if (upgrade.equalsIgnoreCase(\"Upgrade\")) {\n                    webSocketEnabled = true;\n                    break;\n                }\n            }\n        }\n\n        if (webSocketEnabled && !supportWebSocket()) {\n            res.setStatus(501);\n            res.addHeader(X_ATMOSPHERE_ERROR, \"Websocket protocol not supported\");\n            res.flushBuffer();\n            return new Action();\n        }\n\n        if (config.handlers().isEmpty()) {\n            logger.error(\"No AtmosphereHandler found. Make sure you define it inside META-INF/atmosphere.xml\");\n            throw new AtmosphereMappingException(\"No AtmosphereHandler found. Make sure you define it inside META-INF/atmosphere.xml\");\n        }\n\n        if (supportSession()) {\n            // Create the session needed to support the Resume\n            // operation from disparate requests.\n            HttpSession session = req.getSession(true);\n            // Do not allow times out.\n            if (session.getMaxInactiveInterval() == DEFAULT_SESSION_TIMEOUT) {\n                session.setMaxInactiveInterval(-1);\n            }\n        }\n\n        req.setAttribute(FrameworkConfig.SUPPORT_SESSION, supportSession());\n\n        AtmosphereHandlerWrapper handlerWrapper = map(req);\n        // Check Broadcaster state. If destroyed, replace it.\n        Broadcaster b = handlerWrapper.broadcaster;\n        if (b.isDestroyed()) {\n            synchronized (handlerWrapper) {\n                config.getBroadcasterFactory().remove(b, b.getID());\n                handlerWrapper.broadcaster = config.getBroadcasterFactory().get(b.getID());\n            }\n        }\n        AtmosphereResourceImpl resource = new AtmosphereResourceImpl(config, handlerWrapper.broadcaster, req, res, this, handlerWrapper.atmosphereHandler);\n\n        req.setAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE, resource);\n        req.setAttribute(FrameworkConfig.ATMOSPHERE_HANDLER, handlerWrapper.atmosphereHandler);\n\n        try {\n            handlerWrapper.atmosphereHandler.onRequest(resource);\n        } catch (IOException t) {\n            resource.onThrowable(t);\n            throw t;\n        }\n\n        if (trackActiveRequest && resource.getAtmosphereResourceEvent().isSuspended() && req.getAttribute(FrameworkConfig.CANCEL_SUSPEND_OPERATION) == null) {\n            req.setAttribute(MAX_INACTIVE, System.currentTimeMillis());\n            aliveRequests.put(req, resource);\n        }\n        return resource.action();\n    }\n"
  },
  {
    "id": "processing_processing-425-Param-0",
    "old_comment_raw": "@param element what to parse",
    "old_code_raw": "  static protected float getFloatWithUnit(XMLElement element, String attribute) {\n    String val = element.getString(attribute);\n    return (val == null) ? 0 : parseUnitSize(val);\n  }\n",
    "new_code_raw": "  static protected float getFloatWithUnit(PNode element, String attribute) {\n    String val = element.getString(attribute);\n    return (val == null) ? 0 : parseUnitSize(val);\n  }\n"
  },
  {
    "id": "debezium_debezium-0-Param-0",
    "old_comment_raw": "@param properties the properties; may be null or empty",
    "old_code_raw": "    public static Configuration from(Properties properties) {\n        Properties props = new Properties();\n        if (properties != null) props.putAll(properties);\n        return new Configuration() {\n            @Override\n            public String getString(String key) {\n                return properties.getProperty(key);\n            }\n\n            @Override\n            public Set<String> keys() {\n                return properties.stringPropertyNames();\n            }\n            \n            @Override\n            public String toString() {\n                return props.toString();\n            }\n        };\n    }\n",
    "new_code_raw": "    public static Configuration from(Map<String, String> properties) {\n        Map<String, String> props = new HashMap<>();\n        if (properties != null) props.putAll(properties);\n        return new Configuration() {\n            @Override\n            public String getString(String key) {\n                return properties.get(key);\n            }\n\n            @Override\n            public Set<String> keys() {\n                return properties.keySet();\n            }\n\n            @Override\n            public String toString() {\n                return props.toString();\n            }\n        };\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-427-Param-0",
    "old_comment_raw": "@param millis the time instant in millis to query.",
    "old_code_raw": "    public int get(long millis) {\n        return iField.get(millis) + iOffset;\n    }\n",
    "new_code_raw": "    public int get(long instant) {\n        return super.get(instant) + iOffset;\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-490-Param-1",
    "old_comment_raw": "@param partialDocument A partial document, which must contain  SentencesAnnotation and  TokensAnnotation in order to fill in the mention span strings.",
    "old_code_raw": "  private static CorefChain fromProto(CoreMapProtos.CorefChain proto, Annotation partialDocument) {\n    // Get chain ID\n    int cid = proto.getChainID();\n    // Get mentions\n    Map<IntPair, Set<CorefChain.CorefMention>> mentions = new HashMap<IntPair, Set<CorefChain.CorefMention>>();\n    CorefChain.CorefMention representative = null;\n    for (int i = 0; i < proto.getMentionCount(); ++i) {\n      CoreMapProtos.CorefChain.CorefMention mentionProto = proto.getMention(i);\n      // Create mention\n      StringBuilder mentionSpan = new StringBuilder();\n      List<CoreLabel> sentenceTokens = partialDocument.get(SentencesAnnotation.class).get(mentionProto.getSentenceIndex()).get(TokensAnnotation.class);\n      for (int k = mentionProto.getStartIndex(); k < mentionProto.getEndIndex(); ++k) {\n        mentionSpan.append(\" \").append(sentenceTokens.get(k).word());\n      }\n      sentenceTokens.get(mentionProto.getHeadIndex()).set(CorefClusterIdAnnotation.class, cid);\n      CorefChain.CorefMention mention = new CorefChain.CorefMention(\n          Dictionaries.MentionType.valueOf(mentionProto.getMentionType()),\n          Dictionaries.Number.valueOf(mentionProto.getNumber()),\n          Dictionaries.Gender.valueOf(mentionProto.getGender()),\n          Dictionaries.Animacy.valueOf(mentionProto.getAnimacy()),\n          mentionProto.getStartIndex() + 1,\n          mentionProto.getEndIndex() + 1,\n          mentionProto.getHeadIndex() + 1,\n          cid,\n          mentionProto.getMentionID(),\n          mentionProto.getSentenceIndex() + 1,\n          new IntTuple(new int[]{ mentionProto.getSentenceIndex() + 1, mentionProto.getPosition() }),\n          mentionSpan.substring(1));\n      // Register mention\n      IntPair key = new IntPair(mentionProto.getSentenceIndex() - 1, mentionProto.getHeadIndex() - 1);\n      if (!mentions.containsKey(key)) { mentions.put(key, new HashSet<CorefChain.CorefMention>()); }\n      mentions.get(key).add(mention);\n      // Check for representative\n      if (proto.hasRepresentative() && i == proto.getRepresentative()) {\n        representative = mention;\n      }\n    }\n    // Return\n    return new CorefChain(cid, mentions, representative);\n  }\n",
    "new_code_raw": "  private static CorefChain fromProto(CoreNLPProtos.CorefChain proto, Annotation partialDocument) {\n    // Get chain ID\n    int cid = proto.getChainID();\n    // Get mentions\n    Map<IntPair, Set<CorefChain.CorefMention>> mentions = new HashMap<IntPair, Set<CorefChain.CorefMention>>();\n    CorefChain.CorefMention representative = null;\n    for (int i = 0; i < proto.getMentionCount(); ++i) {\n      CoreNLPProtos.CorefChain.CorefMention mentionProto = proto.getMention(i);\n      // Create mention\n      StringBuilder mentionSpan = new StringBuilder();\n      List<CoreLabel> sentenceTokens = partialDocument.get(SentencesAnnotation.class).get(mentionProto.getSentenceIndex()).get(TokensAnnotation.class);\n      for (int k = mentionProto.getStartIndex(); k < mentionProto.getEndIndex(); ++k) {\n        mentionSpan.append(\" \").append(sentenceTokens.get(k).word());\n      }\n      // Set the coref cluster id for the token\n      CorefChain.CorefMention mention = new CorefChain.CorefMention(\n          Dictionaries.MentionType.valueOf(mentionProto.getMentionType()),\n          Dictionaries.Number.valueOf(mentionProto.getNumber()),\n          Dictionaries.Gender.valueOf(mentionProto.getGender()),\n          Dictionaries.Animacy.valueOf(mentionProto.getAnimacy()),\n          mentionProto.getStartIndex() + 1,\n          mentionProto.getEndIndex() + 1,\n          mentionProto.getHeadIndex() + 1,\n          cid,\n          mentionProto.getMentionID(),\n          mentionProto.getSentenceIndex() + 1,\n          new IntTuple(new int[]{ mentionProto.getSentenceIndex() + 1, mentionProto.getPosition() }),\n          mentionSpan.substring(1));\n      // Register mention\n      IntPair key = new IntPair(mentionProto.getSentenceIndex() - 1, mentionProto.getHeadIndex() - 1);\n      if (!mentions.containsKey(key)) { mentions.put(key, new HashSet<CorefChain.CorefMention>()); }\n      mentions.get(key).add(mention);\n      // Check for representative\n      if (proto.hasRepresentative() && i == proto.getRepresentative()) {\n        representative = mention;\n      }\n    }\n    // Return\n    return new CorefChain(cid, mentions, representative);\n  }\n"
  },
  {
    "id": "SeleniumHQ_selenium-1038-Param-0",
    "old_comment_raw": "@param name Frame index, name or a concatenation of frame identifiers that uniquely point to a specific frame.",
    "old_code_raw": "    public WebDriver frame(final String name) {\n      WebWindow window = currentWindow.getTopWindow();\n\n      // Walk over all parts of the frame identifier, each time looking for a frame\n      // with a name or ID matching this part of the identifier (separated by '.').\n      String[] frames = name.split(\"\\\\.\");\n      for (int i = 0; i < frames.length; ++i) {\n        final String currentFrameId = frames[i];\n        final HtmlPage page = (HtmlPage) window.getEnclosedPage();\n        \n        if (isNumericFrameIdValid(currentFrameId, page)) {\n          window = getWindowByNumericFrameId(currentFrameId, page);\n        } else {\n          // Numeric frame ID is not valid - could be either because the identifier\n          // was numeric and not valid OR the number that was given is actually a frame\n          // name, not an index.\n          \n          boolean nextFrameFound = false;\n          for (final FrameWindow frameWindow : page.getFrames()) {\n            final String frameName = frameWindow.getName();\n            final String frameId = frameWindow.getFrameElement().getId();\n            final String remainingFrameId = joinFrom(frames, i, '.');\n            if (frameName.equals(remainingFrameId) || frameId.equals(remainingFrameId)) {\n              currentWindow = frameWindow;\n              return HtmlUnitDriver.this;\n            }\n            if (frameName.equals(currentFrameId) || frameId.equals(currentFrameId)) {\n              window = frameWindow;\n              nextFrameFound = true;\n            }\n          } // End for.\n          \n          if (!nextFrameFound) {\n            throw new NoSuchFrameException(\"Cannot find frame: \" + name);\n          }\n        } // End else\n\n      } // End for\n      \n      currentWindow = window;\n      return HtmlUnitDriver.this;\n    }\n",
    "new_code_raw": "    public WebDriver frame(final String nameOrIdOrIndex) {\n      try {\n        // 1.) try to find frame in current window ...\n        currentWindow = findFrame(currentWindow, nameOrIdOrIndex);\n      } catch (NoSuchFrameException ignored) {\n        // 2.) try to find frame in top window ...\n        final WebWindow topWindow = currentWindow.getTopWindow();\n        currentWindow = findFrame(topWindow, nameOrIdOrIndex);\n      }\n      return HtmlUnitDriver.this;\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-1898-Param-2",
    "old_comment_raw": "@param featureFactories The FeatureFactories to use to extract features",
    "old_code_raw": "  private double[] makeDatumUsingEmbedding(List<IN> info, int loc, List<FeatureFactory<IN>> featureFactories, PaddedList<IN> pInfo, List<String> featuresC, List<Clique> windowCliques) {\n    double[] featureValArr;\n    List<double[]> embeddingList = new ArrayList<>();\n    int concatEmbeddingLen = 0;\n    String currentWord = null;\n    for (int currLoc = loc-2; currLoc <= loc+2; currLoc++) {\n      double[] embedding; // Initialized in cases below // = null;\n      if (currLoc >=0 && currLoc < info.size()) {\n        currentWord = info.get(loc).get(CoreAnnotations.TextAnnotation.class);\n        String word = currentWord.toLowerCase();\n        word = word.replaceAll(\"(-)?\\\\d+(\\\\.\\\\d*)?\", \"0\");\n        if (embeddings.containsKey(word))\n          embedding = embeddings.get(word);\n        else\n          embedding = embeddings.get(\"UNKNOWN\");\n      } else {\n        embedding = embeddings.get(\"PADDING\");\n      }\n\n      for (int e = 0; e < embedding.length; e++) {\n        featuresC.add(\"EMBEDDING-(\" + (currLoc-loc) + \")-\" + e);\n      }\n\n      if (flags.addCapitalFeatures) {\n        int numOfCapitalFeatures = 4;\n        double[] newEmbedding = new double[embedding.length + numOfCapitalFeatures];\n        int currLen = embedding.length;\n        System.arraycopy(embedding, 0, newEmbedding, 0, currLen);\n        for (int e = 0; e < numOfCapitalFeatures; e++)\n          featuresC.add(\"CAPITAL-(\" + (currLoc-loc) + \")-\" + e);\n\n        if (currLoc >=0 && currLoc < info.size()) { // skip PADDING\n          // check if word is all caps\n          if (currentWord.toUpperCase().equals(currentWord))\n            newEmbedding[currLen] = 1;\n          else {\n            currLen += 1;\n            // check if word is all lower\n            if (currentWord.toLowerCase().equals(currentWord))\n              newEmbedding[currLen] = 1;\n            else {\n              currLen += 1;\n              // check first letter cap\n              if (Character.isUpperCase(currentWord.charAt(0)))\n                newEmbedding[currLen] = 1;\n              else {\n                currLen += 1;\n                // check if at least one non-initial letter is cap\n                String remainder = currentWord.substring(1);\n                if (!remainder.toLowerCase().equals(remainder))\n                  newEmbedding[currLen] = 1;\n              }\n            }\n          }\n        }\n        embedding = newEmbedding;\n      }\n\n      embeddingList.add(embedding);\n      concatEmbeddingLen += embedding.length;\n    }\n    double[] concatEmbedding = new double[concatEmbeddingLen];\n    int currPos = 0;\n    for (double[] em: embeddingList) {\n      System.arraycopy(em, 0, concatEmbedding, currPos, em.length);\n      currPos += em.length;\n    }\n\n    if (flags.prependEmbedding) {\n      int additionalFeatureCount = 0;\n      for (Clique c : windowCliques) {\n        for (FeatureFactory<IN> featureFactory : featureFactories) {\n          Collection<String> fCol = featureFactory.getCliqueFeatures(pInfo, loc, c); //todo useless copy because of typing reasons\n          featuresC.addAll(fCol);\n          additionalFeatureCount += fCol.size();\n        }\n      }\n      featureValArr = new double[concatEmbedding.length + additionalFeatureCount];\n      System.arraycopy(concatEmbedding, 0, featureValArr, 0, concatEmbedding.length);\n      Arrays.fill(featureValArr, concatEmbedding.length, featureValArr.length, 1.0);\n    } else {\n      featureValArr = concatEmbedding;\n    }\n\n    if (flags.addBiasToEmbedding) {\n      featuresC.add(\"BIAS-FEATURE\");\n      double[] newFeatureValArr = new double[featureValArr.length + 1];\n      System.arraycopy(featureValArr, 0, newFeatureValArr, 0, featureValArr.length);\n      newFeatureValArr[newFeatureValArr.length-1] = 1;\n      featureValArr = newFeatureValArr;\n    }\n    return featureValArr;\n  }\n",
    "new_code_raw": "  private double[] makeDatumUsingEmbedding(List<IN> info, int loc, List<FeatureFactory<IN>> featureFactories, PaddedList<IN> pInfo, Collection<String> featuresC) {\n    double[] featureValArr;\n    List<double[]> embeddingList = new ArrayList<>();\n    int concatEmbeddingLen = 0;\n    String currentWord = null;\n    for (int currLoc = loc-2; currLoc <= loc+2; currLoc++) {\n      double[] embedding; // Initialized in cases below // = null;\n      if (currLoc >=0 && currLoc < info.size()) {\n        currentWord = info.get(loc).get(CoreAnnotations.TextAnnotation.class);\n        String word = currentWord.toLowerCase();\n        word = word.replaceAll(\"(-)?\\\\d+(\\\\.\\\\d*)?\", \"0\");\n        embedding = embeddings.get(word);\n        if (embedding == null)\n          embedding = embeddings.get(\"UNKNOWN\");\n      } else {\n        embedding = embeddings.get(\"PADDING\");\n      }\n\n      for (int e = 0; e < embedding.length; e++) {\n        featuresC.add(\"EMBEDDING-(\" + (currLoc-loc) + \")-\" + e);\n      }\n\n      if (flags.addCapitalFeatures) {\n        int numOfCapitalFeatures = 4;\n        int currLen = embedding.length;\n        embedding = Arrays.copyOf(embedding, currLen + numOfCapitalFeatures);\n        for (int e = 0; e < numOfCapitalFeatures; e++)\n          featuresC.add(\"CAPITAL-(\" + (currLoc-loc) + \")-\" + e);\n\n        if (currLoc >=0 && currLoc < info.size()) { // skip PADDING\n          // check if word is all caps\n          if (currentWord.toUpperCase().equals(currentWord))\n            embedding[currLen] = 1;\n          else {\n            currLen += 1;\n            // check if word is all lower\n            if (currentWord.toLowerCase().equals(currentWord))\n              embedding[currLen] = 1;\n            else {\n              currLen += 1;\n              // check first letter cap\n              if (Character.isUpperCase(currentWord.charAt(0)))\n                embedding[currLen] = 1;\n              else {\n                currLen += 1;\n                // check if at least one non-initial letter is cap\n                String remainder = currentWord.substring(1);\n                if (!remainder.toLowerCase().equals(remainder))\n                  embedding[currLen] = 1;\n              }\n            }\n          }\n        }\n      }\n\n      embeddingList.add(embedding);\n      concatEmbeddingLen += embedding.length;\n    }\n    double[] concatEmbedding = new double[concatEmbeddingLen];\n    int currPos = 0;\n    for (double[] em: embeddingList) {\n      System.arraycopy(em, 0, concatEmbedding, currPos, em.length);\n      currPos += em.length;\n    }\n\n    if (flags.prependEmbedding) {\n      FeatureFactory.eachClique(0, 0, c -> {\n        for (FeatureFactory<IN> featureFactory : featureFactories) {\n          featuresC.addAll(featureFactory.getCliqueFeatures(pInfo, loc, c)); //todo useless copy because of typing reasons\n        }\n      });\n      featureValArr = Arrays.copyOf(concatEmbedding, featuresC.size());\n      Arrays.fill(featureValArr, concatEmbedding.length, featureValArr.length, 1.0);\n    } else {\n      featureValArr = concatEmbedding;\n    }\n\n    if (flags.addBiasToEmbedding) {\n      featuresC.add(\"BIAS-FEATURE\");\n      featureValArr = Arrays.copyOf(featureValArr, featureValArr.length + 1);\n      featureValArr[featureValArr.length - 1] = 1;\n    }\n    return featureValArr;\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2574-Param-0",
    "old_comment_raw": "@param p Swagger property object",
    "old_code_raw": "    public String toDefaultValue(Property p) {\n        if (p instanceof StringProperty) {\n            StringProperty dp = (StringProperty) p;\n            if (dp.getDefault() != null) {\n                return \"'\" + dp.getDefault() + \"'\";\n            }\n        } else if (p instanceof BooleanProperty) {\n            BooleanProperty dp = (BooleanProperty) p;\n            if (dp.getDefault() != null) {\n                return dp.getDefault().toString();\n            }\n        } else if (p instanceof DateProperty) {\n            // TODO\n        } else if (p instanceof DateTimeProperty) {\n            // TODO\n        } else if (p instanceof DoubleProperty) {\n            DoubleProperty dp = (DoubleProperty) p;\n            if (dp.getDefault() != null) {\n                return dp.getDefault().toString();\n            }\n        } else if (p instanceof FloatProperty) {\n            FloatProperty dp = (FloatProperty) p;\n            if (dp.getDefault() != null) {\n                return dp.getDefault().toString();\n            }\n        } else if (p instanceof IntegerProperty) {\n            IntegerProperty dp = (IntegerProperty) p;\n            if (dp.getDefault() != null) {\n                return dp.getDefault().toString();\n            }\n        } else if (p instanceof LongProperty) {\n            LongProperty dp = (LongProperty) p;\n            if (dp.getDefault() != null) {\n                return dp.getDefault().toString();\n            }\n        }\n\n        return null;\n    }\n",
    "new_code_raw": "    public String toDefaultValue(Schema p) {\n        if (ModelUtils.isBooleanSchema(p)) {\n            if (p.getDefault() != null) {\n                return p.getDefault().toString();\n            }\n        } else if (ModelUtils.isDateSchema(p)) {\n            // TODO\n        } else if (ModelUtils.isDateTimeSchema(p)) {\n            // TODO\n        } else if (ModelUtils.isNumberSchema(p)) {\n            if (p.getDefault() != null) {\n                return p.getDefault().toString();\n            }\n        } else if (ModelUtils.isIntegerSchema(p)) {\n            if (p.getDefault() != null) {\n                return p.getDefault().toString();\n            }\n        } else if (ModelUtils.isStringSchema(p)) {\n            if (p.getDefault() != null) {\n                return \"'\" + p.getDefault() + \"'\";\n            }\n        }\n\n        return null;\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-649-Param-4",
    "old_comment_raw": "@param columns The columns making up the condition of the join.",
    "old_code_raw": "\tpublic JoinSequence createJoinSequence(boolean implicit, AssociationType associationType, String tableAlias, int joinType, String[] columns) {\n\t\tJoinSequence joinSequence = createJoinSequence();\n\t\tjoinSequence.setUseThetaStyle( implicit );\t// Implicit joins use theta style (WHERE pk = fk), explicit joins use JOIN (after from)\n\t\tjoinSequence.addJoin( associationType, tableAlias, joinType, columns );\n\t\treturn joinSequence;\n\t}\n",
    "new_code_raw": "\tpublic JoinSequence createJoinSequence(boolean implicit, AssociationType associationType, String tableAlias, JoinType joinType, String[] columns) {\n\t\tJoinSequence joinSequence = createJoinSequence();\n\t\tjoinSequence.setUseThetaStyle( implicit );\t// Implicit joins use theta style (WHERE pk = fk), explicit joins use JOIN (after from)\n\t\tjoinSequence.addJoin( associationType, tableAlias, joinType, columns );\n\t\treturn joinSequence;\n\t}\n"
  },
  {
    "id": "SeleniumHQ_selenium-846-Param-0",
    "old_comment_raw": "@param selector CSS expression.",
    "old_code_raw": "  public static By cssSelector(final String selector) {\n    if (selector == null)\n      throw new IllegalArgumentException(\n          \"Cannot find elements when the CSS selector is null.\");\n\n    return new ByCssSelector(selector);\n\n  }\n",
    "new_code_raw": "  public static By cssSelector(final String cssSelector) {\n    return new ByCssSelector(cssSelector);\n  }\n"
  },
  {
    "id": "lingochamp_FileDownloader-10-Param-1",
    "old_comment_raw": "@param removeByStatus must remove by status  com.liulishuo.filedownloader.model.FileDownloadStatus#warn  com.liulishuo.filedownloader.model.FileDownloadStatus#paused  com.liulishuo.filedownloader.model.FileDownloadStatus#completed  com.liulishuo.filedownloader.model.FileDownloadStatus#error",
    "old_code_raw": "    public boolean remove(final BaseFileDownloadInternal willRemoveDownload, final int removeByStatus) {\n        boolean succeed;\n        synchronized (list) {\n            succeed = list.remove(willRemoveDownload);\n        }\n\n        if (succeed) {\n            // \u00e6\u008a\u009b\u00e6\u00b6\u0088\u00e6\u0081\u00af\n            switch (removeByStatus) {\n                case FileDownloadStatus.warn:\n                    willRemoveDownload.getDriver().notifyWarn();\n                    break;\n                case FileDownloadStatus.error:\n                    willRemoveDownload.getDriver().notifyError();\n                    break;\n                case FileDownloadStatus.paused:\n                    willRemoveDownload.getDriver().notifyPaused();\n                    break;\n                case FileDownloadStatus.completed:\n                    Throwable ex = null;\n                    try{\n                        willRemoveDownload.getDriver().notifyBlockComplete();\n                    }catch (Throwable e){\n                        ex = e;\n                    }\n\n                    if (ex != null) {\n                        willRemoveDownload.setStatus(FileDownloadStatus.error);\n                        willRemoveDownload.setEx(ex);\n                        willRemoveDownload.getDriver().notifyError();\n                    } else {\n                        willRemoveDownload.getDriver().notifyCompleted();\n                    }\n                    break;\n            }\n\n        } else {\n            FileDownloadLog.e(this, \"remove error, not exist: %s\", willRemoveDownload);\n        }\n\n        return succeed;\n    }\n",
    "new_code_raw": "    public boolean remove(final BaseDownloadTask willRemoveDownload, final int removeByStatus) {\n        boolean succeed;\n        synchronized (list) {\n            succeed = list.remove(willRemoveDownload);\n        }\n\n        if (succeed) {\n            // \u00e6\u008a\u009b\u00e6\u00b6\u0088\u00e6\u0081\u00af\n            switch (removeByStatus) {\n                case FileDownloadStatus.warn:\n                    willRemoveDownload.getDriver().notifyWarn();\n                    break;\n                case FileDownloadStatus.error:\n                    willRemoveDownload.getDriver().notifyError();\n                    break;\n                case FileDownloadStatus.paused:\n                    willRemoveDownload.getDriver().notifyPaused();\n                    break;\n                case FileDownloadStatus.completed:\n                    Throwable ex = null;\n                    try{\n                        willRemoveDownload.getDriver().notifyBlockComplete();\n                    }catch (Throwable e){\n                        ex = e;\n                    }\n\n                    if (ex != null) {\n                        willRemoveDownload.setStatus(FileDownloadStatus.error);\n                        willRemoveDownload.setEx(ex);\n                        willRemoveDownload.getDriver().notifyError();\n                    } else {\n                        willRemoveDownload.getDriver().notifyCompleted();\n                    }\n                    break;\n            }\n\n        } else {\n            FileDownloadLog.e(this, \"remove error, not exist: %s\", willRemoveDownload);\n        }\n\n        return succeed;\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-1145-Param-0",
    "old_comment_raw": "@param obj a duration to check against",
    "old_code_raw": "    public int compareTo(Object obj) {\n        // Comparable contract means we cannot handle null or other types gracefully\n        ReadableDuration thisDuration = (ReadableDuration) this;\n        ReadableDuration otherDuration = (ReadableDuration) obj;\n        \n        long thisMillis = thisDuration.getMillis();\n        long otherMillis = otherDuration.getMillis();\n        \n        // cannot do (thisMillis - otherMillis) as it can overflow\n        if (thisMillis < otherMillis) {\n            return -1;\n        }\n        if (thisMillis > otherMillis) {\n            return 1;\n        }\n        return 0;\n    }\n",
    "new_code_raw": "    public int compareTo(ReadableDuration other) {\n        long thisMillis = this.getMillis();\n        long otherMillis = other.getMillis();\n        \n        // cannot do (thisMillis - otherMillis) as it can overflow\n        if (thisMillis < otherMillis) {\n            return -1;\n        }\n        if (thisMillis > otherMillis) {\n            return 1;\n        }\n        return 0;\n    }\n"
  },
  {
    "id": "debezium_debezium-725-Param-1",
    "old_comment_raw": "@param source the information about the source that was read; may be null",
    "old_code_raw": "    public Struct read(Object record, Struct source, Long timestamp) {\n        Struct struct = new Struct(schema);\n        struct.put(FieldName.OPERATION, Operation.READ.code());\n        struct.put(FieldName.AFTER, record);\n        if (source != null) {\n            struct.put(FieldName.SOURCE, source);\n        }\n        if (timestamp != null) {\n            struct.put(FieldName.TIMESTAMP, timestamp);\n        }\n        return struct;\n    }\n",
    "new_code_raw": "    public Struct read(Object record, Struct source, Instant timestamp) {\n        Struct struct = new Struct(schema);\n        struct.put(FieldName.OPERATION, Operation.READ.code());\n        struct.put(FieldName.AFTER, record);\n        if (source != null) {\n            struct.put(FieldName.SOURCE, source);\n        }\n        if (timestamp != null) {\n            struct.put(FieldName.TIMESTAMP, timestamp.toEpochMilli());\n        }\n        return struct;\n    }\n"
  },
  {
    "id": "zaproxy_zaproxy-2225-Param-1",
    "old_comment_raw": "@param destHost the host param of FindProxyForURL(url, host)",
    "old_code_raw": "    public String evaluate(String destURL, String destHost) throws ScriptException {\n        try {\n            return (String) pacImpl.invokeFunction(\"FindProxyForURL\", destURL, destHost);\n        } catch (NoSuchMethodException | ScriptAbuseException e) {\n            throw new ScriptException(e);\n        }\n    }\n",
    "new_code_raw": "    String evaluate(String url, String host) throws ScriptException {\n        try {\n            return (String) pacImpl.invokeFunction(\"FindProxyForURL\", url, host);\n        } catch (NoSuchMethodException | ScriptAbuseException e) {\n            throw new ScriptException(e);\n        }\n    }\n"
  },
  {
    "id": "apache_kylin-283-Param-0",
    "old_comment_raw": "@param correctedSql",
    "old_code_raw": "    private SQLResponse execute(String correctedSql, SQLRequest sqlRequest, Connection conn) throws Exception {\n        Statement stat = null;\n        ResultSet resultSet = null;\n        Boolean isPushDown = false;\n\n        List<List<String>> results = Lists.newArrayList();\n        List<SelectedColumnMeta> columnMetas = Lists.newArrayList();\n\n        try {\n\n            // special case for prepare query. \n            if (BackdoorToggles.getPrepareOnly()) {\n                return getPrepareOnlySqlResponse(correctedSql, conn, isPushDown, results, columnMetas);\n            }\n\n            stat = conn.createStatement();\n            processStatementAttr(stat, sqlRequest);\n            resultSet = stat.executeQuery(correctedSql);\n\n            ResultSetMetaData metaData = resultSet.getMetaData();\n            int columnCount = metaData.getColumnCount();\n\n            // Fill in selected column meta\n            for (int i = 1; i <= columnCount; ++i) {\n                columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i),\n                        metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i),\n                        metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i),\n                        metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i),\n                        metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i),\n                        metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i),\n                        metaData.isDefinitelyWritable(i)));\n            }\n\n            // fill in results\n            while (resultSet.next()) {\n                List<String> oneRow = Lists.newArrayListWithCapacity(columnCount);\n                for (int i = 0; i < columnCount; i++) {\n                    oneRow.add((resultSet.getString(i + 1)));\n                }\n\n                results.add(oneRow);\n            }\n        } catch (SQLException sqlException) {\n            isPushDown = PushDownUtil.doPushDownQuery(sqlRequest.getProject(), correctedSql, conn.getSchema(), results,\n                    columnMetas, sqlException);\n            if (!isPushDown) {\n                throw sqlException;\n            }\n        } finally {\n            close(resultSet, stat, null);//conn is passed in, not my duty to close\n        }\n\n        return getSqlResponse(isPushDown, results, columnMetas);\n    }\n",
    "new_code_raw": "    private SQLResponse execute(String correctedSql, SQLRequest sqlRequest) throws Exception {\n        Connection conn = null;\n        Statement stat = null;\n        ResultSet resultSet = null;\n        Boolean isPushDown = false;\n\n        List<List<String>> results = Lists.newArrayList();\n        List<SelectedColumnMeta> columnMetas = Lists.newArrayList();\n\n        try {\n            conn = cacheService.getOLAPDataSource(sqlRequest.getProject()).getConnection();\n\n            // special case for prepare query. \n            if (BackdoorToggles.getPrepareOnly()) {\n                return getPrepareOnlySqlResponse(correctedSql, conn, isPushDown, results, columnMetas);\n            }\n\n            stat = conn.createStatement();\n            processStatementAttr(stat, sqlRequest);\n            resultSet = stat.executeQuery(correctedSql);\n\n            ResultSetMetaData metaData = resultSet.getMetaData();\n            int columnCount = metaData.getColumnCount();\n\n            // Fill in selected column meta\n            for (int i = 1; i <= columnCount; ++i) {\n                columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i),\n                        metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i),\n                        metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i),\n                        metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i),\n                        metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i),\n                        metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i),\n                        metaData.isDefinitelyWritable(i)));\n            }\n\n            // fill in results\n            while (resultSet.next()) {\n                List<String> oneRow = Lists.newArrayListWithCapacity(columnCount);\n                for (int i = 0; i < columnCount; i++) {\n                    oneRow.add((resultSet.getString(i + 1)));\n                }\n\n                results.add(oneRow);\n            }\n        } catch (SQLException sqlException) {\n            isPushDown = PushDownUtil.doPushDownQuery(sqlRequest.getProject(), correctedSql, results, columnMetas,\n                    sqlException);\n        } finally {\n            close(resultSet, stat, conn);\n        }\n\n        return getSqlResponse(isPushDown, results, columnMetas);\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1969-Param-1",
    "old_comment_raw": "@param ownerKey The owner key",
    "old_code_raw": "\tpublic PersistentCollection locateLoadingCollection(CollectionPersister persister, Serializable ownerKey) {\n\t\tfinal LoadingCollectionEntry lce = locateLoadingCollectionEntry( new CollectionKey( persister, ownerKey ) );\n\t\tif ( lce != null ) {\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracef(\n\t\t\t\t\t\t\"Returning loading collection: %s\",\n\t\t\t\t\t\tMessageHelper.collectionInfoString( persister, ownerKey, getSession().getFactory() )\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn lce.getCollection();\n\t\t}\n\t\treturn null;\n\t}\n",
    "new_code_raw": "\tpublic PersistentCollection locateLoadingCollection(CollectionPersister persister, CollectionKey key) {\n\t\tfinal LoadingCollectionEntry lce = locateLoadingCollectionEntry( key ) ;\n\t\tif ( lce != null ) {\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracef(\n\t\t\t\t\t\t\"Returning loading collection: %s\",\n\t\t\t\t\t\tMessageHelper.collectionInfoString( persister, key.getKey(), getSession().getFactory() )\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn lce.getCollection();\n\t\t}\n\t\treturn null;\n\t}\n"
  },
  {
    "id": "apache_activemq-1153-Param-1",
    "old_comment_raw": "@param localTransport",
    "old_code_raw": "    public static Transport createLocalTransport(URI uri) throws Exception {\n        return createLocalTransport(uri, false);\n    }\n",
    "new_code_raw": "    public static Transport createLocalTransport(NetworkBridgeConfiguration configuration, URI uri) throws Exception {\n        // one end of the localbroker<->bridge transport needs to be async to allow concurrent forwards and acks\n        return createLocalTransport(uri, !configuration.isDispatchAsync());\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2570-Param-0",
    "old_comment_raw": "@param p Swagger Property object",
    "old_code_raw": "    public String getTypeDeclaration(Property p) {\n        String swaggerType = getSwaggerType(p);\n        if (typeMapping.containsKey(swaggerType)) {\n            return typeMapping.get(swaggerType);\n        }\n        return swaggerType;\n    }\n",
    "new_code_raw": "    public String getTypeDeclaration(Schema schema) {\n        String oasType = getSchemaType(schema);\n        if (typeMapping.containsKey(oasType)) {\n            return typeMapping.get(oasType);\n        }\n        return oasType;\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-98-Param-0",
    "old_comment_raw": "@param prefix custom prefix",
    "old_code_raw": "    private PeriodFormatterBuilder appendPrefix(DurationFieldAffix prefix) {\n        if (prefix == null) {\n            throw new IllegalArgumentException();\n        }\n        if (iPrefix != null) {\n            prefix = new CompositeAffix(iPrefix, prefix);\n        }\n        iPrefix = prefix;\n        return this;\n    }\n",
    "new_code_raw": "    private PeriodFormatterBuilder appendPrefix(PeriodFieldAffix prefix) {\n        if (prefix == null) {\n            throw new IllegalArgumentException();\n        }\n        if (iPrefix != null) {\n            prefix = new CompositeAffix(iPrefix, prefix);\n        }\n        iPrefix = prefix;\n        return this;\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-345-Param-1",
    "old_comment_raw": "@param lo The low value",
    "old_code_raw": "\tpublic static Criterion between(String propertyName, Object lo, Object hi) {\n\t\treturn new BetweenExpression( propertyName, lo, hi );\n\t}\n",
    "new_code_raw": "\tpublic static Criterion between(String propertyName, Object low, Object high) {\n\t\treturn new BetweenExpression( propertyName, low, high );\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-673-Param-0",
    "old_comment_raw": "@param petId ID of pet that needs to be updated (required)",
    "old_code_raw": "  public Call updatePetWithFormAsync(String petId, String name, String status, final ApiCallback<Void> callback) throws ApiException {\n\n    ProgressResponseBody.ProgressListener progressListener = null;\n    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n    if (callback != null) {\n      progressListener = new ProgressResponseBody.ProgressListener() {\n        @Override\n        public void update(long bytesRead, long contentLength, boolean done) {\n          callback.onDownloadProgress(bytesRead, contentLength, done);\n        }\n      };\n\n      progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {\n        @Override\n        public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {\n          callback.onUploadProgress(bytesWritten, contentLength, done);\n        }\n      };\n    }\n\n    Call call = updatePetWithFormCall(petId, name, status, progressListener, progressRequestListener);\n    apiClient.executeAsync(call, callback);\n    return call;\n  }\n",
    "new_code_raw": "  public Call updatePetWithFormAsync(Long petId, String name, String status, final ApiCallback<Void> callback) throws ApiException {\n\n    ProgressResponseBody.ProgressListener progressListener = null;\n    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n    if (callback != null) {\n      progressListener = new ProgressResponseBody.ProgressListener() {\n        @Override\n        public void update(long bytesRead, long contentLength, boolean done) {\n          callback.onDownloadProgress(bytesRead, contentLength, done);\n        }\n      };\n\n      progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {\n        @Override\n        public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {\n          callback.onUploadProgress(bytesWritten, contentLength, done);\n        }\n      };\n    }\n\n    Call call = updatePetWithFormCall(petId, name, status, progressListener, progressRequestListener);\n    apiClient.executeAsync(call, callback);\n    return call;\n  }\n"
  },
  {
    "id": "debezium_debezium-720-Param-3",
    "old_comment_raw": "@param numberOfRows the total number of rows to be read; must be 1 or more",
    "old_code_raw": "        public int create(Object[] row, long ts, int rowNumber, int numberOfRows) throws InterruptedException {\n            return converter.insert(source, row, rowNumber, numberOfRows, includedColumns, ts, consumer);\n        }\n",
    "new_code_raw": "        public int create(Object[] row, Instant ts, int rowNumber, int numberOfRows) throws InterruptedException {\n            return converter.insert(source, row, rowNumber, numberOfRows, includedColumns, ts, consumer);\n        }\n"
  },
  {
    "id": "querydsl_querydsl-1827-Param-1",
    "old_comment_raw": "@param args operation arguments",
    "old_code_raw": "    public static BooleanOperation predicate(Operator operator, Expression<?>... args) {\n        return new BooleanOperation(operator, args);\n    }\n",
    "new_code_raw": "    public static BooleanOperation predicate(Operator operation, Expression<?>... args) {\n        return new BooleanOperation(operation, args);\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-1641-Param-0",
    "old_comment_raw": "@param props The properties to use in the  edu.stanford.nlp.pipeline.WordsToSentencesAnnotator.",
    "old_code_raw": "  public List<Sentence> sentences(Properties props) {\n    if (sentences == null) {\n      // Get annotators\n      Annotator tokenizer = props == EMPTY_PROPS ? defaultTokenize : AnnotatorFactories.tokenize(props, backend).create();\n      Annotator ssplit = props == EMPTY_PROPS ? defaultSSplit : AnnotatorFactories.sentenceSplit(props, backend).create();\n      // Annotate\n      Annotation ann = new Annotation(this.impl.getText());\n      tokenizer.annotate(ann);\n      ssplit.annotate(ann);\n      // Grok results\n      // (docid)\n      if (ann.containsKey(CoreAnnotations.DocIDAnnotation.class)) {\n        impl.setDocID(ann.get(CoreAnnotations.DocIDAnnotation.class));\n      }\n      // (sentences)\n      List<CoreMap> sentences = ann.get(CoreAnnotations.SentencesAnnotation.class);\n      this.sentences = new ArrayList<>(sentences.size());\n      for (CoreMap sentence : sentences) {\n        //Sentence sent = new Sentence(this, sentence);\n        Sentence sent = new Sentence(this, this.serializer.toProtoBuilder(sentence), sentence.get(CoreAnnotations.TextAnnotation.class));\n        this.sentences.add(sent);\n        this.impl.addSentence(sent.serialize());\n      }\n    }\n\n    // Re-computing the sentences invalidates the cached Annotation\n    synchronized (annotationPool) {\n      annotationPool.remove(this);\n    }\n    synchronized (annotationPoolKeys) {\n      annotationPoolKeys.remove(this);\n    }\n\n    return sentences;\n  }\n",
    "new_code_raw": "  protected List<Sentence> sentences(Properties props, Annotator tokenizer) {\n    if (sentences == null) {\n      Annotator ssplit = props == EMPTY_PROPS ? defaultSSplit : AnnotatorFactories.sentenceSplit(props, backend).create();\n      // Annotate\n      Annotation ann = new Annotation(this.impl.getText());\n      tokenizer.annotate(ann);\n      ssplit.annotate(ann);\n      // Grok results\n      // (docid)\n      if (ann.containsKey(CoreAnnotations.DocIDAnnotation.class)) {\n        impl.setDocID(ann.get(CoreAnnotations.DocIDAnnotation.class));\n      }\n      // (sentences)\n      List<CoreMap> sentences = ann.get(CoreAnnotations.SentencesAnnotation.class);\n      this.sentences = new ArrayList<>(sentences.size());\n      for (CoreMap sentence : sentences) {\n        //Sentence sent = new Sentence(this, sentence);\n        Sentence sent = new Sentence(this, this.serializer.toProtoBuilder(sentence), sentence.get(CoreAnnotations.TextAnnotation.class), defaultProps);\n        this.sentences.add(sent);\n        this.impl.addSentence(sent.serialize());\n      }\n    }\n\n    return sentences;\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1730-Param-0",
    "old_comment_raw": "@param httpClient An instance of OkHttpClient",
    "old_code_raw": "    public ApiClient setHttpClient(OkHttpClient httpClient) {\n        this.httpClient = httpClient.newBuilder().addInterceptor(getProgressInterceptor()).build();\n        return this;\n    }\n",
    "new_code_raw": "     public ApiClient setHttpClient(OkHttpClient newHttpClient) {\n        if(!httpClient.equals(newHttpClient)) {\n            OkHttpClient.Builder builder = newHttpClient.newBuilder();\n            Iterator<Interceptor> networkInterceptorIterator = httpClient.networkInterceptors().iterator();\n            while(networkInterceptorIterator.hasNext()) {\n                builder.addNetworkInterceptor(networkInterceptorIterator.next());\n            }\n            Iterator<Interceptor> interceptorIterator = httpClient.interceptors().iterator();\n            while(interceptorIterator.hasNext()) {\n                builder.addInterceptor(interceptorIterator.next());\n            }\n            this.httpClient = builder.build();\n        }\n        return this;\n    }\n"
  },
  {
    "id": "apache_calcite-262-Param-1",
    "old_comment_raw": "@param rel the RelNode that the filter will be put on top of",
    "old_code_raw": "    public PushDownJoinConditionRule() {\n      super(RelOptRule.operand(JoinRelBase.class, RelOptRule.any()),\n          \"PushFilterPastJoinRule:no-filter\",\n          true);\n    }\n",
    "new_code_raw": "    public PushDownJoinConditionRule(RelFactories.FilterFactory filterFactory) {\n      super(RelOptRule.operand(JoinRelBase.class, RelOptRule.any()),\n          \"PushFilterPastJoinRule:no-filter\",\n          true, filterFactory);\n    }\n"
  },
  {
    "id": "Atmosphere_atmosphere-860-Param-0",
    "old_comment_raw": "@param message the message to broadcast.",
    "old_code_raw": "    public BroadcastAction filter(Object originalMessage, Object message) {\n        // Avoid re-broadcasting\n        if (!receivedMessages.remove(message)) {\n            try {\n                jchannel.send(new Message(null, null, new JGroupsBroadcaster.BroadcastMessage(bc.getID(), message)));\n            } catch (ChannelException e) {\n                logger.warn(\"failed to send message\", e);\n            }\n        }\n        return new BroadcastAction(message);\n    }\n",
    "new_code_raw": "    public BroadcastAction filter(Object originalMessage, Object o) {\n        if (o instanceof String){\n            String message = (String)o;\n            // Avoid re-broadcasting\n            if (!receivedMessages.remove(message)) {\n                try {\n                    jchannel.send(new Message(null, null, message));\n                } catch (ChannelException e) {\n                    logger.warn(\"failed to send message\", e);\n                }\n            }\n            return new BroadcastAction(message);\n        } else {\n            return new BroadcastAction(o);\n        }\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-286-Param-6",
    "old_comment_raw": "@param accept The request's Accept header",
    "old_code_raw": "  public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n",
    "new_code_raw": "  public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n"
  },
  {
    "id": "querydsl_querydsl-1828-Param-1",
    "old_comment_raw": "@param alias alias for the joint target",
    "old_code_raw": "    public CloseableIterator<T> iterate() {\n        try {\n            Expression<T> projection = (Expression<T>)queryMixin.getMetadata().getProjection();\n            return new IteratorAdapter<T>(queryEngine.list(getMetadata(), iterables, projection).iterator());\n        } finally {\n            reset();\n        }\n    }\n",
    "new_code_raw": "    public CloseableIterator<Tuple> iterate(Expression<?>... args) {\n        return iterate(queryMixin.createProjection(args));\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1188-Param-1",
    "old_comment_raw": "@param entity The entity instance",
    "old_code_raw": "\tpublic static boolean isTransient(String entityName, Object entity, Boolean assumed, SessionImplementor session) {\n\t\tif ( entity == LazyPropertyInitializer.UNFETCHED_PROPERTY ) {\n\t\t\t// an unfetched association can only point to\n\t\t\t// an entity that already exists in the db\n\t\t\treturn false;\n\t\t}\n\n\t\t// let the interceptor inspect the instance to decide\n\t\tBoolean isUnsaved = session.getInterceptor().isTransient( entity );\n\t\tif ( isUnsaved != null ) {\n\t\t\treturn isUnsaved;\n\t\t}\n\n\t\t// let the persister inspect the instance to decide\n\t\tfinal EntityPersister persister = session.getEntityPersister( entityName, entity );\n\t\tisUnsaved = persister.isTransient( entity, session );\n\t\tif ( isUnsaved != null ) {\n\t\t\treturn isUnsaved;\n\t\t}\n\n\t\t// we use the assumed value, if there is one, to avoid hitting\n\t\t// the database\n\t\tif ( assumed != null ) {\n\t\t\treturn assumed;\n\t\t}\n\n\t\t// hit the database, after checking the session cache for a snapshot\n\t\tfinal Object[] snapshot = session.getPersistenceContext().getDatabaseSnapshot(\n\t\t\t\tpersister.getIdentifier( entity, session ),\n\t\t\t\tpersister\n\t\t);\n\t\treturn snapshot == null;\n\n\t}\n",
    "new_code_raw": "\tpublic static boolean isTransient(String entityName, Object entity, Boolean assumed, SharedSessionContractImplementor session) {\n\t\tif ( entity == LazyPropertyInitializer.UNFETCHED_PROPERTY ) {\n\t\t\t// an unfetched association can only point to\n\t\t\t// an entity that already exists in the db\n\t\t\treturn false;\n\t\t}\n\n\t\t// let the interceptor inspect the instance to decide\n\t\tBoolean isUnsaved = session.getInterceptor().isTransient( entity );\n\t\tif ( isUnsaved != null ) {\n\t\t\treturn isUnsaved;\n\t\t}\n\n\t\t// let the persister inspect the instance to decide\n\t\tfinal EntityPersister persister = session.getEntityPersister( entityName, entity );\n\t\tisUnsaved = persister.isTransient( entity, session );\n\t\tif ( isUnsaved != null ) {\n\t\t\treturn isUnsaved;\n\t\t}\n\n\t\t// we use the assumed value, if there is one, to avoid hitting\n\t\t// the database\n\t\tif ( assumed != null ) {\n\t\t\treturn assumed;\n\t\t}\n\n\t\t// hit the database, afterQuery checking the session cache for a snapshot\n\t\tfinal Object[] snapshot = session.getPersistenceContext().getDatabaseSnapshot(\n\t\t\t\tpersister.getIdentifier( entity, session ),\n\t\t\t\tpersister\n\t\t);\n\t\treturn snapshot == null;\n\n\t}\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-2378-Param-0",
    "old_comment_raw": "@param words The input sentence (a List of words)",
    "old_code_raw": "  public Tree apply(List<? extends HasWord> words) {\n    return parse(words);\n  }\n",
    "new_code_raw": "  public Tree apply(List<? extends HasWord> lst) {\n    return parse(lst);\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1196-Param-1",
    "old_comment_raw": "@param namedParams The named query parameters specified by the application.",
    "old_code_raw": "\tprotected void coordinateSharedCacheCleanup(SessionImplementor session) {\n\t\tfinal BulkOperationCleanupAction action = new BulkOperationCleanupAction( session, getCustomQuery().getQuerySpaces() );\n\n\t\tif ( session.isEventSource() ) {\n\t\t\t( (EventSource) session ).getActionQueue().addAction( action );\n\t\t}\n\t\telse {\n\t\t\taction.getAfterTransactionCompletionProcess().doAfterTransactionCompletion( true, session );\n\t\t}\n\t}\n",
    "new_code_raw": "\tprotected void coordinateSharedCacheCleanup(SharedSessionContractImplementor session) {\n\t\tfinal BulkOperationCleanupAction action = new BulkOperationCleanupAction( session, getCustomQuery().getQuerySpaces() );\n\n\t\tif ( session.isEventSource() ) {\n\t\t\t( (EventSource) session ).getActionQueue().addAction( action );\n\t\t}\n\t\telse {\n\t\t\taction.getAfterTransactionCompletionProcess().doAfterTransactionCompletion( true, session );\n\t\t}\n\t}\n"
  },
  {
    "id": "debezium_debezium-142-Param-3",
    "old_comment_raw": "@param timestamp the timestamp for this message; may be null",
    "old_code_raw": "    public Struct update(Struct before, Struct after, Struct source, Long timestamp) {\n        Struct struct = new Struct(schema);\n        struct.put(FieldName.OPERATION, Operation.UPDATE.code());\n        if (before != null) struct.put(FieldName.BEFORE, before);\n        struct.put(FieldName.AFTER, after);\n        if (source != null) struct.put(FieldName.SOURCE, source);\n        if (timestamp != null) struct.put(FieldName.TIMESTAMP, timestamp);\n        return struct;\n    }\n",
    "new_code_raw": "    public Struct update(Object before, Struct after, Struct source, Long timestamp) {\n        Struct struct = new Struct(schema);\n        struct.put(FieldName.OPERATION, Operation.UPDATE.code());\n        if (before != null) struct.put(FieldName.BEFORE, before);\n        struct.put(FieldName.AFTER, after);\n        if (source != null) struct.put(FieldName.SOURCE, source);\n        if (timestamp != null) struct.put(FieldName.TIMESTAMP, timestamp);\n        return struct;\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-203-Param-8",
    "old_comment_raw": "@param authNames The authentications to apply",
    "old_code_raw": "  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n",
    "new_code_raw": "  public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n"
  },
  {
    "id": "Atmosphere_atmosphere-855-Param-0",
    "old_comment_raw": "@param req the  HttpServletRequest",
    "old_code_raw": "    public Action resumed(HttpServletRequest req, HttpServletResponse res)\n            throws IOException, ServletException {\n        if (logger.isLoggable(Level.FINE)) {\n            logger.fine(\"(resumed) invoked:\\n HttpServletRequest: \" + req\n                    + \"\\n HttpServletResponse: \" + res);\n        }\n        return action(req, res);\n    }\n",
    "new_code_raw": "    public Action resumed(HttpServletRequest request, HttpServletResponse response)\n            throws IOException, ServletException {\n        logger.debug(\"(resumed) invoked:\\n HttpServletRequest: {}\\n HttpServletResponse: {}\", request, response);\n        return action(request, response);\n    }\n"
  },
  {
    "id": "stanfordnlp_CoreNLP-1519-Param-0",
    "old_comment_raw": "@param annotators The annotators the user has requested.",
    "old_code_raw": "  public static String ensurePrerequisiteAnnotators(String[] annotators) {\n    // Get an unordered set of annotators\n    Set<String> unorderedAnnotators = new LinkedHashSet<>();  // linked to preserve order\n    Collections.addAll(unorderedAnnotators, annotators);\n    for (String annotator : annotators) {\n      // Add the annotator\n      if (!getNamedAnnotators().containsKey(annotator.toLowerCase())) {\n        throw new IllegalArgumentException(\"Unknown annotator: \" + annotator);\n      }\n\n      // Add its transitive dependencies\n      unorderedAnnotators.add(annotator.toLowerCase());\n      if (!Annotator.DEFAULT_REQUIREMENTS.containsKey(annotator.toLowerCase())) {\n        throw new IllegalArgumentException(\"Cannot infer requirements for annotator: \" + annotator);\n      }\n      Queue<String> fringe = new LinkedList<>(Annotator.DEFAULT_REQUIREMENTS.get(annotator.toLowerCase()));\n      int ticks = 0;\n      while (!fringe.isEmpty()) {\n        ticks += 1;\n        if (ticks == 1000000) {\n          throw new IllegalStateException(\"[INTERNAL ERROR] Annotators have a circular dependency.\");\n        }\n        String prereq = fringe.poll();\n        unorderedAnnotators.add(prereq);\n        fringe.addAll(Annotator.DEFAULT_REQUIREMENTS.get(prereq.toLowerCase()));\n      }\n    }\n\n    // Order the annotators\n    List<String> orderedAnnotators = new ArrayList<>();\n    while (!unorderedAnnotators.isEmpty()) {\n      boolean somethingAdded = false;  // to make sure the dependencies are satisfiable\n      // Loop over candidate annotators to add\n      Iterator<String> iter = unorderedAnnotators.iterator();\n      while (iter.hasNext()) {\n        String candidate = iter.next();\n        // Are the requirements satisfied?\n        boolean canAdd = true;\n        for (String prereq : Annotator.DEFAULT_REQUIREMENTS.get(candidate.toLowerCase())) {\n          if (!orderedAnnotators.contains(prereq)) {\n            canAdd = false;\n            break;\n          }\n        }\n        // If so, add the annotator\n        if (canAdd) {\n          orderedAnnotators.add(candidate);\n          iter.remove();\n          somethingAdded = true;\n        }\n      }\n      // Make sure we're making progress every iteration, to prevent an infinite loop\n      if (!somethingAdded) {\n        throw new IllegalArgumentException(\"Unsatisfiable annotator list: \" + StringUtils.join(annotators, \",\"));\n      }\n    }\n\n    // Return\n    return StringUtils.join(orderedAnnotators, \",\");\n  }\n",
    "new_code_raw": "  public static String ensurePrerequisiteAnnotators(String[] annotators, Properties props) {\n    // Get an unordered set of annotators\n    Set<String> unorderedAnnotators = new LinkedHashSet<>();  // linked to preserve order\n    Collections.addAll(unorderedAnnotators, annotators);\n    for (String annotator : annotators) {\n      // Add the annotator\n      if (!getNamedAnnotators().containsKey(annotator.toLowerCase())) {\n        throw new IllegalArgumentException(\"Unknown annotator: \" + annotator);\n      }\n\n      // Add its transitive dependencies\n      unorderedAnnotators.add(annotator.toLowerCase());\n      if (!Annotator.DEFAULT_REQUIREMENTS.containsKey(annotator.toLowerCase())) {\n        throw new IllegalArgumentException(\"Cannot infer requirements for annotator: \" + annotator);\n      }\n      Queue<String> fringe = new LinkedList<>(Annotator.DEFAULT_REQUIREMENTS.get(annotator.toLowerCase()));\n      int ticks = 0;\n      while (!fringe.isEmpty()) {\n        ticks += 1;\n        if (ticks == 1000000) {\n          throw new IllegalStateException(\"[INTERNAL ERROR] Annotators have a circular dependency.\");\n        }\n        String prereq = fringe.poll();\n        unorderedAnnotators.add(prereq);\n        fringe.addAll(Annotator.DEFAULT_REQUIREMENTS.get(prereq.toLowerCase()));\n      }\n    }\n\n    // Order the annotators\n    List<String> orderedAnnotators = new ArrayList<>();\n    while (!unorderedAnnotators.isEmpty()) {\n      boolean somethingAdded = false;  // to make sure the dependencies are satisfiable\n      // Loop over candidate annotators to add\n      Iterator<String> iter = unorderedAnnotators.iterator();\n      while (iter.hasNext()) {\n        String candidate = iter.next();\n        // Are the requirements satisfied?\n        boolean canAdd = true;\n        for (String prereq : Annotator.DEFAULT_REQUIREMENTS.get(candidate.toLowerCase())) {\n          if (!orderedAnnotators.contains(prereq)) {\n            canAdd = false;\n            break;\n          }\n        }\n        // If so, add the annotator\n        if (canAdd) {\n          orderedAnnotators.add(candidate);\n          iter.remove();\n          somethingAdded = true;\n        }\n      }\n      // Make sure we're making progress every iteration, to prevent an infinite loop\n      if (!somethingAdded) {\n        throw new IllegalArgumentException(\"Unsatisfiable annotator list: \" + StringUtils.join(annotators, \",\"));\n      }\n    }\n\n    // Remove depparse + parse -- these are redundant\n    if (orderedAnnotators.contains(STANFORD_PARSE) && !ArrayUtils.contains(annotators, STANFORD_DEPENDENCIES)) {\n      orderedAnnotators.remove(STANFORD_DEPENDENCIES);\n    }\n\n    // Tweak the properties, if necessary\n    // (set the mention annotator to use dependency trees, if appropriate)\n    if (orderedAnnotators.contains(Annotator.STANFORD_MENTION) && !orderedAnnotators.contains(Annotator.STANFORD_PARSE) &&\n        !props.containsKey(\"coref.md.type\")) {\n      props.setProperty(\"coref.md.type\", \"dep\");\n    }\n\n    // Return\n    return StringUtils.join(orderedAnnotators, \",\");\n  }\n"
  },
  {
    "id": "apache_calcite-877-Param-0",
    "old_comment_raw": "@param fail Whether to throw an assertion error if not in canonical form",
    "old_code_raw": "  public boolean isNormalized(boolean fail, RexBuilder rexBuilder) {\n    final RexProgram normalizedProgram =\n        RexProgramBuilder.normalize(rexBuilder, this);\n    String normalized = normalizedProgram.toString();\n    String string = toString();\n    if (!normalized.equals(string)) {\n      assert !fail\n          : \"Program is not normalized:\\n\"\n          + \"program:    \" + string + \"\\n\"\n          + \"normalized: \" + normalized + \"\\n\";\n      return false;\n    }\n    return true;\n  }\n",
    "new_code_raw": "  public boolean isNormalized(Litmus litmus, RexBuilder rexBuilder) {\n    final RexProgram normalizedProgram = normalize(rexBuilder, false);\n    String normalized = normalizedProgram.toString();\n    String string = toString();\n    if (!normalized.equals(string)) {\n      return litmus.fail(\"Program is not normalized:\\n\"\n          + \"program:    \" + string + \"\\n\"\n          + \"normalized: \" + normalized + \"\\n\");\n    }\n    return litmus.succeed();\n  }\n"
  },
  {
    "id": "apache_activemq-601-Param-1",
    "old_comment_raw": "@param compositeData used to apply parameters to this transport",
    "old_code_raw": "    public static DiscoveryTransport createTransport(CompositeTransport compositeTransport, CompositeData compositeData) throws IOException {                \n        DiscoveryTransport transport = new DiscoveryTransport(compositeTransport);\n        \n        Map<String, String> parameters = new HashMap<String, String>(compositeData.getParameters());\n        IntrospectionSupport.setProperties(transport, parameters);\n        transport.setParameters(parameters);\n        \n        URI discoveryAgentURI = compositeData.getComponents()[0];\n        DiscoveryAgent discoveryAgent = DiscoveryAgentFactory.createDiscoveryAgent(discoveryAgentURI);\n        transport.setDiscoveryAgent(discoveryAgent);\n        return transport;\n    }\n",
    "new_code_raw": "    public static DiscoveryTransport createTransport(CompositeTransport compositeTransport, CompositeData compositeData, Map<String, String> parameters) throws IOException {\n        DiscoveryTransport transport = new DiscoveryTransport(compositeTransport);\n\n        IntrospectionSupport.setProperties(transport, parameters);\n        transport.setParameters(parameters);\n        \n        URI discoveryAgentURI = compositeData.getComponents()[0];\n        DiscoveryAgent discoveryAgent = DiscoveryAgentFactory.createDiscoveryAgent(discoveryAgentURI);\n        transport.setDiscoveryAgent(discoveryAgent);\n        return transport;\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-335-Param-1",
    "old_comment_raw": "@param dialect The dialect in effect",
    "old_code_raw": "\tprotected String determineValueColumnName(Properties params, Dialect dialect) {\n\t\tfinal ObjectNameNormalizer normalizer = (ObjectNameNormalizer) params.get( IDENTIFIER_NORMALIZER );\n\t\tfinal String name = ConfigurationHelper.getString( VALUE_COLUMN_PARAM, params, DEF_VALUE_COLUMN );\n\t\treturn normalizer.toDatabaseIdentifierText( name );\n\t}\n",
    "new_code_raw": "\tprotected String determineValueColumnName(Properties params, JdbcEnvironment jdbcEnvironment) {\n\t\tfinal String name = ConfigurationHelper.getString( VALUE_COLUMN_PARAM, params, DEF_VALUE_COLUMN );\n\t\treturn jdbcEnvironment.getIdentifierHelper().toIdentifier( name ).render( jdbcEnvironment.getDialect() );\n\t}\n"
  },
  {
    "id": "debezium_debezium-811-Param-0",
    "old_comment_raw": "@param config the field values keyed by their name; may not be null",
    "old_code_raw": "    public boolean validate(Configuration config, Consumer<String> problems) {\n        return validator == null ? true : validator.validate(config, this, problems) == 0;\n    }\n",
    "new_code_raw": "    public boolean validate(Configuration config, ValidationOutput problems) {\n        Validator typeValidator = validatorForType(type);\n        int errors = 0;\n        if (typeValidator != null) errors += typeValidator.validate(config, this, problems);\n        if (validator != null) errors += validator.validate(config, this, problems);\n        return errors == 0;\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2532-Param-0",
    "old_comment_raw": "@param p Swagger property object",
    "old_code_raw": "    public String toDefaultValue(Property p) {\n        if (p instanceof StringProperty) {\n            StringProperty dp = (StringProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\\\"\" + dp.getDefault() + \"\\\"\";\n            }\n        } else if (p instanceof BooleanProperty) {\n            BooleanProperty dp = (BooleanProperty) p;\n            if (dp.getDefault() != null) {\n                if (dp.getDefault().toString().equalsIgnoreCase(\"false\"))\n                    return \"@(NO)\";\n                else\n                    return \"@(YES)\";\n            }\n        } else if (p instanceof DateProperty) {\n            // TODO\n        } else if (p instanceof DateTimeProperty) {\n            // TODO\n        } else if (p instanceof DoubleProperty) {\n            DoubleProperty dp = (DoubleProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof FloatProperty) {\n            FloatProperty dp = (FloatProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof IntegerProperty) {\n            IntegerProperty dp = (IntegerProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof LongProperty) {\n            LongProperty dp = (LongProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        }\n\n        return null;\n    }\n",
    "new_code_raw": "    public String toDefaultValue(Schema p) {\n        if (p instanceof StringSchema) {\n            StringSchema dp = (StringSchema) p;\n            if (dp.getDefault() != null) {\n                return \"@\\\"\" + dp.getDefault() + \"\\\"\";\n            }\n        } else if (p instanceof BooleanSchema) {\n            BooleanSchema dp = (BooleanSchema) p;\n            if (dp.getDefault() != null) {\n                if (dp.getDefault().toString().equalsIgnoreCase(\"false\"))\n                    return \"@(NO)\";\n                else\n                    return \"@(YES)\";\n            }\n        } else if (p instanceof DateSchema) {\n            // TODO\n        } else if (p instanceof DateTimeSchema) {\n            // TODO\n        } else if (p instanceof NumberSchema) {\n            NumberSchema dp = (NumberSchema) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof IntegerSchema) {\n            IntegerSchema dp = (IntegerSchema) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        }\n\n        return null;\n    }\n"
  },
  {
    "id": "debezium_debezium-265-Param-2",
    "old_comment_raw": "@param txId the ID of the transaction that generated the transaction; may be null if this information nis not available",
    "old_code_raw": "    protected SourceInfo update(Long lsn, Long useconds, Integer txId) {\n        this.lsn = lsn;\n        this.useconds = useconds;\n        this.txId = txId;\n        return this;\n    }\n",
    "new_code_raw": "    protected SourceInfo update(Long lsn, Long useconds, Long txId) {\n        this.lsn = lsn;\n        this.useconds = useconds;\n        this.txId = txId;\n        return this;\n    }\n"
  },
  {
    "id": "apache_kylin-379-Param-1",
    "old_comment_raw": "@param rightRel Right input to the join",
    "old_code_raw": "    private RexNode convertUsing(RelNode leftRel, RelNode rightRel, List<String> nameList) {\n        final List<RexNode> list = Lists.newArrayList();\n        for (String name : nameList) {\n            final RelDataType leftRowType = leftRel.getRowType();\n            RelDataTypeField leftField = catalogReader.field(leftRowType, name);\n            RexNode left = rexBuilder.makeInputRef(leftField.getType(), leftField.getIndex());\n            final RelDataType rightRowType = rightRel.getRowType();\n            RelDataTypeField rightField = catalogReader.field(rightRowType, name);\n            RexNode right = rexBuilder.makeInputRef(rightField.getType(), leftRowType.getFieldList().size() + rightField.getIndex());\n            RexNode equalsCall = rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, left, right);\n            list.add(equalsCall);\n        }\n        return RexUtil.composeConjunction(rexBuilder, list, false);\n    }\n",
    "new_code_raw": "    private RexNode convertUsing(SqlValidatorNamespace leftNamespace, SqlValidatorNamespace rightNamespace, List<String> nameList) {\n        final List<RexNode> list = Lists.newArrayList();\n        for (String name : nameList) {\n            List<RexNode> operands = new ArrayList<>();\n            int offset = 0;\n            for (SqlValidatorNamespace n : ImmutableList.of(leftNamespace, rightNamespace)) {\n                final RelDataType rowType = n.getRowType();\n                final RelDataTypeField field = catalogReader.field(rowType, name);\n                operands.add(rexBuilder.makeInputRef(field.getType(), offset + field.getIndex()));\n                offset += rowType.getFieldList().size();\n            }\n            list.add(rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, operands));\n        }\n        return RexUtil.composeConjunction(rexBuilder, list, false);\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-141-Param-0",
    "old_comment_raw": "@param direction the direction in which to scroll",
    "old_code_raw": "\tprivate boolean scroll(int direction) {\n\t\tint yStart;\n\t\tint yEnd;\n\t\tif (direction == DOWN) {\n\t\t\tyStart = (activityUtils.getCurrentActivity().getWindowManager()\n\t\t\t\t\t.getDefaultDisplay().getHeight() - 20);\n\t\t\tyEnd = ((activityUtils.getCurrentActivity().getWindowManager()\n\t\t\t\t\t.getDefaultDisplay().getHeight() / 2));\n\t\t} \n\t\telse {\n\t\t\tyStart = ((activityUtils.getCurrentActivity().getWindowManager()\n\t\t\t\t\t.getDefaultDisplay().getHeight() / 2));\n\t\t\tyEnd = (activityUtils.getCurrentActivity().getWindowManager()\n\t\t\t\t\t.getDefaultDisplay().getHeight() - 20);\n\t\t}\n\t\tint x = activityUtils.getCurrentActivity().getWindowManager()\n\t\t\t\t.getDefaultDisplay().getWidth() / 2;\n\n\t\tif (viewFetcher.getCurrentListViews().size() > 0) {\n\t\t\treturn scrollList(0, direction);\n\t\t} \n\t\telse if (viewFetcher.getCurrentScrollViews().size() > 0) {\n\t\t\tScrollView scroll = viewFetcher.getCurrentScrollViews().get(0);\n\t\t\tscrollAmount = scroll.getScrollY();\n\t\t\tdrag(x, x, yStart, yEnd, 20);\n\t\t\tif (scrollAmount == scroll.getScrollY()) {\n\t\t\t\tscrollAmount = 0;\n\t\t\t\treturn false;\n\t\t\t} \n\t\t\telse\n\t\t\t\treturn true;\n\t\t} \n\t\telse\n\t\t\treturn false;\n\n\t}\n",
    "new_code_raw": "\tprivate boolean scroll(Direction direction) {\n\t\tint yStart;\n\t\tint yEnd;\n\t\tif (direction == Direction.DOWN) {\n\t\t\tyStart = (activityUtils.getCurrentActivity().getWindowManager()\n\t\t\t\t\t.getDefaultDisplay().getHeight() - 20);\n\t\t\tyEnd = ((activityUtils.getCurrentActivity().getWindowManager()\n\t\t\t\t\t.getDefaultDisplay().getHeight() / 2));\n\t\t} \n\t\telse {\n\t\t\tyStart = ((activityUtils.getCurrentActivity().getWindowManager()\n\t\t\t\t\t.getDefaultDisplay().getHeight() / 2));\n\t\t\tyEnd = (activityUtils.getCurrentActivity().getWindowManager()\n\t\t\t\t\t.getDefaultDisplay().getHeight() - 20);\n\t\t}\n\t\tint x = activityUtils.getCurrentActivity().getWindowManager()\n\t\t\t\t.getDefaultDisplay().getWidth() / 2;\n\n\t\tif (viewFetcher.getCurrentListViews().size() > 0) {\n\t\t\treturn scrollList(0, direction);\n\t\t} \n\t\telse if (viewFetcher.getCurrentScrollViews().size() > 0) {\n\t\t\tScrollView scroll = viewFetcher.getCurrentScrollViews().get(0);\n\t\t\tscrollAmount = scroll.getScrollY();\n\t\t\tdrag(x, x, yStart, yEnd, 20);\n\t\t\tif (scrollAmount == scroll.getScrollY()) {\n\t\t\t\tscrollAmount = 0;\n\t\t\t\treturn false;\n\t\t\t} \n\t\t\telse\n\t\t\t\treturn true;\n\t\t} \n\t\telse\n\t\t\treturn false;\n\n\t}\n"
  },
  {
    "id": "SeleniumHQ_selenium-856-Param-0",
    "old_comment_raw": "@param cap",
    "old_code_raw": "  public static RemoteProxy getNewBasicRemoteProxy(Map<String, Object> cap, String url, Registry registry) {\n    RegistrationRequest req = RegistrationRequest.build(\"-role\", \"webdriver\");\n    req.getCapabilities().clear();\n    req.addDesiredCapabilitiy(cap);\n    req.getConfiguration().put(RegistrationRequest.REMOTE_URL, url);\n    return new RemoteProxy(req, registry);\n\n  }\n",
    "new_code_raw": "  public static RemoteProxy getNewBasicRemoteProxy(String browser, String url, Registry registry) {\n\n    RegistrationRequest req = RegistrationRequest.build(\"-role\", \"webdriver\");\n    req.getCapabilities().clear();\n\n    DesiredCapabilities capability = new DesiredCapabilities();\n    capability.setBrowserName(browser);\n    req.addDesiredCapabilitiy(capability);\n\n    Map<String, Object> config = new HashMap<String, Object>();\n    config.put(\"url\", url);\n    req.setConfiguration(config);\n    return new RemoteProxy(req, registry);\n\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1728-Param-1",
    "old_comment_raw": "@param method The request method, one of \"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\", \"PATCH\" and \"DELETE\"",
    "old_code_raw": "    public Request buildRequest(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n        updateParamsForAuth(authNames, queryParams, headerParams);\n\n        final String url = buildUrl(path, queryParams, collectionQueryParams);\n        final Request.Builder reqBuilder = new Request.Builder().url(url);\n        processHeaderParams(headerParams, reqBuilder);\n\n        String contentType = (String) headerParams.get(\"Content-Type\");\n        // ensuring a default content type\n        if (contentType == null) {\n            contentType = \"application/json\";\n        }\n\n        RequestBody reqBody;\n        if (!HttpMethod.permitsRequestBody(method)) {\n            reqBody = null;\n        } else if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n            reqBody = buildRequestBodyFormEncoding(formParams);\n        } else if (\"multipart/form-data\".equals(contentType)) {\n            reqBody = buildRequestBodyMultipart(formParams);\n        } else if (body == null) {\n            if (\"DELETE\".equals(method)) {\n                // allow calling DELETE without sending a request body\n                reqBody = null;\n            } else {\n                // use an empty request body (for POST, PUT and PATCH)\n                reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n            }\n        } else {\n            reqBody = serialize(body, contentType);\n        }\n\n        Request request = null;\n\n        if(progressRequestListener != null && reqBody != null) {\n            ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener);\n            request = reqBuilder.method(method, progressRequestBody).build();\n        } else {\n            request = reqBuilder.method(method, reqBody).build();\n        }\n\n        return request;\n    }\n",
    "new_code_raw": "    public Request buildRequest(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {\n        updateParamsForAuth(authNames, queryParams, headerParams);\n\n        final String url = buildUrl(path, queryParams, collectionQueryParams);\n        final Request.Builder reqBuilder = new Request.Builder().url(url);\n        processHeaderParams(headerParams, reqBuilder);\n\n        String contentType = (String) headerParams.get(\"Content-Type\");\n        // ensuring a default content type\n        if (contentType == null) {\n            contentType = \"application/json\";\n        }\n\n        RequestBody reqBody;\n        if (!HttpMethod.permitsRequestBody(method)) {\n            reqBody = null;\n        } else if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n            reqBody = buildRequestBodyFormEncoding(formParams);\n        } else if (\"multipart/form-data\".equals(contentType)) {\n            reqBody = buildRequestBodyMultipart(formParams);\n        } else if (body == null) {\n            if (\"DELETE\".equals(method)) {\n                // allow calling DELETE without sending a request body\n                reqBody = null;\n            } else {\n                // use an empty request body (for POST, PUT and PATCH)\n                reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n            }\n        } else {\n            reqBody = serialize(body, contentType);\n        }\n\n        // Associate callback with request (if not null) so interceptor can\n        // access it when creating ProgressResponseBody\n        reqBuilder.tag(callback);\n\n        Request request = null;\n\n        if (callback != null && reqBody != null) {\n            ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, callback);\n            request = reqBuilder.method(method, progressRequestBody).build();\n        } else {\n            request = reqBuilder.method(method, reqBody).build();\n        }\n\n        return request;\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-1488-Param-1",
    "old_comment_raw": "@param matches the number of matches expected to be found.  0 matches means that one or more matches are expected to be found",
    "old_code_raw": "\tpublic boolean searchText(String regex, int matches, boolean scroll) {\n\t\treturn searcher.searchWithTimeoutFor(TextView.class, regex, matches, scroll);\n\t}\n",
    "new_code_raw": "\tpublic boolean searchText(String regex, int expectedMinimumNumberOfMatches, boolean scroll) {\n\t\treturn searcher.searchWithTimeoutFor(TextView.class, regex, expectedMinimumNumberOfMatches, scroll);\n\t}\n"
  },
  {
    "id": "apache_flume-3-Param-1",
    "old_comment_raw": "@param ctx",
    "old_code_raw": "  static EventSource buildEventSource(CommonTree t) throws FlumeSpecException {\n    ASTNODE type = ASTNODE.valueOf(t.getText()); // convert to enum\n    switch (type) {\n    case SOURCE: {\n      // TODO thread context through sources\n      // Context ctx = new Context(context);\n      Context ctx = new Context();\n      Pair<String, List<String>> idArgs = handleArgs(t, ctx);\n      String sourceType = idArgs.getLeft();\n      List<String> args = idArgs.getRight();\n\n      EventSource src = srcFactory.getSource(sourceType, args\n          .toArray(new String[0]));\n      if (src == null) {\n        throw new FlumeIdException(\"Invalid source: \"\n            + FlumeSpecGen.genEventSource(t));\n      }\n      return src;\n    }\n    default:\n      throw new FlumeSpecException(\"bad parse tree! Expected source but got \"\n          + t.toStringTree());\n    }\n  }\n",
    "new_code_raw": "  static EventSource buildEventSource(Context context, CommonTree t)\n      throws FlumeSpecException {\n    ASTNODE type = ASTNODE.valueOf(t.getText()); // convert to enum\n    switch (type) {\n    case SOURCE: {\n      Context ctx = new Context(context);\n      Pair<String, List<String>> idArgs = handleArgs(t, ctx);\n      String sourceType = idArgs.getLeft();\n      List<String> args = idArgs.getRight();\n\n      EventSource src = srcFactory.getSource(ctx, sourceType, args\n          .toArray(new String[0]));\n      if (src == null) {\n        throw new FlumeIdException(\"Invalid source: \"\n            + FlumeSpecGen.genEventSource(t));\n      }\n      return src;\n    }\n    default:\n      throw new FlumeSpecException(\"bad parse tree! Expected source but got \"\n          + t.toStringTree());\n    }\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1673-Param-0",
    "old_comment_raw": "@param body Input composite as post body",
    "old_code_raw": "    public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws RestClientException {\n        Object postBody = body;\n        \n        String path = UriComponentsBuilder.fromPath(\"/fake/outer/composite\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<OuterComposite> returnType = new ParameterizedTypeReference<OuterComposite>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n",
    "new_code_raw": "    public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws RestClientException {\n        Object postBody = outerComposite;\n        \n        String path = UriComponentsBuilder.fromPath(\"/fake/outer/composite\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"*/*\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<OuterComposite> returnType = new ParameterizedTypeReference<OuterComposite>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n"
  },
  {
    "id": "Atmosphere_atmosphere-30-Param-0",
    "old_comment_raw": "@param o the message to broadcast.",
    "old_code_raw": "    public BroadcastAction filter(Object o) {\n        if (o instanceof String){\n            String message = (String)o;\n            try {\n                // Avoid re-broadcasting\n                if (!receivedMessages.remove(message)) {\n                    publisher.send(session.createTextMessage(message));\n                }\n            } catch (JMSException ex) {\n                logger.log(Level.WARNING, \"\", ex);\n            }\n            return new BroadcastAction(message);\n        } else {\n            return new BroadcastAction(o);\n        }\n    }\n",
    "new_code_raw": "    public BroadcastAction filter(Object originalMessage, Object o) {\n        if (o instanceof String){\n            String message = (String)o;\n            try {\n                // Avoid re-broadcasting\n                if (!receivedMessages.remove(message)) {\n                    publisher.send(session.createTextMessage(message));\n                }\n            } catch (JMSException ex) {\n                logger.log(Level.WARNING, \"\", ex);\n            }\n            return new BroadcastAction(message);\n        } else {\n            return new BroadcastAction(o);\n        }\n    }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1653-Param-0",
    "old_comment_raw": "@param body client model (required)",
    "old_code_raw": "  public Client testSpecialTags(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling testSpecialTags\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/another-fake/dummy\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public Client testSpecialTags(Client client) throws ApiException {\n    Object localVarPostBody = client;\n    \n    // verify the required parameter 'client' is set\n    if (client == null) {\n      throw new ApiException(400, \"Missing the required parameter 'client' when calling testSpecialTags\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/another-fake/dummy\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-183-Param-4",
    "old_comment_raw": "@param headerParams The header parameters",
    "old_code_raw": "  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n",
    "new_code_raw": "  public String invokeAPI(String path, String method, Set<QueryParam> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (QueryParam queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          // e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1663-Param-0",
    "old_comment_raw": "@param body client model (required)",
    "old_code_raw": "    public Client testClassname(Client body) throws ApiException {\n        ApiResponse<Client> resp = testClassnameWithHttpInfo(body);\n        return resp.getData();\n    }\n",
    "new_code_raw": "    public Client testClassname(Client client) throws ApiException {\n        ApiResponse<Client> resp = testClassnameWithHttpInfo(client);\n        return resp.getData();\n    }\n"
  },
  {
    "id": "dropwizard_dropwizard-199-Param-0",
    "old_comment_raw": "@param sessionFactories",
    "old_code_raw": "    public UnitOfWorkAspect newAspect(ImmutableMap<String, SessionFactory> sessionFactories) {\n        return new UnitOfWorkAspect(sessionFactories);\n    }\n",
    "new_code_raw": "    public UnitOfWorkAspect newAspect(Map<String, SessionFactory> sessionFactories) {\n        return new UnitOfWorkAspect(sessionFactories);\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-424-Param-0",
    "old_comment_raw": "@param millis milliseconds from 1970-01-01T00:00:00Z to get the name for",
    "old_code_raw": "    public String getName(long millis, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(millis);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return offsetFormatter().print(millis, this);\n    }\n",
    "new_code_raw": "    public String getName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return offsetFormatter().print(instant, this);\n    }\n"
  },
  {
    "id": "apache_calcite-843-Param-0",
    "old_comment_raw": "@param hosts list of ES HTTP Hosts to connect to",
    "old_code_raw": "  private static RestClient connect(List<HttpHost> hosts) {\n\n    Objects.requireNonNull(hosts, \"hosts or coordinates\");\n    Preconditions.checkArgument(!hosts.isEmpty(), \"no ES hosts specified\");\n\n    return RestClient.builder(hosts.toArray(new HttpHost[hosts.size()])).build();\n  }\n",
    "new_code_raw": "  private static RestClient connect(List<HttpHost> hosts, String pathPrefix) {\n\n    Objects.requireNonNull(hosts, \"hosts or coordinates\");\n    Preconditions.checkArgument(!hosts.isEmpty(), \"no ES hosts specified\");\n\n    RestClientBuilder builder = RestClient.builder(hosts.toArray(new HttpHost[hosts.size()]));\n    if (pathPrefix != null && !pathPrefix.isEmpty()) {\n      builder.setPathPrefix(pathPrefix);\n    }\n    return builder.build();\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1634-Param-0",
    "old_comment_raw": "@param body Pet object that needs to be added to the store",
    "old_code_raw": "  public void updatePet (Pet body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = body;\n    // verify the required parameter 'body' is set\n    if (body == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'body' when calling updatePet\",\n        new ApiException(400, \"Missing the required parameter 'body' when calling updatePet\"));\n    }\n\n    // create path and map variables\n    String path = \"/pet\";\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n      \"application/json\",\n      \"application/xml\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n    }\n\n    String[] authNames = new String[] { \"petstore_auth\" };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"PUT\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n",
    "new_code_raw": "  public void updatePet (Pet pet) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = pet;\n    // verify the required parameter 'pet' is set\n    if (pet == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'pet' when calling updatePet\",\n        new ApiException(400, \"Missing the required parameter 'pet' when calling updatePet\"));\n    }\n\n    // create path and map variables\n    String path = \"/pet\";\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n    }\n\n    String[] authNames = new String[] { \"petstore_auth\" };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"PUT\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1975-Param-0",
    "old_comment_raw": "@param SDOElements",
    "old_code_raw": "\tpublic static SDOGeometry join(SDOGeometry[] SDOElements) {\n\t\tSDOGeometry SDOCollection = new SDOGeometry();\n\t\tif ( SDOElements == null || SDOElements.length == 0 ) {\n\t\t\tSDOCollection.setGType(\n\t\t\t\t\tnew SDOGType(\n\t\t\t\t\t\t\t2, 0,\n\t\t\t\t\t\t\tTypeGeometry.COLLECTION\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tSDOGeometry firstElement = SDOElements[0];\n\t\t\tint dim = firstElement.getGType().getDimension();\n\t\t\tint lrsDim = firstElement.getGType().getLRSDimension();\n\t\t\tSDOCollection.setGType(\n\t\t\t\t\tnew SDOGType(\n\t\t\t\t\t\t\tdim, lrsDim,\n\t\t\t\t\t\t\tTypeGeometry.COLLECTION\n\t\t\t\t\t)\n\t\t\t);\n\t\t\tint ordinatesOffset = 1;\n\t\t\tfor ( int i = 0; i < SDOElements.length; i++ ) {\n\t\t\t\tElemInfo element = SDOElements[i].getInfo();\n\t\t\t\tDouble[] ordinates = SDOElements[i].getOrdinates()\n\t\t\t\t\t\t.getOrdinateArray();\n\t\t\t\tif ( element != null && element.getSize() > 0 ) {\n\t\t\t\t\tint shift = ordinatesOffset\n\t\t\t\t\t\t\t- element.getOrdinatesOffset( 0 );\n\t\t\t\t\tshiftOrdinateOffset( element, shift );\n\t\t\t\t\tSDOCollection.addElement( element );\n\t\t\t\t\tSDOCollection.addOrdinates( ordinates );\n\t\t\t\t\tordinatesOffset += ordinates.length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn SDOCollection;\n\t}\n",
    "new_code_raw": "\tpublic static SDOGeometry join(SDOGeometry[] sdoElements) {\n\t\tfinal SDOGeometry sdoCollection = new SDOGeometry();\n\t\tif ( sdoElements == null || sdoElements.length == 0 ) {\n\t\t\tsdoCollection.setGType( new SDOGType( 2, 0, TypeGeometry.COLLECTION ) );\n\t\t}\n\t\telse {\n\t\t\tfinal SDOGeometry firstElement = sdoElements[0];\n\t\t\tfinal int dim = firstElement.getGType().getDimension();\n\t\t\tfinal int lrsDim = firstElement.getGType().getLRSDimension();\n\t\t\tsdoCollection.setGType( new SDOGType( dim, lrsDim, TypeGeometry.COLLECTION ) );\n\t\t\tint ordinatesOffset = 1;\n\t\t\tfor ( int i = 0; i < sdoElements.length; i++ ) {\n\t\t\t\tfinal ElemInfo element = sdoElements[i].getInfo();\n\t\t\t\tfinal Double[] ordinates = sdoElements[i].getOrdinates().getOrdinateArray();\n\t\t\t\tif ( element != null && element.getSize() > 0 ) {\n\t\t\t\t\tfinal int shift = ordinatesOffset - element.getOrdinatesOffset( 0 );\n\t\t\t\t\tshiftOrdinateOffset( element, shift );\n\t\t\t\t\tsdoCollection.addElement( element );\n\t\t\t\t\tsdoCollection.addOrdinates( ordinates );\n\t\t\t\t\tordinatesOffset += ordinates.length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sdoCollection;\n\t}\n"
  },
  {
    "id": "zaproxy_zaproxy-2307-Param-1",
    "old_comment_raw": "@param param",
    "old_code_raw": "    protected String setEscapedParameter(HttpMessage msg, String param, String value) {\n        return variant.setEscapedParameter(msg, originalPair, param, value);\n    }\n",
    "new_code_raw": "    protected String setEscapedParameter(HttpMessage message, String param, String value) {\n        return variant.setEscapedParameter(message, originalPair, param, value);\n    }\n"
  },
  {
    "id": "justinedelson_felix-211-Associations-Param1",
    "old_comment_raw": "@param trackClass the class name with which the service was registered, or null for all services.",
    "old_code_raw": "\tprivate ServiceReference[] getInitialReferences(boolean trackAllServices,\n\t\t\tString trackClass, String filterString)\n\t\t\tthrows InvalidSyntaxException {\n\t\tif (trackAllServices) {\n\t\t\treturn context.getAllServiceReferences(trackClass, filterString);\n\t\t}\n\t\telse {\n\t\t\treturn context.getServiceReferences(trackClass, filterString);\n\t\t}\n\t}\n",
    "new_code_raw": "\tprivate ServiceReference[] getInitialReferences(boolean trackAllServices,\n\t\t\tString className, String filterString)\n\t\t\tthrows InvalidSyntaxException {\n\t\tif (trackAllServices) {\n\t\t\treturn context.getAllServiceReferences(className, filterString);\n\t\t}\n\t\treturn context.getServiceReferences(className, filterString);\n\t}\n\n"
  },
  {
    "id": "JodaOrg_joda_time-1146-Param-0",
    "old_comment_raw": "@param instant a readable instant to check against",
    "old_code_raw": "    public int compareTo(Object instant) {\n        if (this == instant) {\n            return 0;\n        }\n        \n        ReadableInstant otherInstant = (ReadableInstant) instant;\n        \n        long otherMillis = otherInstant.getMillis();\n        long thisMillis = getMillis();\n        \n        // cannot do (thisMillis - otherMillis) as can overflow\n        if (thisMillis == otherMillis) {\n            return 0;\n        }\n        if (thisMillis < otherMillis) {\n            return -1;\n        } else {\n            return 1;\n        }\n    }\n",
    "new_code_raw": "    public int compareTo(ReadableInstant other) {\n        if (this == other) {\n            return 0;\n        }\n        \n        long otherMillis = other.getMillis();\n        long thisMillis = getMillis();\n        \n        // cannot do (thisMillis - otherMillis) as can overflow\n        if (thisMillis == otherMillis) {\n            return 0;\n        }\n        if (thisMillis < otherMillis) {\n            return -1;\n        } else {\n            return 1;\n        }\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-57-Associations-Param1",
    "old_comment_raw": "@param expectedMinimumNumberOfMatches the minimum number of matches of text that must be shown.  0 means any number of matches",
    "old_code_raw": "\t\n\tpublic boolean waitForText(String text, int expectedMinimumNumberOfMatches, long timeout, boolean scroll) {\n\t\treturn robotiumUtils.waitForText(text, expectedMinimumNumberOfMatches, timeout, scroll);\n    }\n",
    "new_code_raw": "\t\n\tpublic boolean waitForText(String text, int minimumNumberOfMatches, long timeout, boolean scroll) {\n\t\treturn robotiumUtils.waitForText(text, minimumNumberOfMatches, timeout, scroll);\n    }\n\n"
  },
  {
    "id": "SeleniumHQ_selenium-861-Param-1",
    "old_comment_raw": "@param browserURL - the start URL for the browser",
    "old_code_raw": "  private URL determineSuiteUrl(String browserUrl, String suiteURL) throws IOException {\n    if (suiteURL.startsWith(\"https://\") || suiteURL.startsWith(\"http://\")) {\n      return verifySuiteUrl(new URL(suiteURL));\n    }\n\n    // Is the suiteURL a file?\n    Path path = Paths.get(suiteURL);\n    if (Files.exists(path)) {\n      // Not all drivers can read files from the disk, so we need to host the suite somewhere.\n      try (SocketLock lock = new SocketLock()) {\n        server = new Server();\n        HttpConfiguration httpConfig = new HttpConfiguration();\n\n        ServerConnector http = new ServerConnector(server, new HttpConnectionFactory(httpConfig));\n        int port = PortProber.findFreePort();\n        http.setPort(port);\n        http.setIdleTimeout(500000);\n        server.setConnectors(new Connector[]{http});\n\n        ResourceHandler handler = new ResourceHandler();\n        handler.setDirectoriesListed(true);\n        handler.setWelcomeFiles(new String[]{path.getFileName().toString(), \"index.html\"});\n        handler.setBaseResource(new PathResource(path.toFile().getParentFile().toPath().toRealPath()));\n\n        ContextHandler context = new ContextHandler(\"/tests\");\n        context.setHandler(handler);\n\n        server.setHandler(context);\n        server.start();\n\n        PortProber.waitForPortUp(port, 15, SECONDS);\n\n        URL serverUrl = server.getURI().toURL();\n        return new URL(serverUrl.getProtocol(), serverUrl.getHost(), serverUrl.getPort(),\n                       \"/tests/\");\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n\n    // Well then, it must be a URL relative to whatever the browserUrl. Probe and find out.\n    URL browser = new URL(browserUrl);\n    return verifySuiteUrl(new URL(browser, suiteURL));\n  }\n",
    "new_code_raw": "  private URL determineSuiteUrl(String startURL, String suiteURL) throws IOException {\n    if (suiteURL.startsWith(\"https://\") || suiteURL.startsWith(\"http://\")) {\n      return verifySuiteUrl(new URL(suiteURL));\n    }\n\n    // Is the suiteURL a file?\n    Path path = Paths.get(suiteURL);\n    if (Files.exists(path)) {\n      // Not all drivers can read files from the disk, so we need to host the suite somewhere.\n      try (SocketLock lock = new SocketLock()) {\n        server = new Server();\n        HttpConfiguration httpConfig = new HttpConfiguration();\n\n        ServerConnector http = new ServerConnector(server, new HttpConnectionFactory(httpConfig));\n        int port = PortProber.findFreePort();\n        http.setPort(port);\n        http.setIdleTimeout(500000);\n        server.setConnectors(new Connector[]{http});\n\n        ResourceHandler handler = new ResourceHandler();\n        handler.setDirectoriesListed(true);\n        handler.setWelcomeFiles(new String[]{path.getFileName().toString(), \"index.html\"});\n        handler.setBaseResource(new PathResource(path.toFile().getParentFile().toPath().toRealPath()));\n\n        ContextHandler context = new ContextHandler(\"/tests\");\n        context.setHandler(handler);\n\n        server.setHandler(context);\n        server.start();\n\n        PortProber.waitForPortUp(port, 15, SECONDS);\n\n        URL serverUrl = server.getURI().toURL();\n        return new URL(serverUrl.getProtocol(), serverUrl.getHost(), serverUrl.getPort(),\n                       \"/tests/\");\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n\n    // Well then, it must be a URL relative to whatever the browserUrl. Probe and find out.\n    URL browser = new URL(startURL);\n    return verifySuiteUrl(new URL(browser, suiteURL));\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-2578-Param-0",
    "old_comment_raw": "@param body Input composite as post body (optional)",
    "old_code_raw": "  public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws ApiException {\n    return fakeOuterCompositeSerializeWithHttpInfo(body).getData();\n      }\n",
    "new_code_raw": "  public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws ApiException {\n    return fakeOuterCompositeSerializeWithHttpInfo(outerComposite).getData();\n      }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1665-Param-0",
    "old_comment_raw": "@param body client model (required)",
    "old_code_raw": "  public Client testSpecialTags(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling testSpecialTags\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/another-fake/dummy\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n",
    "new_code_raw": "  public Client testSpecialTags(Client client) throws ApiException {\n    Object localVarPostBody = client;\n    \n    // verify the required parameter 'client' is set\n    if (client == null) {\n      throw new ApiException(400, \"Missing the required parameter 'client' when calling testSpecialTags\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/another-fake/dummy\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n"
  },
  {
    "id": "JodaOrg_joda_time-434-Param-0",
    "old_comment_raw": "@param millis the time instant in millis to update.",
    "old_code_raw": "    public long add(long millis, int years) {\n        if (years == 0) {\n            return millis;\n        }\n        return set(millis, get(millis) + years);\n    }\n",
    "new_code_raw": "    public long add(long instant, int years) {\n        if (years == 0) {\n            return instant;\n        }\n        return set(instant, get(instant) + years);\n    }\n"
  },
  {
    "id": "processing_processing-263-Param-0",
    "old_comment_raw": "@param editor",
    "old_code_raw": "  public boolean highlightNode(JavaEditor editor){\n    if (!(node instanceof SimpleName)) {\n      return false;\n    }\n    SimpleName nodeName = (SimpleName) node;\n    try {\n      //TODO: Redundant code. See ASTGenerator.getJavaSourceCodeline()\n      int javaLineNumber = getLineNumber(nodeName);\n      int pdeOffs[] = editor.getErrorChecker().calculateTabIndexAndLineNumber(javaLineNumber);\n      PlainDocument javaSource = new PlainDocument();\n      javaSource.insertString(0, editor.getErrorChecker().lastCodeCheckResult.sourceCode, null);\n      Element lineElement = javaSource.getDefaultRootElement()\n          .getElement(javaLineNumber-1);\n      if(lineElement == null) {\n        Messages.log(lineNumber + \" line element null while highlighting \" + nodeName);\n        return false;\n      }\n\n      String javaLine = javaSource.getText(lineElement.getStartOffset(),\n                                           lineElement.getEndOffset()\n                                               - lineElement.getStartOffset());\n      editor.getSketch().setCurrentCode(pdeOffs[0]);\n      String pdeLine = editor.getLineText(pdeOffs[1]);\n      String lookingFor = nodeName.toString();\n      Messages.log(lookingFor + \", \" + nodeName.getStartPosition());\n      Messages.log(javaLineNumber +\" JL \" + javaLine + \" LSO \" + lineElement.getStartOffset() + \",\"\n          + lineElement.getEndOffset());\n      Messages.log(pdeOffs[1] + \" PL \" + pdeLine);\n      if (!javaLine.contains(lookingFor) || !pdeLine.contains(lookingFor)) {\n        Messages.loge(\"Logical error in highLightNode(). Please file a bug report.\");\n        return false;\n      }\n\n      OffsetMatcher ofm = new OffsetMatcher(pdeLine, javaLine);\n      int highlightStart = ofm.getPdeOffForJavaOff(nodeName.getStartPosition()\n                                  - lineElement.getStartOffset(),\n                              nodeName.getLength());\n      if (highlightStart == -1) {\n        Messages.loge(\"Logical error in highLightNode() during offset matching. \" +\n        \t\t\"Please file a bug report.\");\n        return false;\n      }\n      int lso = editor.getTextArea().getLineStartOffset(pdeOffs[1]);\n      highlightStart += lso;\n      editor.setSelection(highlightStart, highlightStart\n          + nodeName.getLength());\n      /*\n      // First find the name in the java line, and marks its index\n      Pattern toFind = Pattern.compile(\"\\\\b\" + nodeName.toString() + \"\\\\b\");\n      Matcher matcher = toFind.matcher(javaLine);\n      int count = 0, index = 0;\n      int lsto = lineElement.getStartOffset();\n      while(matcher.find()){\n        count++;\n        //log(matcher.start() + lsto);\n        if(lsto + matcher.start() == nodeName.getStartPosition())\n          break;\n      }\n      log(\"count=\" + count);\n      index = 0;\n      // find the same name in the pde line by its index and get its offsets\n      matcher = toFind.matcher(pdeLine);\n      while(matcher.find()){\n        count--;\n        if(count == 0){\n          log(\"Found on pde line lso: \" + matcher.start());\n          index = matcher.end();\n          break;\n        }\n      }\n      log(\"pde lso \" + (index - lookingFor.length()));\n\n      int lso = astGenerator.editor.ta.getLineStartOffset(pdeOffs[1]);\n      astGenerator.editor.setSelection(lso + index - lookingFor.length(), lso\n          + index);\n      */\n      return true;\n\n    } catch (BadLocationException e) {\n      Messages.loge(\"BLE in highLightNode() for \" + nodeName);\n      e.printStackTrace();\n    }\n    return false;\n  }\n",
    "new_code_raw": "  public boolean highlightNode(ASTGenerator astGenerator){\n    if (!(Node instanceof SimpleName)) {\n      return false;\n    }\n    SimpleName nodeName = (SimpleName) Node;\n    try {\n      //TODO: Redundant code. See ASTGenerator.getJavaSourceCodeline()\n      int javaLineNumber = getLineNumber(nodeName);\n      int pdeOffs[] = astGenerator.errorCheckerService\n          .calculateTabIndexAndLineNumber(javaLineNumber);\n      PlainDocument javaSource = new PlainDocument();\n      javaSource.insertString(0, astGenerator.errorCheckerService.sourceCode, null);\n      Element lineElement = javaSource.getDefaultRootElement()\n          .getElement(javaLineNumber-1);\n      if(lineElement == null) {\n        Messages.log(lineNumber + \" line element null while highlighting \" + nodeName);\n        return false;\n      }\n\n      String javaLine = javaSource.getText(lineElement.getStartOffset(),\n                                           lineElement.getEndOffset()\n                                               - lineElement.getStartOffset());\n      astGenerator.editor.getSketch().setCurrentCode(pdeOffs[0]);\n      String pdeLine = astGenerator.editor.getLineText(pdeOffs[1]);\n      String lookingFor = nodeName.toString();\n      Messages.log(lookingFor + \", \" + nodeName.getStartPosition());\n      Messages.log(javaLineNumber +\" JL \" + javaLine + \" LSO \" + lineElement.getStartOffset() + \",\"\n          + lineElement.getEndOffset());\n      Messages.log(pdeOffs[1] + \" PL \" + pdeLine);\n      if (!javaLine.contains(lookingFor) || !pdeLine.contains(lookingFor)) {\n        Messages.loge(\"Logical error in highLightNode(). Please file a bug report.\");\n        return false;\n      }\n\n      OffsetMatcher ofm = new OffsetMatcher(pdeLine, javaLine);\n      int highlightStart = ofm.getPdeOffForJavaOff(nodeName.getStartPosition()\n                                  - lineElement.getStartOffset(),\n                              nodeName.getLength());\n      if (highlightStart == -1) {\n        Messages.loge(\"Logical error in highLightNode() during offset matching. \" +\n        \t\t\"Please file a bug report.\");\n        return false;\n      }\n      int lso = astGenerator.editor.getTextArea().getLineStartOffset(pdeOffs[1]);\n      highlightStart += lso;\n      astGenerator.editor.setSelection(highlightStart, highlightStart\n          + nodeName.getLength());\n      /*\n      // First find the name in the java line, and marks its index\n      Pattern toFind = Pattern.compile(\"\\\\b\" + nodeName.toString() + \"\\\\b\");\n      Matcher matcher = toFind.matcher(javaLine);\n      int count = 0, index = 0;\n      int lsto = lineElement.getStartOffset();\n      while(matcher.find()){\n        count++;\n        //log(matcher.start() + lsto);\n        if(lsto + matcher.start() == nodeName.getStartPosition())\n          break;\n      }\n      log(\"count=\" + count);\n      index = 0;\n      // find the same name in the pde line by its index and get its offsets\n      matcher = toFind.matcher(pdeLine);\n      while(matcher.find()){\n        count--;\n        if(count == 0){\n          log(\"Found on pde line lso: \" + matcher.start());\n          index = matcher.end();\n          break;\n        }\n      }\n      log(\"pde lso \" + (index - lookingFor.length()));\n\n      int lso = astGenerator.editor.ta.getLineStartOffset(pdeOffs[1]);\n      astGenerator.editor.setSelection(lso + index - lookingFor.length(), lso\n          + index);\n      */\n      return true;\n\n    } catch (BadLocationException e) {\n      Messages.loge(\"BLE in highLightNode() for \" + nodeName);\n      e.printStackTrace();\n    }\n    return false;\n  }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1638-Param-0",
    "old_comment_raw": "@param body List of user object",
    "old_code_raw": "  public void createUsersWithListInput (List<User> body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = body;\n    // verify the required parameter 'body' is set\n    if (body == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'body' when calling createUsersWithListInput\",\n        new ApiException(400, \"Missing the required parameter 'body' when calling createUsersWithListInput\"));\n    }\n\n    // create path and map variables\n    String path = \"/user/createWithList\";\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n    }\n\n    String[] authNames = new String[] {  };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n",
    "new_code_raw": "  public void createUsersWithListInput (List<User> user) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = user;\n    // verify the required parameter 'user' is set\n    if (user == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'user' when calling createUsersWithListInput\",\n        new ApiException(400, \"Missing the required parameter 'user' when calling createUsersWithListInput\"));\n    }\n\n    // create path and map variables\n    String path = \"/user/createWithList\";\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n    }\n\n    String[] authNames = new String[] {  };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n"
  },
  {
    "id": "briancavalier_iterate-3-Associations-Param0",
    "old_comment_raw": "@param predicate  Visitor to apply",
    "old_code_raw": "    public <P extends Visitor<? super X>> P visit(P predicate)\n    {\n        for (X x : this) {\n            predicate.visit(x);\n        }\n\n        return predicate;\n    }\n",
    "new_code_raw": "    public <V extends Visitor<? super X>> V visit(V visitor)\n    {\n        for (X x : this) {\n            visitor.visit(x);\n        }\n\n        return visitor;\n    }\n\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1678-Param-0",
    "old_comment_raw": "@param body order placed for purchasing the pet (required)",
    "old_code_raw": "    public Single<Order> rxPlaceOrder(Order body) {\n        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {\n            delegate.placeOrder(body, fut);\n        }));\n    }\n",
    "new_code_raw": "    public Single<Order> rxPlaceOrder(Order order) {\n        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {\n            delegate.placeOrder(order, fut);\n        }));\n    }\n"
  },
  {
    "id": "apache_calcite-903-Param-0",
    "old_comment_raw": "@param coordinates list of  hostname/port to connect to",
    "old_code_raw": "  private static RestClient connect(Map<String, Integer> coordinates) {\n    Objects.requireNonNull(coordinates, \"coordinates\");\n    Preconditions.checkArgument(!coordinates.isEmpty(), \"no ES coordinates specified\");\n    final Set<HttpHost> set = new LinkedHashSet<>();\n    for (Map.Entry<String, Integer> entry: coordinates.entrySet()) {\n      set.add(new HttpHost(entry.getKey(), entry.getValue()));\n    }\n\n    return RestClient.builder(set.toArray(new HttpHost[0])).build();\n  }\n",
    "new_code_raw": "  private static RestClient connect(List<HttpHost> hosts) {\n\n    Objects.requireNonNull(hosts, \"hosts or coordinates\");\n    Preconditions.checkArgument(!hosts.isEmpty(), \"no ES hosts specified\");\n\n    return RestClient.builder(hosts.toArray(new HttpHost[hosts.size()])).build();\n  }\n"
  },
  {
    "id": "hibernate_hibernate_orm-1477-Param-1",
    "old_comment_raw": "@param concurrencyStrategy",
    "old_code_raw": "\tpublic Configuration setCacheConcurrencyStrategy(String clazz, String concurrencyStrategy)\n\t\t\tthrows MappingException {\n\t\tsetCacheConcurrencyStrategy( clazz, concurrencyStrategy, clazz );\n\t\treturn this;\n\t}\n",
    "new_code_raw": "\tpublic Configuration setCacheConcurrencyStrategy(String entityName, String concurrencyStrategy) {\n\t\tsetCacheConcurrencyStrategy( entityName, concurrencyStrategy, entityName );\n\t\treturn this;\n\t}\n"
  },
  {
    "id": "Atmosphere_atmosphere-821-Param-0",
    "old_comment_raw": "@param request  javax.servlet.http.HttpServletRequest",
    "old_code_raw": "    protected BroadcastAction filter(HttpServletRequest request, HttpServletResponse response, Object object) {\n        BroadcastAction transformed = new BroadcastAction(object);\n        for (PerRequestBroadcastFilter mf : perRequestFilters) {\n            synchronized (mf) {\n                transformed = mf.filter(request, response, transformed.message());\n                if (transformed == null || transformed.action() == BroadcastAction.ACTION.ABORT) {\n                    return transformed;\n                }\n            }\n        }\n        return transformed;\n    }\n",
    "new_code_raw": "    protected BroadcastAction filter(AtmosphereResource<?,?> r, Object message, Object originalMessage) {\n        BroadcastAction transformed = new BroadcastAction(originalMessage);\n        for (PerRequestBroadcastFilter mf : perRequestFilters) {\n            synchronized (mf) {\n                transformed = mf.filter(r, message, transformed.message());\n                if (transformed == null || transformed.action() == BroadcastAction.ACTION.ABORT) {\n                    return transformed;\n                }\n            }\n        }\n        return transformed;\n    }\n"
  },
  {
    "id": "apache_activemq-1304-Param-0",
    "old_comment_raw": "@param fullDestinationName the full name of the JMS Destination",
    "old_code_raw": "    public int getMessageCount(String fullDestinationName) throws Exception {\n        final int QUEUE_TYPE = 1;\n        final int TOPIC_TYPE = 2;\n\n        if (null == brokerService) {\n            throw new IllegalStateException(\"BrokerService has not yet been created - was before() called?\");\n        }\n\n        int destinationType = QUEUE_TYPE;\n        String destinationName = fullDestinationName;\n\n        if (fullDestinationName.startsWith(\"queue:\")) {\n            destinationName = fullDestinationName.substring(fullDestinationName.indexOf(':') + 1);\n        } else if (fullDestinationName.startsWith(\"topic:\")) {\n            destinationType = TOPIC_TYPE;\n            destinationName = fullDestinationName.substring(fullDestinationName.indexOf(':') + 1);\n        }\n\n        int messageCount = -1;\n        boolean foundDestination = false;\n        for (Destination destination : brokerService.getBroker().getDestinationMap().values()) {\n            String tmpName = destination.getName();\n            if (tmpName.equalsIgnoreCase(destinationName)) {\n                switch (destinationType) {\n                    case QUEUE_TYPE:\n                        if (destination instanceof Queue) {\n                            messageCount = destination.getMessageStore().getMessageCount();\n                            foundDestination = true;\n                        }\n                        break;\n                    case TOPIC_TYPE:\n                        if (destination instanceof Topic) {\n                            messageCount = destination.getMessageStore().getMessageCount();\n                            foundDestination = true;\n                        }\n                        break;\n                    default:\n                        // Should never see this\n                        log.error(\"Type didn't match: {}\", destination.getClass().getName());\n                }\n            }\n            if (foundDestination) {\n                break;\n            }\n        }\n\n        if (!foundDestination) {\n            log.warn(\"Didn't find destination {} in broker {}\", fullDestinationName, getBrokerName());\n        }\n\n        return messageCount;\n    }\n",
    "new_code_raw": "    public long getMessageCount(String destinationName) {\n        if (null == brokerService) {\n            throw new IllegalStateException(\"BrokerService has not yet been created - was before() called?\");\n        }\n\n        // TODO: Figure out how to do this for Topics\n        Destination destination = getDestination(destinationName);\n        if (destination == null) {\n            throw new RuntimeException(\"Failed to find destination: \" + destinationName);\n        }\n\n        // return destination.getMessageStore().getMessageCount();\n        return destination.getDestinationStatistics().getMessages().getCount();\n    }\n"
  },
  {
    "id": "Atmosphere_atmosphere-858-Param-0",
    "old_comment_raw": "@param o the message to broadcast.",
    "old_code_raw": "    public BroadcastAction filter(Object originalMessage, Object o) {\n        if (o instanceof String){\n            String message = (String)o;\n            // Avoid re-broadcasting\n            if (!receivedMessages.remove(message)) {\n                try {\n                    jchannel.send(new Message(null, null, message));\n                } catch (ChannelException e) {\n                    logger.warn(\"failed to send message\", e);\n                }\n            }\n            return new BroadcastAction(message);\n        } else {\n            return new BroadcastAction(o);\n        }\n    }\n",
    "new_code_raw": "    public BroadcastAction filter(Object originalMessage, Object message) {\n        // Avoid re-broadcasting\n        if (!receivedMessages.remove(message)) {\n            try {\n                jchannel.send(new Message(null, null, (Serializable)message));\n            } catch (ChannelException e) {\n                logger.warn(\"failed to send message\", e);\n            }\n        }\n        return new BroadcastAction(message);\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-1007-Param-1",
    "old_comment_raw": "@param expectedMinimumNumberOfMatches the minimum number of matches expected to be found.  0 matches means that one or more matches are expected to be found",
    "old_code_raw": "\tpublic boolean searchText(String regex, int expectedMinimumNumberOfMatches) {\n\t\tboolean found = searcher.searchWithTimeoutFor(TextView.class, regex, expectedMinimumNumberOfMatches, true);\n\t\treturn found;\n\t}\n",
    "new_code_raw": "\tpublic boolean searchText(String text, int minimumNumberOfMatches) {\n\t\tboolean found = searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, true);\n\t\treturn found;\n\t}\n"
  },
  {
    "id": "SeleniumHQ_selenium-837-Param-1",
    "old_comment_raw": "@param sub_locator used to find child element. For example td By.xpath(\"./tr/td\")",
    "old_code_raw": "      public List<WebElement> apply(WebDriver webDriver) {\n        Boolean displayed = false;\n        Boolean exists = false;\n        try {\n          exists = findElement(locator, webDriver).findElements(sub_locator).size() > 0;\n          displayed =\n            findElement(locator, webDriver).findElement(sub_locator).isDisplayed();\n        } catch (Exception e) {\n          int i = 0;\n        }\n        return (exists && displayed) ?\n               findElement(locator, webDriver).findElements(sub_locator) :\n               null;\n      }\n",
    "new_code_raw": "      public List<WebElement> apply(WebDriver driver) {\n        WebElement current = findElement(parent, driver);\n\n        List<WebElement> allChildren = current.findElements(childLocator);\n        // The original code only checked the first element. Fair enough.\n        if (!allChildren.isEmpty() && allChildren.get(0).isDisplayed()) {\n          return allChildren;\n        }\n\n        return null;\n      }\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1679-Param-1",
    "old_comment_raw": "@param body Updated user object (required)",
    "old_code_raw": "    public Single<Void> rxUpdateUser(String username, User body) {\n        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {\n            delegate.updateUser(username, body, fut);\n        }));\n    }\n",
    "new_code_raw": "    public Single<Void> rxUpdateUser(String username, User user) {\n        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {\n            delegate.updateUser(username, user, fut);\n        }));\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-1003-Param-0",
    "old_comment_raw": "@param search the string to be searched. The parameter will be interpreted as a regular expression.",
    "old_code_raw": "\tpublic boolean searchText(String search, int matches, boolean scroll) {\n        long now = System.currentTimeMillis();\n        final long endTime = now + TIMEOUT;\n        while (!searchForText(search, matches, scroll) && now < endTime)\n        {\n        \tnow = System.currentTimeMillis();\n        }\n        if(now < endTime)\n        \treturn true;\n        else\n        \treturn false;\n\t}\n",
    "new_code_raw": "\tpublic boolean searchText(String regex, int matches, boolean scroll) {\n        long now = System.currentTimeMillis();\n        final long endTime = now + TIMEOUT;\n        while (!searchForText(regex, matches, scroll) && now < endTime)\n        {\n        \tnow = System.currentTimeMillis();\n        }\n        if(now < endTime)\n        \treturn true;\n        else\n        \treturn false;\n\t}\n"
  },
  {
    "id": "apache_kylin-526-Param-0",
    "old_comment_raw": "@param child an on-tree cuboid",
    "old_code_raw": "    public long findBestMatchCuboid(long child) {\n        long parent = getOnTreeParent(child);\n        while (parent > 0) {\n            if (cubeDesc.getAllCuboids().contains(parent)) {\n                break;\n            }\n            parent = getOnTreeParent(parent);\n        }\n\n        if (parent <= 0) {\n            throw new IllegalStateException(\"Can't find valid parent for Cuboid \" + child);\n        }\n        return parent;\n    }\n",
    "new_code_raw": "    public long findBestMatchCuboid(long cuboid) {\n        return findBestMatchCuboid1(cuboid);\n    }\n"
  },
  {
    "id": "JodaOrg_joda_time-452-Param-0",
    "old_comment_raw": "@param index the index to remove",
    "old_code_raw": "    public DurationConverter removeDurationConverter(int index) throws SecurityException {\n        checkAlterDurationConverters();\n        DurationConverter[] removed = new DurationConverter[1];\n        iDurationConverters = iDurationConverters.remove(index, removed);\n        return removed[0];\n    }\n",
    "new_code_raw": "    public DurationConverter removeDurationConverter(DurationConverter converter)\n            throws SecurityException {\n        \n        checkAlterDurationConverters();\n        if (converter == null) {\n            return null;\n        }\n        DurationConverter[] removed = new DurationConverter[1];\n        iDurationConverters = iDurationConverters.remove(converter, removed);\n        return removed[0];\n    }\n"
  },
  {
    "id": "hibernate_hibernate_orm-306-Param-1",
    "old_comment_raw": "@param opt any option to add to the get invocation. May be null",
    "old_code_raw": "   protected Object get(Object key, FlagAdapter opt, boolean suppressTimeout) throws CacheException {\n      if (suppressTimeout)\n         return cacheAdapter.getAllowingTimeout(key);\n      else\n         return cacheAdapter.get(key);\n   }\n",
    "new_code_raw": "   protected Object get(Object key, boolean suppressTimeout, FlagAdapter... flagAdapters) throws CacheException {\n      CacheAdapter localCacheAdapter = cacheAdapter;\n      if (flagAdapters != null && flagAdapters.length > 0)\n         localCacheAdapter = cacheAdapter.withFlags(flagAdapters);\n\n      if (suppressTimeout)\n         return localCacheAdapter.getAllowingTimeout(key);\n      else\n         return localCacheAdapter.get(key);\n   }\n"
  },
  {
    "id": "RobotiumTech_robotium-1483-Param-0",
    "old_comment_raw": "@param search the search string to be searched",
    "old_code_raw": "    public boolean searchForEditTextWithTimeout(String search) {\n        long now = System.currentTimeMillis();\n        final long endTime = now + TIMEOUT;\n\n\t\twhile (!searchForEditText(search, true) && now < endTime) {\n\t\t\tsleeper.sleep();\n\t\t\tnow = System.currentTimeMillis();\n        }\n\n\t\treturn searchForEditText(search, true);\n\t}\n",
    "new_code_raw": "    public boolean searchForEditTextWithTimeout(String regex) {\n        long now = System.currentTimeMillis();\n        final long endTime = now + TIMEOUT;\n\n\t\twhile (!searchForEditText(regex, true) && now < endTime) {\n\t\t\tsleeper.sleep();\n\t\t\tnow = System.currentTimeMillis();\n        }\n\n\t\treturn searchForEditText(regex, true);\n\t}\n"
  },
  {
    "id": "eclipse_reddeer-35-Associations-Param0",
    "old_comment_raw": "@param w given widget",
    "old_code_raw": "\tpublic boolean isSelected(final ToolItem w) {\n\t\tboolean selectionState = Display.syncExec(new ResultRunnable<Boolean>() {\n\t\t\t@Override\n\t\t\tpublic Boolean run() {\n\t\t\t\t\treturn w.getSelection(); \n\t\t\t}\n\t\t});\n\t\treturn selectionState;\n\t}\n",
    "new_code_raw": "\tpublic boolean isSelected(final ToolItem toolItem) {\n\t\tboolean selectionState = Display.syncExec(new ResultRunnable<Boolean>() {\n\t\t\t@Override\n\t\t\tpublic Boolean run() {\n\t\t\t\t\treturn toolItem.getSelection(); \n\t\t\t}\n\t\t});\n\t\treturn selectionState;\n\t}\n\n"
  },
  {
    "id": "RobotiumTech_robotium-1484-Param-0",
    "old_comment_raw": "@param search the search string to be searched. The parameter will be interpreted as a regular expression.",
    "old_code_raw": "\tpublic boolean searchForEditText(String search, boolean scroll) {\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(search);\n\t\tMatcher matcher;\n\t\tArrayList<EditText> editTextList = viewFetcher.getCurrentViews(EditText.class);\n\t\tfor(EditText editText : editTextList){\n\t\t\tmatcher = p.matcher(editText.getText().toString());\n\t\t\tif (matcher.find()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (scroll && scroller.scroll(Scroller.Direction.DOWN))\n\t\t\treturn searchForEditText(search, scroll);\n\t\telse\n\t\t\treturn false;\n\t}\n",
    "new_code_raw": "\tpublic boolean searchForEditText(String regex, boolean scroll) {\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(regex);\n\t\tMatcher matcher;\n\t\tArrayList<EditText> editTextList = viewFetcher.getCurrentViews(EditText.class);\n\t\tfor(EditText editText : editTextList){\n\t\t\tmatcher = p.matcher(editText.getText().toString());\n\t\t\tif (matcher.find()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (scroll && scroller.scroll(Scroller.Direction.DOWN))\n\t\t\treturn searchForEditText(regex, scroll);\n\t\telse\n\t\t\treturn false;\n\t}\n"
  },
  {
    "id": "OpenAPITools_openapi_generator-1650-Param-0",
    "old_comment_raw": "@param body client model",
    "old_code_raw": "    public Client testClientModel(Client body, Map<String, Object> params) throws IOException {\n        HttpResponse response = testClientModelForHttpResponse(body, params);\n        TypeReference typeRef = new TypeReference<Client>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n",
    "new_code_raw": "    public Client testClientModel(Client client, Map<String, Object> params) throws IOException {\n        HttpResponse response = testClientModelForHttpResponse(client, params);\n        TypeReference typeRef = new TypeReference<Client>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n"
  },
  {
    "id": "RobotiumTech_robotium-1499-Param-0",
    "old_comment_raw": "@param clazz the class of the  Activity to wait for e.g.  \"MyActivity\"",
    "old_code_raw": "    public boolean waitForActivity(Class<? extends Activity> clazz){\n        return waiter.waitForActivity(clazz, TIMEOUT);\n    }\n",
    "new_code_raw": "    public boolean waitForActivity(Class<? extends Activity> activityClass){\n        return waiter.waitForActivity(activityClass, TIMEOUT);\n    }\n"
  },
  {
    "id": "apache_calcite-948-Param-0",
    "old_comment_raw": "@param name the alias of the from item",
    "old_code_raw": "    RexNode lookupExp(String name) {\n      if (nameToNodeMap != null) {\n        RexNode node = nameToNodeMap.get(name);\n        if (node == null) {\n          throw Util.newInternal(\"Unknown identifier '\" + name\n              + \"' encountered while expanding expression\" + node);\n        }\n        return node;\n      }\n      int[] offsets = {-1};\n      final SqlValidatorScope[] ancestorScopes = {null};\n      SqlValidatorNamespace foundNs =\n          scope.resolve(name, ancestorScopes, offsets);\n      if (foundNs == null) {\n        return null;\n      }\n\n      // Found in current query's from list.  Find which from item.\n      // We assume that the order of the from clause items has been\n      // preserved.\n      SqlValidatorScope ancestorScope = ancestorScopes[0];\n      boolean isParent = ancestorScope != scope;\n      if ((inputs != null) && !isParent) {\n        int offset = offsets[0];\n        final LookupContext rels =\n            new LookupContext(this, inputs, systemFieldList.size());\n        return lookup(offset, rels);\n      } else {\n        // We're referencing a relational expression which has not been\n        // converted yet. This occurs when from items are correlated,\n        // e.g. \"select from emp as emp join emp.getDepts() as dept\".\n        // Create a temporary expression.\n        assert isParent;\n        DeferredLookup lookup = new DeferredLookup(this, name);\n        String correlName = createCorrel();\n        mapCorrelToDeferred.put(correlName, lookup);\n        final RelDataType rowType = foundNs.getRowType();\n        return rexBuilder.makeCorrel(rowType, correlName);\n      }\n    }\n",
    "new_code_raw": "    RexNode lookupExp(SqlQualified qualified) {\n      if (nameToNodeMap != null && qualified.prefixLength == 1) {\n        RexNode node = nameToNodeMap.get(qualified.identifier.names.get(0));\n        if (node == null) {\n          throw Util.newInternal(\"Unknown identifier '\" + qualified.identifier\n              + \"' encountered while expanding expression\");\n        }\n        return node;\n      }\n      int[] offsets = {-1};\n      final SqlValidatorScope[] ancestorScopes = {null};\n      SqlValidatorNamespace foundNs =\n          scope.resolve(qualified.prefix(), ancestorScopes, offsets);\n      if (foundNs == null) {\n        return null;\n      }\n\n      // Found in current query's from list.  Find which from item.\n      // We assume that the order of the from clause items has been\n      // preserved.\n      SqlValidatorScope ancestorScope = ancestorScopes[0];\n      boolean isParent = ancestorScope != scope;\n      if ((inputs != null) && !isParent) {\n        int offset = offsets[0];\n        final LookupContext rels =\n            new LookupContext(this, inputs, systemFieldList.size());\n        return lookup(offset, rels);\n      } else {\n        // We're referencing a relational expression which has not been\n        // converted yet. This occurs when from items are correlated,\n        // e.g. \"select from emp as emp join emp.getDepts() as dept\".\n        // Create a temporary expression.\n        assert isParent;\n        DeferredLookup lookup =\n            new DeferredLookup(this, qualified.identifier.names.get(0));\n        String correlName = createCorrel();\n        mapCorrelToDeferred.put(correlName, lookup);\n        final RelDataType rowType = foundNs.getRowType();\n        return rexBuilder.makeCorrel(rowType, correlName);\n      }\n    }\n"
  },
  {
    "id": "Atmosphere_atmosphere-856-Param-0",
    "old_comment_raw": "@param e  BroadcastFilter",
    "old_code_raw": "    public boolean removeFilter(BroadcastFilter e) {\n\n        if (e instanceof BroadcastFilterLifecycle) {\n            ((BroadcastFilterLifecycle) e).destroy();\n        }\n\n        if (e instanceof PerRequestBroadcastFilter) {\n            perRequestFilters.remove(e);\n        }\n        \n        return filters.remove(e);\n    }\n",
    "new_code_raw": "    public boolean removeFilter(BroadcastFilter filter) {\n\n        if (filter instanceof BroadcastFilterLifecycle) {\n            ((BroadcastFilterLifecycle) filter).destroy();\n        }\n\n        if (filter instanceof PerRequestBroadcastFilter) {\n            perRequestFilters.remove(filter);\n        }\n        \n        return filters.remove(filter);\n    }\n"
  },
  {
    "id": "apache_calcite-887-Param-0",
    "old_comment_raw": "@param call the function call",
    "old_code_raw": "  public static Granularity extractGranularity(RexCall call) {\n    if ((call.getKind() != SqlKind.FLOOR && call.getKind() != SqlKind.EXTRACT)\n            || call.getOperands().size() != 2) {\n      return null;\n    }\n    int flagIndex;\n    if (call.getKind() == SqlKind.EXTRACT) {\n      // EXTRACT\n      flagIndex = 0;\n    } else {\n      // FLOOR\n      flagIndex = 1;\n    }\n    final RexLiteral flag = (RexLiteral) call.operands.get(flagIndex);\n    final TimeUnitRange timeUnit = (TimeUnitRange) flag.getValue();\n    if (timeUnit == null) {\n      return null;\n    }\n    switch (timeUnit) {\n    case YEAR:\n      return Granularity.YEAR;\n    case QUARTER:\n      return Granularity.QUARTER;\n    case MONTH:\n      return Granularity.MONTH;\n    case WEEK:\n      return Granularity.WEEK;\n    case DAY:\n      return Granularity.DAY;\n    case HOUR:\n      return Granularity.HOUR;\n    case MINUTE:\n      return Granularity.MINUTE;\n    case SECOND:\n      return Granularity.SECOND;\n    default:\n      return null;\n    }\n  }\n",
    "new_code_raw": "  public static Granularity extractGranularity(RexNode node) {\n    final int flagIndex;\n    switch (node.getKind()) {\n    case EXTRACT:\n      flagIndex = 0;\n      break;\n    case FLOOR:\n      flagIndex = 1;\n      break;\n    default:\n      return null;\n    }\n    final RexCall call = (RexCall) node;\n    if (call.operands.size() != 2) {\n      return null;\n    }\n    final RexLiteral flag = (RexLiteral) call.operands.get(flagIndex);\n    final TimeUnitRange timeUnit = (TimeUnitRange) flag.getValue();\n    if (timeUnit == null) {\n      return null;\n    }\n    switch (timeUnit) {\n    case YEAR:\n      return Granularity.YEAR;\n    case QUARTER:\n      return Granularity.QUARTER;\n    case MONTH:\n      return Granularity.MONTH;\n    case WEEK:\n      return Granularity.WEEK;\n    case DAY:\n      return Granularity.DAY;\n    case HOUR:\n      return Granularity.HOUR;\n    case MINUTE:\n      return Granularity.MINUTE;\n    case SECOND:\n      return Granularity.SECOND;\n    default:\n      return null;\n    }\n  }\n"
  }
]